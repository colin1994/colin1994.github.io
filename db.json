{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/even/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/even/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/blank.gif","path":"lib/fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","path":"lib/fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","path":"lib/fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","path":"lib/fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","path":"lib/fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","path":"lib/fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","path":"lib/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","path":"lib/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","path":"lib/fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/slideout/slideout.min.js","path":"lib/slideout/slideout.min.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/slideout/slideout.js","path":"lib/slideout/slideout.js","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/even/source/image/reward/wechat.png","path":"image/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/even.js","path":"js/src/even.js","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/search.js","path":"js/src/search.js","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","path":"fonts/chancery/apple-chancery-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","path":"fonts/chancery/apple-chancery-webfont.woff","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","path":"fonts/chancery/apple-chancery-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/even/source/lib/jquery/jquery-3.1.1.min.js","path":"lib/jquery/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/even/source/image/reward/alipay.png","path":"image/reward/alipay.png","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","path":"fonts/chancery/apple-chancery-webfont.eot","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","path":"fonts/chancery/apple-chancery-webfont.svg","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","path":"lib/fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","path":"lib/fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/even/.eslintrc","hash":"af17814aa6d4f488f9c09a727652a7efc1552c03","modified":1577062951291},{"_id":"themes/even/LICENSE","hash":"6fd796a4c624297885ceed920ac7130a96f29a85","modified":1577062951291},{"_id":"themes/even/README.md","hash":"820b6d6301574d77db992bdc4b7fd327640c8e29","modified":1577062951292},{"_id":"themes/even/_config.yml","hash":"f7e7a5ca75fa0999f7a079af852bbb72146d7fc8","modified":1577062951292},{"_id":"themes/even/package.json","hash":"d689e42e7364bded66e2df142a5febedaae4be25","modified":1577062951295},{"_id":"themes/even/languages/default.yml","hash":"eeaa1cf150c669c08f4b70336c819b8a8eac1d0b","modified":1577062951292},{"_id":"themes/even/languages/en.yml","hash":"e5eebf05f48a53020ee798cac58b0c3e7f0a95f2","modified":1577062951292},{"_id":"themes/even/languages/zh-cn.yml","hash":"9fca22d97f9381afc187e9b14d9f8de5c0f5d9c5","modified":1577062951292},{"_id":"source/favicon.ico","hash":"d018c6444c3a9cffd2fe2328372503a99615ce58","modified":1577062951291},{"_id":"themes/even/layout/_layout.swig","hash":"011a510b0977c40bda922d5969d39071f0e8ae99","modified":1577062951292},{"_id":"themes/even/layout/archive.swig","hash":"30971263c38e67bffb6fdd90d458f6c82a75c05d","modified":1577062951294},{"_id":"themes/even/layout/categories.swig","hash":"dc244e0ee1fc34f43d5b195b9c1f6ef6d3ad2d0d","modified":1577062951294},{"_id":"themes/even/layout/index.swig","hash":"f3341b5f4af1eab0930a1d078b3022bbe0a59232","modified":1577062951294},{"_id":"themes/even/layout/page.swig","hash":"3a767206198efb3eb487d7061107212c2171106c","modified":1577062951294},{"_id":"themes/even/layout/post.swig","hash":"a0ed82a3aa04d3554dd654a3cf6194644ae1574c","modified":1577062951295},{"_id":"themes/even/layout/tags.swig","hash":"ae9500008d0b445d1962a34cdb59fde3106ed33a","modified":1577062951295},{"_id":"themes/even/source/favicon.ico","hash":"b330ef422487a11bec7801cb2cf1056fd475aaf2","modified":1577062951298},{"_id":"source/_posts/Call-Directory-Extension-Study.md","hash":"4557eef03bc65c3ac6a21012ef21e32b0d1429d2","modified":1577062951284},{"_id":"source/_posts/Core-Image-Custom-Filter.md","hash":"da60fe29179d90875f32a26e186f8a6b0beb3b80","modified":1577062951284},{"_id":"source/_posts/Core-Image-OverView.md","hash":"a6e7b2dc97714ff35e1b47e5ac28cdceb7d1391b","modified":1577062951284},{"_id":"source/_posts/Imitation-Clean-Master.md","hash":"171d08dedc4d35ef0c9b845f0cac9578e1fe89dd","modified":1577062951285},{"_id":"source/_posts/Interactive-animation-is-so-simple.md","hash":"9698afc88a63d811063085cf30a9f217b4f72960","modified":1577062951285},{"_id":"source/_posts/OpenGLES-Lesson00.md","hash":"71a4c14444325ef827b6db5ed1d7a073df559b01","modified":1577062951285},{"_id":"source/_posts/OpenGLES-Lesson01.md","hash":"e18039670116ecec56f2cbbeaa69ce44a5f6e58a","modified":1577062951285},{"_id":"source/_posts/OpenGLES-Lesson02.md","hash":"c554c3f6eb85d56703cabd0e79d7946cba5bc0f1","modified":1577062951285},{"_id":"source/_posts/OpenGLES-Lesson03.md","hash":"bb8a41c472056660400d443fcd22400b3d4a7ef9","modified":1577062951285},{"_id":"source/_posts/OpenGLES-Lesson04.md","hash":"c2bc490e4f7f9e6204d922bd565c2cc8b0aa4449","modified":1577062951288},{"_id":"source/_posts/OpenGLES-Lesson05.md","hash":"ebdd590f581ef9d63d7c94f15c873ccf57e6da62","modified":1577062951289},{"_id":"source/_posts/OpenGLES-Menu.md","hash":"57cbc80a96d059b0f2ab9f5763f50b7ed4d95a85","modified":1577062951289},{"_id":"source/_posts/Photo-Editing-Extension.md","hash":"6748f9372deeee3e21fc6e71a52527c477e84092","modified":1577062951289},{"_id":"source/_posts/Regular-Expressions.md","hash":"f63b78dd3be3d71fe9f4f3add585ef15c8175d1e","modified":1577062951289},{"_id":"source/_posts/TDD-With-Swift.md","hash":"4a3dc821013a015cac69b45b579615068e03a507","modified":1577062951289},{"_id":"source/_posts/TODO-Macro.md","hash":"39a485b12816cfd83a056b2ab9e812d0accc8087","modified":1577062951290},{"_id":"source/_posts/What's_New_in_iOS_10.0_zh_0.md","hash":"d95ba35f37307c7e88b6bb5d94093120b6b47097","modified":1577062951290},{"_id":"source/_posts/hexo-copyright-and-donate.md","hash":"7a4986a06efb674edc7464d1854d6f3249fd3fa4","modified":1577062951290},{"_id":"source/_posts/iOS-Unit-Testing.md","hash":"8912baa9f2fc8ddec1fb471180c4aa0e99690506","modified":1577062951290},{"_id":"source/_posts/iOS-welcome-page-multilingual.md","hash":"985d6491850803b843107641144b35ccad6bf571","modified":1577062951290},{"_id":"source/_posts/interview-summary.md","hash":"97e99ed85e6b01a6686d45fb0a467e10409cf173","modified":1577062951290},{"_id":"source/_posts/metal-tutorial.md","hash":"3d5da901434f24b4e3eef3ff66c2eb0bf7a55b12","modified":1577062951290},{"_id":"source/about/index.md","hash":"5febebd3bb21ef41d0447ad5f2343559aa504667","modified":1577062951290},{"_id":"source/projects/index.html","hash":"c0c0083b064195bab531deca6ffea58fc83e9a4e","modified":1577062951291},{"_id":"source/tags/index.md","hash":"5f339008f2696c081263d445398ddd15954bb1b9","modified":1577062951291},{"_id":"themes/even/layout/_macro/archive.swig","hash":"09cde870c8392d93d4bde0862f2f53a87b196ad4","modified":1577062951292},{"_id":"themes/even/layout/_macro/post.swig","hash":"8473af4d9d48beb4107a78521779b66d86f09ebe","modified":1577062951292},{"_id":"themes/even/layout/_partial/comments.swig","hash":"0f2d637b275d3ff70f78fb22d7d58ab73300dd4b","modified":1577062951293},{"_id":"themes/even/layout/_partial/footer.swig","hash":"248a60fe0122daf3706a291e4313f629de29384f","modified":1577062951293},{"_id":"themes/even/layout/_partial/head.swig","hash":"5497cb03439d90b4ba7148bbc1e9d303539bb388","modified":1577062951293},{"_id":"themes/even/layout/_partial/header.swig","hash":"01972309c0804558c5b5476fa219ce000330f244","modified":1577062951293},{"_id":"themes/even/layout/_partial/pagination.swig","hash":"3843e523b9a7a1c5973d0c2de05cc88467733e09","modified":1577062951293},{"_id":"themes/even/layout/_partial/slideout.swig","hash":"d046aa352c8e3f298c21ce537bd3dffc63e33abc","modified":1577062951293},{"_id":"themes/even/layout/_script/analytics.swig","hash":"24ba4a8adcaf09c9ede76405ee732385595d8e39","modified":1577062951294},{"_id":"themes/even/layout/_script/comments.swig","hash":"eee7b4860b1ec25226cf0d46f2f54cfc13562359","modified":1577062951294},{"_id":"themes/even/layout/_script/config.swig","hash":"7f2a1da26b780079214457d85136ffffaf36092f","modified":1577062951294},{"_id":"themes/even/layout/_script/libs.swig","hash":"67940ae28766608a3d6f287ecc95fa05db49f243","modified":1577062951294},{"_id":"themes/even/layout/_script/search.swig","hash":"02c3361c9b8645e00be01f51b49b562d9e51858f","modified":1577062951294},{"_id":"themes/even/layout/_script/theme.swig","hash":"cb81a0a6a6d5264cc6451dda3dd3a96101f89b1d","modified":1577062951294},{"_id":"themes/even/source/css/_base.scss","hash":"d03265b755abb63f8189750b20321c6aef7b7d7d","modified":1577062951295},{"_id":"themes/even/source/css/_variables.scss","hash":"5d8885a70b5247e535f0970b5805458e6b1608a9","modified":1577062951298},{"_id":"themes/even/source/css/style.scss","hash":"6c57b95c4f936c7cc2a7047150b163919038168e","modified":1577062951298},{"_id":"themes/even/layout/_partial/_footer/social.swig","hash":"65368d0a5108fecc072eaea3b1fb04c597941729","modified":1577062951292},{"_id":"themes/even/layout/_partial/_head/meta.swig","hash":"4692e4aa4675e069f886b7ee49bd610c00f3e3bd","modified":1577062951293},{"_id":"themes/even/layout/_partial/_post/copyright.swig","hash":"dbd57ececb200ee220189f51cc748023b96592d8","modified":1577062951293},{"_id":"themes/even/layout/_partial/_post/reward.swig","hash":"faf64b5461970fda72863e9779f3f024cb493658","modified":1577062951293},{"_id":"themes/even/layout/_partial/_post/toc.swig","hash":"fc21e5b9ebaca219678d85b8c5e4b3ee013fca25","modified":1577062951293},{"_id":"themes/even/layout/_script/_analytics/baidu-analytics.swig","hash":"5d62309b16071f1b6952891ec8e1f1d42e38a088","modified":1577062951293},{"_id":"themes/even/layout/_script/_analytics/google-analytics.swig","hash":"74acc1a34571a960b12921212e6e4cb14869c226","modified":1577062951293},{"_id":"themes/even/layout/_script/_comments/disqus.swig","hash":"0502145777d65515249680d3e4611f249e3d9ff8","modified":1577062951294},{"_id":"themes/even/layout/_script/_comments/duoshou.swig","hash":"34986ff3b065a6aaba981ece010afde182dd97f9","modified":1577062951294},{"_id":"themes/even/layout/_script/_comments/netease.swig","hash":"6dec861157b158b017b2270b7457c33bc158f029","modified":1577062951294},{"_id":"themes/even/source/css/_common/_animation.scss","hash":"f32d2444f0ab4dcb8b811ae1bccae6073f21a988","modified":1577062951295},{"_id":"themes/even/source/css/_common/_normalize.scss","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1577062951295},{"_id":"themes/even/source/css/_common/_utils.scss","hash":"21dfd8cfdb574504b97896a282044d93d972e338","modified":1577062951295},{"_id":"themes/even/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577062951300},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577062951300},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577062951300},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577062951300},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577062951300},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577062951300},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1577062951301},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1577062951301},{"_id":"themes/even/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1577062951295},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1577062951301},{"_id":"themes/even/source/css/_partial/_archive.scss","hash":"019ee950e5da4395c867b950c8da06d03310b3db","modified":1577062951295},{"_id":"themes/even/source/css/_partial/_back-to-top.scss","hash":"c6f586ac04a9a0f3633dadf5c66be9e0c4027f1d","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_categories.scss","hash":"96f47000d25ef4e0e948f8f43fa4e2983ff0d746","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_footer.scss","hash":"76f3a72440be8aa1e93d8ddc5ea958777d1545ab","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_header.scss","hash":"4a3e92feef33bed0021f1a65a801c24ee7d5946f","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_iconfont.scss","hash":"2a68735df51cf6b1c9559e70814ac311804cd8eb","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_mobile.scss","hash":"0d1c60bd92f8e5db01e7843934251152ec4d6d44","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_pagination.scss","hash":"b24db39534e180ebcebba2e81d91d9f1d534eea1","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_post.scss","hash":"7d03216b1fb5007ecc33412cacab74432c4e02d2","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_slideout.scss","hash":"e4820a42698f647a824575b234835b9ce4ac4797","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_tags.scss","hash":"fb4bf54b34291d5b72598a7ba4d3e370c8ad9383","modified":1577062951297},{"_id":"themes/even/source/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1577062951302},{"_id":"themes/even/source/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1577062951302},{"_id":"themes/even/source/js/src/bootstrap.js","hash":"c37073db93271410e30dfa9a894fc78a4f025abd","modified":1577062951300},{"_id":"themes/even/source/image/reward/wechat.png","hash":"6d91b23f8ab20245afd33c640d8e8512cee832e6","modified":1577062951300},{"_id":"themes/even/source/js/src/even.js","hash":"9491d0c34812d76d5caf303100b17510ff8f0fc3","modified":1577062951300},{"_id":"themes/even/source/js/src/search.js","hash":"2670045b8af8150390df1a4f081f8167a5648d67","modified":1577062951300},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1577062951299},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1577062951299},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1577062951299},{"_id":"themes/even/source/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1577062951302},{"_id":"themes/even/source/image/reward/alipay.png","hash":"4984941b2c85b1a96f258ad974aa492725d3dafe","modified":1577062951299},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1577062951298},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1577062951298},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577062951301},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577062951301},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1577062951301},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1577062951301},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577062951301},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1577062951301},{"_id":"themes/even/source/css/_partial/_footer/_copyright.scss","hash":"afbc0f90c674e5cd5fd7509eb1296d60b999d4e1","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_footer/_social.scss","hash":"bca6a1036951c2475278bfbd3a5ce51ff861e9a3","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_header/_logo.scss","hash":"109073dde15146d835bf06faa2f256d1ac658315","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_header/_menu.scss","hash":"c823489bc6c0f320618362f9e07d9114b9f8612b","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_header/_search.scss","hash":"b272e3f0fba05d66de648717f6dfe2718637e8f6","modified":1577062951296},{"_id":"themes/even/source/css/_partial/_post/_code.scss","hash":"d866ae4f05dd3f65e55388727c1277ace55d4c7c","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_post/_content.scss","hash":"d1a84cd75828e165133c7f7e9ad518d2d02e5925","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_post/_copyright.scss","hash":"9e33c5935885552d6abdf43e2b1e5a278211f052","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_post/_footer.scss","hash":"9f2ab0ac20b2a8bfd315febd387c399f72f43d10","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_post/_header.scss","hash":"e3644f535fab81e6437796901cba36500d8ae290","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_post/_reward.scss","hash":"66ec9faa27ed879dc9a2ca59c73ed6bfd5e61dcd","modified":1577062951297},{"_id":"themes/even/source/css/_partial/_post/_toc.scss","hash":"dba41bc7638e22c59eb704fc6de80c32d6f1ed52","modified":1577062951297},{"_id":"public/rss2.xml","hash":"9fa82c0fb9b4c7bd3d91e6769e81a7110b8f53ab","modified":1577063129172},{"_id":"public/search.xml","hash":"fe4818cdb7a14ca174dcfd2ad8c9dd1b0121fa5b","modified":1577063129182},{"_id":"public/about/index.html","hash":"7e914d12dd726126ca11240d7fe6c941097cca2d","modified":1577063129190},{"_id":"public/tags/index.html","hash":"5e97ea3d89f18ce8f24f786a46fc0d4838d5a111","modified":1577063129190},{"_id":"public/archives/index.html","hash":"f46eb9954d34af42ca02de569b374a3d25b1be16","modified":1577063129190},{"_id":"public/archives/page/2/index.html","hash":"10b5647ad5696905797e09e2726297756eb96df6","modified":1577063129190},{"_id":"public/archives/page/3/index.html","hash":"e4bf3c705d3d78d889ac60edd147686d5d726fa3","modified":1577063129190},{"_id":"public/archives/2015/index.html","hash":"b2bea75d9928c2174212fb8bd1c8e67505211f14","modified":1577063129190},{"_id":"public/archives/2015/07/index.html","hash":"5508caddd3f10b5f3879d5de0a47cf939bbe5212","modified":1577063129190},{"_id":"public/archives/2016/index.html","hash":"a3a6fc9d8341f64e060e769c5bc42c526c60955f","modified":1577063129190},{"_id":"public/archives/2016/03/index.html","hash":"00397d5d4c79b4aab983ee412ac7e3d796897ee6","modified":1577063129190},{"_id":"public/archives/2016/06/index.html","hash":"0db2a9134c0eac5d4dcf5e678f4e924e0cdb86ad","modified":1577063129190},{"_id":"public/archives/2016/10/index.html","hash":"aad3e82c942008ae8fc0fb86c31a5ec48dfd28e2","modified":1577063129190},{"_id":"public/archives/2017/index.html","hash":"affc9b321aa88dd676cca3783c739db3f29ed2b1","modified":1577063129190},{"_id":"public/archives/2017/04/index.html","hash":"717c43f6e898291b203627b3f1c0f63099eb639c","modified":1577063129190},{"_id":"public/archives/2017/08/index.html","hash":"6f6791de8bfe6d2804e936cd4333aa44fa5fd18e","modified":1577063129190},{"_id":"public/archives/2017/11/index.html","hash":"327582b33c863e1376096b4a0d005c2a044c1297","modified":1577063129190},{"_id":"public/archives/2018/index.html","hash":"4c8c53c3d75d805c69cb3a1ca7f8b3817e91852d","modified":1577063129190},{"_id":"public/archives/2018/08/index.html","hash":"eec7cbc1dae3e6373dfe6aa21bf201e811f95340","modified":1577063129190},{"_id":"public/page/3/index.html","hash":"5a4e69c381bb7f02dcac2961c22cad2d20a0f09e","modified":1577063129190},{"_id":"public/tags/iOS开发/index.html","hash":"39fd554143f35fab55ce360a2859cdb5dd2faf20","modified":1577063129190},{"_id":"public/tags/iOS开发/page/2/index.html","hash":"a60a5100e115c6892b74300d1d8bac66ebbfaeb1","modified":1577063129190},{"_id":"public/tags/OpenGLES/index.html","hash":"c10cd2cc2d4c6993dd7603b77b2e6237990c97e9","modified":1577063129190},{"_id":"public/tags/图像处理/index.html","hash":"593f7ccc8c76b60ca5038c3014bf004cb5bda3e9","modified":1577063129191},{"_id":"public/tags/宏/index.html","hash":"fd8ad59947f835c449541d310a20b24585d06d76","modified":1577063129191},{"_id":"public/tags/正则/index.html","hash":"314209a0109d3443e7ab11001c219f7fd4d61315","modified":1577063129191},{"_id":"public/tags/Hexo/index.html","hash":"0e78404d88b10b7f0f23e733aacf5bbf8c9f7848","modified":1577063129191},{"_id":"public/tags/教程/index.html","hash":"4cd7dcda3f3a80a883722deb1a765365bf34d5c3","modified":1577063129191},{"_id":"public/tags/iOS-开发/index.html","hash":"b1c492412486c6695815e57f73d4cf9302af29cd","modified":1577063129191},{"_id":"public/tags/Metal/index.html","hash":"156f8ad3372ba485eee287814b35877304d45a14","modified":1577063129191},{"_id":"public/tags/iOS-10/index.html","hash":"a44029eade009d11ac3a29f7d8699d71f56d3e43","modified":1577063129191},{"_id":"public/tags/CallKit/index.html","hash":"586740f4b8ff6a053a7b12aa7a8dfe83523e2ccd","modified":1577063129191},{"_id":"public/tags/设计思想/index.html","hash":"c6e0ee86fdd52ac8ce22bcaef334b76c2de88284","modified":1577063129191},{"_id":"public/tags/测试/index.html","hash":"ebd43b846d20eeba63df630abc2c18332306a69c","modified":1577063129191},{"_id":"public/tags/面试/index.html","hash":"8fcf34b71e510de2c6b56d1c432bbfaa3d8ea887","modified":1577063129191},{"_id":"public/tags/随笔/index.html","hash":"a4f7afa9a8ef88b27f9bee8b4276479269101ad0","modified":1577063129191},{"_id":"public/tags/TDD/index.html","hash":"88229ab74f6697b5131177723b5f9a5deba96b17","modified":1577063129191},{"_id":"public/tags/Swift/index.html","hash":"0fc26a59d4f75c15faeaa651757a27f5674c80ba","modified":1577063129191},{"_id":"public/tags/Core-Image/index.html","hash":"cfbdc658abfa456bb9510a33a277b4959530f6e0","modified":1577063129191},{"_id":"public/tags/翻译/index.html","hash":"6b8a52ab965edaba38b6d50d7a3800d28ffc497c","modified":1577063129191},{"_id":"public/projects/index.html","hash":"0ce60d3ef244d236f8e0b9945e2d6485f8359013","modified":1577063129191},{"_id":"public/2018/08/25/metal-tutorial/index.html","hash":"8b9d99c6552519997ca97b0efc7255887c81339d","modified":1577063129191},{"_id":"public/2017/11/12/OpenGLES-Lesson05/index.html","hash":"5623c643b72352735fa28ce5d5252c3441502cd3","modified":1577063129191},{"_id":"public/2017/11/11/OpenGLES-Lesson04/index.html","hash":"5194e861a0e385aa1d855a4093770532be2d9404","modified":1577063129191},{"_id":"public/2017/08/31/iOS-Unit-Testing/index.html","hash":"1b3781aebc7b0153ae36dc620dcaa2d09c7cda01","modified":1577063129191},{"_id":"public/2017/04/18/OpenGLES-Lesson03/index.html","hash":"ad7e8ff41f4f8fb1b73f081ea979b0f418f78171","modified":1577063129191},{"_id":"public/2017/04/09/OpenGLES-Lesson02/index.html","hash":"5db2135796fa06b33a923036df57a70f277a97ba","modified":1577063129191},{"_id":"public/2017/04/01/OpenGLES-Lesson01/index.html","hash":"fb491e31fb3a99fddbd4de80376534b22c8235a8","modified":1577063129191},{"_id":"public/2017/04/01/OpenGLES-Lesson00/index.html","hash":"ed2aa1174d8dd1fc7f0696e29fd81bb64e965c6f","modified":1577063129192},{"_id":"public/2017/04/01/OpenGLES-Menu/index.html","hash":"0c94ccd12d3caea2952589be3311bc15035d8247","modified":1577063129192},{"_id":"public/2016/10/21/Core-Image-Custom-Filter/index.html","hash":"a146ad4dd91c857a7704ebaf471c896c96037c10","modified":1577063129192},{"_id":"public/2016/10/21/Core-Image-OverView/index.html","hash":"7194f6892acaac8e050b2cc81dd88f52fc9e8316","modified":1577063129192},{"_id":"public/2016/06/17/Call-Directory-Extension-Study/index.html","hash":"7208500927f5792396ac9576a1dea4459680527a","modified":1577063129192},{"_id":"public/2016/06/14/What's_New_in_iOS_10.0_zh_0/index.html","hash":"93de68bf321c34faa106fb0a0f9fa093e3dd22cf","modified":1577063129192},{"_id":"public/2016/06/03/TDD-With-Swift/index.html","hash":"dc57848e6a3cd541414bc0df1140c10ce65f7f8a","modified":1577063129192},{"_id":"public/2016/06/02/hexo-copyright-and-donate/index.html","hash":"edc8eb897ec4666e32348ef15f461ebd0e870f35","modified":1577063129192},{"_id":"public/2016/03/16/Interactive-animation-is-so-simple/index.html","hash":"c03602c1e65579fa4447fc201bb0475131315d08","modified":1577063129192},{"_id":"public/2016/03/12/Photo-Editing-Extension/index.html","hash":"6ef0699f6914dcf1e724d219ebde0cc832b8cab3","modified":1577063129192},{"_id":"public/2016/03/12/iOS-welcome-page-multilingual/index.html","hash":"1a8de3cf27cdd94e0f6d0007a4b95d29325a0c8b","modified":1577063129192},{"_id":"public/2015/07/13/Imitation-Clean-Master/index.html","hash":"eb46f5864f733ccadf2d62af7ba525112e91cc4f","modified":1577063129192},{"_id":"public/2015/07/11/Regular-Expressions/index.html","hash":"c6d8e438b5bd9aaa38fb2c8baeee7197ee53b64d","modified":1577063129192},{"_id":"public/2015/07/12/TODO-Macro/index.html","hash":"8f85efb7731cef2a74029dcc73d58dd4442ad311","modified":1577063129192},{"_id":"public/2015/07/11/interview-summary/index.html","hash":"aa4826cccc1135c16b12e1bd989ed2b457f01ef2","modified":1577063129192},{"_id":"public/index.html","hash":"86e7e6585170b6af5cdea4c66fdfac3ce00d4e4a","modified":1577063129192},{"_id":"public/page/2/index.html","hash":"e65d19e4324c3354229ebf4b6124b958fa56b68d","modified":1577063129192},{"_id":"public/favicon.ico","hash":"b330ef422487a11bec7801cb2cf1056fd475aaf2","modified":1577063129198},{"_id":"public/css/style.scss","hash":"6c57b95c4f936c7cc2a7047150b163919038168e","modified":1577063129198},{"_id":"public/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577063129198},{"_id":"public/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577063129199},{"_id":"public/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577063129199},{"_id":"public/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577063129199},{"_id":"public/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577063129199},{"_id":"public/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577063129199},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1577063129199},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1577063129199},{"_id":"public/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577063129199},{"_id":"public/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1577063129199},{"_id":"public/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1577063129202},{"_id":"public/image/reward/wechat.png","hash":"6d91b23f8ab20245afd33c640d8e8512cee832e6","modified":1577063129202},{"_id":"public/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1577063129203},{"_id":"public/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1577063129203},{"_id":"public/js/src/bootstrap.js","hash":"c37073db93271410e30dfa9a894fc78a4f025abd","modified":1577063129204},{"_id":"public/js/src/even.js","hash":"9491d0c34812d76d5caf303100b17510ff8f0fc3","modified":1577063129204},{"_id":"public/js/src/search.js","hash":"2670045b8af8150390df1a4f081f8167a5648d67","modified":1577063129204},{"_id":"public/image/reward/alipay.png","hash":"4984941b2c85b1a96f258ad974aa492725d3dafe","modified":1577063129204},{"_id":"public/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1577063129204},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577063129206},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1577063129206},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1577063129206},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1577063129206},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577063129206},{"_id":"public/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1577063129208},{"_id":"public/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1577063129210},{"_id":"public/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1577063129210},{"_id":"public/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1577063129211}],"Category":[],"Data":[],"Page":[{"title":"about","layout":"page","date":"2017-04-20T12:49:32.000Z","_content":"\n\n\n## About Me\n\n嗨，我是余龙泽，一名 iOS 开发者，就职于美图。\n\n热爱折腾，享受学习。\n\n讨厌加班，追求高效。\n\n\n\n> 这是大学时期在 CSDN 上维护的一个博客：[Colin丶](https://blog.csdn.net/hitwhylz)，内容比较基础，访问量 200W+，目前已经停止维护。\n>\n> 这是现在在写的一个专栏：[iOS 图像处理](https://xiaozhuanlan.com/colin)，介绍图像处理相关知识，拒绝空谈理论，用实践验证。\n>\n> 或许你会发现，哦，原来这就是他阿。\n\n","source":"about/index.md","raw":"title: about\n\nlayout: page\n\n\ndate: 2017-04-20 20:49:32\n---\n\n\n\n## About Me\n\n嗨，我是余龙泽，一名 iOS 开发者，就职于美图。\n\n热爱折腾，享受学习。\n\n讨厌加班，追求高效。\n\n\n\n> 这是大学时期在 CSDN 上维护的一个博客：[Colin丶](https://blog.csdn.net/hitwhylz)，内容比较基础，访问量 200W+，目前已经停止维护。\n>\n> 这是现在在写的一个专栏：[iOS 图像处理](https://xiaozhuanlan.com/colin)，介绍图像处理相关知识，拒绝空谈理论，用实践验证。\n>\n> 或许你会发现，哦，原来这就是他阿。\n\n","updated":"2019-12-23T01:02:31.290Z","path":"about/index.html","comments":1,"_id":"ck4hqo1lw0001zwlnw2bandqo","content":"<h2 id=\"About_Me\">About Me</h2><p>嗨，我是余龙泽，一名 iOS 开发者，就职于美图。</p>\n<p>热爱折腾，享受学习。</p>\n<p>讨厌加班，追求高效。</p>\n<blockquote>\n<p>这是大学时期在 CSDN 上维护的一个博客：<a href=\"https://blog.csdn.net/hitwhylz\" target=\"_blank\" rel=\"external\">Colin丶</a>，内容比较基础，访问量 200W+，目前已经停止维护。</p>\n<p>这是现在在写的一个专栏：<a href=\"https://xiaozhuanlan.com/colin\" target=\"_blank\" rel=\"external\">iOS 图像处理</a>，介绍图像处理相关知识，拒绝空谈理论，用实践验证。</p>\n<p>或许你会发现，哦，原来这就是他阿。</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"About_Me\">About Me</h2><p>嗨，我是余龙泽，一名 iOS 开发者，就职于美图。</p>\n<p>热爱折腾，享受学习。</p>\n<p>讨厌加班，追求高效。</p>\n<blockquote>\n<p>这是大学时期在 CSDN 上维护的一个博客：<a href=\"https://blog.csdn.net/hitwhylz\">Colin丶</a>，内容比较基础，访问量 200W+，目前已经停止维护。</p>\n<p>这是现在在写的一个专栏：<a href=\"https://xiaozhuanlan.com/colin\">iOS 图像处理</a>，介绍图像处理相关知识，拒绝空谈理论，用实践验证。</p>\n<p>或许你会发现，哦，原来这就是他阿。</p>\n</blockquote>\n"},{"title":"tags","layout":"tags","date":"2017-04-20T12:46:57.000Z","_content":"","source":"tags/index.md","raw":"title: tags\n\nlayout: tags\n\ndate: 2017-04-20 20:46:57\n---\n","updated":"2019-12-23T01:02:31.291Z","path":"tags/index.html","comments":1,"_id":"ck4hqo1ly0003zwlneokukixa","content":"","excerpt":"","more":""},{"_content":"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>Colin's Project</title>\n<meta name=\"keywords\" content=\"dragonfly, free website templates, one page layout, jquery\" />\n<meta name=\"description\" content=\"Dragonfly is one-page layout using jQuery and it is free website template from templatemo.com\" />\n\n\t\n\t<link rel=\"shortcut icon\" href=\"http://colinnest.qiniudn.com/colinLogo.JPG\" />\n\t<link href=\"http://colinnest.qiniudn.com/projectCss%2Ftemplatemo_style.css\" type=\"text/css\" rel=\"stylesheet\" /> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.scrollTo-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.localscroll-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Finit.js\"></script> \n    \n    <link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.css\" type=\"text/css\" media=\"screen\" /> \n    <script type=\"text/JavaScript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.js\"></script> \n\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Forman.css\" type=\"text/css\" media=\"screen\" />\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fnivo-slider.css\" type=\"text/css\" media=\"screen\" />\n\n\n</head> \n<body> \n<div id=\"templatemo_wrapper\">\n<div id=\"templatemo_header\">\n    <div id=\"site_title\"><a href=\"http://colin1994.xyz\"  title=\"返回Colin's Nest\"></a></div>\n    <ul class=\"nav_menu\">\n        <li><a href=\"#app_1\">广陵村委会</a></li>\n\t\t<li><a href=\"#app_2\">软院新闻</a></li>\n\t\t<li><a href=\"#app_3\">小生有礼</a></li>\n\t\t<li><a href=\"#app_4\">情侣手游</a></li>\n\t\t<li><a href=\"#app_5\">专属情人</a></li>\n\t\t<li><a href=\"#app_6\">博客助手</a></li>\n\t\t<li><a href=\"#app_7\">企业通讯录</a></li>\n\t\t<li><a href=\"#app_8\">微博小尾巴</a></li>\n\t\t<li><a href=\"#app_9\">爱眼通</a></li>\n\t\t<li><a href=\"#app_10\">私家相机</a></li>\n\t\t<li><a href=\"#app_11\">甜甜机器伴侣</a></li>\n    </ul>\n    \n</div>\n<div id=\"templatemo_main\">\n\t<div id=\"content\"> \n<!-- \t\t广陵村委会 -->\n        <div class=\"section section_with_padding\" id=\"app_1\"> \n            <h1>广陵村委会</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id787202962?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_1.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;广陵区农村综合信息服务平台</font></B></p><br>\n\t\t\t\n            <p>大一完成的项目, 应广陵区相关领导的要求, 写了一个App, 让他们能随时方便的获取相关信息。该应用比较简单, 涉及一些数据的操作，以及UIWebView的应用。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t软院新闻 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_2\"> \n            <h1>软院新闻</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id796775928?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_2.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈工大软件学院新闻客户端</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 哈工大(威海)软件学院新闻客户端,实时获取最新资讯。 iOS/Android同步上线, 便于广大师生第一时间获取最新学院消息。主要涉及web service, json解析等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n\t\t\n<!-- \t\t小生有礼 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_3\"> \n            <h1>小生有礼</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_3.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好友生日管家+个性礼物</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 通过人人授权, 自动获取人人好友生日信息，并且在好友生日当天弹出提示。另外，包含礼物选购，礼物建购，DIY贺卡，节日短信等等功能。当初完成数据结构课设的一个项目, 也获得了第四届数据结构课程设计第一名。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t情侣手游 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_4\"> \n            <h1>情侣手游</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_4.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的月亮我的心</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 适合双人互动，主要针对于年轻的情侣闲暇时刻娱乐、吸引星星迷的参与。游戏分为双人跑酷, 连线游戏, 合体打怪物, 消星星对战等模式。 每个模式的互动性都极强。  双方游戏相互影响。 并且借助手机屏幕小这一因素, 给情侣制造指尖触电。 该游戏参与第七届com2us游戏设计大赛, 取得了第一名的好成绩</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t<div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_2.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_3.png\" alt=\"image 2\" />\t\n            </div>\n\n        </div> \n\t\t\n\t\t\n<!-- \t\t专属情人 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_5\"> \n            <h1>专属情人</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_5.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;屌丝的福音, 高仿女朋友</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 意在实现\"女朋友\"功能, 让每个屌丝都能有自己的专属情人。 该应用集 美女采集器, 隐形相机, 智能陪聊机器人, 宝宝预测, 泡妞技巧, 笑话等等功能,给你不一样的精彩。涉及内容比较广, 包括百度图片API, 图灵机器人API, face++API等等..</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t博客助手 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_6\"> \n            <h1>博客助手</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id890345475?ls=1&mt=8\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_6.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博客备份,离线浏览</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候自己开始正式使用博客, 发现没有很好的移动端app，就自己写了个。 包括1.在线浏览, 自动排版。2.一键导出, 随时浏览。3.一键搜索, 方便学习等功能。  主要是能把网上的博客备份到本地, 方便离线查看。涉及UIWebView与js的交互等等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t企业通讯录 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_7\"> \n            <h1>企业通讯录</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_7.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蓝牙话机, 企业必备</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 与卡尔电气和铁通公司合作的。 有对应的蓝牙话机,话机和手机之间采用蓝牙传输方式，话机端 蓝牙模块工作在从模式，手机端的蓝牙模块工作在主模式 。手机端应用软件在后台有服务负责跟话机的连接和通信。 提供给企业对应的云服务, 可以管理企业通讯录, 另外通过手机控制话机, 减少辐射的同时提高效率。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n<!-- \t\t微博小尾巴 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_8\"> \n            <h1>微博小尾巴</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_8.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;轻松变土豪</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候iPhone6(plus)刚发布, 微博上有人把小尾巴改成了iPhone6, 导致很多人跟风。 所以就写了这个应用, 能够自定义微博小尾巴, 包括70多种机型, 200多条个性文字。 轻轻松松变土豪。 不过后来微博自己的客户端也增加了这个功能。(在我之后发布的), 所以我这个\"微博小尾巴\"也就没存在必要了.. 完全没竞争力。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t爱眼通 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_9\"> \n            <h1>爱眼通</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id914567654?ls=1&mt=8\" ><img src= \"http://colinnest.qiniudn.com/projectImage%2Ficon_9.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最专业的随身视力测试</font></B></p><br>\n\t\t\t\n            <p>大二完成的项目, 该应用根据国家标准对数视力标准, 创新性实现利用手机随时测试视力。并且, 能自动记录各个时间段的视力测试结果。还能定时播放眼保健操, 休息提示, 模拟眼镜等, 让您舒缓眼部疲劳。更有视力保健指南, 教您更好呵护眼睛。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\n\n<!-- \t\t私家相机 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_10\"> \n            <h1>私家相机</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id924949102?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_10.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 利用私家相机, 您可以\"隐形\"拍照界面。伪装成其他界面。解决了韩版, 日版关不掉快门声的问题。更集合照片美化, 照片拼图功能。众多特效. 快速美化。加密相册, 保护隐私... </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n<!-- \t\t甜甜机器伴侣 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_11\"> \n            <h1>甜甜机器伴侣</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/us/app/tian-tian-ji-qi-ban-lu/id931200767?l=zh&ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_11.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></B></p><br>\n\t\t\t\n\t\t\t<p>大三完成的项目, 支持聊天对话、智能问答•  拥有笑话、天气、公交等丰富功能•  列车,航班,快递 轻松查询•  支持自然语言处理及语义理解•  数十亿知识库数据，应有尽有 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_1.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_2.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_3.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n        \n        \n    </div> \n</div>\n\n</div>\n\n</body> \n</html>","source":"projects/index.html","raw":"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>Colin's Project</title>\n<meta name=\"keywords\" content=\"dragonfly, free website templates, one page layout, jquery\" />\n<meta name=\"description\" content=\"Dragonfly is one-page layout using jQuery and it is free website template from templatemo.com\" />\n\n\t\n\t<link rel=\"shortcut icon\" href=\"http://colinnest.qiniudn.com/colinLogo.JPG\" />\n\t<link href=\"http://colinnest.qiniudn.com/projectCss%2Ftemplatemo_style.css\" type=\"text/css\" rel=\"stylesheet\" /> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.scrollTo-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.localscroll-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Finit.js\"></script> \n    \n    <link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.css\" type=\"text/css\" media=\"screen\" /> \n    <script type=\"text/JavaScript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.js\"></script> \n\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Forman.css\" type=\"text/css\" media=\"screen\" />\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fnivo-slider.css\" type=\"text/css\" media=\"screen\" />\n\n\n</head> \n<body> \n<div id=\"templatemo_wrapper\">\n<div id=\"templatemo_header\">\n    <div id=\"site_title\"><a href=\"http://colin1994.xyz\"  title=\"返回Colin's Nest\"></a></div>\n    <ul class=\"nav_menu\">\n        <li><a href=\"#app_1\">广陵村委会</a></li>\n\t\t<li><a href=\"#app_2\">软院新闻</a></li>\n\t\t<li><a href=\"#app_3\">小生有礼</a></li>\n\t\t<li><a href=\"#app_4\">情侣手游</a></li>\n\t\t<li><a href=\"#app_5\">专属情人</a></li>\n\t\t<li><a href=\"#app_6\">博客助手</a></li>\n\t\t<li><a href=\"#app_7\">企业通讯录</a></li>\n\t\t<li><a href=\"#app_8\">微博小尾巴</a></li>\n\t\t<li><a href=\"#app_9\">爱眼通</a></li>\n\t\t<li><a href=\"#app_10\">私家相机</a></li>\n\t\t<li><a href=\"#app_11\">甜甜机器伴侣</a></li>\n    </ul>\n    \n</div>\n<div id=\"templatemo_main\">\n\t<div id=\"content\"> \n<!-- \t\t广陵村委会 -->\n        <div class=\"section section_with_padding\" id=\"app_1\"> \n            <h1>广陵村委会</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id787202962?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_1.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;广陵区农村综合信息服务平台</font></B></p><br>\n\t\t\t\n            <p>大一完成的项目, 应广陵区相关领导的要求, 写了一个App, 让他们能随时方便的获取相关信息。该应用比较简单, 涉及一些数据的操作，以及UIWebView的应用。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t软院新闻 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_2\"> \n            <h1>软院新闻</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id796775928?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_2.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈工大软件学院新闻客户端</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 哈工大(威海)软件学院新闻客户端,实时获取最新资讯。 iOS/Android同步上线, 便于广大师生第一时间获取最新学院消息。主要涉及web service, json解析等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n\t\t\n<!-- \t\t小生有礼 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_3\"> \n            <h1>小生有礼</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_3.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好友生日管家+个性礼物</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 通过人人授权, 自动获取人人好友生日信息，并且在好友生日当天弹出提示。另外，包含礼物选购，礼物建购，DIY贺卡，节日短信等等功能。当初完成数据结构课设的一个项目, 也获得了第四届数据结构课程设计第一名。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t情侣手游 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_4\"> \n            <h1>情侣手游</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_4.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的月亮我的心</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 适合双人互动，主要针对于年轻的情侣闲暇时刻娱乐、吸引星星迷的参与。游戏分为双人跑酷, 连线游戏, 合体打怪物, 消星星对战等模式。 每个模式的互动性都极强。  双方游戏相互影响。 并且借助手机屏幕小这一因素, 给情侣制造指尖触电。 该游戏参与第七届com2us游戏设计大赛, 取得了第一名的好成绩</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t<div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_2.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_3.png\" alt=\"image 2\" />\t\n            </div>\n\n        </div> \n\t\t\n\t\t\n<!-- \t\t专属情人 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_5\"> \n            <h1>专属情人</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_5.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;屌丝的福音, 高仿女朋友</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 意在实现\"女朋友\"功能, 让每个屌丝都能有自己的专属情人。 该应用集 美女采集器, 隐形相机, 智能陪聊机器人, 宝宝预测, 泡妞技巧, 笑话等等功能,给你不一样的精彩。涉及内容比较广, 包括百度图片API, 图灵机器人API, face++API等等..</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t博客助手 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_6\"> \n            <h1>博客助手</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id890345475?ls=1&mt=8\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_6.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博客备份,离线浏览</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候自己开始正式使用博客, 发现没有很好的移动端app，就自己写了个。 包括1.在线浏览, 自动排版。2.一键导出, 随时浏览。3.一键搜索, 方便学习等功能。  主要是能把网上的博客备份到本地, 方便离线查看。涉及UIWebView与js的交互等等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t企业通讯录 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_7\"> \n            <h1>企业通讯录</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_7.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蓝牙话机, 企业必备</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 与卡尔电气和铁通公司合作的。 有对应的蓝牙话机,话机和手机之间采用蓝牙传输方式，话机端 蓝牙模块工作在从模式，手机端的蓝牙模块工作在主模式 。手机端应用软件在后台有服务负责跟话机的连接和通信。 提供给企业对应的云服务, 可以管理企业通讯录, 另外通过手机控制话机, 减少辐射的同时提高效率。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n<!-- \t\t微博小尾巴 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_8\"> \n            <h1>微博小尾巴</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_8.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;轻松变土豪</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候iPhone6(plus)刚发布, 微博上有人把小尾巴改成了iPhone6, 导致很多人跟风。 所以就写了这个应用, 能够自定义微博小尾巴, 包括70多种机型, 200多条个性文字。 轻轻松松变土豪。 不过后来微博自己的客户端也增加了这个功能。(在我之后发布的), 所以我这个\"微博小尾巴\"也就没存在必要了.. 完全没竞争力。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t爱眼通 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_9\"> \n            <h1>爱眼通</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id914567654?ls=1&mt=8\" ><img src= \"http://colinnest.qiniudn.com/projectImage%2Ficon_9.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最专业的随身视力测试</font></B></p><br>\n\t\t\t\n            <p>大二完成的项目, 该应用根据国家标准对数视力标准, 创新性实现利用手机随时测试视力。并且, 能自动记录各个时间段的视力测试结果。还能定时播放眼保健操, 休息提示, 模拟眼镜等, 让您舒缓眼部疲劳。更有视力保健指南, 教您更好呵护眼睛。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\n\n<!-- \t\t私家相机 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_10\"> \n            <h1>私家相机</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id924949102?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_10.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 利用私家相机, 您可以\"隐形\"拍照界面。伪装成其他界面。解决了韩版, 日版关不掉快门声的问题。更集合照片美化, 照片拼图功能。众多特效. 快速美化。加密相册, 保护隐私... </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n<!-- \t\t甜甜机器伴侣 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_11\"> \n            <h1>甜甜机器伴侣</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/us/app/tian-tian-ji-qi-ban-lu/id931200767?l=zh&ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_11.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></B></p><br>\n\t\t\t\n\t\t\t<p>大三完成的项目, 支持聊天对话、智能问答•  拥有笑话、天气、公交等丰富功能•  列车,航班,快递 轻松查询•  支持自然语言处理及语义理解•  数十亿知识库数据，应有尽有 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_1.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_2.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_3.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n        \n        \n    </div> \n</div>\n\n</div>\n\n</body> \n</html>","date":"2019-12-23T01:02:31.291Z","updated":"2019-12-23T01:02:31.291Z","path":"projects/index.html","title":"","comments":1,"layout":"page","_id":"ck4hqo1n3001yzwlnu123ik5j","content":"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>Colin's Project</title>\n<meta name=\"keywords\" content=\"dragonfly, free website templates, one page layout, jquery\">\n<meta name=\"description\" content=\"Dragonfly is one-page layout using jQuery and it is free website template from templatemo.com\">\n\n\t\n\t<link rel=\"shortcut icon\" href=\"http://colinnest.qiniudn.com/colinLogo.JPG\">\n\t<link href=\"http://colinnest.qiniudn.com/projectCss%2Ftemplatemo_style.css\" type=\"text/css\" rel=\"stylesheet\"> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.scrollTo-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.localscroll-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Finit.js\"></script> \n    \n    <link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.css\" type=\"text/css\" media=\"screen\"> \n    <script type=\"text/JavaScript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.js\"></script> \n\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Forman.css\" type=\"text/css\" media=\"screen\">\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fnivo-slider.css\" type=\"text/css\" media=\"screen\">\n\n\n</head> \n<body> \n<div id=\"templatemo_wrapper\">\n<div id=\"templatemo_header\">\n    <div id=\"site_title\"><a href=\"http://colin1994.xyz\" title=\"返回Colin's Nest\" target=\"_blank\" rel=\"external\"></a></div>\n    <ul class=\"nav_menu\">\n        <li><a href=\"#app_1\">广陵村委会</a></li>\n\t\t<li><a href=\"#app_2\">软院新闻</a></li>\n\t\t<li><a href=\"#app_3\">小生有礼</a></li>\n\t\t<li><a href=\"#app_4\">情侣手游</a></li>\n\t\t<li><a href=\"#app_5\">专属情人</a></li>\n\t\t<li><a href=\"#app_6\">博客助手</a></li>\n\t\t<li><a href=\"#app_7\">企业通讯录</a></li>\n\t\t<li><a href=\"#app_8\">微博小尾巴</a></li>\n\t\t<li><a href=\"#app_9\">爱眼通</a></li>\n\t\t<li><a href=\"#app_10\">私家相机</a></li>\n\t\t<li><a href=\"#app_11\">甜甜机器伴侣</a></li>\n    </ul>\n    \n</div>\n<div id=\"templatemo_main\">\n\t<div id=\"content\"> \n<!-- \t\t广陵村委会 -->\n        <div class=\"section section_with_padding\" id=\"app_1\"> \n            <h1>广陵村委会</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id787202962?ls=1&mt=8\" target=\"_blank\" rel=\"external\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_1.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;广陵区农村综合信息服务平台</font></b></p><br>\n\t\t\t\n            <p>大一完成的项目, 应广陵区相关领导的要求, 写了一个App, 让他们能随时方便的获取相关信息。该应用比较简单, 涉及一些数据的操作，以及UIWebView的应用。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_2.png\" alt=\"image 2\">\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t软院新闻 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_2\"> \n            <h1>软院新闻</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id796775928?ls=1&mt=8\" target=\"_blank\" rel=\"external\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_2.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈工大软件学院新闻客户端</font></b></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 哈工大(威海)软件学院新闻客户端,实时获取最新资讯。 iOS/Android同步上线, 便于广大师生第一时间获取最新学院消息。主要涉及web service, json解析等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_2.png\" alt=\"image 2\">\t\n            </div>\n        </div> \n\t\t\n\t\t\n<!-- \t\t小生有礼 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_3\"> \n            <h1>小生有礼</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_3.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好友生日管家+个性礼物</font></b></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 通过人人授权, 自动获取人人好友生日信息，并且在好友生日当天弹出提示。另外，包含礼物选购，礼物建购，DIY贺卡，节日短信等等功能。当初完成数据结构课设的一个项目, 也获得了第四届数据结构课程设计第一名。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_2.png\" alt=\"image 2\">\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t情侣手游 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_4\"> \n            <h1>情侣手游</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_4.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的月亮我的心</font></b></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 适合双人互动，主要针对于年轻的情侣闲暇时刻娱乐、吸引星星迷的参与。游戏分为双人跑酷, 连线游戏, 合体打怪物, 消星星对战等模式。 每个模式的互动性都极强。  双方游戏相互影响。 并且借助手机屏幕小这一因素, 给情侣制造指尖触电。 该游戏参与第七届com2us游戏设计大赛, 取得了第一名的好成绩</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t<div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_2.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_3.png\" alt=\"image 2\">\t\n            </div>\n\n        </div> \n\t\t\n\t\t\n<!-- \t\t专属情人 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_5\"> \n            <h1>专属情人</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_5.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;屌丝的福音, 高仿女朋友</font></b></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 意在实现\"女朋友\"功能, 让每个屌丝都能有自己的专属情人。 该应用集 美女采集器, 隐形相机, 智能陪聊机器人, 宝宝预测, 泡妞技巧, 笑话等等功能,给你不一样的精彩。涉及内容比较广, 包括百度图片API, 图灵机器人API, face++API等等..</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_2.png\" alt=\"image 2\">\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t博客助手 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_6\"> \n            <h1>博客助手</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id890345475?ls=1&mt=8\" target=\"_blank\" rel=\"external\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_6.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博客备份,离线浏览</font></b></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候自己开始正式使用博客, 发现没有很好的移动端app，就自己写了个。 包括1.在线浏览, 自动排版。2.一键导出, 随时浏览。3.一键搜索, 方便学习等功能。  主要是能把网上的博客备份到本地, 方便离线查看。涉及UIWebView与js的交互等等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_2.png\" alt=\"image 2\">\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t企业通讯录 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_7\"> \n            <h1>企业通讯录</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_7.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蓝牙话机, 企业必备</font></b></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 与卡尔电气和铁通公司合作的。 有对应的蓝牙话机,话机和手机之间采用蓝牙传输方式，话机端 蓝牙模块工作在从模式，手机端的蓝牙模块工作在主模式 。手机端应用软件在后台有服务负责跟话机的连接和通信。 提供给企业对应的云服务, 可以管理企业通讯录, 另外通过手机控制话机, 减少辐射的同时提高效率。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_2.png\" alt=\"image 2\">\t\n            </div>\n        </div>\n\t\t\n\t\t\n<!-- \t\t微博小尾巴 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_8\"> \n            <h1>微博小尾巴</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_8.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;轻松变土豪</font></b></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候iPhone6(plus)刚发布, 微博上有人把小尾巴改成了iPhone6, 导致很多人跟风。 所以就写了这个应用, 能够自定义微博小尾巴, 包括70多种机型, 200多条个性文字。 轻轻松松变土豪。 不过后来微博自己的客户端也增加了这个功能。(在我之后发布的), 所以我这个\"微博小尾巴\"也就没存在必要了.. 完全没竞争力。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_2.png\" alt=\"image 2\">\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t爱眼通 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_9\"> \n            <h1>爱眼通</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id914567654?ls=1&mt=8\" target=\"_blank\" rel=\"external\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_9.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最专业的随身视力测试</font></b></p><br>\n\t\t\t\n            <p>大二完成的项目, 该应用根据国家标准对数视力标准, 创新性实现利用手机随时测试视力。并且, 能自动记录各个时间段的视力测试结果。还能定时播放眼保健操, 休息提示, 模拟眼镜等, 让您舒缓眼部疲劳。更有视力保健指南, 教您更好呵护眼睛。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_2.png\" alt=\"image 2\">\t\n            </div>\n        </div>\n\t\n\n<!-- \t\t私家相机 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_10\"> \n            <h1>私家相机</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id924949102?ls=1&mt=8\" target=\"_blank\" rel=\"external\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_10.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></b></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 利用私家相机, 您可以\"隐形\"拍照界面。伪装成其他界面。解决了韩版, 日版关不掉快门声的问题。更集合照片美化, 照片拼图功能。众多特效. 快速美化。加密相册, 保护隐私... </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_0.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_1.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_2.png\" alt=\"image 2\">\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n<!-- \t\t甜甜机器伴侣 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_11\"> \n            <h1>甜甜机器伴侣</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/us/app/tian-tian-ji-qi-ban-lu/id931200767?l=zh&ls=1&mt=8\" target=\"_blank\" rel=\"external\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_11.png\" alt=\"image 1\"></a>\t\n          \t</div>\n            <p><b><font size=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></b></p><br>\n\t\t\t\n\t\t\t<p>大三完成的项目, 支持聊天对话、智能问答•  拥有笑话、天气、公交等丰富功能•  列车,航班,快递 轻松查询•  支持自然语言处理及语义理解•  数十亿知识库数据，应有尽有 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_1.png\" alt=\"image 2\">\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_2.png\" alt=\"image 2\">\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_3.png\" alt=\"image 2\">\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n        \n        \n    </div> \n</div>\n\n</div>\n\n</body> \n</html>","excerpt":"","more":"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>Colin's Project</title>\n<meta name=\"keywords\" content=\"dragonfly, free website templates, one page layout, jquery\" />\n<meta name=\"description\" content=\"Dragonfly is one-page layout using jQuery and it is free website template from templatemo.com\" />\n\n\t\n\t<link rel=\"shortcut icon\" href=\"http://colinnest.qiniudn.com/colinLogo.JPG\" />\n\t<link href=\"http://colinnest.qiniudn.com/projectCss%2Ftemplatemo_style.css\" type=\"text/css\" rel=\"stylesheet\" /> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.scrollTo-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fjquery.localscroll-min.js\"></script> \n\t<script type=\"text/javascript\" src=\"http://colinnest.qiniudn.com/projectCss%2Finit.js\"></script> \n    \n    <link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.css\" type=\"text/css\" media=\"screen\" /> \n    <script type=\"text/JavaScript\" src=\"http://colinnest.qiniudn.com/projectCss%2Fslimbox2.js\"></script> \n\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Forman.css\" type=\"text/css\" media=\"screen\" />\n<link rel=\"stylesheet\" href=\"http://colinnest.qiniudn.com/projectCss%2Fnivo-slider.css\" type=\"text/css\" media=\"screen\" />\n\n\n</head> \n<body> \n<div id=\"templatemo_wrapper\">\n<div id=\"templatemo_header\">\n    <div id=\"site_title\"><a href=\"http://colin1994.xyz\"  title=\"返回Colin's Nest\"></a></div>\n    <ul class=\"nav_menu\">\n        <li><a href=\"#app_1\">广陵村委会</a></li>\n\t\t<li><a href=\"#app_2\">软院新闻</a></li>\n\t\t<li><a href=\"#app_3\">小生有礼</a></li>\n\t\t<li><a href=\"#app_4\">情侣手游</a></li>\n\t\t<li><a href=\"#app_5\">专属情人</a></li>\n\t\t<li><a href=\"#app_6\">博客助手</a></li>\n\t\t<li><a href=\"#app_7\">企业通讯录</a></li>\n\t\t<li><a href=\"#app_8\">微博小尾巴</a></li>\n\t\t<li><a href=\"#app_9\">爱眼通</a></li>\n\t\t<li><a href=\"#app_10\">私家相机</a></li>\n\t\t<li><a href=\"#app_11\">甜甜机器伴侣</a></li>\n    </ul>\n    \n</div>\n<div id=\"templatemo_main\">\n\t<div id=\"content\"> \n<!-- \t\t广陵村委会 -->\n        <div class=\"section section_with_padding\" id=\"app_1\"> \n            <h1>广陵村委会</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id787202962?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_1.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;广陵区农村综合信息服务平台</font></B></p><br>\n\t\t\t\n            <p>大一完成的项目, 应广陵区相关领导的要求, 写了一个App, 让他们能随时方便的获取相关信息。该应用比较简单, 涉及一些数据的操作，以及UIWebView的应用。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_1_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t软院新闻 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_2\"> \n            <h1>软院新闻</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id796775928?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_2.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈工大软件学院新闻客户端</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 哈工大(威海)软件学院新闻客户端,实时获取最新资讯。 iOS/Android同步上线, 便于广大师生第一时间获取最新学院消息。主要涉及web service, json解析等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_2_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n\t\t\n<!-- \t\t小生有礼 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_3\"> \n            <h1>小生有礼</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_3.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好友生日管家+个性礼物</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 通过人人授权, 自动获取人人好友生日信息，并且在好友生日当天弹出提示。另外，包含礼物选购，礼物建购，DIY贺卡，节日短信等等功能。当初完成数据结构课设的一个项目, 也获得了第四届数据结构课程设计第一名。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_3_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t情侣手游 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_4\"> \n            <h1>情侣手游</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_4.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的月亮我的心</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 适合双人互动，主要针对于年轻的情侣闲暇时刻娱乐、吸引星星迷的参与。游戏分为双人跑酷, 连线游戏, 合体打怪物, 消星星对战等模式。 每个模式的互动性都极强。  双方游戏相互影响。 并且借助手机屏幕小这一因素, 给情侣制造指尖触电。 该游戏参与第七届com2us游戏设计大赛, 取得了第一名的好成绩</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t<div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_2.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fr\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_4_3.png\" alt=\"image 2\" />\t\n            </div>\n\n        </div> \n\t\t\n\t\t\n<!-- \t\t专属情人 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_5\"> \n            <h1>专属情人</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_5.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;屌丝的福音, 高仿女朋友</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 意在实现\"女朋友\"功能, 让每个屌丝都能有自己的专属情人。 该应用集 美女采集器, 隐形相机, 智能陪聊机器人, 宝宝预测, 泡妞技巧, 笑话等等功能,给你不一样的精彩。涉及内容比较广, 包括百度图片API, 图灵机器人API, face++API等等..</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_5_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div> \n\t\t\n<!-- \t\t博客助手 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_6\"> \n            <h1>博客助手</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id890345475?ls=1&mt=8\"><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_6.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博客备份,离线浏览</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候自己开始正式使用博客, 发现没有很好的移动端app，就自己写了个。 包括1.在线浏览, 自动排版。2.一键导出, 随时浏览。3.一键搜索, 方便学习等功能。  主要是能把网上的博客备份到本地, 方便离线查看。涉及UIWebView与js的交互等等知识。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_6_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t企业通讯录 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_7\"> \n            <h1>企业通讯录</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_7.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蓝牙话机, 企业必备</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 与卡尔电气和铁通公司合作的。 有对应的蓝牙话机,话机和手机之间采用蓝牙传输方式，话机端 蓝牙模块工作在从模式，手机端的蓝牙模块工作在主模式 。手机端应用软件在后台有服务负责跟话机的连接和通信。 提供给企业对应的云服务, 可以管理企业通讯录, 另外通过手机控制话机, 减少辐射的同时提高效率。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_7_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n<!-- \t\t微博小尾巴 -->\n\t\t\n\t\t<div class=\"section section_with_padding\" id=\"app_8\"> \n            <h1>微博小尾巴</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_8.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;轻松变土豪</font></B></p>\n\t\t\t\n\t\t\t<p>大二完成的项目, 那时候iPhone6(plus)刚发布, 微博上有人把小尾巴改成了iPhone6, 导致很多人跟风。 所以就写了这个应用, 能够自定义微博小尾巴, 包括70多种机型, 200多条个性文字。 轻轻松松变土豪。 不过后来微博自己的客户端也增加了这个功能。(在我之后发布的), 所以我这个\"微博小尾巴\"也就没存在必要了.. 完全没竞争力。</p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_8_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n<!-- \t\t爱眼通 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_9\"> \n            <h1>爱眼通</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id914567654?ls=1&mt=8\" ><img src= \"http://colinnest.qiniudn.com/projectImage%2Ficon_9.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最专业的随身视力测试</font></B></p><br>\n\t\t\t\n            <p>大二完成的项目, 该应用根据国家标准对数视力标准, 创新性实现利用手机随时测试视力。并且, 能自动记录各个时间段的视力测试结果。还能定时播放眼保健操, 休息提示, 模拟眼镜等, 让您舒缓眼部疲劳。更有视力保健指南, 教您更好呵护眼睛。 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_9_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\n\n<!-- \t\t私家相机 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_10\"> \n            <h1>私家相机</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/cn/app/wo-du/id924949102?ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_10.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></B></p><br>\n\t\t\t\n\t\t\t<p>大二完成的项目, 利用私家相机, 您可以\"隐形\"拍照界面。伪装成其他界面。解决了韩版, 日版关不掉快门声的问题。更集合照片美化, 照片拼图功能。众多特效. 快速美化。加密相册, 保护隐私... </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_0.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_1.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_10_2.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n<!-- \t\t甜甜机器伴侣 -->\n\t\t<div class=\"section section_with_padding\" id=\"app_11\"> \n            <h1>甜甜机器伴侣</h1>\n            <div class=\"img_border img_fl\"> \n\t\t\t\t<a href=\"https://itunes.apple.com/us/app/tian-tian-ji-qi-ban-lu/id931200767?l=zh&ls=1&mt=8\" ><img src=\"http://colinnest.qiniudn.com/projectImage%2Ficon_11.png\" alt=\"image 1\" /></a>\t\n          \t</div>\n            <p><B><font size=5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无声无影,想拍就拍</font></B></p><br>\n\t\t\t\n\t\t\t<p>大三完成的项目, 支持聊天对话、智能问答•  拥有笑话、天气、公交等丰富功能•  列车,航班,快递 轻松查询•  支持自然语言处理及语义理解•  数十亿知识库数据，应有尽有 </p>\t    \n            <div class=\"clear h20\"></div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_1.png\" alt=\"image 2\" />\t\n            </div>\n            <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_2.png\" alt=\"image 2\" />\t\n            </div>\n\t\t\t <div class=\"img_border img_fl\">\n                <img src=\"http://colinnest.qiniudn.com/projectImage%2Fproject_11_3.png\" alt=\"image 2\" />\t\n            </div>\n        </div>\n\t\t\n\t\t\n\t\t\n        \n        \n    </div> \n</div>\n\n</div>\n\n</body> \n</html>"}],"Post":[{"title":"OpenGL ES 开篇","date":"2017-04-01T11:30:10.000Z","_content":"\n在学习 OpenGL ES 之前，总结下我自己接触 OpenGL ES 时的一些疑惑，我相信这也是初学者都会遇到的一些困惑。\n\n## Q & A\n\n**Q：OpenGL 是什么 ?**\n\n> A：**OpenGL**（Open Graphics Library）是 Khronos Group （一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准）开发维护的一个规范，它是硬件无关的。它主要为我们定义了用来操作图形和图片的一系列函数的 API，需要注意的是 **OpenGL 本身并非 API**。\n>\n> 而 GPU 的硬件开发商则需要提供满足 OpenGL 规范的实现，这些实现通常被称为”驱动“，它们负责将 OpenGL 定义的 API 命令翻译为 GPU 指令。**所以你可以用同样的 OpenGL 代码在不同的显卡上跑**，因为它们实现了同一套规范，尽管内部实现可能存在差异。\n\n<!--more-->\n\n\n\n**Q：OpenGL ES 和 OpenGL 有什么关系 ?**\n\n> A：OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该规范也是由 Khronos Group 开发维护。\n>\n> OpenGL ES 是从 OpenGL 裁剪定制而来的，去除了 glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性，剩下最核心有用的部分。\n>\n> 可以理解成是一个**在移动平台上能够支持 OpenGL 最基本功能的精简规范**。\n>\n> ![20170111148411873373682.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_1.jpg)\n>\n> OpenGL ES 横跨在两个处理器之间，**协调两个内存区域之间的数据交换**。\n\n\n\n**Q：为什么要使用 OpenGL ES ?**\n\n> A：通常来说，计算机系统中 CPU、GPU 是协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。所以，尽可能让 CPU 和 GPU 各司其职发挥作用是提高渲染效率的关键。\n>\n> 正如我们之前提到过，OpenGL 正是给我们提供了访问 GPU 的能力，不仅如此，它还引入了**缓存**（Buffer）这个概念，大大提高了处理效率。\n>\n> ![20170111148411700373589.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_2.jpg)\n>\n> 图中的剪头，代表着数据交换，也是主要的性能瓶颈。\n>\n> **从一个内存区域复制到另一个内存区域的速度是相对较慢的**，并且在内存复制的过程中，CPU 和 GPU 都不能处理这区域内存，避免引起错误。此外，CPU / GPU 执行计算的速度是很快的，而内存的访问是相对较慢的，这也导致**处理器的性能处于次优状态**，这种状态叫做“**数据饥饿**”，简单来说就是**空有一身本事却无用武之地**。\n>\n> 针对此，OpenGL 为了提升渲染的性能，为两个内存区域间的数据交换定义了**缓存**。缓存是指 **GPU 能够控制和管理的连续 RAM**。程序从 CPU 的内存复制数据到 OpenGL ES 的缓存。通过独占缓存，GPU 能够尽可能以有效的方式读写内存。 GPU 把它处理数据的能力异步地应用在缓存上，意味着 GPU 使用缓存中的数据工作的同时，运行在 CPU 中的程序可以继续执行。\n>\n> 另外，在 iOS 平台上，[SpriteKit](https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043)，[Core Image](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185)，[Core Animation](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514) 也都是基于 OpenGL ES 实现的，所以在它们各自的领域，也都有不错的表现。\n>\n> 在图像处理方面，Core Image 提供了便捷的使用以及高效的性能，但是使用原生的 OpenGL ES 会更灵活，可定制性更高，同时支持跨平台。\n\n\n\n**Q：学习 OpenGL ES 需要关注哪些内容，本系列会如何介绍 OpenGL ES ?**\n\n> A：当然，如果你想全面系统的了解 OpenGL ES，那么每个接口，每种数据类型，OpenGL 工作原理，图形渲染管线每个阶段做了什么，如何编写着色器脚本等等都是需要了解的。这样的话，对着红蓝宝书学习是没有错的。\n>\n> 毋庸置疑，这样的学习必定是漫长枯燥的。\n>\n> - 你可能看了半天，学会渲染一个旋转的立方体，然后被一堆矩阵变换公式折腾的死去活来...\n> - 又或者看了半天，了解了一大堆概念，混合，深度测试，模版测试，面剔除等等，但是却不知道什么时候该用...\n>\n> 无可厚非，OpenGL 需要学习的东西太多太多（至少我个人还只是学了点皮毛），但是它们也有轻重之分，也有更好的学习方式。\n>\n> 本系列要做的，就是先详述必备的概念，便于之后的学习。然后用最直接的方式，**针对图像处理，逐步实现各种效果**，来慢慢深入学习 OpenGL。毕竟真正做出了东西，才会有学习的动力。\n\n\n\n**Q：该系列会使用哪个版本的 OpenGL ES ?**\n\n> A：OpenGL ES 2.0\n>\n> 目前 iOS 平台支持的有 OpenGL ES 1.0，2.0，3.0。\n>\n> OpenGL ES 1.0 是**固定管线**，就是只可配置的管线，实现不同效果就好像在电路中打开不同的开关一样，可定制程度低，当然不选择它。\n>\n> OpenGL ES 2.0，3.0 都是**可编程管线**，各种效果及他们的组合可以通过一般编程的方式实现，自由度高得多。虽然 OpenGL ES 3.0 加入了一些新的特性，但是它除了需要 **iOS 7.0** 以上之外，还对硬件有要求。**需要 iPhone 5S 之后的设备才支持**，这意味着包括 iPhone 5C 上使用的 PowerVR Series6 的 GPU 也是不支持。\n>\n> 出于现有主流设备的考虑，选择了 OpenGL ES 2.0。\n\n\n\n至此，如果觉得本系列文章还值得期待，那么，让我们一起努力吧～","source":"_posts/OpenGLES-Lesson00.md","raw":"title: OpenGL ES 开篇\n\ndate: 2017-04-01 19:30:10\n\ntags:\n\n- iOS开发\n- OpenGLES\n- 图像处理\n\n------\n\n在学习 OpenGL ES 之前，总结下我自己接触 OpenGL ES 时的一些疑惑，我相信这也是初学者都会遇到的一些困惑。\n\n## Q & A\n\n**Q：OpenGL 是什么 ?**\n\n> A：**OpenGL**（Open Graphics Library）是 Khronos Group （一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准）开发维护的一个规范，它是硬件无关的。它主要为我们定义了用来操作图形和图片的一系列函数的 API，需要注意的是 **OpenGL 本身并非 API**。\n>\n> 而 GPU 的硬件开发商则需要提供满足 OpenGL 规范的实现，这些实现通常被称为”驱动“，它们负责将 OpenGL 定义的 API 命令翻译为 GPU 指令。**所以你可以用同样的 OpenGL 代码在不同的显卡上跑**，因为它们实现了同一套规范，尽管内部实现可能存在差异。\n\n<!--more-->\n\n\n\n**Q：OpenGL ES 和 OpenGL 有什么关系 ?**\n\n> A：OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该规范也是由 Khronos Group 开发维护。\n>\n> OpenGL ES 是从 OpenGL 裁剪定制而来的，去除了 glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性，剩下最核心有用的部分。\n>\n> 可以理解成是一个**在移动平台上能够支持 OpenGL 最基本功能的精简规范**。\n>\n> ![20170111148411873373682.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_1.jpg)\n>\n> OpenGL ES 横跨在两个处理器之间，**协调两个内存区域之间的数据交换**。\n\n\n\n**Q：为什么要使用 OpenGL ES ?**\n\n> A：通常来说，计算机系统中 CPU、GPU 是协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。所以，尽可能让 CPU 和 GPU 各司其职发挥作用是提高渲染效率的关键。\n>\n> 正如我们之前提到过，OpenGL 正是给我们提供了访问 GPU 的能力，不仅如此，它还引入了**缓存**（Buffer）这个概念，大大提高了处理效率。\n>\n> ![20170111148411700373589.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_2.jpg)\n>\n> 图中的剪头，代表着数据交换，也是主要的性能瓶颈。\n>\n> **从一个内存区域复制到另一个内存区域的速度是相对较慢的**，并且在内存复制的过程中，CPU 和 GPU 都不能处理这区域内存，避免引起错误。此外，CPU / GPU 执行计算的速度是很快的，而内存的访问是相对较慢的，这也导致**处理器的性能处于次优状态**，这种状态叫做“**数据饥饿**”，简单来说就是**空有一身本事却无用武之地**。\n>\n> 针对此，OpenGL 为了提升渲染的性能，为两个内存区域间的数据交换定义了**缓存**。缓存是指 **GPU 能够控制和管理的连续 RAM**。程序从 CPU 的内存复制数据到 OpenGL ES 的缓存。通过独占缓存，GPU 能够尽可能以有效的方式读写内存。 GPU 把它处理数据的能力异步地应用在缓存上，意味着 GPU 使用缓存中的数据工作的同时，运行在 CPU 中的程序可以继续执行。\n>\n> 另外，在 iOS 平台上，[SpriteKit](https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043)，[Core Image](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185)，[Core Animation](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514) 也都是基于 OpenGL ES 实现的，所以在它们各自的领域，也都有不错的表现。\n>\n> 在图像处理方面，Core Image 提供了便捷的使用以及高效的性能，但是使用原生的 OpenGL ES 会更灵活，可定制性更高，同时支持跨平台。\n\n\n\n**Q：学习 OpenGL ES 需要关注哪些内容，本系列会如何介绍 OpenGL ES ?**\n\n> A：当然，如果你想全面系统的了解 OpenGL ES，那么每个接口，每种数据类型，OpenGL 工作原理，图形渲染管线每个阶段做了什么，如何编写着色器脚本等等都是需要了解的。这样的话，对着红蓝宝书学习是没有错的。\n>\n> 毋庸置疑，这样的学习必定是漫长枯燥的。\n>\n> - 你可能看了半天，学会渲染一个旋转的立方体，然后被一堆矩阵变换公式折腾的死去活来...\n> - 又或者看了半天，了解了一大堆概念，混合，深度测试，模版测试，面剔除等等，但是却不知道什么时候该用...\n>\n> 无可厚非，OpenGL 需要学习的东西太多太多（至少我个人还只是学了点皮毛），但是它们也有轻重之分，也有更好的学习方式。\n>\n> 本系列要做的，就是先详述必备的概念，便于之后的学习。然后用最直接的方式，**针对图像处理，逐步实现各种效果**，来慢慢深入学习 OpenGL。毕竟真正做出了东西，才会有学习的动力。\n\n\n\n**Q：该系列会使用哪个版本的 OpenGL ES ?**\n\n> A：OpenGL ES 2.0\n>\n> 目前 iOS 平台支持的有 OpenGL ES 1.0，2.0，3.0。\n>\n> OpenGL ES 1.0 是**固定管线**，就是只可配置的管线，实现不同效果就好像在电路中打开不同的开关一样，可定制程度低，当然不选择它。\n>\n> OpenGL ES 2.0，3.0 都是**可编程管线**，各种效果及他们的组合可以通过一般编程的方式实现，自由度高得多。虽然 OpenGL ES 3.0 加入了一些新的特性，但是它除了需要 **iOS 7.0** 以上之外，还对硬件有要求。**需要 iPhone 5S 之后的设备才支持**，这意味着包括 iPhone 5C 上使用的 PowerVR Series6 的 GPU 也是不支持。\n>\n> 出于现有主流设备的考虑，选择了 OpenGL ES 2.0。\n\n\n\n至此，如果觉得本系列文章还值得期待，那么，让我们一起努力吧～","slug":"OpenGLES-Lesson00","published":1,"updated":"2019-12-23T01:02:31.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1lr0000zwlnijf5roqj","content":"<p>在学习 OpenGL ES 之前，总结下我自己接触 OpenGL ES 时的一些疑惑，我相信这也是初学者都会遇到的一些困惑。</p>\n<h2 id=\"Q_&amp;_A\">Q &amp; A</h2><p><strong>Q：OpenGL 是什么 ?</strong></p>\n<blockquote>\n<p>A：<strong>OpenGL</strong>（Open Graphics Library）是 Khronos Group （一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准）开发维护的一个规范，它是硬件无关的。它主要为我们定义了用来操作图形和图片的一系列函数的 API，需要注意的是 <strong>OpenGL 本身并非 API</strong>。</p>\n<p>而 GPU 的硬件开发商则需要提供满足 OpenGL 规范的实现，这些实现通常被称为”驱动“，它们负责将 OpenGL 定义的 API 命令翻译为 GPU 指令。<strong>所以你可以用同样的 OpenGL 代码在不同的显卡上跑</strong>，因为它们实现了同一套规范，尽管内部实现可能存在差异。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>Q：OpenGL ES 和 OpenGL 有什么关系 ?</strong></p>\n<blockquote>\n<p>A：OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该规范也是由 Khronos Group 开发维护。</p>\n<p>OpenGL ES 是从 OpenGL 裁剪定制而来的，去除了 glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性，剩下最核心有用的部分。</p>\n<p>可以理解成是一个<strong>在移动平台上能够支持 OpenGL 最基本功能的精简规范</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_1.jpg\" alt=\"20170111148411873373682.jpg\"></p>\n<p>OpenGL ES 横跨在两个处理器之间，<strong>协调两个内存区域之间的数据交换</strong>。</p>\n</blockquote>\n<p><strong>Q：为什么要使用 OpenGL ES ?</strong></p>\n<blockquote>\n<p>A：通常来说，计算机系统中 CPU、GPU 是协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。所以，尽可能让 CPU 和 GPU 各司其职发挥作用是提高渲染效率的关键。</p>\n<p>正如我们之前提到过，OpenGL 正是给我们提供了访问 GPU 的能力，不仅如此，它还引入了<strong>缓存</strong>（Buffer）这个概念，大大提高了处理效率。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_2.jpg\" alt=\"20170111148411700373589.jpg\"></p>\n<p>图中的剪头，代表着数据交换，也是主要的性能瓶颈。</p>\n<p><strong>从一个内存区域复制到另一个内存区域的速度是相对较慢的</strong>，并且在内存复制的过程中，CPU 和 GPU 都不能处理这区域内存，避免引起错误。此外，CPU / GPU 执行计算的速度是很快的，而内存的访问是相对较慢的，这也导致<strong>处理器的性能处于次优状态</strong>，这种状态叫做“<strong>数据饥饿</strong>”，简单来说就是<strong>空有一身本事却无用武之地</strong>。</p>\n<p>针对此，OpenGL 为了提升渲染的性能，为两个内存区域间的数据交换定义了<strong>缓存</strong>。缓存是指 <strong>GPU 能够控制和管理的连续 RAM</strong>。程序从 CPU 的内存复制数据到 OpenGL ES 的缓存。通过独占缓存，GPU 能够尽可能以有效的方式读写内存。 GPU 把它处理数据的能力异步地应用在缓存上，意味着 GPU 使用缓存中的数据工作的同时，运行在 CPU 中的程序可以继续执行。</p>\n<p>另外，在 iOS 平台上，<a href=\"https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043\" target=\"_blank\" rel=\"external\">SpriteKit</a>，<a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185\" target=\"_blank\" rel=\"external\">Core Image</a>，<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514\" target=\"_blank\" rel=\"external\">Core Animation</a> 也都是基于 OpenGL ES 实现的，所以在它们各自的领域，也都有不错的表现。</p>\n<p>在图像处理方面，Core Image 提供了便捷的使用以及高效的性能，但是使用原生的 OpenGL ES 会更灵活，可定制性更高，同时支持跨平台。</p>\n</blockquote>\n<p><strong>Q：学习 OpenGL ES 需要关注哪些内容，本系列会如何介绍 OpenGL ES ?</strong></p>\n<blockquote>\n<p>A：当然，如果你想全面系统的了解 OpenGL ES，那么每个接口，每种数据类型，OpenGL 工作原理，图形渲染管线每个阶段做了什么，如何编写着色器脚本等等都是需要了解的。这样的话，对着红蓝宝书学习是没有错的。</p>\n<p>毋庸置疑，这样的学习必定是漫长枯燥的。</p>\n<ul>\n<li>你可能看了半天，学会渲染一个旋转的立方体，然后被一堆矩阵变换公式折腾的死去活来…</li>\n<li>又或者看了半天，了解了一大堆概念，混合，深度测试，模版测试，面剔除等等，但是却不知道什么时候该用…</li>\n</ul>\n<p>无可厚非，OpenGL 需要学习的东西太多太多（至少我个人还只是学了点皮毛），但是它们也有轻重之分，也有更好的学习方式。</p>\n<p>本系列要做的，就是先详述必备的概念，便于之后的学习。然后用最直接的方式，<strong>针对图像处理，逐步实现各种效果</strong>，来慢慢深入学习 OpenGL。毕竟真正做出了东西，才会有学习的动力。</p>\n</blockquote>\n<p><strong>Q：该系列会使用哪个版本的 OpenGL ES ?</strong></p>\n<blockquote>\n<p>A：OpenGL ES 2.0</p>\n<p>目前 iOS 平台支持的有 OpenGL ES 1.0，2.0，3.0。</p>\n<p>OpenGL ES 1.0 是<strong>固定管线</strong>，就是只可配置的管线，实现不同效果就好像在电路中打开不同的开关一样，可定制程度低，当然不选择它。</p>\n<p>OpenGL ES 2.0，3.0 都是<strong>可编程管线</strong>，各种效果及他们的组合可以通过一般编程的方式实现，自由度高得多。虽然 OpenGL ES 3.0 加入了一些新的特性，但是它除了需要 <strong>iOS 7.0</strong> 以上之外，还对硬件有要求。<strong>需要 iPhone 5S 之后的设备才支持</strong>，这意味着包括 iPhone 5C 上使用的 PowerVR Series6 的 GPU 也是不支持。</p>\n<p>出于现有主流设备的考虑，选择了 OpenGL ES 2.0。</p>\n</blockquote>\n<p>至此，如果觉得本系列文章还值得期待，那么，让我们一起努力吧～</p>\n","excerpt":"<p>在学习 OpenGL ES 之前，总结下我自己接触 OpenGL ES 时的一些疑惑，我相信这也是初学者都会遇到的一些困惑。</p>\n<h2 id=\"Q_&amp;_A\">Q &amp; A</h2><p><strong>Q：OpenGL 是什么 ?</strong></p>\n<blockquote>\n<p>A：<strong>OpenGL</strong>（Open Graphics Library）是 Khronos Group （一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准）开发维护的一个规范，它是硬件无关的。它主要为我们定义了用来操作图形和图片的一系列函数的 API，需要注意的是 <strong>OpenGL 本身并非 API</strong>。</p>\n<p>而 GPU 的硬件开发商则需要提供满足 OpenGL 规范的实现，这些实现通常被称为”驱动“，它们负责将 OpenGL 定义的 API 命令翻译为 GPU 指令。<strong>所以你可以用同样的 OpenGL 代码在不同的显卡上跑</strong>，因为它们实现了同一套规范，尽管内部实现可能存在差异。</p>\n</blockquote>","more":"<p><strong>Q：OpenGL ES 和 OpenGL 有什么关系 ?</strong></p>\n<blockquote>\n<p>A：OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该规范也是由 Khronos Group 开发维护。</p>\n<p>OpenGL ES 是从 OpenGL 裁剪定制而来的，去除了 glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性，剩下最核心有用的部分。</p>\n<p>可以理解成是一个<strong>在移动平台上能够支持 OpenGL 最基本功能的精简规范</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_1.jpg\" alt=\"20170111148411873373682.jpg\"></p>\n<p>OpenGL ES 横跨在两个处理器之间，<strong>协调两个内存区域之间的数据交换</strong>。</p>\n</blockquote>\n<p><strong>Q：为什么要使用 OpenGL ES ?</strong></p>\n<blockquote>\n<p>A：通常来说，计算机系统中 CPU、GPU 是协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。所以，尽可能让 CPU 和 GPU 各司其职发挥作用是提高渲染效率的关键。</p>\n<p>正如我们之前提到过，OpenGL 正是给我们提供了访问 GPU 的能力，不仅如此，它还引入了<strong>缓存</strong>（Buffer）这个概念，大大提高了处理效率。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_1_2.jpg\" alt=\"20170111148411700373589.jpg\"></p>\n<p>图中的剪头，代表着数据交换，也是主要的性能瓶颈。</p>\n<p><strong>从一个内存区域复制到另一个内存区域的速度是相对较慢的</strong>，并且在内存复制的过程中，CPU 和 GPU 都不能处理这区域内存，避免引起错误。此外，CPU / GPU 执行计算的速度是很快的，而内存的访问是相对较慢的，这也导致<strong>处理器的性能处于次优状态</strong>，这种状态叫做“<strong>数据饥饿</strong>”，简单来说就是<strong>空有一身本事却无用武之地</strong>。</p>\n<p>针对此，OpenGL 为了提升渲染的性能，为两个内存区域间的数据交换定义了<strong>缓存</strong>。缓存是指 <strong>GPU 能够控制和管理的连续 RAM</strong>。程序从 CPU 的内存复制数据到 OpenGL ES 的缓存。通过独占缓存，GPU 能够尽可能以有效的方式读写内存。 GPU 把它处理数据的能力异步地应用在缓存上，意味着 GPU 使用缓存中的数据工作的同时，运行在 CPU 中的程序可以继续执行。</p>\n<p>另外，在 iOS 平台上，<a href=\"https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043\">SpriteKit</a>，<a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185\">Core Image</a>，<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514\">Core Animation</a> 也都是基于 OpenGL ES 实现的，所以在它们各自的领域，也都有不错的表现。</p>\n<p>在图像处理方面，Core Image 提供了便捷的使用以及高效的性能，但是使用原生的 OpenGL ES 会更灵活，可定制性更高，同时支持跨平台。</p>\n</blockquote>\n<p><strong>Q：学习 OpenGL ES 需要关注哪些内容，本系列会如何介绍 OpenGL ES ?</strong></p>\n<blockquote>\n<p>A：当然，如果你想全面系统的了解 OpenGL ES，那么每个接口，每种数据类型，OpenGL 工作原理，图形渲染管线每个阶段做了什么，如何编写着色器脚本等等都是需要了解的。这样的话，对着红蓝宝书学习是没有错的。</p>\n<p>毋庸置疑，这样的学习必定是漫长枯燥的。</p>\n<ul>\n<li>你可能看了半天，学会渲染一个旋转的立方体，然后被一堆矩阵变换公式折腾的死去活来…</li>\n<li>又或者看了半天，了解了一大堆概念，混合，深度测试，模版测试，面剔除等等，但是却不知道什么时候该用…</li>\n</ul>\n<p>无可厚非，OpenGL 需要学习的东西太多太多（至少我个人还只是学了点皮毛），但是它们也有轻重之分，也有更好的学习方式。</p>\n<p>本系列要做的，就是先详述必备的概念，便于之后的学习。然后用最直接的方式，<strong>针对图像处理，逐步实现各种效果</strong>，来慢慢深入学习 OpenGL。毕竟真正做出了东西，才会有学习的动力。</p>\n</blockquote>\n<p><strong>Q：该系列会使用哪个版本的 OpenGL ES ?</strong></p>\n<blockquote>\n<p>A：OpenGL ES 2.0</p>\n<p>目前 iOS 平台支持的有 OpenGL ES 1.0，2.0，3.0。</p>\n<p>OpenGL ES 1.0 是<strong>固定管线</strong>，就是只可配置的管线，实现不同效果就好像在电路中打开不同的开关一样，可定制程度低，当然不选择它。</p>\n<p>OpenGL ES 2.0，3.0 都是<strong>可编程管线</strong>，各种效果及他们的组合可以通过一般编程的方式实现，自由度高得多。虽然 OpenGL ES 3.0 加入了一些新的特性，但是它除了需要 <strong>iOS 7.0</strong> 以上之外，还对硬件有要求。<strong>需要 iPhone 5S 之后的设备才支持</strong>，这意味着包括 iPhone 5C 上使用的 PowerVR Series6 的 GPU 也是不支持。</p>\n<p>出于现有主流设备的考虑，选择了 OpenGL ES 2.0。</p>\n</blockquote>\n<p>至此，如果觉得本系列文章还值得期待，那么，让我们一起努力吧～</p>"},{"title":"OpenGL ES， 初学者的自我总结","date":"2017-04-01T11:18:10.000Z","_content":"\n## 前言：\n\n> 学习 OpenGL ES 一段时间了，**深知这个过程的不容易**。\n>\n> 尤其是入门，OpenGL 到底好在哪里？什么是渲染管线？什么是状态机？纹理是不是就是图片？深度测试，模版测试又是什么鬼？...\n>\n> OpenGL **有太多太多的东西需要学习**。我最初接触 OpenGL，就是想借助它，实现美图秀秀里的一些功能。然而，不知道看了多少教程，实现了多少个旋转立方体，困惑了多少次，放弃了多少回...\n>\n> 慢慢地，似乎找到了一些门路...\n>\n> - 可以导入照片处理并保存了\n> - 可以实现简单的滤镜了\n> - 可以实现画笔功能了\n> - 可以实现马赛克功能了\n> - ...\n>\n> 于是，这系列的文章应运而生。\n\n<!--more-->\n\n\n\n## 目标\n\n这系列文章主要是个人学习过程中的一些总结，因为本人也是初学者，所以会从初学者角度，介绍 OpenGL ES 图像处理最直接的一些知识。\n\n**利用 OpenGL ES，学习如何在 iOS 平台上进行图像处理，实现各种效果。**\n\n这，就是我想学到的，也是想分享给大家的。\n\n\n\n> PS：时间允许的话，希望能保证一个星期输出一篇文章，鞭策自己～\n\n\n\n## 目录\n\n### 基础扫盲：\n\n1. [OpenGL ES 开篇](http://colin1994.github.io/2017/04/01/OpenGLES-Lesson00/) : 以 Q&A 的形式，列举出在学习 OpenGL ES 之前会存在的一些疑惑。权衡是否该继续学习 OpenGL ES。\n2. [OpenGL ES 基础概念](http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/)：扫盲篇，先介绍一些必须了解的知识，便于之后能直接进入实战阶段。\n3. [OpenGL ES 环境搭建](http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/)：详解 OpenGL ES 接入方式，以最基础效果（设置背景色）来阐述。\n4. [OpenGL ES 渲染基本图元](http://colin1994.github.io/2017/04/18/OpenGLES-Lesson03/)：详细介绍可编程图形渲染管线是如何工作的。\n5. [GLSL 详解（基础篇）](http://colin1994.github.io/2017/11/11/OpenGLES-Lesson04/)：详细介绍 OpenGL ES 2.0 着色器语言 GLSL 基础语法。\n6. [GLSL 详解（高级篇）](http://colin1994.github.io/2017/11/12/OpenGLES-Lesson05/)：详细介绍 OpenGL ES 2.0 着色器语言高级特性。\n\n\n\n### Demo 讲解：\n\n1. 显示图片\n2. 视图封装\n3. 滤镜：色温（简单全局应用）\n4. 滤镜：Vignette，晕映（根据距离，区分处理）\n5. 形变：马赛克（简单形变，几点汇聚成一点）\n6. 形变：素描效果（根据边缘点，动态计算取样点色值）\n7. 基于 Lookup Table（Lut）的滤镜实现（用查找表替代浮点计算，提高效率）\n8. 多重滤镜叠加（实现及优化）\n\n\n\n### 实战训练：\n\n> 敬请期待\n\n\n\n\n\n## 学习资料\n\n> PS：这里将罗列个人学习过程中，认为好的一些书籍，教程，Demo等。\n>\n> 该系列的文章中，一些阐述，配图，可能是从其它文章或者书籍中摘录整理的。为保证阅读以及书写方便，这部分出处说明统一放到学习资料里。\n>\n> 本人也处于学习阶段，精力有限，难免引用前人优秀教程。如果对您造成不必要的麻烦，请及时告知。\n\n\n\n### 书籍\n\n[OpenGL ES 2.0 API 快速参考卡片](https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf)\n\n[红宝书：OpenGL Programming Guide](https://www.amazon.com/OpenGL-Programming-Guide-Official-Learning/dp/0134495497)\n\n[蓝宝书：OpenGL Superbible](https://www.amazon.com/OpenGL-Superbible-Comprehensive-Tutorial-Reference/dp/0672337479)\n\n\n\n### 教程\n\n[OpenGL ES Programming Guide for iOS](https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1)\n\n[Learn OpenGL](http://learnopengl.com/)\n\n[OpenGL ES_Max](http://www.edwinho.org/lessons/2015-08/opengl-es.html)\n\n[OpenGL ES 01 OpenGL ES之初体验](http://blog.csdn.net/kesalin/article/details/8221393)\n\n[Opengles Shading Language](https://www.khronos.org/files/opengles_shading_language.pdf)\n\n[OpenGL ES 2.0 着色器语言GLSL](http://aillieo.cn/post/2017-01-15-opengl-es-glsl-01/)\n\n\n\n### Demo\n\n[GLImageProcessing](https://github.com/twenty3/GLImageProcessing)\n\n[GPUImage](https://github.com/BradLarson/GPUImage)\n\n[BCMeshTransformView](https://github.com/Ciechan/BCMeshTransformView)\n\n\n\n### Idea\n\n[Shadertoy](https://www.shadertoy.com/)\n\n[PhotoFunia](https://photofunia.com/)\n\n\n\n\n\n> PS：本人也处于 OpenGL ES 学习阶段，所以文章中**难免存在问题**，或者待优化地方。如果有任何不对，**欢迎指出交流**～\n","source":"_posts/OpenGLES-Menu.md","raw":"title: OpenGL ES， 初学者的自我总结\n\ndate: 2017-04-01 19:18:10\n\ntags:\n\n- iOS开发\n- OpenGLES\n- 图像处理\n\n------\n\n## 前言：\n\n> 学习 OpenGL ES 一段时间了，**深知这个过程的不容易**。\n>\n> 尤其是入门，OpenGL 到底好在哪里？什么是渲染管线？什么是状态机？纹理是不是就是图片？深度测试，模版测试又是什么鬼？...\n>\n> OpenGL **有太多太多的东西需要学习**。我最初接触 OpenGL，就是想借助它，实现美图秀秀里的一些功能。然而，不知道看了多少教程，实现了多少个旋转立方体，困惑了多少次，放弃了多少回...\n>\n> 慢慢地，似乎找到了一些门路...\n>\n> - 可以导入照片处理并保存了\n> - 可以实现简单的滤镜了\n> - 可以实现画笔功能了\n> - 可以实现马赛克功能了\n> - ...\n>\n> 于是，这系列的文章应运而生。\n\n<!--more-->\n\n\n\n## 目标\n\n这系列文章主要是个人学习过程中的一些总结，因为本人也是初学者，所以会从初学者角度，介绍 OpenGL ES 图像处理最直接的一些知识。\n\n**利用 OpenGL ES，学习如何在 iOS 平台上进行图像处理，实现各种效果。**\n\n这，就是我想学到的，也是想分享给大家的。\n\n\n\n> PS：时间允许的话，希望能保证一个星期输出一篇文章，鞭策自己～\n\n\n\n## 目录\n\n### 基础扫盲：\n\n1. [OpenGL ES 开篇](http://colin1994.github.io/2017/04/01/OpenGLES-Lesson00/) : 以 Q&A 的形式，列举出在学习 OpenGL ES 之前会存在的一些疑惑。权衡是否该继续学习 OpenGL ES。\n2. [OpenGL ES 基础概念](http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/)：扫盲篇，先介绍一些必须了解的知识，便于之后能直接进入实战阶段。\n3. [OpenGL ES 环境搭建](http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/)：详解 OpenGL ES 接入方式，以最基础效果（设置背景色）来阐述。\n4. [OpenGL ES 渲染基本图元](http://colin1994.github.io/2017/04/18/OpenGLES-Lesson03/)：详细介绍可编程图形渲染管线是如何工作的。\n5. [GLSL 详解（基础篇）](http://colin1994.github.io/2017/11/11/OpenGLES-Lesson04/)：详细介绍 OpenGL ES 2.0 着色器语言 GLSL 基础语法。\n6. [GLSL 详解（高级篇）](http://colin1994.github.io/2017/11/12/OpenGLES-Lesson05/)：详细介绍 OpenGL ES 2.0 着色器语言高级特性。\n\n\n\n### Demo 讲解：\n\n1. 显示图片\n2. 视图封装\n3. 滤镜：色温（简单全局应用）\n4. 滤镜：Vignette，晕映（根据距离，区分处理）\n5. 形变：马赛克（简单形变，几点汇聚成一点）\n6. 形变：素描效果（根据边缘点，动态计算取样点色值）\n7. 基于 Lookup Table（Lut）的滤镜实现（用查找表替代浮点计算，提高效率）\n8. 多重滤镜叠加（实现及优化）\n\n\n\n### 实战训练：\n\n> 敬请期待\n\n\n\n\n\n## 学习资料\n\n> PS：这里将罗列个人学习过程中，认为好的一些书籍，教程，Demo等。\n>\n> 该系列的文章中，一些阐述，配图，可能是从其它文章或者书籍中摘录整理的。为保证阅读以及书写方便，这部分出处说明统一放到学习资料里。\n>\n> 本人也处于学习阶段，精力有限，难免引用前人优秀教程。如果对您造成不必要的麻烦，请及时告知。\n\n\n\n### 书籍\n\n[OpenGL ES 2.0 API 快速参考卡片](https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf)\n\n[红宝书：OpenGL Programming Guide](https://www.amazon.com/OpenGL-Programming-Guide-Official-Learning/dp/0134495497)\n\n[蓝宝书：OpenGL Superbible](https://www.amazon.com/OpenGL-Superbible-Comprehensive-Tutorial-Reference/dp/0672337479)\n\n\n\n### 教程\n\n[OpenGL ES Programming Guide for iOS](https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1)\n\n[Learn OpenGL](http://learnopengl.com/)\n\n[OpenGL ES_Max](http://www.edwinho.org/lessons/2015-08/opengl-es.html)\n\n[OpenGL ES 01 OpenGL ES之初体验](http://blog.csdn.net/kesalin/article/details/8221393)\n\n[Opengles Shading Language](https://www.khronos.org/files/opengles_shading_language.pdf)\n\n[OpenGL ES 2.0 着色器语言GLSL](http://aillieo.cn/post/2017-01-15-opengl-es-glsl-01/)\n\n\n\n### Demo\n\n[GLImageProcessing](https://github.com/twenty3/GLImageProcessing)\n\n[GPUImage](https://github.com/BradLarson/GPUImage)\n\n[BCMeshTransformView](https://github.com/Ciechan/BCMeshTransformView)\n\n\n\n### Idea\n\n[Shadertoy](https://www.shadertoy.com/)\n\n[PhotoFunia](https://photofunia.com/)\n\n\n\n\n\n> PS：本人也处于 OpenGL ES 学习阶段，所以文章中**难免存在问题**，或者待优化地方。如果有任何不对，**欢迎指出交流**～\n","slug":"OpenGLES-Menu","published":1,"updated":"2019-12-23T01:02:31.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1lx0002zwlnzl7kai3a","content":"<h2 id=\"前言：\">前言：</h2><blockquote>\n<p>学习 OpenGL ES 一段时间了，<strong>深知这个过程的不容易</strong>。</p>\n<p>尤其是入门，OpenGL 到底好在哪里？什么是渲染管线？什么是状态机？纹理是不是就是图片？深度测试，模版测试又是什么鬼？…</p>\n<p>OpenGL <strong>有太多太多的东西需要学习</strong>。我最初接触 OpenGL，就是想借助它，实现美图秀秀里的一些功能。然而，不知道看了多少教程，实现了多少个旋转立方体，困惑了多少次，放弃了多少回…</p>\n<p>慢慢地，似乎找到了一些门路…</p>\n<ul>\n<li>可以导入照片处理并保存了</li>\n<li>可以实现简单的滤镜了</li>\n<li>可以实现画笔功能了</li>\n<li>可以实现马赛克功能了</li>\n<li>…</li>\n</ul>\n<p>于是，这系列的文章应运而生。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"目标\">目标</h2><p>这系列文章主要是个人学习过程中的一些总结，因为本人也是初学者，所以会从初学者角度，介绍 OpenGL ES 图像处理最直接的一些知识。</p>\n<p><strong>利用 OpenGL ES，学习如何在 iOS 平台上进行图像处理，实现各种效果。</strong></p>\n<p>这，就是我想学到的，也是想分享给大家的。</p>\n<blockquote>\n<p>PS：时间允许的话，希望能保证一个星期输出一篇文章，鞭策自己～</p>\n</blockquote>\n<h2 id=\"目录\">目录</h2><h3 id=\"基础扫盲：\">基础扫盲：</h3><ol>\n<li><a href=\"http://colin1994.github.io/2017/04/01/OpenGLES-Lesson00/\" target=\"_blank\" rel=\"external\">OpenGL ES 开篇</a> : 以 Q&amp;A 的形式，列举出在学习 OpenGL ES 之前会存在的一些疑惑。权衡是否该继续学习 OpenGL ES。</li>\n<li><a href=\"http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/\" target=\"_blank\" rel=\"external\">OpenGL ES 基础概念</a>：扫盲篇，先介绍一些必须了解的知识，便于之后能直接进入实战阶段。</li>\n<li><a href=\"http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/\" target=\"_blank\" rel=\"external\">OpenGL ES 环境搭建</a>：详解 OpenGL ES 接入方式，以最基础效果（设置背景色）来阐述。</li>\n<li><a href=\"http://colin1994.github.io/2017/04/18/OpenGLES-Lesson03/\" target=\"_blank\" rel=\"external\">OpenGL ES 渲染基本图元</a>：详细介绍可编程图形渲染管线是如何工作的。</li>\n<li><a href=\"http://colin1994.github.io/2017/11/11/OpenGLES-Lesson04/\" target=\"_blank\" rel=\"external\">GLSL 详解（基础篇）</a>：详细介绍 OpenGL ES 2.0 着色器语言 GLSL 基础语法。</li>\n<li><a href=\"http://colin1994.github.io/2017/11/12/OpenGLES-Lesson05/\" target=\"_blank\" rel=\"external\">GLSL 详解（高级篇）</a>：详细介绍 OpenGL ES 2.0 着色器语言高级特性。</li>\n</ol>\n<h3 id=\"Demo_讲解：\">Demo 讲解：</h3><ol>\n<li>显示图片</li>\n<li>视图封装</li>\n<li>滤镜：色温（简单全局应用）</li>\n<li>滤镜：Vignette，晕映（根据距离，区分处理）</li>\n<li>形变：马赛克（简单形变，几点汇聚成一点）</li>\n<li>形变：素描效果（根据边缘点，动态计算取样点色值）</li>\n<li>基于 Lookup Table（Lut）的滤镜实现（用查找表替代浮点计算，提高效率）</li>\n<li>多重滤镜叠加（实现及优化）</li>\n</ol>\n<h3 id=\"实战训练：\">实战训练：</h3><blockquote>\n<p>敬请期待</p>\n</blockquote>\n<h2 id=\"学习资料\">学习资料</h2><blockquote>\n<p>PS：这里将罗列个人学习过程中，认为好的一些书籍，教程，Demo等。</p>\n<p>该系列的文章中，一些阐述，配图，可能是从其它文章或者书籍中摘录整理的。为保证阅读以及书写方便，这部分出处说明统一放到学习资料里。</p>\n<p>本人也处于学习阶段，精力有限，难免引用前人优秀教程。如果对您造成不必要的麻烦，请及时告知。</p>\n</blockquote>\n<h3 id=\"书籍\">书籍</h3><p><a href=\"https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf\" target=\"_blank\" rel=\"external\">OpenGL ES 2.0 API 快速参考卡片</a></p>\n<p><a href=\"https://www.amazon.com/OpenGL-Programming-Guide-Official-Learning/dp/0134495497\" target=\"_blank\" rel=\"external\">红宝书：OpenGL Programming Guide</a></p>\n<p><a href=\"https://www.amazon.com/OpenGL-Superbible-Comprehensive-Tutorial-Reference/dp/0672337479\" target=\"_blank\" rel=\"external\">蓝宝书：OpenGL Superbible</a></p>\n<h3 id=\"教程\">教程</h3><p><a href=\"https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1\" target=\"_blank\" rel=\"external\">OpenGL ES Programming Guide for iOS</a></p>\n<p><a href=\"http://learnopengl.com/\" target=\"_blank\" rel=\"external\">Learn OpenGL</a></p>\n<p><a href=\"http://www.edwinho.org/lessons/2015-08/opengl-es.html\" target=\"_blank\" rel=\"external\">OpenGL ES_Max</a></p>\n<p><a href=\"http://blog.csdn.net/kesalin/article/details/8221393\" target=\"_blank\" rel=\"external\">OpenGL ES 01 OpenGL ES之初体验</a></p>\n<p><a href=\"https://www.khronos.org/files/opengles_shading_language.pdf\" target=\"_blank\" rel=\"external\">Opengles Shading Language</a></p>\n<p><a href=\"http://aillieo.cn/post/2017-01-15-opengl-es-glsl-01/\" target=\"_blank\" rel=\"external\">OpenGL ES 2.0 着色器语言GLSL</a></p>\n<h3 id=\"Demo\">Demo</h3><p><a href=\"https://github.com/twenty3/GLImageProcessing\" target=\"_blank\" rel=\"external\">GLImageProcessing</a></p>\n<p><a href=\"https://github.com/BradLarson/GPUImage\" target=\"_blank\" rel=\"external\">GPUImage</a></p>\n<p><a href=\"https://github.com/Ciechan/BCMeshTransformView\" target=\"_blank\" rel=\"external\">BCMeshTransformView</a></p>\n<h3 id=\"Idea\">Idea</h3><p><a href=\"https://www.shadertoy.com/\" target=\"_blank\" rel=\"external\">Shadertoy</a></p>\n<p><a href=\"https://photofunia.com/\" target=\"_blank\" rel=\"external\">PhotoFunia</a></p>\n<blockquote>\n<p>PS：本人也处于 OpenGL ES 学习阶段，所以文章中<strong>难免存在问题</strong>，或者待优化地方。如果有任何不对，<strong>欢迎指出交流</strong>～</p>\n</blockquote>\n","excerpt":"<h2 id=\"前言：\">前言：</h2><blockquote>\n<p>学习 OpenGL ES 一段时间了，<strong>深知这个过程的不容易</strong>。</p>\n<p>尤其是入门，OpenGL 到底好在哪里？什么是渲染管线？什么是状态机？纹理是不是就是图片？深度测试，模版测试又是什么鬼？…</p>\n<p>OpenGL <strong>有太多太多的东西需要学习</strong>。我最初接触 OpenGL，就是想借助它，实现美图秀秀里的一些功能。然而，不知道看了多少教程，实现了多少个旋转立方体，困惑了多少次，放弃了多少回…</p>\n<p>慢慢地，似乎找到了一些门路…</p>\n<ul>\n<li>可以导入照片处理并保存了</li>\n<li>可以实现简单的滤镜了</li>\n<li>可以实现画笔功能了</li>\n<li>可以实现马赛克功能了</li>\n<li>…</li>\n</ul>\n<p>于是，这系列的文章应运而生。</p>\n</blockquote>","more":"<h2 id=\"目标\">目标</h2><p>这系列文章主要是个人学习过程中的一些总结，因为本人也是初学者，所以会从初学者角度，介绍 OpenGL ES 图像处理最直接的一些知识。</p>\n<p><strong>利用 OpenGL ES，学习如何在 iOS 平台上进行图像处理，实现各种效果。</strong></p>\n<p>这，就是我想学到的，也是想分享给大家的。</p>\n<blockquote>\n<p>PS：时间允许的话，希望能保证一个星期输出一篇文章，鞭策自己～</p>\n</blockquote>\n<h2 id=\"目录\">目录</h2><h3 id=\"基础扫盲：\">基础扫盲：</h3><ol>\n<li><a href=\"http://colin1994.github.io/2017/04/01/OpenGLES-Lesson00/\">OpenGL ES 开篇</a> : 以 Q&amp;A 的形式，列举出在学习 OpenGL ES 之前会存在的一些疑惑。权衡是否该继续学习 OpenGL ES。</li>\n<li><a href=\"http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/\">OpenGL ES 基础概念</a>：扫盲篇，先介绍一些必须了解的知识，便于之后能直接进入实战阶段。</li>\n<li><a href=\"http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/\">OpenGL ES 环境搭建</a>：详解 OpenGL ES 接入方式，以最基础效果（设置背景色）来阐述。</li>\n<li><a href=\"http://colin1994.github.io/2017/04/18/OpenGLES-Lesson03/\">OpenGL ES 渲染基本图元</a>：详细介绍可编程图形渲染管线是如何工作的。</li>\n<li><a href=\"http://colin1994.github.io/2017/11/11/OpenGLES-Lesson04/\">GLSL 详解（基础篇）</a>：详细介绍 OpenGL ES 2.0 着色器语言 GLSL 基础语法。</li>\n<li><a href=\"http://colin1994.github.io/2017/11/12/OpenGLES-Lesson05/\">GLSL 详解（高级篇）</a>：详细介绍 OpenGL ES 2.0 着色器语言高级特性。</li>\n</ol>\n<h3 id=\"Demo_讲解：\">Demo 讲解：</h3><ol>\n<li>显示图片</li>\n<li>视图封装</li>\n<li>滤镜：色温（简单全局应用）</li>\n<li>滤镜：Vignette，晕映（根据距离，区分处理）</li>\n<li>形变：马赛克（简单形变，几点汇聚成一点）</li>\n<li>形变：素描效果（根据边缘点，动态计算取样点色值）</li>\n<li>基于 Lookup Table（Lut）的滤镜实现（用查找表替代浮点计算，提高效率）</li>\n<li>多重滤镜叠加（实现及优化）</li>\n</ol>\n<h3 id=\"实战训练：\">实战训练：</h3><blockquote>\n<p>敬请期待</p>\n</blockquote>\n<h2 id=\"学习资料\">学习资料</h2><blockquote>\n<p>PS：这里将罗列个人学习过程中，认为好的一些书籍，教程，Demo等。</p>\n<p>该系列的文章中，一些阐述，配图，可能是从其它文章或者书籍中摘录整理的。为保证阅读以及书写方便，这部分出处说明统一放到学习资料里。</p>\n<p>本人也处于学习阶段，精力有限，难免引用前人优秀教程。如果对您造成不必要的麻烦，请及时告知。</p>\n</blockquote>\n<h3 id=\"书籍\">书籍</h3><p><a href=\"https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf\">OpenGL ES 2.0 API 快速参考卡片</a></p>\n<p><a href=\"https://www.amazon.com/OpenGL-Programming-Guide-Official-Learning/dp/0134495497\">红宝书：OpenGL Programming Guide</a></p>\n<p><a href=\"https://www.amazon.com/OpenGL-Superbible-Comprehensive-Tutorial-Reference/dp/0672337479\">蓝宝书：OpenGL Superbible</a></p>\n<h3 id=\"教程\">教程</h3><p><a href=\"https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1\">OpenGL ES Programming Guide for iOS</a></p>\n<p><a href=\"http://learnopengl.com/\">Learn OpenGL</a></p>\n<p><a href=\"http://www.edwinho.org/lessons/2015-08/opengl-es.html\">OpenGL ES_Max</a></p>\n<p><a href=\"http://blog.csdn.net/kesalin/article/details/8221393\">OpenGL ES 01 OpenGL ES之初体验</a></p>\n<p><a href=\"https://www.khronos.org/files/opengles_shading_language.pdf\">Opengles Shading Language</a></p>\n<p><a href=\"http://aillieo.cn/post/2017-01-15-opengl-es-glsl-01/\">OpenGL ES 2.0 着色器语言GLSL</a></p>\n<h3 id=\"Demo\">Demo</h3><p><a href=\"https://github.com/twenty3/GLImageProcessing\">GLImageProcessing</a></p>\n<p><a href=\"https://github.com/BradLarson/GPUImage\">GPUImage</a></p>\n<p><a href=\"https://github.com/Ciechan/BCMeshTransformView\">BCMeshTransformView</a></p>\n<h3 id=\"Idea\">Idea</h3><p><a href=\"https://www.shadertoy.com/\">Shadertoy</a></p>\n<p><a href=\"https://photofunia.com/\">PhotoFunia</a></p>\n<blockquote>\n<p>PS：本人也处于 OpenGL ES 学习阶段，所以文章中<strong>难免存在问题</strong>，或者待优化地方。如果有任何不对，<strong>欢迎指出交流</strong>～</p>\n</blockquote>"},{"layout":"iOS开发小记","title":"正则表达式","date":"2015-07-11T02:14:52.000Z","_content":"\n> 正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。\n\n\n\n1. 系统自带的, 如: NSPredicate, rangeOfString：option, NSRegularExpression\n2. [RegexKitLite](http://regexkit.sourceforge.net/RegexKitLite/) RegexKitLite 是一个轻量级的 Objective-C 的正则表达式库,支持 Mac OS X 和 iOS,使用 ICU 库开发。\n\n至于`RegexKitLite`, 这里不做介绍。着重介绍系统自带的那几个办法。\n\n> PS: 阅读本文前提是您已经掌握了正则基本语法, 如果对正则还不太了解, 可以参考以下几个链接:\n\n正则表达式学习链接：\n\n1. [55分钟学会正则表达式](http://doslin.com/regular%20expressions/2014/03/11/learn-regular-expressions-in-about-55-minutes.html)\n2. [揭开正则表达式的神秘面纱](http://www.regexlab.com/zh/regref.htm)\n3. [RegExLib.com(正则表达式库查询)](http://www.regexplib.com/DisplayPatterns.aspx?cattabindex=4&categoryId=5)\n\n*****\n\n<!--more-->\n\n\n\n## 1. NSPredicate\n\n> 简述：Cocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取。\n\n``` objc\nNSPredicate *predicate = [NSPredicate predicateWithFormat:(NSString *), ...];\n```\n\n其中, 常见的`Format `有:\n\n(1) 比较运算符: >, <, ==, >=, <=, !=\n\n``` \n例：@\"number > 100\"\n```\n\n(2) 范围运算符: IN, BETWEEN\n\n​\t\n\n``` \n例：@\"number BETWEEN {1,5}\"\n   @\"address IN {'shanghai','beijing'}\"\n```\n\n(3) 字符串本身: SELF \n\n``` \n例：@“SELF == ‘APPLE’\"\n```\n\n(4) 字符串相关: BEGINSWITH, ENDSWITH, CONTAINS\n\n``` \n例：@\"name CONTAINS[cd] 'ang'\"  //包含某个字符串\n   @\"name BEGINSWITH[c] 'sh'\"  //以某个字符串开头\n   @\"name ENDSWITH[d] 'ang'\"   //以某个字符串结束\n\n注:[c]不区分大小写\n   [d]不区分发音符号即没有重音符号\n   [cd]既不区分大小写，也不区分发音符号。\n```\n\n(5) 通配符: LIKE\n\n``` \n例：@\"name LIKE[cd] '*er*'\"    //*代表通配符,Like也接受[cd].\n   @\"name LIKE[cd] '???er*'\"\n```\n\n(6) 正则表达式: MATCHES\n\n``` \n例：NSString *regex = @\"^A.+e$\";   //以A开头，e结尾\n  @\"name MATCHES %@\",regex\n```\n\n至于如何使用呢? 下面举几个例子:\n\n(a) 对NSArray进行过滤, 帅选出包含\"ang\"的项\n\n``` objc\n    NSArray *array = [[NSArray alloc]initWithObjects:@\"beijing\", @\"shanghai\", @\"guangzou\", @\"wuhan\", nil];\n    NSString *string = @\"ang\";\n    NSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF CONTAINS %@\", string];\n    NSLog(@\"%@\", [array filteredArrayUsingPredicate:pred]);\n\n//    打印结果:\n//    (\n//     shanghai,\n//     guangzou\n//    )\n\n```\n\n(b) 对NSDate进行筛选\n\n``` objc\n    //日期在十天之内:\n    NSDate *endDate = [NSDate date];\n    NSTimeInterval timeInterval= [endDate timeIntervalSinceReferenceDate];\n    timeInterval -=3600*24*10;\n    NSDate *beginDate = [NSDate dateWithTimeIntervalSinceReferenceDate:timeInterval];\n    //对coredata进行筛选(假设有fetchRequest)\n    NSPredicate *predicate_date = [NSPredicate predicateWithFormat:@\"date >= %@ AND date <= %@\", beginDate,endDate];\n    [fetchRequest setPredicate:predicate_date];\n```\n\n\n\nOK, `NSPredicate `的功能很多, 也很强大。这里暂时就点到此, 感兴趣的可以自己一一试验。 下面举两个例子说明一下如何使用正则。\n\n\n\n``` objc\n// 判断是否是有效邮箱\n- (BOOL)isValidateEmail:(NSString *)email{\n\n    NSString *regex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}\";\n    NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", regex];\n    return [predicate evaluateWithObject:email];\n}\n\n// 判断字符串首字母是否为字母\n- (BOOL)isStartedWithWord:(NSString *)aString{\n\n    NSString *regex = @\"[A-Za-z]+\";\n    NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", regex];\n    return [predicate evaluateWithObject:aString];\n}\n\n```\n\n******\n\n## 2. 利用rangeOfString：option：直接查找\n\n``` objc\n    NSString *searchText = @\"// Do any additional setup after loading the view, typically from a nib.\";\n    NSRange range = [searchText rangeOfString:@\"(?:[^,])*\\\\.\" options:NSRegularExpressionSearch];\n    if (range.location != NSNotFound) {\n        NSLog(@\"%@\", [searchText substringWithRange:range]);\n    }\n\n//    打印结果:\n//      typically from a nib.\n\n```\n\n> options中设定NSRegularExpressionSearch就是表示利用正则表达式匹配，会返回第一个匹配结果的位置。\n\n\n\n*****\n\n# 3. 使用正则表达式类\n\n详细了解:  [iOS 正则表达式 NSRegularExpression](http://blog.csdn.net/crayondeng/article/details/16991579)\n\n上面那篇文章总结的很不错. 这里简单再举个例子:\n\n``` objc\n    NSString *searchText = @\"// Do any additional setup after loading the view, typically from a nib.\";    \n    NSError *error = NULL;\n    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@\"(?:[^,])*\\\\.\" options:NSRegularExpressionCaseInsensitive error:&error];\n    NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];\n    if (result) {\n        NSLog(@\"%@\\n\", [searchText substringWithRange:result.range]);\n    }\n\n//    打印结果:\n//      typically from a nib.\n```\n\n> 使用系统的正则表达式类（NSRegularExpression）会返回匹配的多个结果。\n> \n> \n\n******\n\n针对以上3种方式, 做一个小小总结\n\n> 第一种匹配需要学习NSPredicate的写法，需要查阅苹果相关技术文档；\n\n>\n\n> 如果只关心第一个匹配的结果，第二种匹配较为简洁；\n\n>\n\n> 如果需要匹配多个结果，同时匹配多次，第三种方式效率会更高。\n\n>\n\n\n\n## 常用正则表达式\n\n参考:  [IOS常用正则表达式](http://blog.csdn.net/chaoyuan899/article/details/38583759)\n\n\n\n\n\n| 表达式                                      | 作用              |\n| ---------------------------------------- | --------------- |\n| [\\u4e00-\\u9fa5]                          | 匹配中文字符          |\n| [^\\x00-\\xff]                             | 匹配双字节字符(包括汉字在内) |\n| \\n\\s\\*\\r                                 | 匹配空白行           |\n| <(\\S\\*?)[^>]\\*>.\\*?</\\1>\\                | <.\\*? />        |\n| ^\\s\\*\\                                   | \\s\\*$           |\n| \\w+([-+.]\\w+)\\*@\\w+([-.]\\w+)\\*\\.\\w+([-.]\\w+)\\* | 匹配Email地        |\n| [a-zA-z]+://[^\\s]*                       | 匹配网址URL         |\n| \\d{3}-\\d{8}\\                             | \\d{4}-\\d{7}     |\n| [1-9]\\d{5}(?!\\d)                         | 匹配中国邮政编码        |\n| \\d+\\.\\d+\\.\\d+\\.\\d+                       | 匹配ip地址          |","source":"_posts/Regular-Expressions.md","raw":"layout: \"iOS开发小记\"\n\ntitle: 正则表达式\n\ndate: 2015-07-11 10:14:52\n\ntags:\n\n- iOS开发\n- 正则\n\n---\n\n> 正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。\n\n\n\n1. 系统自带的, 如: NSPredicate, rangeOfString：option, NSRegularExpression\n2. [RegexKitLite](http://regexkit.sourceforge.net/RegexKitLite/) RegexKitLite 是一个轻量级的 Objective-C 的正则表达式库,支持 Mac OS X 和 iOS,使用 ICU 库开发。\n\n至于`RegexKitLite`, 这里不做介绍。着重介绍系统自带的那几个办法。\n\n> PS: 阅读本文前提是您已经掌握了正则基本语法, 如果对正则还不太了解, 可以参考以下几个链接:\n\n正则表达式学习链接：\n\n1. [55分钟学会正则表达式](http://doslin.com/regular%20expressions/2014/03/11/learn-regular-expressions-in-about-55-minutes.html)\n2. [揭开正则表达式的神秘面纱](http://www.regexlab.com/zh/regref.htm)\n3. [RegExLib.com(正则表达式库查询)](http://www.regexplib.com/DisplayPatterns.aspx?cattabindex=4&categoryId=5)\n\n*****\n\n<!--more-->\n\n\n\n## 1. NSPredicate\n\n> 简述：Cocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取。\n\n``` objc\nNSPredicate *predicate = [NSPredicate predicateWithFormat:(NSString *), ...];\n```\n\n其中, 常见的`Format `有:\n\n(1) 比较运算符: >, <, ==, >=, <=, !=\n\n``` \n例：@\"number > 100\"\n```\n\n(2) 范围运算符: IN, BETWEEN\n\n​\t\n\n``` \n例：@\"number BETWEEN {1,5}\"\n   @\"address IN {'shanghai','beijing'}\"\n```\n\n(3) 字符串本身: SELF \n\n``` \n例：@“SELF == ‘APPLE’\"\n```\n\n(4) 字符串相关: BEGINSWITH, ENDSWITH, CONTAINS\n\n``` \n例：@\"name CONTAINS[cd] 'ang'\"  //包含某个字符串\n   @\"name BEGINSWITH[c] 'sh'\"  //以某个字符串开头\n   @\"name ENDSWITH[d] 'ang'\"   //以某个字符串结束\n\n注:[c]不区分大小写\n   [d]不区分发音符号即没有重音符号\n   [cd]既不区分大小写，也不区分发音符号。\n```\n\n(5) 通配符: LIKE\n\n``` \n例：@\"name LIKE[cd] '*er*'\"    //*代表通配符,Like也接受[cd].\n   @\"name LIKE[cd] '???er*'\"\n```\n\n(6) 正则表达式: MATCHES\n\n``` \n例：NSString *regex = @\"^A.+e$\";   //以A开头，e结尾\n  @\"name MATCHES %@\",regex\n```\n\n至于如何使用呢? 下面举几个例子:\n\n(a) 对NSArray进行过滤, 帅选出包含\"ang\"的项\n\n``` objc\n    NSArray *array = [[NSArray alloc]initWithObjects:@\"beijing\", @\"shanghai\", @\"guangzou\", @\"wuhan\", nil];\n    NSString *string = @\"ang\";\n    NSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF CONTAINS %@\", string];\n    NSLog(@\"%@\", [array filteredArrayUsingPredicate:pred]);\n\n//    打印结果:\n//    (\n//     shanghai,\n//     guangzou\n//    )\n\n```\n\n(b) 对NSDate进行筛选\n\n``` objc\n    //日期在十天之内:\n    NSDate *endDate = [NSDate date];\n    NSTimeInterval timeInterval= [endDate timeIntervalSinceReferenceDate];\n    timeInterval -=3600*24*10;\n    NSDate *beginDate = [NSDate dateWithTimeIntervalSinceReferenceDate:timeInterval];\n    //对coredata进行筛选(假设有fetchRequest)\n    NSPredicate *predicate_date = [NSPredicate predicateWithFormat:@\"date >= %@ AND date <= %@\", beginDate,endDate];\n    [fetchRequest setPredicate:predicate_date];\n```\n\n\n\nOK, `NSPredicate `的功能很多, 也很强大。这里暂时就点到此, 感兴趣的可以自己一一试验。 下面举两个例子说明一下如何使用正则。\n\n\n\n``` objc\n// 判断是否是有效邮箱\n- (BOOL)isValidateEmail:(NSString *)email{\n\n    NSString *regex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}\";\n    NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", regex];\n    return [predicate evaluateWithObject:email];\n}\n\n// 判断字符串首字母是否为字母\n- (BOOL)isStartedWithWord:(NSString *)aString{\n\n    NSString *regex = @\"[A-Za-z]+\";\n    NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", regex];\n    return [predicate evaluateWithObject:aString];\n}\n\n```\n\n******\n\n## 2. 利用rangeOfString：option：直接查找\n\n``` objc\n    NSString *searchText = @\"// Do any additional setup after loading the view, typically from a nib.\";\n    NSRange range = [searchText rangeOfString:@\"(?:[^,])*\\\\.\" options:NSRegularExpressionSearch];\n    if (range.location != NSNotFound) {\n        NSLog(@\"%@\", [searchText substringWithRange:range]);\n    }\n\n//    打印结果:\n//      typically from a nib.\n\n```\n\n> options中设定NSRegularExpressionSearch就是表示利用正则表达式匹配，会返回第一个匹配结果的位置。\n\n\n\n*****\n\n# 3. 使用正则表达式类\n\n详细了解:  [iOS 正则表达式 NSRegularExpression](http://blog.csdn.net/crayondeng/article/details/16991579)\n\n上面那篇文章总结的很不错. 这里简单再举个例子:\n\n``` objc\n    NSString *searchText = @\"// Do any additional setup after loading the view, typically from a nib.\";    \n    NSError *error = NULL;\n    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@\"(?:[^,])*\\\\.\" options:NSRegularExpressionCaseInsensitive error:&error];\n    NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];\n    if (result) {\n        NSLog(@\"%@\\n\", [searchText substringWithRange:result.range]);\n    }\n\n//    打印结果:\n//      typically from a nib.\n```\n\n> 使用系统的正则表达式类（NSRegularExpression）会返回匹配的多个结果。\n> \n> \n\n******\n\n针对以上3种方式, 做一个小小总结\n\n> 第一种匹配需要学习NSPredicate的写法，需要查阅苹果相关技术文档；\n\n>\n\n> 如果只关心第一个匹配的结果，第二种匹配较为简洁；\n\n>\n\n> 如果需要匹配多个结果，同时匹配多次，第三种方式效率会更高。\n\n>\n\n\n\n## 常用正则表达式\n\n参考:  [IOS常用正则表达式](http://blog.csdn.net/chaoyuan899/article/details/38583759)\n\n\n\n\n\n| 表达式                                      | 作用              |\n| ---------------------------------------- | --------------- |\n| [\\u4e00-\\u9fa5]                          | 匹配中文字符          |\n| [^\\x00-\\xff]                             | 匹配双字节字符(包括汉字在内) |\n| \\n\\s\\*\\r                                 | 匹配空白行           |\n| <(\\S\\*?)[^>]\\*>.\\*?</\\1>\\                | <.\\*? />        |\n| ^\\s\\*\\                                   | \\s\\*$           |\n| \\w+([-+.]\\w+)\\*@\\w+([-.]\\w+)\\*\\.\\w+([-.]\\w+)\\* | 匹配Email地        |\n| [a-zA-z]+://[^\\s]*                       | 匹配网址URL         |\n| \\d{3}-\\d{8}\\                             | \\d{4}-\\d{7}     |\n| [1-9]\\d{5}(?!\\d)                         | 匹配中国邮政编码        |\n| \\d+\\.\\d+\\.\\d+\\.\\d+                       | 匹配ip地址          |","slug":"Regular-Expressions","published":1,"updated":"2019-12-23T01:02:31.289Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1m00005zwlnae5uoyxr","content":"<blockquote>\n<p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>\n</blockquote>\n<ol>\n<li>系统自带的, 如: NSPredicate, rangeOfString：option, NSRegularExpression</li>\n<li><a href=\"http://regexkit.sourceforge.net/RegexKitLite/\" target=\"_blank\" rel=\"external\">RegexKitLite</a> RegexKitLite 是一个轻量级的 Objective-C 的正则表达式库,支持 Mac OS X 和 iOS,使用 ICU 库开发。</li>\n</ol>\n<p>至于<code>RegexKitLite</code>, 这里不做介绍。着重介绍系统自带的那几个办法。</p>\n<blockquote>\n<p>PS: 阅读本文前提是您已经掌握了正则基本语法, 如果对正则还不太了解, 可以参考以下几个链接:</p>\n</blockquote>\n<p>正则表达式学习链接：</p>\n<ol>\n<li><a href=\"http://doslin.com/regular%20expressions/2014/03/11/learn-regular-expressions-in-about-55-minutes.html\" target=\"_blank\" rel=\"external\">55分钟学会正则表达式</a></li>\n<li><a href=\"http://www.regexlab.com/zh/regref.htm\" target=\"_blank\" rel=\"external\">揭开正则表达式的神秘面纱</a></li>\n<li><a href=\"http://www.regexplib.com/DisplayPatterns.aspx?cattabindex=4&amp;categoryId=5\" target=\"_blank\" rel=\"external\">RegExLib.com(正则表达式库查询)</a></li>\n</ol>\n<hr>\n<a id=\"more\"></a>\n<h2 id=\"1-_NSPredicate\">1. NSPredicate</h2><blockquote>\n<p>简述：Cocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:(<span class=\"built_in\">NSString</span> *), ...];</span><br></pre></td></tr></table></figure>\n<p>其中, 常见的<code>Format</code>有:</p>\n<p>(1) 比较运算符: &gt;, &lt;, ==, &gt;=, &lt;=, !=</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;number &gt; 100&quot;</span><br></pre></td></tr></table></figure>\n<p>(2) 范围运算符: IN, BETWEEN</p>\n<p>​    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;number BETWEEN &#123;1,5&#125;&quot;</span><br><span class=\"line\">   @&quot;address IN &#123;&apos;shanghai&apos;,&apos;beijing&apos;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<p>(3) 字符串本身: SELF </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@“SELF == ‘APPLE’&quot;</span><br></pre></td></tr></table></figure>\n<p>(4) 字符串相关: BEGINSWITH, ENDSWITH, CONTAINS</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;name CONTAINS[cd] &apos;ang&apos;&quot;  //包含某个字符串</span><br><span class=\"line\">   @&quot;name BEGINSWITH[c] &apos;sh&apos;&quot;  //以某个字符串开头</span><br><span class=\"line\">   @&quot;name ENDSWITH[d] &apos;ang&apos;&quot;   //以某个字符串结束</span><br><span class=\"line\"></span><br><span class=\"line\">注:[c]不区分大小写</span><br><span class=\"line\">   [d]不区分发音符号即没有重音符号</span><br><span class=\"line\">   [cd]既不区分大小写，也不区分发音符号。</span><br></pre></td></tr></table></figure>\n<p>(5) 通配符: LIKE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;name LIKE[cd] &apos;*er*&apos;&quot;    //*代表通配符,Like也接受[cd].</span><br><span class=\"line\">   @&quot;name LIKE[cd] &apos;???er*&apos;&quot;</span><br></pre></td></tr></table></figure>\n<p>(6) 正则表达式: MATCHES</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：NSString *regex = @&quot;^A.+e$&quot;;   //以A开头，e结尾</span><br><span class=\"line\">  @&quot;name MATCHES %@&quot;,regex</span><br></pre></td></tr></table></figure>\n<p>至于如何使用呢? 下面举几个例子:</p>\n<p>(a) 对NSArray进行过滤, 帅选出包含”ang”的项</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">NSArray</span> *array = [[<span class=\"built_in\">NSArray</span> alloc]initWithObjects:<span class=\"string\">@\"beijing\"</span>, <span class=\"string\">@\"shanghai\"</span>, <span class=\"string\">@\"guangzou\"</span>, <span class=\"string\">@\"wuhan\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *string = <span class=\"string\">@\"ang\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSPredicate</span> *pred = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF CONTAINS %@\"</span>, string];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array filteredArrayUsingPredicate:pred]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    打印结果:</span></span><br><span class=\"line\"><span class=\"comment\">//    (</span></span><br><span class=\"line\"><span class=\"comment\">//     shanghai,</span></span><br><span class=\"line\"><span class=\"comment\">//     guangzou</span></span><br><span class=\"line\"><span class=\"comment\">//    )</span></span><br></pre></td></tr></table></figure>\n<p>(b) 对NSDate进行筛选</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//日期在十天之内:</span></span><br><span class=\"line\"><span class=\"built_in\">NSDate</span> *endDate = [<span class=\"built_in\">NSDate</span> date];</span><br><span class=\"line\"><span class=\"built_in\">NSTimeInterval</span> timeInterval= [endDate timeIntervalSinceReferenceDate];</span><br><span class=\"line\">timeInterval -=<span class=\"number\">3600</span>*<span class=\"number\">24</span>*<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSDate</span> *beginDate = [<span class=\"built_in\">NSDate</span> dateWithTimeIntervalSinceReferenceDate:timeInterval];</span><br><span class=\"line\"><span class=\"comment\">//对coredata进行筛选(假设有fetchRequest)</span></span><br><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *predicate_date = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"date &gt;= %@ AND date &lt;= %@\"</span>, beginDate,endDate];</span><br><span class=\"line\">[fetchRequest setPredicate:predicate_date];</span><br></pre></td></tr></table></figure>\n<p>OK, <code>NSPredicate</code>的功能很多, 也很强大。这里暂时就点到此, 感兴趣的可以自己一一试验。 下面举两个例子说明一下如何使用正则。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断是否是有效邮箱</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isValidateEmail:(<span class=\"built_in\">NSString</span> *)email&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *regex = <span class=\"string\">@\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]&#123;2,4&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF MATCHES %@\"</span>, regex];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [predicate evaluateWithObject:email];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断字符串首字母是否为字母</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isStartedWithWord:(<span class=\"built_in\">NSString</span> *)aString&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *regex = <span class=\"string\">@\"[A-Za-z]+\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF MATCHES %@\"</span>, regex];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [predicate evaluateWithObject:aString];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2-_利用rangeOfString：option：直接查找\">2. 利用rangeOfString：option：直接查找</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">NSString</span> *searchText = <span class=\"string\">@\"// Do any additional setup after loading the view, typically from a nib.\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSRange</span> range = [searchText rangeOfString:<span class=\"string\">@\"(?:[^,])*\\\\.\"</span> options:<span class=\"built_in\">NSRegularExpressionSearch</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (range.location != <span class=\"built_in\">NSNotFound</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [searchText substringWithRange:range]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    打印结果:</span></span><br><span class=\"line\"><span class=\"comment\">//      typically from a nib.</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>options中设定NSRegularExpressionSearch就是表示利用正则表达式匹配，会返回第一个匹配结果的位置。</p>\n</blockquote>\n<hr>\n<h1 id=\"3-_使用正则表达式类\">3. 使用正则表达式类</h1><p>详细了解:  <a href=\"http://blog.csdn.net/crayondeng/article/details/16991579\" target=\"_blank\" rel=\"external\">iOS 正则表达式 NSRegularExpression</a></p>\n<p>上面那篇文章总结的很不错. 这里简单再举个例子:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">NSString</span> *searchText = <span class=\"string\">@\"// Do any additional setup after loading the view, typically from a nib.\"</span>;    </span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSRegularExpression</span> *regex = [<span class=\"built_in\">NSRegularExpression</span> regularExpressionWithPattern:<span class=\"string\">@\"(?:[^,])*\\\\.\"</span> options:<span class=\"built_in\">NSRegularExpressionCaseInsensitive</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"built_in\">NSTextCheckingResult</span> *result = [regex firstMatchInString:searchText options:<span class=\"number\">0</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, [searchText length])];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\\n\"</span>, [searchText substringWithRange:result.range]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    打印结果:</span></span><br><span class=\"line\"><span class=\"comment\">//      typically from a nib.</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用系统的正则表达式类（NSRegularExpression）会返回匹配的多个结果。</p>\n</blockquote>\n<hr>\n<p>针对以上3种方式, 做一个小小总结</p>\n<blockquote>\n<p>第一种匹配需要学习NSPredicate的写法，需要查阅苹果相关技术文档；</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>如果只关心第一个匹配的结果，第二种匹配较为简洁；</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>如果需要匹配多个结果，同时匹配多次，第三种方式效率会更高。</p>\n</blockquote>\n<p>&gt;</p>\n<h2 id=\"常用正则表达式\">常用正则表达式</h2><p>参考:  <a href=\"http://blog.csdn.net/chaoyuan899/article/details/38583759\" target=\"_blank\" rel=\"external\">IOS常用正则表达式</a></p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[\\u4e00-\\u9fa5]</td>\n<td>匹配中文字符</td>\n</tr>\n<tr>\n<td>[^\\x00-\\xff]</td>\n<td>匹配双字节字符(包括汉字在内)</td>\n</tr>\n<tr>\n<td>\\n\\s*\\r</td>\n<td>匹配空白行</td>\n</tr>\n<tr>\n<td>&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;\\</td>\n<td>&lt;.*? /&gt;</td>\n</tr>\n<tr>\n<td>^\\s*\\</td>\n<td>\\s*$</td>\n</tr>\n<tr>\n<td>\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*</td>\n<td>匹配Email地</td>\n</tr>\n<tr>\n<td>[a-zA-z]+://[^\\s]*</td>\n<td>匹配网址URL</td>\n</tr>\n<tr>\n<td>\\d{3}-\\d{8}\\</td>\n<td>\\d{4}-\\d{7}</td>\n</tr>\n<tr>\n<td>[1-9]\\d{5}(?!\\d)</td>\n<td>匹配中国邮政编码</td>\n</tr>\n<tr>\n<td>\\d+.\\d+.\\d+.\\d+</td>\n<td>匹配ip地址</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"<blockquote>\n<p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>\n</blockquote>\n<ol>\n<li>系统自带的, 如: NSPredicate, rangeOfString：option, NSRegularExpression</li>\n<li><a href=\"http://regexkit.sourceforge.net/RegexKitLite/\">RegexKitLite</a> RegexKitLite 是一个轻量级的 Objective-C 的正则表达式库,支持 Mac OS X 和 iOS,使用 ICU 库开发。</li>\n</ol>\n<p>至于<code>RegexKitLite</code>, 这里不做介绍。着重介绍系统自带的那几个办法。</p>\n<blockquote>\n<p>PS: 阅读本文前提是您已经掌握了正则基本语法, 如果对正则还不太了解, 可以参考以下几个链接:</p>\n</blockquote>\n<p>正则表达式学习链接：</p>\n<ol>\n<li><a href=\"http://doslin.com/regular%20expressions/2014/03/11/learn-regular-expressions-in-about-55-minutes.html\">55分钟学会正则表达式</a></li>\n<li><a href=\"http://www.regexlab.com/zh/regref.htm\">揭开正则表达式的神秘面纱</a></li>\n<li><a href=\"http://www.regexplib.com/DisplayPatterns.aspx?cattabindex=4&amp;categoryId=5\">RegExLib.com(正则表达式库查询)</a></li>\n</ol>\n<hr>","more":"<h2 id=\"1-_NSPredicate\">1. NSPredicate</h2><blockquote>\n<p>简述：Cocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:(<span class=\"built_in\">NSString</span> *), ...];</span><br></pre></td></tr></table></figure>\n<p>其中, 常见的<code>Format</code>有:</p>\n<p>(1) 比较运算符: &gt;, &lt;, ==, &gt;=, &lt;=, !=</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;number &gt; 100&quot;</span><br></pre></td></tr></table></figure>\n<p>(2) 范围运算符: IN, BETWEEN</p>\n<p>​    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;number BETWEEN &#123;1,5&#125;&quot;</span><br><span class=\"line\">   @&quot;address IN &#123;&apos;shanghai&apos;,&apos;beijing&apos;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<p>(3) 字符串本身: SELF </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@“SELF == ‘APPLE’&quot;</span><br></pre></td></tr></table></figure>\n<p>(4) 字符串相关: BEGINSWITH, ENDSWITH, CONTAINS</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;name CONTAINS[cd] &apos;ang&apos;&quot;  //包含某个字符串</span><br><span class=\"line\">   @&quot;name BEGINSWITH[c] &apos;sh&apos;&quot;  //以某个字符串开头</span><br><span class=\"line\">   @&quot;name ENDSWITH[d] &apos;ang&apos;&quot;   //以某个字符串结束</span><br><span class=\"line\"></span><br><span class=\"line\">注:[c]不区分大小写</span><br><span class=\"line\">   [d]不区分发音符号即没有重音符号</span><br><span class=\"line\">   [cd]既不区分大小写，也不区分发音符号。</span><br></pre></td></tr></table></figure>\n<p>(5) 通配符: LIKE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：@&quot;name LIKE[cd] &apos;*er*&apos;&quot;    //*代表通配符,Like也接受[cd].</span><br><span class=\"line\">   @&quot;name LIKE[cd] &apos;???er*&apos;&quot;</span><br></pre></td></tr></table></figure>\n<p>(6) 正则表达式: MATCHES</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：NSString *regex = @&quot;^A.+e$&quot;;   //以A开头，e结尾</span><br><span class=\"line\">  @&quot;name MATCHES %@&quot;,regex</span><br></pre></td></tr></table></figure>\n<p>至于如何使用呢? 下面举几个例子:</p>\n<p>(a) 对NSArray进行过滤, 帅选出包含”ang”的项</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">NSArray</span> *array = [[<span class=\"built_in\">NSArray</span> alloc]initWithObjects:<span class=\"string\">@\"beijing\"</span>, <span class=\"string\">@\"shanghai\"</span>, <span class=\"string\">@\"guangzou\"</span>, <span class=\"string\">@\"wuhan\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *string = <span class=\"string\">@\"ang\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSPredicate</span> *pred = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF CONTAINS %@\"</span>, string];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array filteredArrayUsingPredicate:pred]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    打印结果:</span></span><br><span class=\"line\"><span class=\"comment\">//    (</span></span><br><span class=\"line\"><span class=\"comment\">//     shanghai,</span></span><br><span class=\"line\"><span class=\"comment\">//     guangzou</span></span><br><span class=\"line\"><span class=\"comment\">//    )</span></span><br></pre></td></tr></table></figure>\n<p>(b) 对NSDate进行筛选</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//日期在十天之内:</span></span><br><span class=\"line\"><span class=\"built_in\">NSDate</span> *endDate = [<span class=\"built_in\">NSDate</span> date];</span><br><span class=\"line\"><span class=\"built_in\">NSTimeInterval</span> timeInterval= [endDate timeIntervalSinceReferenceDate];</span><br><span class=\"line\">timeInterval -=<span class=\"number\">3600</span>*<span class=\"number\">24</span>*<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSDate</span> *beginDate = [<span class=\"built_in\">NSDate</span> dateWithTimeIntervalSinceReferenceDate:timeInterval];</span><br><span class=\"line\"><span class=\"comment\">//对coredata进行筛选(假设有fetchRequest)</span></span><br><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *predicate_date = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"date &gt;= %@ AND date &lt;= %@\"</span>, beginDate,endDate];</span><br><span class=\"line\">[fetchRequest setPredicate:predicate_date];</span><br></pre></td></tr></table></figure>\n<p>OK, <code>NSPredicate</code>的功能很多, 也很强大。这里暂时就点到此, 感兴趣的可以自己一一试验。 下面举两个例子说明一下如何使用正则。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断是否是有效邮箱</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isValidateEmail:(<span class=\"built_in\">NSString</span> *)email&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *regex = <span class=\"string\">@\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]&#123;2,4&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF MATCHES %@\"</span>, regex];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [predicate evaluateWithObject:email];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断字符串首字母是否为字母</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isStartedWithWord:(<span class=\"built_in\">NSString</span> *)aString&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *regex = <span class=\"string\">@\"[A-Za-z]+\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF MATCHES %@\"</span>, regex];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [predicate evaluateWithObject:aString];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2-_利用rangeOfString：option：直接查找\">2. 利用rangeOfString：option：直接查找</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">NSString</span> *searchText = <span class=\"string\">@\"// Do any additional setup after loading the view, typically from a nib.\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSRange</span> range = [searchText rangeOfString:<span class=\"string\">@\"(?:[^,])*\\\\.\"</span> options:<span class=\"built_in\">NSRegularExpressionSearch</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (range.location != <span class=\"built_in\">NSNotFound</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [searchText substringWithRange:range]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    打印结果:</span></span><br><span class=\"line\"><span class=\"comment\">//      typically from a nib.</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>options中设定NSRegularExpressionSearch就是表示利用正则表达式匹配，会返回第一个匹配结果的位置。</p>\n</blockquote>\n<hr>\n<h1 id=\"3-_使用正则表达式类\">3. 使用正则表达式类</h1><p>详细了解:  <a href=\"http://blog.csdn.net/crayondeng/article/details/16991579\">iOS 正则表达式 NSRegularExpression</a></p>\n<p>上面那篇文章总结的很不错. 这里简单再举个例子:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">NSString</span> *searchText = <span class=\"string\">@\"// Do any additional setup after loading the view, typically from a nib.\"</span>;    </span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSRegularExpression</span> *regex = [<span class=\"built_in\">NSRegularExpression</span> regularExpressionWithPattern:<span class=\"string\">@\"(?:[^,])*\\\\.\"</span> options:<span class=\"built_in\">NSRegularExpressionCaseInsensitive</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"built_in\">NSTextCheckingResult</span> *result = [regex firstMatchInString:searchText options:<span class=\"number\">0</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, [searchText length])];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\\n\"</span>, [searchText substringWithRange:result.range]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    打印结果:</span></span><br><span class=\"line\"><span class=\"comment\">//      typically from a nib.</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用系统的正则表达式类（NSRegularExpression）会返回匹配的多个结果。</p>\n</blockquote>\n<hr>\n<p>针对以上3种方式, 做一个小小总结</p>\n<blockquote>\n<p>第一种匹配需要学习NSPredicate的写法，需要查阅苹果相关技术文档；</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>如果只关心第一个匹配的结果，第二种匹配较为简洁；</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>如果需要匹配多个结果，同时匹配多次，第三种方式效率会更高。</p>\n</blockquote>\n<p>&gt;</p>\n<h2 id=\"常用正则表达式\">常用正则表达式</h2><p>参考:  <a href=\"http://blog.csdn.net/chaoyuan899/article/details/38583759\">IOS常用正则表达式</a></p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[\\u4e00-\\u9fa5]</td>\n<td>匹配中文字符</td>\n</tr>\n<tr>\n<td>[^\\x00-\\xff]</td>\n<td>匹配双字节字符(包括汉字在内)</td>\n</tr>\n<tr>\n<td>\\n\\s*\\r</td>\n<td>匹配空白行</td>\n</tr>\n<tr>\n<td>&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;\\</td>\n<td>&lt;.*? /&gt;</td>\n</tr>\n<tr>\n<td>^\\s*\\</td>\n<td>\\s*$</td>\n</tr>\n<tr>\n<td>\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*</td>\n<td>匹配Email地</td>\n</tr>\n<tr>\n<td>[a-zA-z]+://[^\\s]*</td>\n<td>匹配网址URL</td>\n</tr>\n<tr>\n<td>\\d{3}-\\d{8}\\</td>\n<td>\\d{4}-\\d{7}</td>\n</tr>\n<tr>\n<td>[1-9]\\d{5}(?!\\d)</td>\n<td>匹配中国邮政编码</td>\n</tr>\n<tr>\n<td>\\d+.\\d+.\\d+.\\d+</td>\n<td>匹配ip地址</td>\n</tr>\n</tbody>\n</table>"},{"layout":"代码备忘","title":"TODO宏实现","date":"2015-07-12T02:14:52.000Z","_content":"\n# 代码备忘, TODO宏实现\n\n> 我们平时在开发过程中, 往往并不是憋足气一股脑敲完全部代码。每个模块, 每个函数的实现总有个先后顺序。又或者哪个部分需要做调整, 修改... 所以, 我们需要有一个东西, 来提醒我们, 起到代码备忘功能, 避免某个功能忘记实现, 也能让我们快速定位。 所以这篇文章, 就是要实现一个TODO宏, 来达到代码备忘功能。\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387345_9339.jpeg\" width=\"500\"/>\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_3643.jpeg\" width=\"500\"/>\n\n\n\n<!--more-->\n\n## **下面来分析下如何实现这个宏**\n\n\n\n************\n\n在实现TODO之前, 已经自带了几个预处理指令来实现报警/报错:\n\n``` objc\n#warning Colin\n#error Colin\n#pragma message \"Colin\"\n#pragma GCC warning \"Colin\"\n#pragma GCC error \"Colin\"\n```\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_8391.jpeg\" width=\"500\"/>\n\n既然有了, 那为什么还需要自己实现这个TODO宏呢?\n\n1. error 和 warning所代表的意义已经深入猿心, 我们没有理由使用它来做备忘。\n2. 如果也使用warning, 在警告导航栏中, 我们很难区分哪个才是我们手动打的标记, 哪个是程序本身的warning\n3. 带#的预处理指令是无法被#define的, 也就是没办法直接利用这个来定义我们的TODO\n\n好在C99提供了一个 **_Pragma** 运算符可以把部分#pragma指令字符串化, 如下:\n\n\n\n``` objc\n#pragma message \"Colin\"\n// 等价于\n_Pragma(\"message \\\"Colin\\\"\") // 需要注意双引号的转义\n// 或\n_Pragma(\"message(\\\"Colin\\\")\") // 需要注意双引号的转义\n\n```\n\n利用这个特性，我们就可以将warning定义成宏:\n\n``` objc\n#define MY_WARNING _Pragma(\"message (\\\"警察临检, 男左女右!\\\")\")\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n\n    MY_WARNING\n}\n```\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_6563.jpeg\" width=\"500\"/>\n\n到这里, 大体有那么一个感觉。 不过我们提示的内容, 是define的, 也就是写死固定的, 不太合适。\n\n所以我们希望这个宏能接受入参, 让它正常显示到warning中。\n\n这就涉及了一些宏的基本用法。\n\n\n\n``` objc\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n\n```\n\nSTRINGIFY(S) 将入参转化成字符串，省去了_Pragma中全串加转义字符的困扰。\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387347_2653.jpeg\" width=\"500\"/>\n\n\n\n这时，一个基本功能的TODO宏就完成了，下面向其中加入额外的信息：\n\n``` objc\n// 两个已有的宏\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n// 延迟1次展开的宏\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n// 下面的宏在第一行用`\\`折行\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\"  \\\n    DEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n```\n\n\n\n其中涉及到的知识：\n\n* 两个常量字符串可以拼接成一个整串 “123””456” => “123456”\n* 使用到3个预定义宏，__COUNTER__宏展开次数的计数器，全局唯一；__FILE__当前文件完整目录字符串；__LINE__在当前文件第几行\n* 在字符串中预定义宏应延时展开，如果将上面的DEFER_STRINGIFY换成STRINGIFY的话，如__LINE__不能被正确展开成行数，而是成了一个常量字符串\"__LINE__\"\n* 为了美化，warning message中可以使用\\n换行\n\n于是，使用FORMATTED_MESSAGE(MSG)宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。\n\n*********\n\n其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加@的形式：\n\n``` objc\n#define KEYWORDIFY try {} @catch (...) {}\n\n```\n\n***********\n\n## **最终版本**\n\n\n\n``` objc\n\n// 转成字符串\n#define STRINGIFY(S) #S\n// 需要解两次才解开的宏\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n\n// 为warning增加更多信息\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\" DEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n\n// 使宏前面可以加@\n#define KEYWORDIFY try {} @catch (...) {}\n\n// 最终使用的宏\n#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))\n\n```\n\n\n\n# References\n\n[http://blog.sunnyxx.com/2015/03/01/todo-macro/](http://blog.sunnyxx.com/2015/03/01/todo-macro/)\n\n[http://clang.llvm.org/docs/UsersManual.html](http://clang.llvm.org/docs/UsersManual.html)\n\n[https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html](https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html)","source":"_posts/TODO-Macro.md","raw":"layout: \"代码备忘\"\n\ntitle: TODO宏实现\n\ndate: 2015-07-12 10:14:52\n\ntags:\n\n- iOS开发\n- 宏\n\n---\n\n# 代码备忘, TODO宏实现\n\n> 我们平时在开发过程中, 往往并不是憋足气一股脑敲完全部代码。每个模块, 每个函数的实现总有个先后顺序。又或者哪个部分需要做调整, 修改... 所以, 我们需要有一个东西, 来提醒我们, 起到代码备忘功能, 避免某个功能忘记实现, 也能让我们快速定位。 所以这篇文章, 就是要实现一个TODO宏, 来达到代码备忘功能。\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387345_9339.jpeg\" width=\"500\"/>\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_3643.jpeg\" width=\"500\"/>\n\n\n\n<!--more-->\n\n## **下面来分析下如何实现这个宏**\n\n\n\n************\n\n在实现TODO之前, 已经自带了几个预处理指令来实现报警/报错:\n\n``` objc\n#warning Colin\n#error Colin\n#pragma message \"Colin\"\n#pragma GCC warning \"Colin\"\n#pragma GCC error \"Colin\"\n```\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_8391.jpeg\" width=\"500\"/>\n\n既然有了, 那为什么还需要自己实现这个TODO宏呢?\n\n1. error 和 warning所代表的意义已经深入猿心, 我们没有理由使用它来做备忘。\n2. 如果也使用warning, 在警告导航栏中, 我们很难区分哪个才是我们手动打的标记, 哪个是程序本身的warning\n3. 带#的预处理指令是无法被#define的, 也就是没办法直接利用这个来定义我们的TODO\n\n好在C99提供了一个 **_Pragma** 运算符可以把部分#pragma指令字符串化, 如下:\n\n\n\n``` objc\n#pragma message \"Colin\"\n// 等价于\n_Pragma(\"message \\\"Colin\\\"\") // 需要注意双引号的转义\n// 或\n_Pragma(\"message(\\\"Colin\\\")\") // 需要注意双引号的转义\n\n```\n\n利用这个特性，我们就可以将warning定义成宏:\n\n``` objc\n#define MY_WARNING _Pragma(\"message (\\\"警察临检, 男左女右!\\\")\")\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n\n    MY_WARNING\n}\n```\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_6563.jpeg\" width=\"500\"/>\n\n到这里, 大体有那么一个感觉。 不过我们提示的内容, 是define的, 也就是写死固定的, 不太合适。\n\n所以我们希望这个宏能接受入参, 让它正常显示到warning中。\n\n这就涉及了一些宏的基本用法。\n\n\n\n``` objc\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n\n```\n\nSTRINGIFY(S) 将入参转化成字符串，省去了_Pragma中全串加转义字符的困扰。\n\n**效果如下:**\n\n<img src=\"http://img.my.csdn.net/uploads/201503/15/1426387347_2653.jpeg\" width=\"500\"/>\n\n\n\n这时，一个基本功能的TODO宏就完成了，下面向其中加入额外的信息：\n\n``` objc\n// 两个已有的宏\n#define STRINGIFY(S) #S\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n// 延迟1次展开的宏\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n// 下面的宏在第一行用`\\`折行\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\"  \\\n    DEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n```\n\n\n\n其中涉及到的知识：\n\n* 两个常量字符串可以拼接成一个整串 “123””456” => “123456”\n* 使用到3个预定义宏，__COUNTER__宏展开次数的计数器，全局唯一；__FILE__当前文件完整目录字符串；__LINE__在当前文件第几行\n* 在字符串中预定义宏应延时展开，如果将上面的DEFER_STRINGIFY换成STRINGIFY的话，如__LINE__不能被正确展开成行数，而是成了一个常量字符串\"__LINE__\"\n* 为了美化，warning message中可以使用\\n换行\n\n于是，使用FORMATTED_MESSAGE(MSG)宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。\n\n*********\n\n其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加@的形式：\n\n``` objc\n#define KEYWORDIFY try {} @catch (...) {}\n\n```\n\n***********\n\n## **最终版本**\n\n\n\n``` objc\n\n// 转成字符串\n#define STRINGIFY(S) #S\n// 需要解两次才解开的宏\n#define DEFER_STRINGIFY(S) STRINGIFY(S)\n\n#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))\n\n// 为warning增加更多信息\n#define FORMATTED_MESSAGE(MSG) \"[TODO-\" DEFER_STRINGIFY(__COUNTER__) \"] \" MSG \" \\n\" DEFER_STRINGIFY(__FILE__) \" line \" DEFER_STRINGIFY(__LINE__)\n\n// 使宏前面可以加@\n#define KEYWORDIFY try {} @catch (...) {}\n\n// 最终使用的宏\n#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))\n\n```\n\n\n\n# References\n\n[http://blog.sunnyxx.com/2015/03/01/todo-macro/](http://blog.sunnyxx.com/2015/03/01/todo-macro/)\n\n[http://clang.llvm.org/docs/UsersManual.html](http://clang.llvm.org/docs/UsersManual.html)\n\n[https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html](https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html)","slug":"TODO-Macro","published":1,"updated":"2019-12-23T01:02:31.290Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1m00006zwln569cdgll","content":"<h1 id=\"代码备忘,_TODO宏实现\">代码备忘, TODO宏实现</h1><blockquote>\n<p>我们平时在开发过程中, 往往并不是憋足气一股脑敲完全部代码。每个模块, 每个函数的实现总有个先后顺序。又或者哪个部分需要做调整, 修改… 所以, 我们需要有一个东西, 来提醒我们, 起到代码备忘功能, 避免某个功能忘记实现, 也能让我们快速定位。 所以这篇文章, 就是要实现一个TODO宏, 来达到代码备忘功能。</p>\n</blockquote>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387345_9339.jpeg\" width=\"500\"></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_3643.jpeg\" width=\"500\"></p>\n<a id=\"more\"></a>\n<h2 id=\"下面来分析下如何实现这个宏\"><strong>下面来分析下如何实现这个宏</strong></h2><hr>\n<p>在实现TODO之前, 已经自带了几个预处理指令来实现报警/报错:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#warning Colin</span></span><br><span class=\"line\"><span class=\"meta\">#error Colin</span></span><br><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"Colin\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC warning <span class=\"meta-string\">\"Colin\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC error <span class=\"meta-string\">\"Colin\"</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_8391.jpeg\" width=\"500\"></p>\n<p>既然有了, 那为什么还需要自己实现这个TODO宏呢?</p>\n<ol>\n<li>error 和 warning所代表的意义已经深入猿心, 我们没有理由使用它来做备忘。</li>\n<li>如果也使用warning, 在警告导航栏中, 我们很难区分哪个才是我们手动打的标记, 哪个是程序本身的warning</li>\n<li>带#的预处理指令是无法被#define的, 也就是没办法直接利用这个来定义我们的TODO</li>\n</ol>\n<p>好在C99提供了一个 <strong>_Pragma</strong> 运算符可以把部分#pragma指令字符串化, 如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"Colin\"</span></span></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message \\\"Colin\\\"\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message(\\\"Colin\\\")\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br></pre></td></tr></table></figure>\n<p>利用这个特性，我们就可以将warning定义成宏:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define MY_WARNING _Pragma(<span class=\"meta-string\">\"message (\\\"</span>警察临检, 男左女右!\\<span class=\"meta-string\">\")\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    MY_WARNING</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_6563.jpeg\" width=\"500\"></p>\n<p>到这里, 大体有那么一个感觉。 不过我们提示的内容, 是define的, 也就是写死固定的, 不太合适。</p>\n<p>所以我们希望这个宏能接受入参, 让它正常显示到warning中。</p>\n<p>这就涉及了一些宏的基本用法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br></pre></td></tr></table></figure>\n<p>STRINGIFY(S) 将入参转化成字符串，省去了_Pragma中全串加转义字符的困扰。</p>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387347_2653.jpeg\" width=\"500\"></p>\n<p>这时，一个基本功能的TODO宏就完成了，下面向其中加入额外的信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两个已有的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"><span class=\"comment\">// 延迟1次展开的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"><span class=\"comment\">// 下面的宏在第一行用`\\`折行</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span>  \\</span></span><br><span class=\"line\">    DEFER_STRINGIFY(__FILE__) <span class=\"string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span><br></pre></td></tr></table></figure>\n<p>其中涉及到的知识：</p>\n<ul>\n<li>两个常量字符串可以拼接成一个整串 “123””456” =&gt; “123456”</li>\n<li>使用到3个预定义宏，<strong>COUNTER</strong>宏展开次数的计数器，全局唯一；<strong>FILE</strong>当前文件完整目录字符串；<strong>LINE</strong>在当前文件第几行</li>\n<li>在字符串中预定义宏应延时展开，如果将上面的DEFER<em>STRINGIFY换成STRINGIFY的话，如<strong>LINE</strong>不能被正确展开成行数，而是成了一个常量字符串”<em>_LINE</em></em>“</li>\n<li>为了美化，warning message中可以使用\\n换行</li>\n</ul>\n<p>于是，使用FORMATTED_MESSAGE(MSG)宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。</p>\n<hr>\n<p>其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加@的形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"最终版本\"><strong>最终版本</strong></h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转成字符串</span></span><br><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"comment\">// 需要解两次才解开的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为warning增加更多信息</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span> DEFER_STRINGIFY(__FILE__) <span class=\"meta-string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使宏前面可以加@</span></span><br><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最终使用的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"References\">References</h1><p><a href=\"http://blog.sunnyxx.com/2015/03/01/todo-macro/\" target=\"_blank\" rel=\"external\">http://blog.sunnyxx.com/2015/03/01/todo-macro/</a></p>\n<p><a href=\"http://clang.llvm.org/docs/UsersManual.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/docs/UsersManual.html</a></p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html\" target=\"_blank\" rel=\"external\">https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html</a></p>\n","excerpt":"<h1 id=\"代码备忘,_TODO宏实现\">代码备忘, TODO宏实现</h1><blockquote>\n<p>我们平时在开发过程中, 往往并不是憋足气一股脑敲完全部代码。每个模块, 每个函数的实现总有个先后顺序。又或者哪个部分需要做调整, 修改… 所以, 我们需要有一个东西, 来提醒我们, 起到代码备忘功能, 避免某个功能忘记实现, 也能让我们快速定位。 所以这篇文章, 就是要实现一个TODO宏, 来达到代码备忘功能。</p>\n</blockquote>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387345_9339.jpeg\" width=\"500\"/></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_3643.jpeg\" width=\"500\"/></p>","more":"<h2 id=\"下面来分析下如何实现这个宏\"><strong>下面来分析下如何实现这个宏</strong></h2><hr>\n<p>在实现TODO之前, 已经自带了几个预处理指令来实现报警/报错:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#warning Colin</span></span><br><span class=\"line\"><span class=\"meta\">#error Colin</span></span><br><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"Colin\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC warning <span class=\"meta-string\">\"Colin\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC error <span class=\"meta-string\">\"Colin\"</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_8391.jpeg\" width=\"500\"/></p>\n<p>既然有了, 那为什么还需要自己实现这个TODO宏呢?</p>\n<ol>\n<li>error 和 warning所代表的意义已经深入猿心, 我们没有理由使用它来做备忘。</li>\n<li>如果也使用warning, 在警告导航栏中, 我们很难区分哪个才是我们手动打的标记, 哪个是程序本身的warning</li>\n<li>带#的预处理指令是无法被#define的, 也就是没办法直接利用这个来定义我们的TODO</li>\n</ol>\n<p>好在C99提供了一个 <strong>_Pragma</strong> 运算符可以把部分#pragma指令字符串化, 如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma message <span class=\"meta-string\">\"Colin\"</span></span></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message \\\"Colin\\\"\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">_Pragma(<span class=\"string\">\"message(\\\"Colin\\\")\"</span>) <span class=\"comment\">// 需要注意双引号的转义</span></span><br></pre></td></tr></table></figure>\n<p>利用这个特性，我们就可以将warning定义成宏:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define MY_WARNING _Pragma(<span class=\"meta-string\">\"message (\\\"</span>警察临检, 男左女右!\\<span class=\"meta-string\">\")\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    MY_WARNING</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387346_6563.jpeg\" width=\"500\"/></p>\n<p>到这里, 大体有那么一个感觉。 不过我们提示的内容, 是define的, 也就是写死固定的, 不太合适。</p>\n<p>所以我们希望这个宏能接受入参, 让它正常显示到warning中。</p>\n<p>这就涉及了一些宏的基本用法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br></pre></td></tr></table></figure>\n<p>STRINGIFY(S) 将入参转化成字符串，省去了_Pragma中全串加转义字符的困扰。</p>\n<p><strong>效果如下:</strong></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201503/15/1426387347_2653.jpeg\" width=\"500\"/></p>\n<p>这时，一个基本功能的TODO宏就完成了，下面向其中加入额外的信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两个已有的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"><span class=\"comment\">// 延迟1次展开的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"><span class=\"comment\">// 下面的宏在第一行用`\\`折行</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span>  \\</span></span><br><span class=\"line\">    DEFER_STRINGIFY(__FILE__) <span class=\"string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span><br></pre></td></tr></table></figure>\n<p>其中涉及到的知识：</p>\n<ul>\n<li>两个常量字符串可以拼接成一个整串 “123””456” =&gt; “123456”</li>\n<li>使用到3个预定义宏，<strong>COUNTER</strong>宏展开次数的计数器，全局唯一；<strong>FILE</strong>当前文件完整目录字符串；<strong>LINE</strong>在当前文件第几行</li>\n<li>在字符串中预定义宏应延时展开，如果将上面的DEFER<em>STRINGIFY换成STRINGIFY的话，如<strong>LINE</strong>不能被正确展开成行数，而是成了一个常量字符串”<em>_LINE</em></em>“</li>\n<li>为了美化，warning message中可以使用\\n换行</li>\n</ul>\n<p>于是，使用FORMATTED_MESSAGE(MSG)宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。</p>\n<hr>\n<p>其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加@的形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"最终版本\"><strong>最终版本</strong></h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转成字符串</span></span><br><span class=\"line\"><span class=\"meta\">#define STRINGIFY(S) #S</span></span><br><span class=\"line\"><span class=\"comment\">// 需要解两次才解开的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为warning增加更多信息</span></span><br><span class=\"line\"><span class=\"meta\">#define FORMATTED_MESSAGE(MSG) <span class=\"meta-string\">\"[TODO-\"</span> DEFER_STRINGIFY(__COUNTER__) <span class=\"meta-string\">\"] \"</span> MSG <span class=\"meta-string\">\" \\n\"</span> DEFER_STRINGIFY(__FILE__) <span class=\"meta-string\">\" line \"</span> DEFER_STRINGIFY(__LINE__)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使宏前面可以加@</span></span><br><span class=\"line\"><span class=\"meta\">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最终使用的宏</span></span><br><span class=\"line\"><span class=\"meta\">#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"References\">References</h1><p><a href=\"http://blog.sunnyxx.com/2015/03/01/todo-macro/\">http://blog.sunnyxx.com/2015/03/01/todo-macro/</a></p>\n<p><a href=\"http://clang.llvm.org/docs/UsersManual.html\">http://clang.llvm.org/docs/UsersManual.html</a></p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html\">https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html</a></p>"},{"layout":"Hexo折腾","title":"为Hexo博客添加版权说明和打赏功能","date":"2016-06-02T12:06:06.000Z","_content":"\n> 今天为博客配置了自动添加版权说明和打赏功能，加深了对Hexo框架的理解，做个小小的总结。当然，如果喜欢也可以试试为自己的博客添加上。\n\n效果图：\n\n![tailResult](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/tailResult.png)\n\n\n\n<!--more-->\n\n\n\n## 版权说明\n\n具体实现步骤如下：\n\n1. 在博客根目录下（和 source 同级），新建一个名为 `scripts` 的文件夹。\n2. 在 `scripts` 文件夹内, 新建一个 `AddTail.js` 脚本文件，脚本具体内容详见下文。\n3. 在博客根目录下，新建一个 `tail.md` 文件，里面写想要展示的版本说明内容。示例如下文所示。\n\n `AddTail.js` 脚本文件：\n\n```javascript\n// Filename: AddTail.js\n// Author: Colin\n// Date: 2016/06/02\n// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/\n\n// Add a tail to every post from tail.md\n// Great for adding copyright info\n\nvar fs = require('fs');\n\nhexo.extend.filter.register('before_post_render', function(data){\n\tif(data.copyright == false) return data;\n\t\n\t// Add seperate line\n\tdata.content += '\\n___\\n';\n\t\n\t// Try to read tail.md\n\ttry {\n\t\tvar file_content = fs.readFileSync('tail.md');\n\t\tif(file_content && data.content.length > 50) \n\t\t{\n\t\t\tdata.content += file_content;\n\t\t}\n\t} catch (err) {\n\t\tif (err.code !== 'ENOENT') throw err;\n\t\t\n\t\t// No process for ENOENT error\n\t}\n\n  \t// 添加具体文章链接, 不需要去掉即可\n\tvar permalink = '\\n本文链接：' + data.permalink;\n\tdata.content += permalink;\n  \n\treturn data;\n});\n```\n\n\n\n`tail.md` 文件示例：\n\n[![知识共享许可协议](http://i.creativecommons.org/l/by/2.5/cn/88x31.png)](http://creativecommons.org/licenses/by/2.5/cn/)本作品采用[知识共享署名 2.5 中国大陆许可协议](http://creativecommons.org/licenses/by/2.5/cn/)进行许可，欢迎转载，但转载请注明来自[Colin's Nest](http://colin1994.github.io/)，并保持转载后文章内容的完整。本人保留所有版权相关权利。\n\n\n\n如此，`hero clean` 后重新 `hexo generate` 即可。\n\n\n\n## 打赏功能\n\n打赏功能的实现其实是直接嵌入到博客主题中的，所以修改了原先 `clone` 下来的源码。当然，你可以发个 `PR` ，或者直接选择支持打赏功能的主题。我这里选择的 [Yilia](https://github.com/litten/hexo-theme-yilia) 主题并不支持这个功能，所以只好自己实现一下。（虽然知道大概并没有什么用...）\n\n\n\n### 目标\n\n既然是嵌入到博客主题中，那么当然希望是可定制的。例如主题本身给我们提供的配置一样。大致目标如下：\n\n我们只需要在 `_config.yml` 中加入如下语句, 即可完成打赏的配置\n\n```xml\n#打赏\ndonate:\n  enable: true\n  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！\n  wechat: http://7xkc7a.com1.z0.glb.clouddn.com/wechatImage.png\n  alipay: http://7xkc7a.com1.z0.glb.clouddn.com/alipayImage.png\n```\n\n- `enable` 参数设置是否开启打赏功能。( `true` or ` false` )\n- `text` 参数配置需要显示的内容\n- `wechat` 参数设置微信支付二维码 URL\n- `alipay` 参数设置支付宝支付二维码 URL\n\n### 实现步骤\n\n编辑主题内的 `article.ejs` 文件，比如我这里位于 `themes/yilia/layout/_partial/article.ejs` 。\n\n在 `<div class=\"article-content\">...</div>` 的下面，`<%- partial('footer') %>` 的上面插入如下HTML代码：\n\n```html\n<% if (theme.donate) { %>\n  <!-- css -->\n  <style type=\"text/css\">\n      .center {\n          text-align: center;\n      }\n      .hidden {\n          display: none;\n      }\n    .donate_bar a.btn_donate{\n      display: inline-block;\n      width: 82px;\n      height: 82px;\n      background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;\n      _background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;\n\n      <!-- http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif\n           因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，\n         为了在让打赏按钮显示效果正常 而 添加了以下几行 css，\n         嵌入其它博客时不一定要它们。 -->\n      -webkit-transition: background 0s;\n      -moz-transition: background 0s;\n      -o-transition: background 0s;\n      -ms-transition: background 0s;\n      transition: background 0s;\n      <!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 -->\n    }\n\n    .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}\n    .donate_bar .donate_txt {\n      display: block;\n      color: #9d9d9d;\n      font: 14px/2 \"Microsoft Yahei\";\n    }\n    .bold{ font-weight: bold; }\n  </style>\n  <!-- /css -->\n\n    <!-- Donate Module -->\n    <div id=\"donate_module\">\n\n  <!-- btn_donate & tips -->\n  <div id=\"donate_board\" class=\"donate_bar center\">\n      <br>\n      ------------------------------------------------------------------------------------------------------------------------------\n      <br>\n    <a id=\"btn_donate\" class=\"btn_donate\" target=\"_self\" href=\"javascript:;\" title=\"Donate 打赏\"></a>\n    <span class=\"donate_txt\">\n      <%= theme.donate.text %>\n    </span>\n      \n    \n  </div>\n  <!-- /btn_donate & tips -->\n\n  <!-- donate guide -->\n    \n  <div id=\"donate_guide\" class=\"donate_bar center hidden\">\n        <br>\n      ------------------------------------------------------------------------------------------------------------------------------\n      <br>\n\n    <a href=\"<%= theme.donate.wechat %>\" title=\"用微信扫一扫哦~\" class=\"fancybox\" rel=\"article0\">\n      <img src=\"<%= theme.donate.wechat %>\" title=\"微信打赏 Colin\" height=\"190px\" width=\"auto\"/>\n    </a>\n        \n        &nbsp;&nbsp;\n\n    <a href=\"<%= theme.donate.alipay %>\" title=\"用支付宝扫一扫即可~\" class=\"fancybox\" rel=\"article0\">\n      <img src=\"<%= theme.donate.alipay %>\" title=\"支付宝打赏 Colin\" height=\"190px\" width=\"auto\"/>\n    </a>\n\n    <span class=\"donate_txt\">\n      <%= theme.donate.text %>\n    </span>\n\n  </div>\n  <!-- /donate guide -->\n\n  <!-- donate script -->\n  <script type=\"text/javascript\">\n    document.getElementById('btn_donate').onclick = function() {\n      $('#donate_board').addClass('hidden');\n      $('#donate_guide').removeClass('hidden');\n    }\n\n    function donate_on_web(){\n      $('#donate').submit();\n        }\n\n    var original_window_onload = window.onload;\n        window.onload = function () {\n            if (original_window_onload) {\n                original_window_onload();\n            }\n            document.getElementById('donate_board_wdg').className = 'hidden';\n    }\n  </script>\n  <!-- /donate script -->\n</div>\n<!-- /Donate Module -->\n   <% } %>\n```\n\n这里通过判断是否显示打赏模块，执行相应的操作。点击打赏按钮，显示相应的二维码。\n\n这里还有个问题，在文章列表中，有时候也会显示打赏功能，这显然不是我们想要的。需要做的就是判断当前的的页面是详情页面还是介绍页面，比如我这里，把上面的代码放在如下判断语句中：\n\n```html\n<% if (!post.excerpt || !index){ %>\n  \n  <!-- /上述代码 -->\n<% }%>\n```\n\n\n\n如此，一个简单的打赏功能就实现了。\n\n\n\n当然，你如果觉得麻烦，但是又想实现打赏功能，那么可以尝试下 [云打赏](http://www.dashangcloud.com)，据说一行代码集成打赏功能。\n\nHave fun ~     ：）\n\n\n\n## 参考链接\n\n[￼为Hexo博客文章自动添加版权信息](https://tono.tk/2016/03/26/Add_copyright_for_hexo/)\n\n[实现网站的支付宝打赏功能](http://icehe.me/web/donate/)\n\n","source":"_posts/hexo-copyright-and-donate.md","raw":"layout: 'Hexo折腾'\n\ntitle: 为Hexo博客添加版权说明和打赏功能\n\ndate: 2016-06-02 20:06:06\n\ntags:\n\n- Hexo\n- 教程\n\n------\n\n> 今天为博客配置了自动添加版权说明和打赏功能，加深了对Hexo框架的理解，做个小小的总结。当然，如果喜欢也可以试试为自己的博客添加上。\n\n效果图：\n\n![tailResult](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/tailResult.png)\n\n\n\n<!--more-->\n\n\n\n## 版权说明\n\n具体实现步骤如下：\n\n1. 在博客根目录下（和 source 同级），新建一个名为 `scripts` 的文件夹。\n2. 在 `scripts` 文件夹内, 新建一个 `AddTail.js` 脚本文件，脚本具体内容详见下文。\n3. 在博客根目录下，新建一个 `tail.md` 文件，里面写想要展示的版本说明内容。示例如下文所示。\n\n `AddTail.js` 脚本文件：\n\n```javascript\n// Filename: AddTail.js\n// Author: Colin\n// Date: 2016/06/02\n// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/\n\n// Add a tail to every post from tail.md\n// Great for adding copyright info\n\nvar fs = require('fs');\n\nhexo.extend.filter.register('before_post_render', function(data){\n\tif(data.copyright == false) return data;\n\t\n\t// Add seperate line\n\tdata.content += '\\n___\\n';\n\t\n\t// Try to read tail.md\n\ttry {\n\t\tvar file_content = fs.readFileSync('tail.md');\n\t\tif(file_content && data.content.length > 50) \n\t\t{\n\t\t\tdata.content += file_content;\n\t\t}\n\t} catch (err) {\n\t\tif (err.code !== 'ENOENT') throw err;\n\t\t\n\t\t// No process for ENOENT error\n\t}\n\n  \t// 添加具体文章链接, 不需要去掉即可\n\tvar permalink = '\\n本文链接：' + data.permalink;\n\tdata.content += permalink;\n  \n\treturn data;\n});\n```\n\n\n\n`tail.md` 文件示例：\n\n[![知识共享许可协议](http://i.creativecommons.org/l/by/2.5/cn/88x31.png)](http://creativecommons.org/licenses/by/2.5/cn/)本作品采用[知识共享署名 2.5 中国大陆许可协议](http://creativecommons.org/licenses/by/2.5/cn/)进行许可，欢迎转载，但转载请注明来自[Colin's Nest](http://colin1994.github.io/)，并保持转载后文章内容的完整。本人保留所有版权相关权利。\n\n\n\n如此，`hero clean` 后重新 `hexo generate` 即可。\n\n\n\n## 打赏功能\n\n打赏功能的实现其实是直接嵌入到博客主题中的，所以修改了原先 `clone` 下来的源码。当然，你可以发个 `PR` ，或者直接选择支持打赏功能的主题。我这里选择的 [Yilia](https://github.com/litten/hexo-theme-yilia) 主题并不支持这个功能，所以只好自己实现一下。（虽然知道大概并没有什么用...）\n\n\n\n### 目标\n\n既然是嵌入到博客主题中，那么当然希望是可定制的。例如主题本身给我们提供的配置一样。大致目标如下：\n\n我们只需要在 `_config.yml` 中加入如下语句, 即可完成打赏的配置\n\n```xml\n#打赏\ndonate:\n  enable: true\n  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！\n  wechat: http://7xkc7a.com1.z0.glb.clouddn.com/wechatImage.png\n  alipay: http://7xkc7a.com1.z0.glb.clouddn.com/alipayImage.png\n```\n\n- `enable` 参数设置是否开启打赏功能。( `true` or ` false` )\n- `text` 参数配置需要显示的内容\n- `wechat` 参数设置微信支付二维码 URL\n- `alipay` 参数设置支付宝支付二维码 URL\n\n### 实现步骤\n\n编辑主题内的 `article.ejs` 文件，比如我这里位于 `themes/yilia/layout/_partial/article.ejs` 。\n\n在 `<div class=\"article-content\">...</div>` 的下面，`<%- partial('footer') %>` 的上面插入如下HTML代码：\n\n```html\n<% if (theme.donate) { %>\n  <!-- css -->\n  <style type=\"text/css\">\n      .center {\n          text-align: center;\n      }\n      .hidden {\n          display: none;\n      }\n    .donate_bar a.btn_donate{\n      display: inline-block;\n      width: 82px;\n      height: 82px;\n      background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;\n      _background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;\n\n      <!-- http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif\n           因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，\n         为了在让打赏按钮显示效果正常 而 添加了以下几行 css，\n         嵌入其它博客时不一定要它们。 -->\n      -webkit-transition: background 0s;\n      -moz-transition: background 0s;\n      -o-transition: background 0s;\n      -ms-transition: background 0s;\n      transition: background 0s;\n      <!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 -->\n    }\n\n    .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}\n    .donate_bar .donate_txt {\n      display: block;\n      color: #9d9d9d;\n      font: 14px/2 \"Microsoft Yahei\";\n    }\n    .bold{ font-weight: bold; }\n  </style>\n  <!-- /css -->\n\n    <!-- Donate Module -->\n    <div id=\"donate_module\">\n\n  <!-- btn_donate & tips -->\n  <div id=\"donate_board\" class=\"donate_bar center\">\n      <br>\n      ------------------------------------------------------------------------------------------------------------------------------\n      <br>\n    <a id=\"btn_donate\" class=\"btn_donate\" target=\"_self\" href=\"javascript:;\" title=\"Donate 打赏\"></a>\n    <span class=\"donate_txt\">\n      <%= theme.donate.text %>\n    </span>\n      \n    \n  </div>\n  <!-- /btn_donate & tips -->\n\n  <!-- donate guide -->\n    \n  <div id=\"donate_guide\" class=\"donate_bar center hidden\">\n        <br>\n      ------------------------------------------------------------------------------------------------------------------------------\n      <br>\n\n    <a href=\"<%= theme.donate.wechat %>\" title=\"用微信扫一扫哦~\" class=\"fancybox\" rel=\"article0\">\n      <img src=\"<%= theme.donate.wechat %>\" title=\"微信打赏 Colin\" height=\"190px\" width=\"auto\"/>\n    </a>\n        \n        &nbsp;&nbsp;\n\n    <a href=\"<%= theme.donate.alipay %>\" title=\"用支付宝扫一扫即可~\" class=\"fancybox\" rel=\"article0\">\n      <img src=\"<%= theme.donate.alipay %>\" title=\"支付宝打赏 Colin\" height=\"190px\" width=\"auto\"/>\n    </a>\n\n    <span class=\"donate_txt\">\n      <%= theme.donate.text %>\n    </span>\n\n  </div>\n  <!-- /donate guide -->\n\n  <!-- donate script -->\n  <script type=\"text/javascript\">\n    document.getElementById('btn_donate').onclick = function() {\n      $('#donate_board').addClass('hidden');\n      $('#donate_guide').removeClass('hidden');\n    }\n\n    function donate_on_web(){\n      $('#donate').submit();\n        }\n\n    var original_window_onload = window.onload;\n        window.onload = function () {\n            if (original_window_onload) {\n                original_window_onload();\n            }\n            document.getElementById('donate_board_wdg').className = 'hidden';\n    }\n  </script>\n  <!-- /donate script -->\n</div>\n<!-- /Donate Module -->\n   <% } %>\n```\n\n这里通过判断是否显示打赏模块，执行相应的操作。点击打赏按钮，显示相应的二维码。\n\n这里还有个问题，在文章列表中，有时候也会显示打赏功能，这显然不是我们想要的。需要做的就是判断当前的的页面是详情页面还是介绍页面，比如我这里，把上面的代码放在如下判断语句中：\n\n```html\n<% if (!post.excerpt || !index){ %>\n  \n  <!-- /上述代码 -->\n<% }%>\n```\n\n\n\n如此，一个简单的打赏功能就实现了。\n\n\n\n当然，你如果觉得麻烦，但是又想实现打赏功能，那么可以尝试下 [云打赏](http://www.dashangcloud.com)，据说一行代码集成打赏功能。\n\nHave fun ~     ：）\n\n\n\n## 参考链接\n\n[￼为Hexo博客文章自动添加版权信息](https://tono.tk/2016/03/26/Add_copyright_for_hexo/)\n\n[实现网站的支付宝打赏功能](http://icehe.me/web/donate/)\n\n","slug":"hexo-copyright-and-donate","published":1,"updated":"2019-12-23T01:02:31.290Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1m10008zwlnfbgbj6qh","content":"<blockquote>\n<p>今天为博客配置了自动添加版权说明和打赏功能，加深了对Hexo框架的理解，做个小小的总结。当然，如果喜欢也可以试试为自己的博客添加上。</p>\n</blockquote>\n<p>效果图：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/tailResult.png\" alt=\"tailResult\"></p>\n<a id=\"more\"></a>\n<h2 id=\"版权说明\">版权说明</h2><p>具体实现步骤如下：</p>\n<ol>\n<li>在博客根目录下（和 source 同级），新建一个名为 <code>scripts</code> 的文件夹。</li>\n<li>在 <code>scripts</code> 文件夹内, 新建一个 <code>AddTail.js</code> 脚本文件，脚本具体内容详见下文。</li>\n<li><p>在博客根目录下，新建一个 <code>tail.md</code> 文件，里面写想要展示的版本说明内容。示例如下文所示。</p>\n<p><code>AddTail.js</code> 脚本文件：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Filename: AddTail.js</span></span><br><span class=\"line\"><span class=\"comment\">// Author: Colin</span></span><br><span class=\"line\"><span class=\"comment\">// Date: 2016/06/02</span></span><br><span class=\"line\"><span class=\"comment\">// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add a tail to every post from tail.md</span></span><br><span class=\"line\"><span class=\"comment\">// Great for adding copyright info</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">'before_post_render'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(data.copyright == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Add seperate line</span></span><br><span class=\"line\">\tdata.content += <span class=\"string\">'\\n___\\n'</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Try to read tail.md</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> file_content = fs.readFileSync(<span class=\"string\">'tail.md'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(file_content &amp;&amp; data.content.length &gt; <span class=\"number\">50</span>) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdata.content += file_content;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err.code !== <span class=\"string\">'ENOENT'</span>) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// No process for ENOENT error</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">// 添加具体文章链接, 不需要去掉即可</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> permalink = <span class=\"string\">'\\n本文链接：'</span> + data.permalink;</span><br><span class=\"line\">\tdata.content += permalink;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>tail.md</code> 文件示例：</p>\n<p><a href=\"http://creativecommons.org/licenses/by/2.5/cn/\" target=\"_blank\" rel=\"external\"><img src=\"http://i.creativecommons.org/l/by/2.5/cn/88x31.png\" alt=\"知识共享许可协议\"></a>本作品采用<a href=\"http://creativecommons.org/licenses/by/2.5/cn/\" target=\"_blank\" rel=\"external\">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href=\"http://colin1994.github.io/\" target=\"_blank\" rel=\"external\">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>\n<p>如此，<code>hero clean</code> 后重新 <code>hexo generate</code> 即可。</p>\n<h2 id=\"打赏功能\">打赏功能</h2><p>打赏功能的实现其实是直接嵌入到博客主题中的，所以修改了原先 <code>clone</code> 下来的源码。当然，你可以发个 <code>PR</code> ，或者直接选择支持打赏功能的主题。我这里选择的 <a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"external\">Yilia</a> 主题并不支持这个功能，所以只好自己实现一下。（虽然知道大概并没有什么用…）</p>\n<h3 id=\"目标\">目标</h3><p>既然是嵌入到博客主题中，那么当然希望是可定制的。例如主题本身给我们提供的配置一样。大致目标如下：</p>\n<p>我们只需要在 <code>_config.yml</code> 中加入如下语句, 即可完成打赏的配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#打赏</span><br><span class=\"line\">donate:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</span><br><span class=\"line\">  wechat: http://7xkc7a.com1.z0.glb.clouddn.com/wechatImage.png</span><br><span class=\"line\">  alipay: http://7xkc7a.com1.z0.glb.clouddn.com/alipayImage.png</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>enable</code> 参数设置是否开启打赏功能。( <code>true</code> or <code>false</code> )</li>\n<li><code>text</code> 参数配置需要显示的内容</li>\n<li><code>wechat</code> 参数设置微信支付二维码 URL</li>\n<li><code>alipay</code> 参数设置支付宝支付二维码 URL</li>\n</ul>\n<h3 id=\"实现步骤\">实现步骤</h3><p>编辑主题内的 <code>article.ejs</code> 文件，比如我这里位于 <code>themes/yilia/layout/_partial/article.ejs</code> 。</p>\n<p>在 <code>&lt;div class=&quot;article-content&quot;&gt;...&lt;/div&gt;</code> 的下面，<code>&lt;%- partial(&#39;footer&#39;) %&gt;</code> 的上面插入如下HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">if</span> (<span class=\"attr\">theme.donate</span>) &#123; %&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- css --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"xml\"></span><br><span class=\"line\">      .center &#123;</span><br><span class=\"line\">          text-align: center;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      .hidden &#123;</span><br><span class=\"line\">          display: none;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    .donate_bar a.btn_donate&#123;</span><br><span class=\"line\">      display: inline-block;</span><br><span class=\"line\">      width: 82px;</span><br><span class=\"line\">      height: 82px;</span><br><span class=\"line\">      background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;</span><br><span class=\"line\">      _background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif</span><br><span class=\"line\">           因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，</span><br><span class=\"line\">         为了在让打赏按钮显示效果正常 而 添加了以下几行 css，</span><br><span class=\"line\">         嵌入其它博客时不一定要它们。 --&gt;</span></span><br><span class=\"line\">      -webkit-transition: background 0s;</span><br><span class=\"line\">      -moz-transition: background 0s;</span><br><span class=\"line\">      -o-transition: background 0s;</span><br><span class=\"line\">      -ms-transition: background 0s;</span><br><span class=\"line\">      transition: background 0s;</span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 --&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .donate_bar a.btn_donate:hover&#123; background-position: 0px -82px;&#125;</span><br><span class=\"line\">    .donate_bar .donate_txt &#123;</span><br><span class=\"line\">      display: block;</span><br><span class=\"line\">      color: #9d9d9d;</span><br><span class=\"line\">      font: 14px/2 \"Microsoft Yahei\";</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .bold&#123; font-weight: bold; &#125;</span><br><span class=\"line\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /css --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Donate Module --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"donate_module\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- btn_donate &amp; tips --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"donate_board\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_bar center\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      ------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn_donate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn_donate\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_self\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"javascript:;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Donate 打赏\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_txt\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.donate.text</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /btn_donate &amp; tips --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- donate guide --&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"donate_guide\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_bar center hidden\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      ------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%= theme.donate.wechat %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"用微信扫一扫哦~\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fancybox\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"article0\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%= theme.donate.wechat %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"微信打赏 Colin\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"190px\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"auto\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        &amp;nbsp;&amp;nbsp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%= theme.donate.alipay %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"用支付宝扫一扫即可~\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fancybox\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"article0\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%= theme.donate.alipay %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"支付宝打赏 Colin\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"190px\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"auto\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_txt\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.donate.text</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /donate guide --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- donate script --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn_donate'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      $(<span class=\"string\">'#donate_board'</span>).addClass(<span class=\"string\">'hidden'</span>);</span><br><span class=\"line\">      $(<span class=\"string\">'#donate_guide'</span>).removeClass(<span class=\"string\">'hidden'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">donate_on_web</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      $(<span class=\"string\">'#donate'</span>).submit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> original_window_onload = <span class=\"built_in\">window</span>.onload;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (original_window_onload) &#123;</span><br><span class=\"line\">                original_window_onload();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'donate_board_wdg'</span>).className = <span class=\"string\">'hidden'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /donate script --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- /Donate Module --&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里通过判断是否显示打赏模块，执行相应的操作。点击打赏按钮，显示相应的二维码。</p>\n<p>这里还有个问题，在文章列表中，有时候也会显示打赏功能，这显然不是我们想要的。需要做的就是判断当前的的页面是详情页面还是介绍页面，比如我这里，把上面的代码放在如下判断语句中：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">if</span> (!<span class=\"attr\">post.excerpt</span> || !<span class=\"attr\">index</span>)&#123; %&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /上述代码 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> &#125;%&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如此，一个简单的打赏功能就实现了。</p>\n<p>当然，你如果觉得麻烦，但是又想实现打赏功能，那么可以尝试下 <a href=\"http://www.dashangcloud.com\" target=\"_blank\" rel=\"external\">云打赏</a>，据说一行代码集成打赏功能。</p>\n<p>Have fun ~     ：）</p>\n<h2 id=\"参考链接\">参考链接</h2><p><a href=\"https://tono.tk/2016/03/26/Add_copyright_for_hexo/\" target=\"_blank\" rel=\"external\">￼为Hexo博客文章自动添加版权信息</a></p>\n<p><a href=\"http://icehe.me/web/donate/\" target=\"_blank\" rel=\"external\">实现网站的支付宝打赏功能</a></p>\n","excerpt":"<blockquote>\n<p>今天为博客配置了自动添加版权说明和打赏功能，加深了对Hexo框架的理解，做个小小的总结。当然，如果喜欢也可以试试为自己的博客添加上。</p>\n</blockquote>\n<p>效果图：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/tailResult.png\" alt=\"tailResult\"></p>","more":"<h2 id=\"版权说明\">版权说明</h2><p>具体实现步骤如下：</p>\n<ol>\n<li>在博客根目录下（和 source 同级），新建一个名为 <code>scripts</code> 的文件夹。</li>\n<li>在 <code>scripts</code> 文件夹内, 新建一个 <code>AddTail.js</code> 脚本文件，脚本具体内容详见下文。</li>\n<li><p>在博客根目录下，新建一个 <code>tail.md</code> 文件，里面写想要展示的版本说明内容。示例如下文所示。</p>\n<p><code>AddTail.js</code> 脚本文件：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Filename: AddTail.js</span></span><br><span class=\"line\"><span class=\"comment\">// Author: Colin</span></span><br><span class=\"line\"><span class=\"comment\">// Date: 2016/06/02</span></span><br><span class=\"line\"><span class=\"comment\">// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add a tail to every post from tail.md</span></span><br><span class=\"line\"><span class=\"comment\">// Great for adding copyright info</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">'before_post_render'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(data.copyright == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Add seperate line</span></span><br><span class=\"line\">\tdata.content += <span class=\"string\">'\\n___\\n'</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Try to read tail.md</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> file_content = fs.readFileSync(<span class=\"string\">'tail.md'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(file_content &amp;&amp; data.content.length &gt; <span class=\"number\">50</span>) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdata.content += file_content;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err.code !== <span class=\"string\">'ENOENT'</span>) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// No process for ENOENT error</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">// 添加具体文章链接, 不需要去掉即可</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> permalink = <span class=\"string\">'\\n本文链接：'</span> + data.permalink;</span><br><span class=\"line\">\tdata.content += permalink;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>tail.md</code> 文件示例：</p>\n<p><a href=\"http://creativecommons.org/licenses/by/2.5/cn/\"><img src=\"http://i.creativecommons.org/l/by/2.5/cn/88x31.png\" alt=\"知识共享许可协议\"></a>本作品采用<a href=\"http://creativecommons.org/licenses/by/2.5/cn/\">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href=\"http://colin1994.github.io/\">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>\n<p>如此，<code>hero clean</code> 后重新 <code>hexo generate</code> 即可。</p>\n<h2 id=\"打赏功能\">打赏功能</h2><p>打赏功能的实现其实是直接嵌入到博客主题中的，所以修改了原先 <code>clone</code> 下来的源码。当然，你可以发个 <code>PR</code> ，或者直接选择支持打赏功能的主题。我这里选择的 <a href=\"https://github.com/litten/hexo-theme-yilia\">Yilia</a> 主题并不支持这个功能，所以只好自己实现一下。（虽然知道大概并没有什么用…）</p>\n<h3 id=\"目标\">目标</h3><p>既然是嵌入到博客主题中，那么当然希望是可定制的。例如主题本身给我们提供的配置一样。大致目标如下：</p>\n<p>我们只需要在 <code>_config.yml</code> 中加入如下语句, 即可完成打赏的配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#打赏</span><br><span class=\"line\">donate:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</span><br><span class=\"line\">  wechat: http://7xkc7a.com1.z0.glb.clouddn.com/wechatImage.png</span><br><span class=\"line\">  alipay: http://7xkc7a.com1.z0.glb.clouddn.com/alipayImage.png</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>enable</code> 参数设置是否开启打赏功能。( <code>true</code> or <code>false</code> )</li>\n<li><code>text</code> 参数配置需要显示的内容</li>\n<li><code>wechat</code> 参数设置微信支付二维码 URL</li>\n<li><code>alipay</code> 参数设置支付宝支付二维码 URL</li>\n</ul>\n<h3 id=\"实现步骤\">实现步骤</h3><p>编辑主题内的 <code>article.ejs</code> 文件，比如我这里位于 <code>themes/yilia/layout/_partial/article.ejs</code> 。</p>\n<p>在 <code>&lt;div class=&quot;article-content&quot;&gt;...&lt;/div&gt;</code> 的下面，<code>&lt;%- partial(&#39;footer&#39;) %&gt;</code> 的上面插入如下HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">if</span> (<span class=\"attr\">theme.donate</span>) &#123; %&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- css --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"xml\"></span><br><span class=\"line\">      .center &#123;</span><br><span class=\"line\">          text-align: center;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      .hidden &#123;</span><br><span class=\"line\">          display: none;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    .donate_bar a.btn_donate&#123;</span><br><span class=\"line\">      display: inline-block;</span><br><span class=\"line\">      width: 82px;</span><br><span class=\"line\">      height: 82px;</span><br><span class=\"line\">      background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;</span><br><span class=\"line\">      _background: url(\"http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif\") no-repeat;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif</span><br><span class=\"line\">           因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，</span><br><span class=\"line\">         为了在让打赏按钮显示效果正常 而 添加了以下几行 css，</span><br><span class=\"line\">         嵌入其它博客时不一定要它们。 --&gt;</span></span><br><span class=\"line\">      -webkit-transition: background 0s;</span><br><span class=\"line\">      -moz-transition: background 0s;</span><br><span class=\"line\">      -o-transition: background 0s;</span><br><span class=\"line\">      -ms-transition: background 0s;</span><br><span class=\"line\">      transition: background 0s;</span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 --&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .donate_bar a.btn_donate:hover&#123; background-position: 0px -82px;&#125;</span><br><span class=\"line\">    .donate_bar .donate_txt &#123;</span><br><span class=\"line\">      display: block;</span><br><span class=\"line\">      color: #9d9d9d;</span><br><span class=\"line\">      font: 14px/2 \"Microsoft Yahei\";</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .bold&#123; font-weight: bold; &#125;</span><br><span class=\"line\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /css --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Donate Module --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"donate_module\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- btn_donate &amp; tips --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"donate_board\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_bar center\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      ------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn_donate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn_donate\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_self\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"javascript:;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Donate 打赏\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_txt\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.donate.text</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /btn_donate &amp; tips --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- donate guide --&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"donate_guide\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_bar center hidden\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      ------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%= theme.donate.wechat %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"用微信扫一扫哦~\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fancybox\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"article0\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%= theme.donate.wechat %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"微信打赏 Colin\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"190px\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"auto\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        &amp;nbsp;&amp;nbsp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%= theme.donate.alipay %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"用支付宝扫一扫即可~\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fancybox\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"article0\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%= theme.donate.alipay %&gt;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"支付宝打赏 Colin\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"190px\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"auto\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"donate_txt\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.donate.text</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /donate guide --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- donate script --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn_donate'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      $(<span class=\"string\">'#donate_board'</span>).addClass(<span class=\"string\">'hidden'</span>);</span><br><span class=\"line\">      $(<span class=\"string\">'#donate_guide'</span>).removeClass(<span class=\"string\">'hidden'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">donate_on_web</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      $(<span class=\"string\">'#donate'</span>).submit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> original_window_onload = <span class=\"built_in\">window</span>.onload;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (original_window_onload) &#123;</span><br><span class=\"line\">                original_window_onload();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'donate_board_wdg'</span>).className = <span class=\"string\">'hidden'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /donate script --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- /Donate Module --&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里通过判断是否显示打赏模块，执行相应的操作。点击打赏按钮，显示相应的二维码。</p>\n<p>这里还有个问题，在文章列表中，有时候也会显示打赏功能，这显然不是我们想要的。需要做的就是判断当前的的页面是详情页面还是介绍页面，比如我这里，把上面的代码放在如下判断语句中：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">if</span> (!<span class=\"attr\">post.excerpt</span> || !<span class=\"attr\">index</span>)&#123; %&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- /上述代码 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> &#125;%&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如此，一个简单的打赏功能就实现了。</p>\n<p>当然，你如果觉得麻烦，但是又想实现打赏功能，那么可以尝试下 <a href=\"http://www.dashangcloud.com\">云打赏</a>，据说一行代码集成打赏功能。</p>\n<p>Have fun ~     ：）</p>\n<h2 id=\"参考链接\">参考链接</h2><p><a href=\"https://tono.tk/2016/03/26/Add_copyright_for_hexo/\">￼为Hexo博客文章自动添加版权信息</a></p>\n<p><a href=\"http://icehe.me/web/donate/\">实现网站的支付宝打赏功能</a></p>"},{"title":"Metal 系列教程","date":"2018-08-25T02:59:45.000Z","_content":"\n\n\n从 2014 年，Apple 正式推出 Metal 到现在，这个 Metal 系列教程，酝酿了很久，却迟迟没有进展。\n\n直到 **WWDC 2018，Apple 宣布 iOS 12 将弃用 OpenGL / CL**，我想，这或许是个机会。\n\n> Apps built using OpenGL ES will continue to run in iOS 12, but Open GL ES is deprecated in iOS 12. Games and graphics-intensive apps that previously used OpenGL ES should now adopt Metal.\n\n![](https://diycode.b0.upaiyun.com/photo/2018/de088c47205fd04fc8d9e11748813b10.jpeg)\n\n\n\n这个系列会回顾整理之前学习的内容，有序输出。算是对自己的一个交代，同时也希望，能帮助到那些想要学习 Metal 却不知道怎么下手的朋友。\n\n<!--more-->\n\n> 这系列文章，目前发布在我的小专栏 [iOS 图像处理](https://xiaozhuanlan.com/colin) 上。欢迎订阅~\n\n\n\n那么，**什么是 Metal** ？\n\n> Render advanced 3D graphics and perform data-parallel computations using the GPU.\n\n总结来说，**Metal 能让你尽可能的发挥 GPU 强大的渲染、运算的能力。**\n\n这里，我不做过多的阐述，如果你对图像处理，游戏编程感兴趣，又或者你只是认可这项技术，相信它是未来，值得投资学习。那么，我想这个系列不会让你失望。\n\n\n\n这个系列的文章，**是教程、实践，而不是文档**。\n\n我会尽可能，在实现功能的过程中，穿插介绍各个知识点。而不是一股脑的全部输出。\n\n不然可能看了四五篇，发现自己还是什么都做不了，还是不懂之前学到的具体是什么。\n\n然后，就不了了之了。\n\nMetal 系列的实战教程，会循序渐进，穿插详细介绍各个用到的 Metal 对象。\n\n由于 Metal（iOS 8 + A7），MetalKit（iOS 9 + A7）的软／硬件限制，以及不同读者的需求，之后的配套 Demo，会同时包含 iOS+Swift 和 macOS+ObjC 两种，文章以 iOS+Swift 进行演示。并且尽可能不用 MetalKit，功能都自己实现（避免一些实现细节被屏蔽了，以及降低系统版本限制）。当然，也会有专门的文章，介绍 MetalKit 相关。\n\n另外，每节 Demo 都有 start ／ end 两份代码，建议阅读完后，自己根据 start 基础工程，完成本节新的内容。该系列 Demo 主要是为了学习 Metal，所以一些语法特性，代码／文件结构，容错，封装等，不会去细究。\n\n每篇文章争取控制在 15 分钟的阅读量，细分知识点，便于随时阅读，学习。\n\n\n\n另外，之后的实战，会侧重于**图像处理**，比如**滤镜，画笔，马赛克，增高，相机，AR 贴图**等。开发过程中，也会结合系统的其他框架，比如 **Core Image、ARKit、Core ML、Vision** 等，做一些好玩的事情。\n\n> PS：\n> 订阅后的朋友，可以加我微信：wxidlongze，拉你进群。交流，扯淡，学习资源分享～\n>  最后，源码在小专栏中有链接～\n\n------\n\n\n## 目录\n\n### 基础概念：\n\n**[一。Metal 概述](https://xiaozhuanlan.com/topic/3420765198)**\n\n> Metal 是什么，Metal 能做什么，为什么要用 Metal。\n\n\n\n**[二。Metal 框架一览](https://xiaozhuanlan.com/topic/1287954630)**\n\n>Metal 进行图像处理的整体框架。宏观介绍渲染管线。\n\n\n\n### 基础实践：\n\n**[三。清屏](https://xiaozhuanlan.com/topic/9870134265)**\n\n> 最最最最简单的一个基础工程。介绍整体的显示渲染流程。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4677bca4a9633908b463e670646d434c.png)\n\n\n\n**[四。绘制一个三角形](https://xiaozhuanlan.com/topic/6503719284)**\n\n> 堪称图形界的 Hello World。会较为完整的过一遍渲染管线。\n>\n> 涉及的内容包括：**渲染管线的配置，着色器的编写，顶点数据的提交，图元的绘制**。\n>\n> 麻雀虽小，五脏俱全。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/68788a0103eac111ea445b0dcf02fa58.png)\n\n\n\n**[五。Buffer & Texture](https://xiaozhuanlan.com/topic/0459813726)**\n\n> 实现基础图像的渲染，即在屏幕上，显示一张我们指定的图片。主要关心非基础图元的绘制，Metal 里面的数据、资源的管理方式，图像解码的一些基础知识。介绍 MTLBuffer 以及 MTLTexture 相关内容。\n>\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ac2b226808a57f0acb725a46dde09759.png)\n\n\n\n**[六。GPUImage 3 浅析、基础框架搭建](https://xiaozhuanlan.com/topic/2514387096)**\n\n> 浅析一下 GPUImage 3 的设计，然后基于此，剥离出一些代码，形成基础框架，实现视图封装，也为之后的效果处理提供支持。\n\n![GPUImage](https://camo.githubusercontent.com/68ce8767f20b6a40f2a695c56396d30234363431/687474703a2f2f73756e7365746c616b65736f6674776172652e636f6d2f73697465732f64656661756c742f66696c65732f475055496d6167654c6f676f2e706e67)\n\n\n\n**[七。颜色滤镜](https://xiaozhuanlan.com/topic/3654810792)\u0010**\n\n> 介绍颜色滤镜常见的两种实现方式：**shader** 和 **lookup table**，并实现饱和度、亮度滤镜，以及常见的阿宝色滤镜。\n>\n> 同时会分析对应算法的原理。\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2019/f794ad7337d2885699c4d189694e7cf2.gif)\n\n\n\n\n\n**[八。风格化滤镜(上)](https://xiaozhuanlan.com/topic/3105827964)**\n\n> 上篇我们介绍了简单的颜色滤镜，即独立像素点变换，按照一定规律，修改当前像素点的色值。每个像素点都是独立的，不相互依赖。相对的，其他几类，我们可以统一归类为风格化滤镜，这类滤镜有一个显著的特点：当前点的最终色值，需要依赖其他位置点的色值，来共同决定。\n> 这一篇中，会介绍这么两个滤镜 Zoom Blur 和 Toon 的具体实现。\n>\n> 以及**系统提供的景深信息**等。\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2018/5d29ead45b570276f7bda57e2fb755df.gif)\n\n\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2018/20c51bfbfaaf5e981a0e77e89a121c45.png)\n\n\n\n\n\n**[九。风格化滤镜(下)](https://xiaozhuanlan.com/topic/5823149607)**\n\n> 介绍 Toon 效果的具体实现。\n> 介绍下更复杂的滤镜，比如之前很火的风格转换，以及借助 Core ML 模型的一些方式。\n>\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2018/93697319b46e0592ea443d7ecea200de.gif)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/e0c8acd368f9b02b24ad6e506dce3298.png)\n\n\n\n\n\n**[十。增高 & MTLHeap](https://xiaozhuanlan.com/topic/4896073512)**\n\n> MTLHeap：An abstract memory pool from which you can create resources.\n> 就是一块预先分配好的内存区域，然后这块区域用来干什么，完全是由开发者来控制的，可以随意复用。\n> 这次，我们同样是实现一个新的效果，增高。并分析使用 MTLHeap 带来的优势。\n>\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2019/1a826064d70d1c2ae4d9862a50f9e0ce.gif)\n\n\n\n\n\n\n\n**十一。抠图换背景 & Mask**\n\n> Mask 的使用场景，以及抠图换背景的具体实现。\n>\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2019/e8cd0d3fccd096ff5b6403a1319657e3.gif)\n\n\n\n...\n**To be continued ~**\n\n------\n\n> 这系列文章，目前发布在我的小专栏 [iOS 图像处理](https://xiaozhuanlan.com/colin) 上。欢迎订阅~","source":"_posts/metal-tutorial.md","raw":"title: Metal 系列教程\n\ndate: 2018-08-25 10:59:45\n\ntags:\n\n- iOS 开发\n- Metal\n- 图像处理\n- 教程\n\n------\n\n\n\n从 2014 年，Apple 正式推出 Metal 到现在，这个 Metal 系列教程，酝酿了很久，却迟迟没有进展。\n\n直到 **WWDC 2018，Apple 宣布 iOS 12 将弃用 OpenGL / CL**，我想，这或许是个机会。\n\n> Apps built using OpenGL ES will continue to run in iOS 12, but Open GL ES is deprecated in iOS 12. Games and graphics-intensive apps that previously used OpenGL ES should now adopt Metal.\n\n![](https://diycode.b0.upaiyun.com/photo/2018/de088c47205fd04fc8d9e11748813b10.jpeg)\n\n\n\n这个系列会回顾整理之前学习的内容，有序输出。算是对自己的一个交代，同时也希望，能帮助到那些想要学习 Metal 却不知道怎么下手的朋友。\n\n<!--more-->\n\n> 这系列文章，目前发布在我的小专栏 [iOS 图像处理](https://xiaozhuanlan.com/colin) 上。欢迎订阅~\n\n\n\n那么，**什么是 Metal** ？\n\n> Render advanced 3D graphics and perform data-parallel computations using the GPU.\n\n总结来说，**Metal 能让你尽可能的发挥 GPU 强大的渲染、运算的能力。**\n\n这里，我不做过多的阐述，如果你对图像处理，游戏编程感兴趣，又或者你只是认可这项技术，相信它是未来，值得投资学习。那么，我想这个系列不会让你失望。\n\n\n\n这个系列的文章，**是教程、实践，而不是文档**。\n\n我会尽可能，在实现功能的过程中，穿插介绍各个知识点。而不是一股脑的全部输出。\n\n不然可能看了四五篇，发现自己还是什么都做不了，还是不懂之前学到的具体是什么。\n\n然后，就不了了之了。\n\nMetal 系列的实战教程，会循序渐进，穿插详细介绍各个用到的 Metal 对象。\n\n由于 Metal（iOS 8 + A7），MetalKit（iOS 9 + A7）的软／硬件限制，以及不同读者的需求，之后的配套 Demo，会同时包含 iOS+Swift 和 macOS+ObjC 两种，文章以 iOS+Swift 进行演示。并且尽可能不用 MetalKit，功能都自己实现（避免一些实现细节被屏蔽了，以及降低系统版本限制）。当然，也会有专门的文章，介绍 MetalKit 相关。\n\n另外，每节 Demo 都有 start ／ end 两份代码，建议阅读完后，自己根据 start 基础工程，完成本节新的内容。该系列 Demo 主要是为了学习 Metal，所以一些语法特性，代码／文件结构，容错，封装等，不会去细究。\n\n每篇文章争取控制在 15 分钟的阅读量，细分知识点，便于随时阅读，学习。\n\n\n\n另外，之后的实战，会侧重于**图像处理**，比如**滤镜，画笔，马赛克，增高，相机，AR 贴图**等。开发过程中，也会结合系统的其他框架，比如 **Core Image、ARKit、Core ML、Vision** 等，做一些好玩的事情。\n\n> PS：\n> 订阅后的朋友，可以加我微信：wxidlongze，拉你进群。交流，扯淡，学习资源分享～\n>  最后，源码在小专栏中有链接～\n\n------\n\n\n## 目录\n\n### 基础概念：\n\n**[一。Metal 概述](https://xiaozhuanlan.com/topic/3420765198)**\n\n> Metal 是什么，Metal 能做什么，为什么要用 Metal。\n\n\n\n**[二。Metal 框架一览](https://xiaozhuanlan.com/topic/1287954630)**\n\n>Metal 进行图像处理的整体框架。宏观介绍渲染管线。\n\n\n\n### 基础实践：\n\n**[三。清屏](https://xiaozhuanlan.com/topic/9870134265)**\n\n> 最最最最简单的一个基础工程。介绍整体的显示渲染流程。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4677bca4a9633908b463e670646d434c.png)\n\n\n\n**[四。绘制一个三角形](https://xiaozhuanlan.com/topic/6503719284)**\n\n> 堪称图形界的 Hello World。会较为完整的过一遍渲染管线。\n>\n> 涉及的内容包括：**渲染管线的配置，着色器的编写，顶点数据的提交，图元的绘制**。\n>\n> 麻雀虽小，五脏俱全。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/68788a0103eac111ea445b0dcf02fa58.png)\n\n\n\n**[五。Buffer & Texture](https://xiaozhuanlan.com/topic/0459813726)**\n\n> 实现基础图像的渲染，即在屏幕上，显示一张我们指定的图片。主要关心非基础图元的绘制，Metal 里面的数据、资源的管理方式，图像解码的一些基础知识。介绍 MTLBuffer 以及 MTLTexture 相关内容。\n>\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ac2b226808a57f0acb725a46dde09759.png)\n\n\n\n**[六。GPUImage 3 浅析、基础框架搭建](https://xiaozhuanlan.com/topic/2514387096)**\n\n> 浅析一下 GPUImage 3 的设计，然后基于此，剥离出一些代码，形成基础框架，实现视图封装，也为之后的效果处理提供支持。\n\n![GPUImage](https://camo.githubusercontent.com/68ce8767f20b6a40f2a695c56396d30234363431/687474703a2f2f73756e7365746c616b65736f6674776172652e636f6d2f73697465732f64656661756c742f66696c65732f475055496d6167654c6f676f2e706e67)\n\n\n\n**[七。颜色滤镜](https://xiaozhuanlan.com/topic/3654810792)\u0010**\n\n> 介绍颜色滤镜常见的两种实现方式：**shader** 和 **lookup table**，并实现饱和度、亮度滤镜，以及常见的阿宝色滤镜。\n>\n> 同时会分析对应算法的原理。\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2019/f794ad7337d2885699c4d189694e7cf2.gif)\n\n\n\n\n\n**[八。风格化滤镜(上)](https://xiaozhuanlan.com/topic/3105827964)**\n\n> 上篇我们介绍了简单的颜色滤镜，即独立像素点变换，按照一定规律，修改当前像素点的色值。每个像素点都是独立的，不相互依赖。相对的，其他几类，我们可以统一归类为风格化滤镜，这类滤镜有一个显著的特点：当前点的最终色值，需要依赖其他位置点的色值，来共同决定。\n> 这一篇中，会介绍这么两个滤镜 Zoom Blur 和 Toon 的具体实现。\n>\n> 以及**系统提供的景深信息**等。\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2018/5d29ead45b570276f7bda57e2fb755df.gif)\n\n\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2018/20c51bfbfaaf5e981a0e77e89a121c45.png)\n\n\n\n\n\n**[九。风格化滤镜(下)](https://xiaozhuanlan.com/topic/5823149607)**\n\n> 介绍 Toon 效果的具体实现。\n> 介绍下更复杂的滤镜，比如之前很火的风格转换，以及借助 Core ML 模型的一些方式。\n>\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2018/93697319b46e0592ea443d7ecea200de.gif)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/e0c8acd368f9b02b24ad6e506dce3298.png)\n\n\n\n\n\n**[十。增高 & MTLHeap](https://xiaozhuanlan.com/topic/4896073512)**\n\n> MTLHeap：An abstract memory pool from which you can create resources.\n> 就是一块预先分配好的内存区域，然后这块区域用来干什么，完全是由开发者来控制的，可以随意复用。\n> 这次，我们同样是实现一个新的效果，增高。并分析使用 MTLHeap 带来的优势。\n>\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2019/1a826064d70d1c2ae4d9862a50f9e0ce.gif)\n\n\n\n\n\n\n\n**十一。抠图换背景 & Mask**\n\n> Mask 的使用场景，以及抠图换背景的具体实现。\n>\n\n\n\n![](https://diycode.b0.upaiyun.com/photo/2019/e8cd0d3fccd096ff5b6403a1319657e3.gif)\n\n\n\n...\n**To be continued ~**\n\n------\n\n> 这系列文章，目前发布在我的小专栏 [iOS 图像处理](https://xiaozhuanlan.com/colin) 上。欢迎订阅~","slug":"metal-tutorial","published":1,"updated":"2019-12-23T01:02:31.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1m20009zwlnhx70fn2e","content":"<p>从 2014 年，Apple 正式推出 Metal 到现在，这个 Metal 系列教程，酝酿了很久，却迟迟没有进展。</p>\n<p>直到 <strong>WWDC 2018，Apple 宣布 iOS 12 将弃用 OpenGL / CL</strong>，我想，这或许是个机会。</p>\n<blockquote>\n<p>Apps built using OpenGL ES will continue to run in iOS 12, but Open GL ES is deprecated in iOS 12. Games and graphics-intensive apps that previously used OpenGL ES should now adopt Metal.</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/de088c47205fd04fc8d9e11748813b10.jpeg\" alt=\"\"></p>\n<p>这个系列会回顾整理之前学习的内容，有序输出。算是对自己的一个交代，同时也希望，能帮助到那些想要学习 Metal 却不知道怎么下手的朋友。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>这系列文章，目前发布在我的小专栏 <a href=\"https://xiaozhuanlan.com/colin\" target=\"_blank\" rel=\"external\">iOS 图像处理</a> 上。欢迎订阅~</p>\n</blockquote>\n<p>那么，<strong>什么是 Metal</strong> ？</p>\n<blockquote>\n<p>Render advanced 3D graphics and perform data-parallel computations using the GPU.</p>\n</blockquote>\n<p>总结来说，<strong>Metal 能让你尽可能的发挥 GPU 强大的渲染、运算的能力。</strong></p>\n<p>这里，我不做过多的阐述，如果你对图像处理，游戏编程感兴趣，又或者你只是认可这项技术，相信它是未来，值得投资学习。那么，我想这个系列不会让你失望。</p>\n<p>这个系列的文章，<strong>是教程、实践，而不是文档</strong>。</p>\n<p>我会尽可能，在实现功能的过程中，穿插介绍各个知识点。而不是一股脑的全部输出。</p>\n<p>不然可能看了四五篇，发现自己还是什么都做不了，还是不懂之前学到的具体是什么。</p>\n<p>然后，就不了了之了。</p>\n<p>Metal 系列的实战教程，会循序渐进，穿插详细介绍各个用到的 Metal 对象。</p>\n<p>由于 Metal（iOS 8 + A7），MetalKit（iOS 9 + A7）的软／硬件限制，以及不同读者的需求，之后的配套 Demo，会同时包含 iOS+Swift 和 macOS+ObjC 两种，文章以 iOS+Swift 进行演示。并且尽可能不用 MetalKit，功能都自己实现（避免一些实现细节被屏蔽了，以及降低系统版本限制）。当然，也会有专门的文章，介绍 MetalKit 相关。</p>\n<p>另外，每节 Demo 都有 start ／ end 两份代码，建议阅读完后，自己根据 start 基础工程，完成本节新的内容。该系列 Demo 主要是为了学习 Metal，所以一些语法特性，代码／文件结构，容错，封装等，不会去细究。</p>\n<p>每篇文章争取控制在 15 分钟的阅读量，细分知识点，便于随时阅读，学习。</p>\n<p>另外，之后的实战，会侧重于<strong>图像处理</strong>，比如<strong>滤镜，画笔，马赛克，增高，相机，AR 贴图</strong>等。开发过程中，也会结合系统的其他框架，比如 <strong>Core Image、ARKit、Core ML、Vision</strong> 等，做一些好玩的事情。</p>\n<blockquote>\n<p>PS：<br>订阅后的朋友，可以加我微信：wxidlongze，拉你进群。交流，扯淡，学习资源分享～<br> 最后，源码在小专栏中有链接～</p>\n</blockquote>\n<hr>\n<h2 id=\"目录\">目录</h2><h3 id=\"基础概念：\">基础概念：</h3><p><strong><a href=\"https://xiaozhuanlan.com/topic/3420765198\" target=\"_blank\" rel=\"external\">一。Metal 概述</a></strong></p>\n<blockquote>\n<p>Metal 是什么，Metal 能做什么，为什么要用 Metal。</p>\n</blockquote>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/1287954630\" target=\"_blank\" rel=\"external\">二。Metal 框架一览</a></strong></p>\n<blockquote>\n<p>Metal 进行图像处理的整体框架。宏观介绍渲染管线。</p>\n</blockquote>\n<h3 id=\"基础实践：\">基础实践：</h3><p><strong><a href=\"https://xiaozhuanlan.com/topic/9870134265\" target=\"_blank\" rel=\"external\">三。清屏</a></strong></p>\n<blockquote>\n<p>最最最最简单的一个基础工程。介绍整体的显示渲染流程。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4677bca4a9633908b463e670646d434c.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/6503719284\" target=\"_blank\" rel=\"external\">四。绘制一个三角形</a></strong></p>\n<blockquote>\n<p>堪称图形界的 Hello World。会较为完整的过一遍渲染管线。</p>\n<p>涉及的内容包括：<strong>渲染管线的配置，着色器的编写，顶点数据的提交，图元的绘制</strong>。</p>\n<p>麻雀虽小，五脏俱全。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/68788a0103eac111ea445b0dcf02fa58.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/0459813726\" target=\"_blank\" rel=\"external\">五。Buffer &amp; Texture</a></strong></p>\n<blockquote>\n<p>实现基础图像的渲染，即在屏幕上，显示一张我们指定的图片。主要关心非基础图元的绘制，Metal 里面的数据、资源的管理方式，图像解码的一些基础知识。介绍 MTLBuffer 以及 MTLTexture 相关内容。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ac2b226808a57f0acb725a46dde09759.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/2514387096\" target=\"_blank\" rel=\"external\">六。GPUImage 3 浅析、基础框架搭建</a></strong></p>\n<blockquote>\n<p>浅析一下 GPUImage 3 的设计，然后基于此，剥离出一些代码，形成基础框架，实现视图封装，也为之后的效果处理提供支持。</p>\n</blockquote>\n<p><img src=\"https://camo.githubusercontent.com/68ce8767f20b6a40f2a695c56396d30234363431/687474703a2f2f73756e7365746c616b65736f6674776172652e636f6d2f73697465732f64656661756c742f66696c65732f475055496d6167654c6f676f2e706e67\" alt=\"GPUImage\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/3654810792\" target=\"_blank\" rel=\"external\">七。颜色滤镜</a>\u0010</strong></p>\n<blockquote>\n<p>介绍颜色滤镜常见的两种实现方式：<strong>shader</strong> 和 <strong>lookup table</strong>，并实现饱和度、亮度滤镜，以及常见的阿宝色滤镜。</p>\n<p>同时会分析对应算法的原理。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2019/f794ad7337d2885699c4d189694e7cf2.gif\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/3105827964\" target=\"_blank\" rel=\"external\">八。风格化滤镜(上)</a></strong></p>\n<blockquote>\n<p>上篇我们介绍了简单的颜色滤镜，即独立像素点变换，按照一定规律，修改当前像素点的色值。每个像素点都是独立的，不相互依赖。相对的，其他几类，我们可以统一归类为风格化滤镜，这类滤镜有一个显著的特点：当前点的最终色值，需要依赖其他位置点的色值，来共同决定。<br>这一篇中，会介绍这么两个滤镜 Zoom Blur 和 Toon 的具体实现。</p>\n<p>以及<strong>系统提供的景深信息</strong>等。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5d29ead45b570276f7bda57e2fb755df.gif\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/20c51bfbfaaf5e981a0e77e89a121c45.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/5823149607\" target=\"_blank\" rel=\"external\">九。风格化滤镜(下)</a></strong></p>\n<blockquote>\n<p>介绍 Toon 效果的具体实现。<br>介绍下更复杂的滤镜，比如之前很火的风格转换，以及借助 Core ML 模型的一些方式。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/93697319b46e0592ea443d7ecea200de.gif\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e0c8acd368f9b02b24ad6e506dce3298.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/4896073512\" target=\"_blank\" rel=\"external\">十。增高 &amp; MTLHeap</a></strong></p>\n<blockquote>\n<p>MTLHeap：An abstract memory pool from which you can create resources.<br>就是一块预先分配好的内存区域，然后这块区域用来干什么，完全是由开发者来控制的，可以随意复用。<br>这次，我们同样是实现一个新的效果，增高。并分析使用 MTLHeap 带来的优势。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2019/1a826064d70d1c2ae4d9862a50f9e0ce.gif\" alt=\"\"></p>\n<p><strong>十一。抠图换背景 &amp; Mask</strong></p>\n<blockquote>\n<p>Mask 的使用场景，以及抠图换背景的具体实现。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2019/e8cd0d3fccd096ff5b6403a1319657e3.gif\" alt=\"\"></p>\n<p>…<br><strong>To be continued ~</strong></p>\n<hr>\n<blockquote>\n<p>这系列文章，目前发布在我的小专栏 <a href=\"https://xiaozhuanlan.com/colin\" target=\"_blank\" rel=\"external\">iOS 图像处理</a> 上。欢迎订阅~</p>\n</blockquote>\n","excerpt":"<p>从 2014 年，Apple 正式推出 Metal 到现在，这个 Metal 系列教程，酝酿了很久，却迟迟没有进展。</p>\n<p>直到 <strong>WWDC 2018，Apple 宣布 iOS 12 将弃用 OpenGL / CL</strong>，我想，这或许是个机会。</p>\n<blockquote>\n<p>Apps built using OpenGL ES will continue to run in iOS 12, but Open GL ES is deprecated in iOS 12. Games and graphics-intensive apps that previously used OpenGL ES should now adopt Metal.</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/de088c47205fd04fc8d9e11748813b10.jpeg\" alt=\"\"></p>\n<p>这个系列会回顾整理之前学习的内容，有序输出。算是对自己的一个交代，同时也希望，能帮助到那些想要学习 Metal 却不知道怎么下手的朋友。</p>","more":"<blockquote>\n<p>这系列文章，目前发布在我的小专栏 <a href=\"https://xiaozhuanlan.com/colin\">iOS 图像处理</a> 上。欢迎订阅~</p>\n</blockquote>\n<p>那么，<strong>什么是 Metal</strong> ？</p>\n<blockquote>\n<p>Render advanced 3D graphics and perform data-parallel computations using the GPU.</p>\n</blockquote>\n<p>总结来说，<strong>Metal 能让你尽可能的发挥 GPU 强大的渲染、运算的能力。</strong></p>\n<p>这里，我不做过多的阐述，如果你对图像处理，游戏编程感兴趣，又或者你只是认可这项技术，相信它是未来，值得投资学习。那么，我想这个系列不会让你失望。</p>\n<p>这个系列的文章，<strong>是教程、实践，而不是文档</strong>。</p>\n<p>我会尽可能，在实现功能的过程中，穿插介绍各个知识点。而不是一股脑的全部输出。</p>\n<p>不然可能看了四五篇，发现自己还是什么都做不了，还是不懂之前学到的具体是什么。</p>\n<p>然后，就不了了之了。</p>\n<p>Metal 系列的实战教程，会循序渐进，穿插详细介绍各个用到的 Metal 对象。</p>\n<p>由于 Metal（iOS 8 + A7），MetalKit（iOS 9 + A7）的软／硬件限制，以及不同读者的需求，之后的配套 Demo，会同时包含 iOS+Swift 和 macOS+ObjC 两种，文章以 iOS+Swift 进行演示。并且尽可能不用 MetalKit，功能都自己实现（避免一些实现细节被屏蔽了，以及降低系统版本限制）。当然，也会有专门的文章，介绍 MetalKit 相关。</p>\n<p>另外，每节 Demo 都有 start ／ end 两份代码，建议阅读完后，自己根据 start 基础工程，完成本节新的内容。该系列 Demo 主要是为了学习 Metal，所以一些语法特性，代码／文件结构，容错，封装等，不会去细究。</p>\n<p>每篇文章争取控制在 15 分钟的阅读量，细分知识点，便于随时阅读，学习。</p>\n<p>另外，之后的实战，会侧重于<strong>图像处理</strong>，比如<strong>滤镜，画笔，马赛克，增高，相机，AR 贴图</strong>等。开发过程中，也会结合系统的其他框架，比如 <strong>Core Image、ARKit、Core ML、Vision</strong> 等，做一些好玩的事情。</p>\n<blockquote>\n<p>PS：<br>订阅后的朋友，可以加我微信：wxidlongze，拉你进群。交流，扯淡，学习资源分享～<br> 最后，源码在小专栏中有链接～</p>\n</blockquote>\n<hr>\n<h2 id=\"目录\">目录</h2><h3 id=\"基础概念：\">基础概念：</h3><p><strong><a href=\"https://xiaozhuanlan.com/topic/3420765198\">一。Metal 概述</a></strong></p>\n<blockquote>\n<p>Metal 是什么，Metal 能做什么，为什么要用 Metal。</p>\n</blockquote>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/1287954630\">二。Metal 框架一览</a></strong></p>\n<blockquote>\n<p>Metal 进行图像处理的整体框架。宏观介绍渲染管线。</p>\n</blockquote>\n<h3 id=\"基础实践：\">基础实践：</h3><p><strong><a href=\"https://xiaozhuanlan.com/topic/9870134265\">三。清屏</a></strong></p>\n<blockquote>\n<p>最最最最简单的一个基础工程。介绍整体的显示渲染流程。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4677bca4a9633908b463e670646d434c.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/6503719284\">四。绘制一个三角形</a></strong></p>\n<blockquote>\n<p>堪称图形界的 Hello World。会较为完整的过一遍渲染管线。</p>\n<p>涉及的内容包括：<strong>渲染管线的配置，着色器的编写，顶点数据的提交，图元的绘制</strong>。</p>\n<p>麻雀虽小，五脏俱全。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/68788a0103eac111ea445b0dcf02fa58.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/0459813726\">五。Buffer &amp; Texture</a></strong></p>\n<blockquote>\n<p>实现基础图像的渲染，即在屏幕上，显示一张我们指定的图片。主要关心非基础图元的绘制，Metal 里面的数据、资源的管理方式，图像解码的一些基础知识。介绍 MTLBuffer 以及 MTLTexture 相关内容。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ac2b226808a57f0acb725a46dde09759.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/2514387096\">六。GPUImage 3 浅析、基础框架搭建</a></strong></p>\n<blockquote>\n<p>浅析一下 GPUImage 3 的设计，然后基于此，剥离出一些代码，形成基础框架，实现视图封装，也为之后的效果处理提供支持。</p>\n</blockquote>\n<p><img src=\"https://camo.githubusercontent.com/68ce8767f20b6a40f2a695c56396d30234363431/687474703a2f2f73756e7365746c616b65736f6674776172652e636f6d2f73697465732f64656661756c742f66696c65732f475055496d6167654c6f676f2e706e67\" alt=\"GPUImage\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/3654810792\">七。颜色滤镜</a>\u0010</strong></p>\n<blockquote>\n<p>介绍颜色滤镜常见的两种实现方式：<strong>shader</strong> 和 <strong>lookup table</strong>，并实现饱和度、亮度滤镜，以及常见的阿宝色滤镜。</p>\n<p>同时会分析对应算法的原理。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2019/f794ad7337d2885699c4d189694e7cf2.gif\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/3105827964\">八。风格化滤镜(上)</a></strong></p>\n<blockquote>\n<p>上篇我们介绍了简单的颜色滤镜，即独立像素点变换，按照一定规律，修改当前像素点的色值。每个像素点都是独立的，不相互依赖。相对的，其他几类，我们可以统一归类为风格化滤镜，这类滤镜有一个显著的特点：当前点的最终色值，需要依赖其他位置点的色值，来共同决定。<br>这一篇中，会介绍这么两个滤镜 Zoom Blur 和 Toon 的具体实现。</p>\n<p>以及<strong>系统提供的景深信息</strong>等。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5d29ead45b570276f7bda57e2fb755df.gif\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/20c51bfbfaaf5e981a0e77e89a121c45.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/5823149607\">九。风格化滤镜(下)</a></strong></p>\n<blockquote>\n<p>介绍 Toon 效果的具体实现。<br>介绍下更复杂的滤镜，比如之前很火的风格转换，以及借助 Core ML 模型的一些方式。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/93697319b46e0592ea443d7ecea200de.gif\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e0c8acd368f9b02b24ad6e506dce3298.png\" alt=\"\"></p>\n<p><strong><a href=\"https://xiaozhuanlan.com/topic/4896073512\">十。增高 &amp; MTLHeap</a></strong></p>\n<blockquote>\n<p>MTLHeap：An abstract memory pool from which you can create resources.<br>就是一块预先分配好的内存区域，然后这块区域用来干什么，完全是由开发者来控制的，可以随意复用。<br>这次，我们同样是实现一个新的效果，增高。并分析使用 MTLHeap 带来的优势。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2019/1a826064d70d1c2ae4d9862a50f9e0ce.gif\" alt=\"\"></p>\n<p><strong>十一。抠图换背景 &amp; Mask</strong></p>\n<blockquote>\n<p>Mask 的使用场景，以及抠图换背景的具体实现。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2019/e8cd0d3fccd096ff5b6403a1319657e3.gif\" alt=\"\"></p>\n<p>…<br><strong>To be continued ~</strong></p>\n<hr>\n<blockquote>\n<p>这系列文章，目前发布在我的小专栏 <a href=\"https://xiaozhuanlan.com/colin\">iOS 图像处理</a> 上。欢迎订阅~</p>\n</blockquote>"},{"layout":"iOS开发小记","title":"iOS启动页多语言","date":"2016-03-12T09:06:29.000Z","_content":"\n>  启动页适配多语言, 想必很多 App 都有类似的需求。但是之前尝试过程中, 发现  “多语言” 的那几种实现方式, 在欢迎页上都不适应, 直到遇到了 `UILaunchImages` ~ 下文将详细描述如何实现启动页多语言。\n\n<!--more-->\n\n## 传统多语言设置\n\n说起多语言, 我们无非这样实现:\n\n1. 为 App 添加多语言支持。![LaunchImages_0](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_0.png)\n   \n2. 添加对应的配置, 资源。 比如：\n   \n   文本: ![LaunchImages_1](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_1.png)\n   \n   图片:![LaunchImages_2](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_2.png)\n   \n3. 使用对应资源, 比如:\n   \n   ``` objc\n   label.text = NSLocalizedString(@\"多语言\", nil);\n   ```\n\n\n\n再麻烦一点, 就是xib, storyboard的多语言的。 但是原理一样, 这样的方式都能实现多语言支持。So, 就是这么简单~\n\n![emoji](http://wanzao2.b0.upaiyun.com/system/pictures/181/original/%E5%BC%80%E5%BF%8309.png)\n\n 然而, 启动页貌似不吃这套 ,,,\n\n\n\n## 启动页设置\n\n先说说我们如何设置启动页吧。\n\n`Assets.xcassets` 这玩意引入之前, 我们是对启动页图片按规范命名, 比如 Default, -568h, @2x, @3x 之类的, 让系统帮助我们自动判断对应的启动页图片。\n\n`Assets.xcassets` 之后, 我们都了一种选择, 可以直接拖拽图片到 `LaunchImage` 中, 并且图片命名也没那么多要求。\n\n![LaunchImage_3](http://upload-images.jianshu.io/upload_images/262538-a84f9bece1aa8b37.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg)\n\n\n\n再之后, 多了 `LaunchScreen.storyboard` , 意味着我们有了更多的选择, 可以做更多的事情, 把它当做一个xib, 拖拽相关控件上去就好~\n\n\n\n方式很多, 是否意味着实现多语言的办法也很多 ?\n\n然而并不是,, ![emoji](http://wanzao2.b0.upaiyun.com/system/pictures/283/original/%E7%94%9F%E6%B0%9411.png)\n\n\n\n不论是对` 图片` 进行多语言, 还是 `LaunchScreen.storyboard` 多语言, 发现启动页始终没有跟着系统语言变, 血崩..\n\n\n\n当然, 办法并不是没有, 只是没找到对的而已~ 下面介绍如何通过`UILaunchImages` 实现启动页多语言。\n\n> PS: 感觉 LaunchScreen.storyboard 是能做到多语言支持的, 难道是我实现过程中有问题 ? \n\n\n\n## UILaunchImages\n\n先看一下官方文档:\n\n\n\n> UILaunchImages (Array - iOS) Explicitly specifies the launch images to use for the app. This key contains an array of dictionaries. Each dictionary contains detailed information about a single launch image and how it is used. Xcode fills in the value of each dictionary based on information you provide in your project settings.\n\n显然, 我们可以通过设置 `UILaunchImages` 来配置启动图片。\n\n至于 `UILaunchImages` 的几个 Key , 简单描述如下: \n\n- `UILaunchImageName` (required) 启动页资源名称\n  \n- `UILaunchImageMinimumOSVersion`(required) 启动页支持的最低版本\n  \n- `UILaunchImageSize` 启动页尺寸\n  \n- `UILaunchImageOrientation` 启动页方向\n  \n  ​\n\n代表什么, 都比较简单, 具体可以参考官方文档~ [  [UILaunchImages](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW28) ]\n\n用这种方式配置启动页也十分简单, 具体步骤:\n\n1. 取消启动页使用的 Asset Catalog\n   \n   ![](http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImages%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-12%20%E4%B8%8B%E5%8D%884.44.06.png)\n   \n2. 在Info.plist 中添加UILaunchImages项\n   \n   ``` xml\n   <key>UILaunchImages</key>\n           <array>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>7.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{320, 480}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage-568h</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>7.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{320, 568}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage-667h</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>8.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{375, 667}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage-736h</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>8.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{414, 736}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n           </array>\n   ```\n   \n   ![](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_4.png)\n   \n3. 添加对应的启动页资源\n   \n   ![](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_3.png)\n   \n   ​\n\n\n\n如此, 即可完成 启动页 多语言的适配, 不信你就试试呗~ \n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/270/original/%E5%BE%97%E7%91%9F10.png)\n\n\n\n> PS: 这里, 说明一点。 启动页只会保留一份, 也就是说, 你第一次加载完以后, 切换了语言, 再重新打开App, 它的启动页不会跟着更新的。 这也符合苹果的用户交互指引。\n> \n> 如果你想要动态修改启动页面图LaunchImage, 抱歉！**根据苹果的用户交互指引,该页面是在程序加载时显示的,不建议动态修改.**\n> \n> 正确的做法一般都是用固定的图片做启动页面图,在启动页面结束之后做任何你想做的事.\n> \n> 如果真想动态修改启动页面,启动页面是固定的名字,可以在程序执行之后强制把页面替换掉,不过这样APP可能会被拒.\n> \n> 该怎么设置一个动态的启动图呢？在启动图结束的时候，用一个View来展示你的动图，记得placeHolder设置为和你的LaunchImage的图片一样就行，这样就可以做出类似的效果了","source":"_posts/iOS-welcome-page-multilingual.md","raw":"layout: \"iOS开发小记\"\n\ntitle: iOS启动页多语言\n\ndate: 2016-03-12 17:06:29\n\ntags:\n\n- iOS开发\n- 教程\n\n------\n\n>  启动页适配多语言, 想必很多 App 都有类似的需求。但是之前尝试过程中, 发现  “多语言” 的那几种实现方式, 在欢迎页上都不适应, 直到遇到了 `UILaunchImages` ~ 下文将详细描述如何实现启动页多语言。\n\n<!--more-->\n\n## 传统多语言设置\n\n说起多语言, 我们无非这样实现:\n\n1. 为 App 添加多语言支持。![LaunchImages_0](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_0.png)\n   \n2. 添加对应的配置, 资源。 比如：\n   \n   文本: ![LaunchImages_1](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_1.png)\n   \n   图片:![LaunchImages_2](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_2.png)\n   \n3. 使用对应资源, 比如:\n   \n   ``` objc\n   label.text = NSLocalizedString(@\"多语言\", nil);\n   ```\n\n\n\n再麻烦一点, 就是xib, storyboard的多语言的。 但是原理一样, 这样的方式都能实现多语言支持。So, 就是这么简单~\n\n![emoji](http://wanzao2.b0.upaiyun.com/system/pictures/181/original/%E5%BC%80%E5%BF%8309.png)\n\n 然而, 启动页貌似不吃这套 ,,,\n\n\n\n## 启动页设置\n\n先说说我们如何设置启动页吧。\n\n`Assets.xcassets` 这玩意引入之前, 我们是对启动页图片按规范命名, 比如 Default, -568h, @2x, @3x 之类的, 让系统帮助我们自动判断对应的启动页图片。\n\n`Assets.xcassets` 之后, 我们都了一种选择, 可以直接拖拽图片到 `LaunchImage` 中, 并且图片命名也没那么多要求。\n\n![LaunchImage_3](http://upload-images.jianshu.io/upload_images/262538-a84f9bece1aa8b37.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg)\n\n\n\n再之后, 多了 `LaunchScreen.storyboard` , 意味着我们有了更多的选择, 可以做更多的事情, 把它当做一个xib, 拖拽相关控件上去就好~\n\n\n\n方式很多, 是否意味着实现多语言的办法也很多 ?\n\n然而并不是,, ![emoji](http://wanzao2.b0.upaiyun.com/system/pictures/283/original/%E7%94%9F%E6%B0%9411.png)\n\n\n\n不论是对` 图片` 进行多语言, 还是 `LaunchScreen.storyboard` 多语言, 发现启动页始终没有跟着系统语言变, 血崩..\n\n\n\n当然, 办法并不是没有, 只是没找到对的而已~ 下面介绍如何通过`UILaunchImages` 实现启动页多语言。\n\n> PS: 感觉 LaunchScreen.storyboard 是能做到多语言支持的, 难道是我实现过程中有问题 ? \n\n\n\n## UILaunchImages\n\n先看一下官方文档:\n\n\n\n> UILaunchImages (Array - iOS) Explicitly specifies the launch images to use for the app. This key contains an array of dictionaries. Each dictionary contains detailed information about a single launch image and how it is used. Xcode fills in the value of each dictionary based on information you provide in your project settings.\n\n显然, 我们可以通过设置 `UILaunchImages` 来配置启动图片。\n\n至于 `UILaunchImages` 的几个 Key , 简单描述如下: \n\n- `UILaunchImageName` (required) 启动页资源名称\n  \n- `UILaunchImageMinimumOSVersion`(required) 启动页支持的最低版本\n  \n- `UILaunchImageSize` 启动页尺寸\n  \n- `UILaunchImageOrientation` 启动页方向\n  \n  ​\n\n代表什么, 都比较简单, 具体可以参考官方文档~ [  [UILaunchImages](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW28) ]\n\n用这种方式配置启动页也十分简单, 具体步骤:\n\n1. 取消启动页使用的 Asset Catalog\n   \n   ![](http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImages%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-12%20%E4%B8%8B%E5%8D%884.44.06.png)\n   \n2. 在Info.plist 中添加UILaunchImages项\n   \n   ``` xml\n   <key>UILaunchImages</key>\n           <array>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>7.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{320, 480}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage-568h</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>7.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{320, 568}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage-667h</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>8.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{375, 667}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n               <dict>\n                   <key>UILaunchImageName</key>\n                   <string>LaunchImage-736h</string>\n                   <key>UILaunchImageMinimumOSVersion</key>\n                   <string>8.0</string>\n                   <key>UILaunchImageSize</key>\n                   <string>{414, 736}</string>\n                   <key>UILaunchImageOrientation</key>\n                   <string>Portrait</string>\n               </dict>\n           </array>\n   ```\n   \n   ![](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_4.png)\n   \n3. 添加对应的启动页资源\n   \n   ![](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_3.png)\n   \n   ​\n\n\n\n如此, 即可完成 启动页 多语言的适配, 不信你就试试呗~ \n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/270/original/%E5%BE%97%E7%91%9F10.png)\n\n\n\n> PS: 这里, 说明一点。 启动页只会保留一份, 也就是说, 你第一次加载完以后, 切换了语言, 再重新打开App, 它的启动页不会跟着更新的。 这也符合苹果的用户交互指引。\n> \n> 如果你想要动态修改启动页面图LaunchImage, 抱歉！**根据苹果的用户交互指引,该页面是在程序加载时显示的,不建议动态修改.**\n> \n> 正确的做法一般都是用固定的图片做启动页面图,在启动页面结束之后做任何你想做的事.\n> \n> 如果真想动态修改启动页面,启动页面是固定的名字,可以在程序执行之后强制把页面替换掉,不过这样APP可能会被拒.\n> \n> 该怎么设置一个动态的启动图呢？在启动图结束的时候，用一个View来展示你的动图，记得placeHolder设置为和你的LaunchImage的图片一样就行，这样就可以做出类似的效果了","slug":"iOS-welcome-page-multilingual","published":1,"updated":"2019-12-23T01:02:31.290Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1m3000azwlnd4hb9n5h","content":"<blockquote>\n<p> 启动页适配多语言, 想必很多 App 都有类似的需求。但是之前尝试过程中, 发现  “多语言” 的那几种实现方式, 在欢迎页上都不适应, 直到遇到了 <code>UILaunchImages</code> ~ 下文将详细描述如何实现启动页多语言。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"传统多语言设置\">传统多语言设置</h2><p>说起多语言, 我们无非这样实现:</p>\n<ol>\n<li><p>为 App 添加多语言支持。<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_0.png\" alt=\"LaunchImages_0\"></p>\n</li>\n<li><p>添加对应的配置, 资源。 比如：</p>\n<p>文本: <img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_1.png\" alt=\"LaunchImages_1\"></p>\n<p>图片:<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_2.png\" alt=\"LaunchImages_2\"></p>\n</li>\n<li><p>使用对应资源, 比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label.text = <span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"多语言\"</span>, <span class=\"literal\">nil</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>再麻烦一点, 就是xib, storyboard的多语言的。 但是原理一样, 这样的方式都能实现多语言支持。So, 就是这么简单~</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/181/original/%E5%BC%80%E5%BF%8309.png\" alt=\"emoji\"></p>\n<p> 然而, 启动页貌似不吃这套 ,,,</p>\n<h2 id=\"启动页设置\">启动页设置</h2><p>先说说我们如何设置启动页吧。</p>\n<p><code>Assets.xcassets</code> 这玩意引入之前, 我们是对启动页图片按规范命名, 比如 Default, -568h, @2x, @3x 之类的, 让系统帮助我们自动判断对应的启动页图片。</p>\n<p><code>Assets.xcassets</code> 之后, 我们都了一种选择, 可以直接拖拽图片到 <code>LaunchImage</code> 中, 并且图片命名也没那么多要求。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/262538-a84f9bece1aa8b37.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg\" alt=\"LaunchImage_3\"></p>\n<p>再之后, 多了 <code>LaunchScreen.storyboard</code> , 意味着我们有了更多的选择, 可以做更多的事情, 把它当做一个xib, 拖拽相关控件上去就好~</p>\n<p>方式很多, 是否意味着实现多语言的办法也很多 ?</p>\n<p>然而并不是,, <img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/283/original/%E7%94%9F%E6%B0%9411.png\" alt=\"emoji\"></p>\n<p>不论是对<code>图片</code> 进行多语言, 还是 <code>LaunchScreen.storyboard</code> 多语言, 发现启动页始终没有跟着系统语言变, 血崩..</p>\n<p>当然, 办法并不是没有, 只是没找到对的而已~ 下面介绍如何通过<code>UILaunchImages</code> 实现启动页多语言。</p>\n<blockquote>\n<p>PS: 感觉 LaunchScreen.storyboard 是能做到多语言支持的, 难道是我实现过程中有问题 ? </p>\n</blockquote>\n<h2 id=\"UILaunchImages\">UILaunchImages</h2><p>先看一下官方文档:</p>\n<blockquote>\n<p>UILaunchImages (Array - iOS) Explicitly specifies the launch images to use for the app. This key contains an array of dictionaries. Each dictionary contains detailed information about a single launch image and how it is used. Xcode fills in the value of each dictionary based on information you provide in your project settings.</p>\n</blockquote>\n<p>显然, 我们可以通过设置 <code>UILaunchImages</code> 来配置启动图片。</p>\n<p>至于 <code>UILaunchImages</code> 的几个 Key , 简单描述如下: </p>\n<ul>\n<li><p><code>UILaunchImageName</code> (required) 启动页资源名称</p>\n</li>\n<li><p><code>UILaunchImageMinimumOSVersion</code>(required) 启动页支持的最低版本</p>\n</li>\n<li><p><code>UILaunchImageSize</code> 启动页尺寸</p>\n</li>\n<li><p><code>UILaunchImageOrientation</code> 启动页方向</p>\n<p>​</p>\n</li>\n</ul>\n<p>代表什么, 都比较简单, 具体可以参考官方文档~ [  <a href=\"https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW28\" target=\"_blank\" rel=\"external\">UILaunchImages</a> ]</p>\n<p>用这种方式配置启动页也十分简单, 具体步骤:</p>\n<ol>\n<li><p>取消启动页使用的 Asset Catalog</p>\n<p><img src=\"http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImages%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-12%20%E4%B8%8B%E5%8D%884.44.06.png\" alt=\"\"></p>\n</li>\n<li><p>在Info.plist 中添加UILaunchImages项</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImages<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>7.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;320, 480&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage-568h<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>7.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;320, 568&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage-667h<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>8.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;375, 667&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage-736h<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>8.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;414, 736&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   <img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_4.png\" alt=\"\"></p>\n<ol>\n<li><p>添加对应的启动页资源</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_3.png\" alt=\"\"></p>\n<p>​</p>\n</li>\n</ol>\n<p>如此, 即可完成 启动页 多语言的适配, 不信你就试试呗~ </p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/270/original/%E5%BE%97%E7%91%9F10.png\" alt=\"\"></p>\n<blockquote>\n<p>PS: 这里, 说明一点。 启动页只会保留一份, 也就是说, 你第一次加载完以后, 切换了语言, 再重新打开App, 它的启动页不会跟着更新的。 这也符合苹果的用户交互指引。</p>\n<p>如果你想要动态修改启动页面图LaunchImage, 抱歉！<strong>根据苹果的用户交互指引,该页面是在程序加载时显示的,不建议动态修改.</strong></p>\n<p>正确的做法一般都是用固定的图片做启动页面图,在启动页面结束之后做任何你想做的事.</p>\n<p>如果真想动态修改启动页面,启动页面是固定的名字,可以在程序执行之后强制把页面替换掉,不过这样APP可能会被拒.</p>\n<p>该怎么设置一个动态的启动图呢？在启动图结束的时候，用一个View来展示你的动图，记得placeHolder设置为和你的LaunchImage的图片一样就行，这样就可以做出类似的效果了</p>\n</blockquote>\n","excerpt":"<blockquote>\n<p> 启动页适配多语言, 想必很多 App 都有类似的需求。但是之前尝试过程中, 发现  “多语言” 的那几种实现方式, 在欢迎页上都不适应, 直到遇到了 <code>UILaunchImages</code> ~ 下文将详细描述如何实现启动页多语言。</p>\n</blockquote>","more":"<h2 id=\"传统多语言设置\">传统多语言设置</h2><p>说起多语言, 我们无非这样实现:</p>\n<ol>\n<li><p>为 App 添加多语言支持。<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_0.png\" alt=\"LaunchImages_0\"></p>\n</li>\n<li><p>添加对应的配置, 资源。 比如：</p>\n<p>文本: <img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_1.png\" alt=\"LaunchImages_1\"></p>\n<p>图片:<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_2.png\" alt=\"LaunchImages_2\"></p>\n</li>\n<li><p>使用对应资源, 比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label.text = <span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"多语言\"</span>, <span class=\"literal\">nil</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>再麻烦一点, 就是xib, storyboard的多语言的。 但是原理一样, 这样的方式都能实现多语言支持。So, 就是这么简单~</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/181/original/%E5%BC%80%E5%BF%8309.png\" alt=\"emoji\"></p>\n<p> 然而, 启动页貌似不吃这套 ,,,</p>\n<h2 id=\"启动页设置\">启动页设置</h2><p>先说说我们如何设置启动页吧。</p>\n<p><code>Assets.xcassets</code> 这玩意引入之前, 我们是对启动页图片按规范命名, 比如 Default, -568h, @2x, @3x 之类的, 让系统帮助我们自动判断对应的启动页图片。</p>\n<p><code>Assets.xcassets</code> 之后, 我们都了一种选择, 可以直接拖拽图片到 <code>LaunchImage</code> 中, 并且图片命名也没那么多要求。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/262538-a84f9bece1aa8b37.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg\" alt=\"LaunchImage_3\"></p>\n<p>再之后, 多了 <code>LaunchScreen.storyboard</code> , 意味着我们有了更多的选择, 可以做更多的事情, 把它当做一个xib, 拖拽相关控件上去就好~</p>\n<p>方式很多, 是否意味着实现多语言的办法也很多 ?</p>\n<p>然而并不是,, <img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/283/original/%E7%94%9F%E6%B0%9411.png\" alt=\"emoji\"></p>\n<p>不论是对<code>图片</code> 进行多语言, 还是 <code>LaunchScreen.storyboard</code> 多语言, 发现启动页始终没有跟着系统语言变, 血崩..</p>\n<p>当然, 办法并不是没有, 只是没找到对的而已~ 下面介绍如何通过<code>UILaunchImages</code> 实现启动页多语言。</p>\n<blockquote>\n<p>PS: 感觉 LaunchScreen.storyboard 是能做到多语言支持的, 难道是我实现过程中有问题 ? </p>\n</blockquote>\n<h2 id=\"UILaunchImages\">UILaunchImages</h2><p>先看一下官方文档:</p>\n<blockquote>\n<p>UILaunchImages (Array - iOS) Explicitly specifies the launch images to use for the app. This key contains an array of dictionaries. Each dictionary contains detailed information about a single launch image and how it is used. Xcode fills in the value of each dictionary based on information you provide in your project settings.</p>\n</blockquote>\n<p>显然, 我们可以通过设置 <code>UILaunchImages</code> 来配置启动图片。</p>\n<p>至于 <code>UILaunchImages</code> 的几个 Key , 简单描述如下: </p>\n<ul>\n<li><p><code>UILaunchImageName</code> (required) 启动页资源名称</p>\n</li>\n<li><p><code>UILaunchImageMinimumOSVersion</code>(required) 启动页支持的最低版本</p>\n</li>\n<li><p><code>UILaunchImageSize</code> 启动页尺寸</p>\n</li>\n<li><p><code>UILaunchImageOrientation</code> 启动页方向</p>\n<p>​</p>\n</li>\n</ul>\n<p>代表什么, 都比较简单, 具体可以参考官方文档~ [  <a href=\"https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW28\">UILaunchImages</a> ]</p>\n<p>用这种方式配置启动页也十分简单, 具体步骤:</p>\n<ol>\n<li><p>取消启动页使用的 Asset Catalog</p>\n<p><img src=\"http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImages%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-12%20%E4%B8%8B%E5%8D%884.44.06.png\" alt=\"\"></p>\n</li>\n<li><p>在Info.plist 中添加UILaunchImages项</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImages<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>7.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;320, 480&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage-568h<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>7.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;320, 568&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage-667h<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>8.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;375, 667&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>LaunchImage-736h<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>8.0<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageSize<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>&#123;414, 736&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UILaunchImageOrientation<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Portrait<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   <img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_4.png\" alt=\"\"></p>\n<ol>\n<li><p>添加对应的启动页资源</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/LaunchImage/LaunchImagesLaunchImages_3.png\" alt=\"\"></p>\n<p>​</p>\n</li>\n</ol>\n<p>如此, 即可完成 启动页 多语言的适配, 不信你就试试呗~ </p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/270/original/%E5%BE%97%E7%91%9F10.png\" alt=\"\"></p>\n<blockquote>\n<p>PS: 这里, 说明一点。 启动页只会保留一份, 也就是说, 你第一次加载完以后, 切换了语言, 再重新打开App, 它的启动页不会跟着更新的。 这也符合苹果的用户交互指引。</p>\n<p>如果你想要动态修改启动页面图LaunchImage, 抱歉！<strong>根据苹果的用户交互指引,该页面是在程序加载时显示的,不建议动态修改.</strong></p>\n<p>正确的做法一般都是用固定的图片做启动页面图,在启动页面结束之后做任何你想做的事.</p>\n<p>如果真想动态修改启动页面,启动页面是固定的名字,可以在程序执行之后强制把页面替换掉,不过这样APP可能会被拒.</p>\n<p>该怎么设置一个动态的启动图呢？在启动图结束的时候，用一个View来展示你的动图，记得placeHolder设置为和你的LaunchImage的图片一样就行，这样就可以做出类似的效果了</p>\n</blockquote>"},{"title":"Call Directory Extension 初探","date":"2016-06-17T14:33:15.000Z","_content":"\n> iOS 10中引入了许多令人振奋的新特性，其中 CallKit让我特别感兴趣。这是一个非常重要的 API，继2014年苹果推出 VoIP证书后，这次 VoIP 接口的开放，以及一个全新的 App Extension，简直是VOIP的福音，可见苹果对VOIP的重视。并且，**”that enable call blocking and caller identification. You can create an app extension that can associate a phone number with a name or tell the system when a number should be blocked.”** 这意味着现在可以通过 Call Directory Extension 来实现电话黑名单功能了。Cool~ 本文简单阐述了如果实现简单的来电黑名单功能。\n\n\n\n**阅读须知：目前学习的资料也仅限相关 API，另外 API也没有详细的注释，所以本文主要是个人探索所得，如果有什么错误，还望见谅并予以指正。现在，让我们开始吧~**\n\n<!--more-->\n\n## API介绍\n\n**Extension** 一直给我的印象就是很轻量，单一的，就如之前接触的  [Photo Editing Extension](http://colin1994.github.io/2016/03/12/Photo-Editing-Extension/) 一样，使用起来十分简单。这次的 **Call Directory Extension** 也不出例外，出奇的简单。只涉及了两个类，四个方法。下面我们逐一介绍：\n\n```swift\n//\n//  CXCallDirectoryProvider.h\n//  CallKit\n//\n//  Copyright © 2016 Apple. All rights reserved.\n//\n\n@available(iOS 10.0, *)\npublic class CXCallDirectoryProvider : NSObject, NSExtensionRequestHandling {\n\n    public func beginRequest(with context: CXCallDirectoryExtensionContext)\n}\n```\n\n首先是第一个类 **CXCallDirectoryProvider**，它是来电的响应者，为我们提供了 **beginRequest** 方法，该方法在 Containing App 调用 reload 或者在 设置 —> 电话 —> Call Blocking & Identification里开启权限的时候，会自动被调用。所以我们之后将要重写它，来实现黑名单相关逻辑。怎么样，简单吧~ ![emoji_1](http://wanzao2.b0.upaiyun.com/system/pictures/2/original/21.png)\n\nNow, Go on~\n\n接下来是另外一个类 **CXCallDirectoryExtensionContext**，它提供了另外三个方法，如下所示：\n\n```swift\n//\n//  CXCallDirectoryExtensionContext.h\n//  CallKit\n//\n//  Copyright © 2016 Apple. All rights reserved.\n//\n\n@available(iOS 10.0, *)\npublic class CXCallDirectoryExtensionContext : NSExtensionContext {\n    \n    public func addBlockingEntry(withNextSequentialPhoneNumber phoneNumber: String)\n    \n    public func addIdentificationEntry(withNextSequentialPhoneNumber phoneNumber: String, label: String)\n    \n    public func completeRequest(completionHandler completion: ((Bool) -> Swift.Void)? = nil)\n}\n```\n\n不难看出，**CXCallDirectoryExtensionContext** 主要负责提交我们处理好的请求。说白点，我们利用它来让系统知道，我们对某个来电所做出的判断。 **addBlockingEntry** 方法，接受一个电话号码字符串，形如 **“+8618...69”** (PS：不要问我为什么要加区号.. 这都是血与泪的经验)，来直接加入黑名单，也就是不接听该来电。**addIdentificationEntry** 方法，接受一个电话号码字符串以及对该号码的描述，也就是来电的时候需要显示的内容。 **completeRequest** 也就是提交之前的处理结果。至此，我们所要做的工作就完成了。![emoji_2](http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png)\n\n\n\n## 实战演示\n\n虽然自认为上面的描述已经够详细了，不过这里还是有必要详细走一遍流程，以免遗漏。\n\n开发环境：Xcode8.0 Beta + 64位 iOS10设备（至于为什么64位，之后再解释，说多了都是泪..）\n\n### 1. 创建工程\n\n没什么特别。 **Xcode —> File —> New —> Project**。随便选个 iOS Application，创建即可。这里我选择开发语言为 Swift，你随意~。\n\n这里我们的目标是来电黑名单，也就是 Extension部分，所以创建好的 Containing App，不用做什么改动。\n\n### 2.添加 Extension\n\n**Xcode —> File —> New —> Target**。创建一个 **Call Directory Extension**，如下图所示：\n\n![Extension_1](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_1.jpeg)\n\n\n\n这里注意下底部的说明， （This extension and the app it is bundled with must be **64-bit only**）也就是，这个 extension只支持 64位的设备，坑爹有没有！！之前创建太急，没认真看，用那台 5C倒腾了半天，就是出问题。只好狠心把主力机也升级了。\n\n创建好 Extension，会弹出这样的提示框：\n\n![Extension_2](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_2.jpeg)\n\n询问我们是否激活这个 scheme，当然选择激活咯，继续~\n\n之后只要关注 **xxxHandler.swift** 即可，xxx是你之前创建的 extension命名。\n\n这里的相关代码如下：\n\n```swift\nimport Foundation\nimport CallKit\n\nclass CallDirectoryHandler: CXCallDirectoryProvider {\n\n    override func beginRequest(with context: CXCallDirectoryExtensionContext) {\n    \t// --- 1\n        guard let phoneNumbersToBlock = retrievePhoneNumbersToBlock() else {\n            NSLog(\"Unable to retrieve phone numbers to block\")\n            let error = NSError(domain: \"CallDirectoryHandler\", code: 1, userInfo: nil)\n            context.cancelRequest(withError: error)\n            return\n        }\n        \n        // --- 2\n        for phoneNumber in phoneNumbersToBlock {\n            context.addBlockingEntry(withNextSequentialPhoneNumber: phoneNumber)\n        }\n        \n        // --- 3\n        guard let (phoneNumbersToIdentify, phoneNumberIdentificationLabels) = retrievePhoneNumbersToIdentifyAndLabels() else {\n            NSLog(\"Unable to retrieve phone numbers to identify and their labels\")\n            let error = NSError(domain: \"CallDirectoryHandler\", code: 2, userInfo: nil)\n            context.cancelRequest(withError: error)\n            return\n        }\n        \n        // --- 4\n        for (phoneNumber, label) in zip(phoneNumbersToIdentify, phoneNumberIdentificationLabels) {\n            context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label)\n        }\n        \n        // --- 5\n        context.completeRequest()\n    }\n    \n    private func retrievePhoneNumbersToBlock() -> [String]? {\n        // retrieve list of phone numbers to block\n        return [\"+8618xxxx157\"]\n    }\n    \n    private func retrievePhoneNumbersToIdentifyAndLabels() -> (phoneNumbers: [String], labels: [String])? {\n        // retrieve list of phone numbers to identify, and their labels\n        return ([\"+8618xxxx569\"], [\"测试\"])\n    }\n    \n}\n```\n\n一个简单的来电黑名单，我们只要补全 `retrievePhoneNumbersToBlock` 和 `retrievePhoneNumbersToIdentifyAndLabels` 中的相关数据即可，它们分别表示直接加入黑名单的号码以及识别出来，需要判断的号码。\n\n\b现在我们具体看一下这个类到底做了什么。\n\n`beginRequest` ，该方法在 Containing App 调用 reload 或者在 设置 —> 电话 —> Call Blocking & Identification里开启权限的时候，会自动被调用。每次调用，都会提交当前的黑名单列表，具体操作如下：\n\n在 **// --- 1** 中，先判断是否成功调用了 `retrievePhoneNumbersToBlock` 方法，如果没有，则打印 Log： **Unable to retrieve phone numbers to block**，然后直接终止这次请求并返回。\n\n在 **// --- 2** 中，遍历添加黑名单中的号码，这里的号码将直接拦截。\n\n在 **// --- 3** 中，先判断是否成功调用了 `retrievePhoneNumbersToIdentifyAndLabels` 方法，如果没有，则打印 Log： **Unable to retrieve phone numbers to identify and their labels**，然后直接终止这次请求并返回。\n\n在 **// --- 4** 中，遍历添加识别后的号码及其描述，这里的号码将连带描述一起显示。\n\n在 **// --- 5** 中，完成提交请求。 \n\n到这里，代码已经全部完成了。\n\n### 3. 开启权限\n\n之后我们运行该 App到设备中，然后进入设备的设置 —> 电话 —> Call Blocking & Identification，开启我们的 App即可。如下图所示：\n\n![Extension_3](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_3.png)\n\n\n\n至此，相关的工作就都完成了，我们的来电黑名单也已经实现了，可以用添加到列表中的号码来测试啦，如下所示：\n\n![Extension_4](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_4.png)\n\n\n\n## 相关思考及后续\n\n虽然实现黑名单功能很简单，但是这里我认为主要的问题应该是集中在，如何编辑这个黑名单列表。列表数据项可能很多，并且数据可能是实时更新添加的，那应该怎么做才更好呢？这里我的第一反应就是利用 App Group实现数据共享，在 Containing App完成相关的数据操作，在 Extension App中去获取即可。至于可行性，倒是没有验证过，如果不行，就当我瞎比比咯~。 当然，可能还有其他的办法，以及可能还会遇到其他的问题，这里在之后的学习过程中，我会逐步完善。\n\n当然，对于 CallKit的学习，我也仅限于这一两天，还是没有资料的情况下。所以文中难免存在各种错误以及遗漏，欢迎指正。\n\n这之后，继续 CallKit的学习，实现它的另外一个功能：VoIP App。 wait...\n\n\n\nEnjoy it~\n\n## 参考链接\n\n[Enhancing VoIP Apps with CallKit](https://developer.apple.com/videos/play/wwdc2016/230/)\n\n[CallKit](https://developer.apple.com/reference/callkit)\n\n","source":"_posts/Call-Directory-Extension-Study.md","raw":"title: Call Directory Extension 初探\ndate: 2016-06-17 22:33:15\n\ntags:\n\n- iOS 10\n- CallKit\n\n------\n\n> iOS 10中引入了许多令人振奋的新特性，其中 CallKit让我特别感兴趣。这是一个非常重要的 API，继2014年苹果推出 VoIP证书后，这次 VoIP 接口的开放，以及一个全新的 App Extension，简直是VOIP的福音，可见苹果对VOIP的重视。并且，**”that enable call blocking and caller identification. You can create an app extension that can associate a phone number with a name or tell the system when a number should be blocked.”** 这意味着现在可以通过 Call Directory Extension 来实现电话黑名单功能了。Cool~ 本文简单阐述了如果实现简单的来电黑名单功能。\n\n\n\n**阅读须知：目前学习的资料也仅限相关 API，另外 API也没有详细的注释，所以本文主要是个人探索所得，如果有什么错误，还望见谅并予以指正。现在，让我们开始吧~**\n\n<!--more-->\n\n## API介绍\n\n**Extension** 一直给我的印象就是很轻量，单一的，就如之前接触的  [Photo Editing Extension](http://colin1994.github.io/2016/03/12/Photo-Editing-Extension/) 一样，使用起来十分简单。这次的 **Call Directory Extension** 也不出例外，出奇的简单。只涉及了两个类，四个方法。下面我们逐一介绍：\n\n```swift\n//\n//  CXCallDirectoryProvider.h\n//  CallKit\n//\n//  Copyright © 2016 Apple. All rights reserved.\n//\n\n@available(iOS 10.0, *)\npublic class CXCallDirectoryProvider : NSObject, NSExtensionRequestHandling {\n\n    public func beginRequest(with context: CXCallDirectoryExtensionContext)\n}\n```\n\n首先是第一个类 **CXCallDirectoryProvider**，它是来电的响应者，为我们提供了 **beginRequest** 方法，该方法在 Containing App 调用 reload 或者在 设置 —> 电话 —> Call Blocking & Identification里开启权限的时候，会自动被调用。所以我们之后将要重写它，来实现黑名单相关逻辑。怎么样，简单吧~ ![emoji_1](http://wanzao2.b0.upaiyun.com/system/pictures/2/original/21.png)\n\nNow, Go on~\n\n接下来是另外一个类 **CXCallDirectoryExtensionContext**，它提供了另外三个方法，如下所示：\n\n```swift\n//\n//  CXCallDirectoryExtensionContext.h\n//  CallKit\n//\n//  Copyright © 2016 Apple. All rights reserved.\n//\n\n@available(iOS 10.0, *)\npublic class CXCallDirectoryExtensionContext : NSExtensionContext {\n    \n    public func addBlockingEntry(withNextSequentialPhoneNumber phoneNumber: String)\n    \n    public func addIdentificationEntry(withNextSequentialPhoneNumber phoneNumber: String, label: String)\n    \n    public func completeRequest(completionHandler completion: ((Bool) -> Swift.Void)? = nil)\n}\n```\n\n不难看出，**CXCallDirectoryExtensionContext** 主要负责提交我们处理好的请求。说白点，我们利用它来让系统知道，我们对某个来电所做出的判断。 **addBlockingEntry** 方法，接受一个电话号码字符串，形如 **“+8618...69”** (PS：不要问我为什么要加区号.. 这都是血与泪的经验)，来直接加入黑名单，也就是不接听该来电。**addIdentificationEntry** 方法，接受一个电话号码字符串以及对该号码的描述，也就是来电的时候需要显示的内容。 **completeRequest** 也就是提交之前的处理结果。至此，我们所要做的工作就完成了。![emoji_2](http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png)\n\n\n\n## 实战演示\n\n虽然自认为上面的描述已经够详细了，不过这里还是有必要详细走一遍流程，以免遗漏。\n\n开发环境：Xcode8.0 Beta + 64位 iOS10设备（至于为什么64位，之后再解释，说多了都是泪..）\n\n### 1. 创建工程\n\n没什么特别。 **Xcode —> File —> New —> Project**。随便选个 iOS Application，创建即可。这里我选择开发语言为 Swift，你随意~。\n\n这里我们的目标是来电黑名单，也就是 Extension部分，所以创建好的 Containing App，不用做什么改动。\n\n### 2.添加 Extension\n\n**Xcode —> File —> New —> Target**。创建一个 **Call Directory Extension**，如下图所示：\n\n![Extension_1](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_1.jpeg)\n\n\n\n这里注意下底部的说明， （This extension and the app it is bundled with must be **64-bit only**）也就是，这个 extension只支持 64位的设备，坑爹有没有！！之前创建太急，没认真看，用那台 5C倒腾了半天，就是出问题。只好狠心把主力机也升级了。\n\n创建好 Extension，会弹出这样的提示框：\n\n![Extension_2](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_2.jpeg)\n\n询问我们是否激活这个 scheme，当然选择激活咯，继续~\n\n之后只要关注 **xxxHandler.swift** 即可，xxx是你之前创建的 extension命名。\n\n这里的相关代码如下：\n\n```swift\nimport Foundation\nimport CallKit\n\nclass CallDirectoryHandler: CXCallDirectoryProvider {\n\n    override func beginRequest(with context: CXCallDirectoryExtensionContext) {\n    \t// --- 1\n        guard let phoneNumbersToBlock = retrievePhoneNumbersToBlock() else {\n            NSLog(\"Unable to retrieve phone numbers to block\")\n            let error = NSError(domain: \"CallDirectoryHandler\", code: 1, userInfo: nil)\n            context.cancelRequest(withError: error)\n            return\n        }\n        \n        // --- 2\n        for phoneNumber in phoneNumbersToBlock {\n            context.addBlockingEntry(withNextSequentialPhoneNumber: phoneNumber)\n        }\n        \n        // --- 3\n        guard let (phoneNumbersToIdentify, phoneNumberIdentificationLabels) = retrievePhoneNumbersToIdentifyAndLabels() else {\n            NSLog(\"Unable to retrieve phone numbers to identify and their labels\")\n            let error = NSError(domain: \"CallDirectoryHandler\", code: 2, userInfo: nil)\n            context.cancelRequest(withError: error)\n            return\n        }\n        \n        // --- 4\n        for (phoneNumber, label) in zip(phoneNumbersToIdentify, phoneNumberIdentificationLabels) {\n            context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label)\n        }\n        \n        // --- 5\n        context.completeRequest()\n    }\n    \n    private func retrievePhoneNumbersToBlock() -> [String]? {\n        // retrieve list of phone numbers to block\n        return [\"+8618xxxx157\"]\n    }\n    \n    private func retrievePhoneNumbersToIdentifyAndLabels() -> (phoneNumbers: [String], labels: [String])? {\n        // retrieve list of phone numbers to identify, and their labels\n        return ([\"+8618xxxx569\"], [\"测试\"])\n    }\n    \n}\n```\n\n一个简单的来电黑名单，我们只要补全 `retrievePhoneNumbersToBlock` 和 `retrievePhoneNumbersToIdentifyAndLabels` 中的相关数据即可，它们分别表示直接加入黑名单的号码以及识别出来，需要判断的号码。\n\n\b现在我们具体看一下这个类到底做了什么。\n\n`beginRequest` ，该方法在 Containing App 调用 reload 或者在 设置 —> 电话 —> Call Blocking & Identification里开启权限的时候，会自动被调用。每次调用，都会提交当前的黑名单列表，具体操作如下：\n\n在 **// --- 1** 中，先判断是否成功调用了 `retrievePhoneNumbersToBlock` 方法，如果没有，则打印 Log： **Unable to retrieve phone numbers to block**，然后直接终止这次请求并返回。\n\n在 **// --- 2** 中，遍历添加黑名单中的号码，这里的号码将直接拦截。\n\n在 **// --- 3** 中，先判断是否成功调用了 `retrievePhoneNumbersToIdentifyAndLabels` 方法，如果没有，则打印 Log： **Unable to retrieve phone numbers to identify and their labels**，然后直接终止这次请求并返回。\n\n在 **// --- 4** 中，遍历添加识别后的号码及其描述，这里的号码将连带描述一起显示。\n\n在 **// --- 5** 中，完成提交请求。 \n\n到这里，代码已经全部完成了。\n\n### 3. 开启权限\n\n之后我们运行该 App到设备中，然后进入设备的设置 —> 电话 —> Call Blocking & Identification，开启我们的 App即可。如下图所示：\n\n![Extension_3](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_3.png)\n\n\n\n至此，相关的工作就都完成了，我们的来电黑名单也已经实现了，可以用添加到列表中的号码来测试啦，如下所示：\n\n![Extension_4](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_4.png)\n\n\n\n## 相关思考及后续\n\n虽然实现黑名单功能很简单，但是这里我认为主要的问题应该是集中在，如何编辑这个黑名单列表。列表数据项可能很多，并且数据可能是实时更新添加的，那应该怎么做才更好呢？这里我的第一反应就是利用 App Group实现数据共享，在 Containing App完成相关的数据操作，在 Extension App中去获取即可。至于可行性，倒是没有验证过，如果不行，就当我瞎比比咯~。 当然，可能还有其他的办法，以及可能还会遇到其他的问题，这里在之后的学习过程中，我会逐步完善。\n\n当然，对于 CallKit的学习，我也仅限于这一两天，还是没有资料的情况下。所以文中难免存在各种错误以及遗漏，欢迎指正。\n\n这之后，继续 CallKit的学习，实现它的另外一个功能：VoIP App。 wait...\n\n\n\nEnjoy it~\n\n## 参考链接\n\n[Enhancing VoIP Apps with CallKit](https://developer.apple.com/videos/play/wwdc2016/230/)\n\n[CallKit](https://developer.apple.com/reference/callkit)\n\n","slug":"Call-Directory-Extension-Study","published":1,"updated":"2019-12-23T01:02:31.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1mr0017zwln2hvadra6","content":"<blockquote>\n<p>iOS 10中引入了许多令人振奋的新特性，其中 CallKit让我特别感兴趣。这是一个非常重要的 API，继2014年苹果推出 VoIP证书后，这次 VoIP 接口的开放，以及一个全新的 App Extension，简直是VOIP的福音，可见苹果对VOIP的重视。并且，<strong>”that enable call blocking and caller identification. You can create an app extension that can associate a phone number with a name or tell the system when a number should be blocked.”</strong> 这意味着现在可以通过 Call Directory Extension 来实现电话黑名单功能了。Cool~ 本文简单阐述了如果实现简单的来电黑名单功能。</p>\n</blockquote>\n<p><strong>阅读须知：目前学习的资料也仅限相关 API，另外 API也没有详细的注释，所以本文主要是个人探索所得，如果有什么错误，还望见谅并予以指正。现在，让我们开始吧~</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"API介绍\">API介绍</h2><p><strong>Extension</strong> 一直给我的印象就是很轻量，单一的，就如之前接触的  <a href=\"http://colin1994.github.io/2016/03/12/Photo-Editing-Extension/\" target=\"_blank\" rel=\"external\">Photo Editing Extension</a> 一样，使用起来十分简单。这次的 <strong>Call Directory Extension</strong> 也不出例外，出奇的简单。只涉及了两个类，四个方法。下面我们逐一介绍：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  CXCallDirectoryProvider.h</span></span><br><span class=\"line\"><span class=\"comment\">//  CallKit</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright © 2016 Apple. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">10.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CXCallDirectoryProvider</span> : <span class=\"title\">NSObject</span>, <span class=\"title\">NSExtensionRequestHandling</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">beginRequest</span><span class=\"params\">(with context: CXCallDirectoryExtensionContext)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是第一个类 <strong>CXCallDirectoryProvider</strong>，它是来电的响应者，为我们提供了 <strong>beginRequest</strong> 方法，该方法在 Containing App 调用 reload 或者在 设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification里开启权限的时候，会自动被调用。所以我们之后将要重写它，来实现黑名单相关逻辑。怎么样，简单吧~ <img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/2/original/21.png\" alt=\"emoji_1\"></p>\n<p>Now, Go on~</p>\n<p>接下来是另外一个类 <strong>CXCallDirectoryExtensionContext</strong>，它提供了另外三个方法，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  CXCallDirectoryExtensionContext.h</span></span><br><span class=\"line\"><span class=\"comment\">//  CallKit</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright © 2016 Apple. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">10.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CXCallDirectoryExtensionContext</span> : <span class=\"title\">NSExtensionContext</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addBlockingEntry</span><span class=\"params\">(withNextSequentialPhoneNumber phoneNumber: String)</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addIdentificationEntry</span><span class=\"params\">(withNextSequentialPhoneNumber phoneNumber: String, label: String)</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">completeRequest</span><span class=\"params\">(completionHandler completion: <span class=\"params\">(<span class=\"params\">(Bool)</span></span></span></span> -&gt; <span class=\"type\">Swift</span>.<span class=\"type\">Void</span>)? = <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不难看出，<strong>CXCallDirectoryExtensionContext</strong> 主要负责提交我们处理好的请求。说白点，我们利用它来让系统知道，我们对某个来电所做出的判断。 <strong>addBlockingEntry</strong> 方法，接受一个电话号码字符串，形如 <strong>“+8618…69”</strong> (PS：不要问我为什么要加区号.. 这都是血与泪的经验)，来直接加入黑名单，也就是不接听该来电。<strong>addIdentificationEntry</strong> 方法，接受一个电话号码字符串以及对该号码的描述，也就是来电的时候需要显示的内容。 <strong>completeRequest</strong> 也就是提交之前的处理结果。至此，我们所要做的工作就完成了。<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png\" alt=\"emoji_2\"></p>\n<h2 id=\"实战演示\">实战演示</h2><p>虽然自认为上面的描述已经够详细了，不过这里还是有必要详细走一遍流程，以免遗漏。</p>\n<p>开发环境：Xcode8.0 Beta + 64位 iOS10设备（至于为什么64位，之后再解释，说多了都是泪..）</p>\n<h3 id=\"1-_创建工程\">1. 创建工程</h3><p>没什么特别。 <strong>Xcode —&gt; File —&gt; New —&gt; Project</strong>。随便选个 iOS Application，创建即可。这里我选择开发语言为 Swift，你随意~。</p>\n<p>这里我们的目标是来电黑名单，也就是 Extension部分，所以创建好的 Containing App，不用做什么改动。</p>\n<h3 id=\"2-添加_Extension\">2.添加 Extension</h3><p><strong>Xcode —&gt; File —&gt; New —&gt; Target</strong>。创建一个 <strong>Call Directory Extension</strong>，如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_1.jpeg\" alt=\"Extension_1\"></p>\n<p>这里注意下底部的说明， （This extension and the app it is bundled with must be <strong>64-bit only</strong>）也就是，这个 extension只支持 64位的设备，坑爹有没有！！之前创建太急，没认真看，用那台 5C倒腾了半天，就是出问题。只好狠心把主力机也升级了。</p>\n<p>创建好 Extension，会弹出这样的提示框：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_2.jpeg\" alt=\"Extension_2\"></p>\n<p>询问我们是否激活这个 scheme，当然选择激活咯，继续~</p>\n<p>之后只要关注 <strong>xxxHandler.swift</strong> 即可，xxx是你之前创建的 extension命名。</p>\n<p>这里的相关代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> CallKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallDirectoryHandler</span>: <span class=\"title\">CXCallDirectoryProvider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">beginRequest</span><span class=\"params\">(with context: CXCallDirectoryExtensionContext)</span></span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// --- 1</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> phoneNumbersToBlock = retrievePhoneNumbersToBlock() <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"Unable to retrieve phone numbers to block\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> error = <span class=\"type\">NSError</span>(domain: <span class=\"string\">\"CallDirectoryHandler\"</span>, code: <span class=\"number\">1</span>, userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            context.cancelRequest(withError: error)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> phoneNumber <span class=\"keyword\">in</span> phoneNumbersToBlock &#123;</span><br><span class=\"line\">            context.addBlockingEntry(withNextSequentialPhoneNumber: phoneNumber)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 3</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> (phoneNumbersToIdentify, phoneNumberIdentificationLabels) = retrievePhoneNumbersToIdentifyAndLabels() <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"Unable to retrieve phone numbers to identify and their labels\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> error = <span class=\"type\">NSError</span>(domain: <span class=\"string\">\"CallDirectoryHandler\"</span>, code: <span class=\"number\">2</span>, userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            context.cancelRequest(withError: error)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 4</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (phoneNumber, label) <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(phoneNumbersToIdentify, phoneNumberIdentificationLabels) &#123;</span><br><span class=\"line\">            context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 5</span></span><br><span class=\"line\">        context.completeRequest()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">retrievePhoneNumbersToBlock</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">String</span>]? &#123;</span><br><span class=\"line\">        <span class=\"comment\">// retrieve list of phone numbers to block</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">\"+8618xxxx157\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">retrievePhoneNumbersToIdentifyAndLabels</span><span class=\"params\">()</span></span> -&gt; (phoneNumbers: [<span class=\"type\">String</span>], labels: [<span class=\"type\">String</span>])? &#123;</span><br><span class=\"line\">        <span class=\"comment\">// retrieve list of phone numbers to identify, and their labels</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ([<span class=\"string\">\"+8618xxxx569\"</span>], [<span class=\"string\">\"测试\"</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的来电黑名单，我们只要补全 <code>retrievePhoneNumbersToBlock</code> 和 <code>retrievePhoneNumbersToIdentifyAndLabels</code> 中的相关数据即可，它们分别表示直接加入黑名单的号码以及识别出来，需要判断的号码。</p>\n<p>\b现在我们具体看一下这个类到底做了什么。</p>\n<p><code>beginRequest</code> ，该方法在 Containing App 调用 reload 或者在 设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification里开启权限的时候，会自动被调用。每次调用，都会提交当前的黑名单列表，具体操作如下：</p>\n<p>在 <strong>// —- 1</strong> 中，先判断是否成功调用了 <code>retrievePhoneNumbersToBlock</code> 方法，如果没有，则打印 Log： <strong>Unable to retrieve phone numbers to block</strong>，然后直接终止这次请求并返回。</p>\n<p>在 <strong>// —- 2</strong> 中，遍历添加黑名单中的号码，这里的号码将直接拦截。</p>\n<p>在 <strong>// —- 3</strong> 中，先判断是否成功调用了 <code>retrievePhoneNumbersToIdentifyAndLabels</code> 方法，如果没有，则打印 Log： <strong>Unable to retrieve phone numbers to identify and their labels</strong>，然后直接终止这次请求并返回。</p>\n<p>在 <strong>// —- 4</strong> 中，遍历添加识别后的号码及其描述，这里的号码将连带描述一起显示。</p>\n<p>在 <strong>// —- 5</strong> 中，完成提交请求。 </p>\n<p>到这里，代码已经全部完成了。</p>\n<h3 id=\"3-_开启权限\">3. 开启权限</h3><p>之后我们运行该 App到设备中，然后进入设备的设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification，开启我们的 App即可。如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_3.png\" alt=\"Extension_3\"></p>\n<p>至此，相关的工作就都完成了，我们的来电黑名单也已经实现了，可以用添加到列表中的号码来测试啦，如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_4.png\" alt=\"Extension_4\"></p>\n<h2 id=\"相关思考及后续\">相关思考及后续</h2><p>虽然实现黑名单功能很简单，但是这里我认为主要的问题应该是集中在，如何编辑这个黑名单列表。列表数据项可能很多，并且数据可能是实时更新添加的，那应该怎么做才更好呢？这里我的第一反应就是利用 App Group实现数据共享，在 Containing App完成相关的数据操作，在 Extension App中去获取即可。至于可行性，倒是没有验证过，如果不行，就当我瞎比比咯~。 当然，可能还有其他的办法，以及可能还会遇到其他的问题，这里在之后的学习过程中，我会逐步完善。</p>\n<p>当然，对于 CallKit的学习，我也仅限于这一两天，还是没有资料的情况下。所以文中难免存在各种错误以及遗漏，欢迎指正。</p>\n<p>这之后，继续 CallKit的学习，实现它的另外一个功能：VoIP App。 wait…</p>\n<p>Enjoy it~</p>\n<h2 id=\"参考链接\">参考链接</h2><p><a href=\"https://developer.apple.com/videos/play/wwdc2016/230/\" target=\"_blank\" rel=\"external\">Enhancing VoIP Apps with CallKit</a></p>\n<p><a href=\"https://developer.apple.com/reference/callkit\" target=\"_blank\" rel=\"external\">CallKit</a></p>\n","excerpt":"<blockquote>\n<p>iOS 10中引入了许多令人振奋的新特性，其中 CallKit让我特别感兴趣。这是一个非常重要的 API，继2014年苹果推出 VoIP证书后，这次 VoIP 接口的开放，以及一个全新的 App Extension，简直是VOIP的福音，可见苹果对VOIP的重视。并且，<strong>”that enable call blocking and caller identification. You can create an app extension that can associate a phone number with a name or tell the system when a number should be blocked.”</strong> 这意味着现在可以通过 Call Directory Extension 来实现电话黑名单功能了。Cool~ 本文简单阐述了如果实现简单的来电黑名单功能。</p>\n</blockquote>\n<p><strong>阅读须知：目前学习的资料也仅限相关 API，另外 API也没有详细的注释，所以本文主要是个人探索所得，如果有什么错误，还望见谅并予以指正。现在，让我们开始吧~</strong></p>","more":"<h2 id=\"API介绍\">API介绍</h2><p><strong>Extension</strong> 一直给我的印象就是很轻量，单一的，就如之前接触的  <a href=\"http://colin1994.github.io/2016/03/12/Photo-Editing-Extension/\">Photo Editing Extension</a> 一样，使用起来十分简单。这次的 <strong>Call Directory Extension</strong> 也不出例外，出奇的简单。只涉及了两个类，四个方法。下面我们逐一介绍：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  CXCallDirectoryProvider.h</span></span><br><span class=\"line\"><span class=\"comment\">//  CallKit</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright © 2016 Apple. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">10.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CXCallDirectoryProvider</span> : <span class=\"title\">NSObject</span>, <span class=\"title\">NSExtensionRequestHandling</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">beginRequest</span><span class=\"params\">(with context: CXCallDirectoryExtensionContext)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是第一个类 <strong>CXCallDirectoryProvider</strong>，它是来电的响应者，为我们提供了 <strong>beginRequest</strong> 方法，该方法在 Containing App 调用 reload 或者在 设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification里开启权限的时候，会自动被调用。所以我们之后将要重写它，来实现黑名单相关逻辑。怎么样，简单吧~ <img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/2/original/21.png\" alt=\"emoji_1\"></p>\n<p>Now, Go on~</p>\n<p>接下来是另外一个类 <strong>CXCallDirectoryExtensionContext</strong>，它提供了另外三个方法，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  CXCallDirectoryExtensionContext.h</span></span><br><span class=\"line\"><span class=\"comment\">//  CallKit</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright © 2016 Apple. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">10.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CXCallDirectoryExtensionContext</span> : <span class=\"title\">NSExtensionContext</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addBlockingEntry</span><span class=\"params\">(withNextSequentialPhoneNumber phoneNumber: String)</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addIdentificationEntry</span><span class=\"params\">(withNextSequentialPhoneNumber phoneNumber: String, label: String)</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">completeRequest</span><span class=\"params\">(completionHandler completion: <span class=\"params\">(<span class=\"params\">(Bool)</span></span></span></span> -&gt; <span class=\"type\">Swift</span>.<span class=\"type\">Void</span>)? = <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不难看出，<strong>CXCallDirectoryExtensionContext</strong> 主要负责提交我们处理好的请求。说白点，我们利用它来让系统知道，我们对某个来电所做出的判断。 <strong>addBlockingEntry</strong> 方法，接受一个电话号码字符串，形如 <strong>“+8618…69”</strong> (PS：不要问我为什么要加区号.. 这都是血与泪的经验)，来直接加入黑名单，也就是不接听该来电。<strong>addIdentificationEntry</strong> 方法，接受一个电话号码字符串以及对该号码的描述，也就是来电的时候需要显示的内容。 <strong>completeRequest</strong> 也就是提交之前的处理结果。至此，我们所要做的工作就完成了。<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png\" alt=\"emoji_2\"></p>\n<h2 id=\"实战演示\">实战演示</h2><p>虽然自认为上面的描述已经够详细了，不过这里还是有必要详细走一遍流程，以免遗漏。</p>\n<p>开发环境：Xcode8.0 Beta + 64位 iOS10设备（至于为什么64位，之后再解释，说多了都是泪..）</p>\n<h3 id=\"1-_创建工程\">1. 创建工程</h3><p>没什么特别。 <strong>Xcode —&gt; File —&gt; New —&gt; Project</strong>。随便选个 iOS Application，创建即可。这里我选择开发语言为 Swift，你随意~。</p>\n<p>这里我们的目标是来电黑名单，也就是 Extension部分，所以创建好的 Containing App，不用做什么改动。</p>\n<h3 id=\"2-添加_Extension\">2.添加 Extension</h3><p><strong>Xcode —&gt; File —&gt; New —&gt; Target</strong>。创建一个 <strong>Call Directory Extension</strong>，如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_1.jpeg\" alt=\"Extension_1\"></p>\n<p>这里注意下底部的说明， （This extension and the app it is bundled with must be <strong>64-bit only</strong>）也就是，这个 extension只支持 64位的设备，坑爹有没有！！之前创建太急，没认真看，用那台 5C倒腾了半天，就是出问题。只好狠心把主力机也升级了。</p>\n<p>创建好 Extension，会弹出这样的提示框：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_2.jpeg\" alt=\"Extension_2\"></p>\n<p>询问我们是否激活这个 scheme，当然选择激活咯，继续~</p>\n<p>之后只要关注 <strong>xxxHandler.swift</strong> 即可，xxx是你之前创建的 extension命名。</p>\n<p>这里的相关代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> CallKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallDirectoryHandler</span>: <span class=\"title\">CXCallDirectoryProvider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">beginRequest</span><span class=\"params\">(with context: CXCallDirectoryExtensionContext)</span></span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// --- 1</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> phoneNumbersToBlock = retrievePhoneNumbersToBlock() <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"Unable to retrieve phone numbers to block\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> error = <span class=\"type\">NSError</span>(domain: <span class=\"string\">\"CallDirectoryHandler\"</span>, code: <span class=\"number\">1</span>, userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            context.cancelRequest(withError: error)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> phoneNumber <span class=\"keyword\">in</span> phoneNumbersToBlock &#123;</span><br><span class=\"line\">            context.addBlockingEntry(withNextSequentialPhoneNumber: phoneNumber)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 3</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> (phoneNumbersToIdentify, phoneNumberIdentificationLabels) = retrievePhoneNumbersToIdentifyAndLabels() <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"Unable to retrieve phone numbers to identify and their labels\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> error = <span class=\"type\">NSError</span>(domain: <span class=\"string\">\"CallDirectoryHandler\"</span>, code: <span class=\"number\">2</span>, userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            context.cancelRequest(withError: error)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 4</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (phoneNumber, label) <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(phoneNumbersToIdentify, phoneNumberIdentificationLabels) &#123;</span><br><span class=\"line\">            context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// --- 5</span></span><br><span class=\"line\">        context.completeRequest()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">retrievePhoneNumbersToBlock</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">String</span>]? &#123;</span><br><span class=\"line\">        <span class=\"comment\">// retrieve list of phone numbers to block</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">\"+8618xxxx157\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">retrievePhoneNumbersToIdentifyAndLabels</span><span class=\"params\">()</span></span> -&gt; (phoneNumbers: [<span class=\"type\">String</span>], labels: [<span class=\"type\">String</span>])? &#123;</span><br><span class=\"line\">        <span class=\"comment\">// retrieve list of phone numbers to identify, and their labels</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ([<span class=\"string\">\"+8618xxxx569\"</span>], [<span class=\"string\">\"测试\"</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的来电黑名单，我们只要补全 <code>retrievePhoneNumbersToBlock</code> 和 <code>retrievePhoneNumbersToIdentifyAndLabels</code> 中的相关数据即可，它们分别表示直接加入黑名单的号码以及识别出来，需要判断的号码。</p>\n<p>\b现在我们具体看一下这个类到底做了什么。</p>\n<p><code>beginRequest</code> ，该方法在 Containing App 调用 reload 或者在 设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification里开启权限的时候，会自动被调用。每次调用，都会提交当前的黑名单列表，具体操作如下：</p>\n<p>在 <strong>// —- 1</strong> 中，先判断是否成功调用了 <code>retrievePhoneNumbersToBlock</code> 方法，如果没有，则打印 Log： <strong>Unable to retrieve phone numbers to block</strong>，然后直接终止这次请求并返回。</p>\n<p>在 <strong>// —- 2</strong> 中，遍历添加黑名单中的号码，这里的号码将直接拦截。</p>\n<p>在 <strong>// —- 3</strong> 中，先判断是否成功调用了 <code>retrievePhoneNumbersToIdentifyAndLabels</code> 方法，如果没有，则打印 Log： <strong>Unable to retrieve phone numbers to identify and their labels</strong>，然后直接终止这次请求并返回。</p>\n<p>在 <strong>// —- 4</strong> 中，遍历添加识别后的号码及其描述，这里的号码将连带描述一起显示。</p>\n<p>在 <strong>// —- 5</strong> 中，完成提交请求。 </p>\n<p>到这里，代码已经全部完成了。</p>\n<h3 id=\"3-_开启权限\">3. 开启权限</h3><p>之后我们运行该 App到设备中，然后进入设备的设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification，开启我们的 App即可。如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_3.png\" alt=\"Extension_3\"></p>\n<p>至此，相关的工作就都完成了，我们的来电黑名单也已经实现了，可以用添加到列表中的号码来测试啦，如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/CallDirectory/callExtension_4.png\" alt=\"Extension_4\"></p>\n<h2 id=\"相关思考及后续\">相关思考及后续</h2><p>虽然实现黑名单功能很简单，但是这里我认为主要的问题应该是集中在，如何编辑这个黑名单列表。列表数据项可能很多，并且数据可能是实时更新添加的，那应该怎么做才更好呢？这里我的第一反应就是利用 App Group实现数据共享，在 Containing App完成相关的数据操作，在 Extension App中去获取即可。至于可行性，倒是没有验证过，如果不行，就当我瞎比比咯~。 当然，可能还有其他的办法，以及可能还会遇到其他的问题，这里在之后的学习过程中，我会逐步完善。</p>\n<p>当然，对于 CallKit的学习，我也仅限于这一两天，还是没有资料的情况下。所以文中难免存在各种错误以及遗漏，欢迎指正。</p>\n<p>这之后，继续 CallKit的学习，实现它的另外一个功能：VoIP App。 wait…</p>\n<p>Enjoy it~</p>\n<h2 id=\"参考链接\">参考链接</h2><p><a href=\"https://developer.apple.com/videos/play/wwdc2016/230/\">Enhancing VoIP Apps with CallKit</a></p>\n<p><a href=\"https://developer.apple.com/reference/callkit\">CallKit</a></p>"},{"layout":"iOS开发小记","title":"仿猎豹垃圾清理","date":"2015-07-13T02:14:52.000Z","_content":"\n> 前几天无意打开猎豹内存大师, 发现它的垃圾清理很强大, 效果也不错, 闲着就研究了下。 不过.. 结果貌似和我想象的不太一样。怎么说呢, 听我下文一一分析。\n\n效果图:\n\n<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_0.PNG\">\n\n<!--more-->\n\n<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_1.PNG\">\n\n\n\n从效果图, 我们可以看出它有以下几个功能:\n\n1. 获取设备上已安装的所有App\n2. 获取App的信息, 包括图标和名称\n3. 获取当前已用存储和可用存储\n4. 扫描App动画效果\n5. 清除所有App垃圾文件\n\n看到这里, 你是不是也觉得很强大?\n\n然后然后, 感叹的同时, 我有几点疑惑。\n\n1. 获取到所有已安装的App, 这个功能能通过审核?(我是去年在App Store上下载的这个App)\n2. App的图标如何获取到的? (因为扫描到的App包括我自己没上架的demo, icon只能是本地获取, 从其他App沙盒拿？)\n3. 垃圾清理过程, 为什么会出现“存储容量已满”这个提示？ 明明是清理垃圾, 中途还会出现存储满的情况?\n\n困惑, 不解..~ 于是乎, 折腾呗。 花了两天时间。写了个小demo。\n\n效果如下:\n\n<img src=\"http://img.my.csdn.net/uploads/201505/28/1432801698_3530.gif\" width=400>\n\n\n\n接下去, 我会介绍以下各个功能的实现过程, 包括:\n\n1. 获取设备已安装App列表已经App信息\n2. 扫描动画的实现\n3. 获取已用存储和可用存储\n4. 垃圾清理\n\n不过, 分析之前, 说明以下, 该功能不能够上传到App Store上! 也就是说, 它通不过审核的。原因有二:\n\n1. 使用了私有API\n2. 苹果不允许App有处理内存相关功能\n\n至于猎豹内存大师这个App、它也早已经被下架了。我怀疑它利用混淆代码通过的审核。至于功能的实现, 我觉得和猎豹的实现思路应该是一样的。\n\n至此, 如果你还对这篇文章感兴趣, 欢迎继续往下阅读。\n\n本文参考源码: [CSDN下载_防猎豹垃圾清理](http://download.csdn.net/detail/hitwhylz/8748739)\n\n\n\n**********\n\n## 获取设备已安装App列表已经App信息\n\n\n\n### 不越狱, 非私有API\n\n没有越狱的设备，官方没有提供api，所以只能用一些技巧，但是获取内容不全。\n\n这里主要有两种办法:\n\n> 方法一：利用URL scheme，看对于某一应用特有的url scheme，有没有响应。如果有响应，就说明安装了这个特定的app。\n\n说实在.. 这个办法比较傻。 App Store几百万的App, 如何枚举的过来? 并且, 也无法扫描到自己的demo。 不过, 还真有人这么干..\n\n这是对应的demo, 感兴趣可以看看。 [iHasApp](https://github.com/danielamitay/iHasApp)\n\n[官方教程: iPhoneURLScheme_Reference](http://developer.apple.com/library/ios/#featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html)\n\n\n\n> 方法二：利用一些方法获得当前正在运行的进程信息，从进程信息中获得安装的app信息。\n\n[参考: UIDevice_Category_For_Processes](http://forrst.com/posts/UIDevice_Category_For_Processes-h1H)\n\n总的来说, 不越狱, 非私有API, 想获得完整列表, 基本没什么可能。\n\n\n\n### 不越狱, 私有API。\n\n这里就是我demo所采用的办法, 比较简单。\n\n``` objc\n#include <objc/runtime.h>\n\nClass LSApplicationWorkspace_class = objc_getClass(\"LSApplicationWorkspace\");  \nNSObject* workspace = [LSApplicationWorkspace_class performSelector:@selector(defaultWorkspace)];  \nNSLog(@\"apps: %@\", [workspace performSelector:@selector(allApplications)]);  \n```\n\n**返回结果**\n\n``` objc\n\n\t\"LSApplicationProxy: com.qunar.iphoneclient8\",\n    \"LSApplicationProxy: com.apple.mobilemail\",\n    \"LSApplicationProxy: com.apple.mobilenotes\",\n    \"LSApplicationProxy: com.apple.compass\",\n    \"LSApplicationProxy: com.tencent.happymj\",\n    \"LSApplicationProxy: com.apple.mobilesafari\",\n    \"LSApplicationProxy: com.apple.reminders\"\n```\n\n返回的是个数据, 每个元素都是`LSApplicationProxy `.它的description只返回了 它的bundle id。然而这并不是我们想要的。\n\n\n\n接下去我们看\n\n[LSApplicationProxy.h](https://searchcode.com/codesearch/view/15673930/)\n\n形如:\n\n``` objc\n@class LSApplicationProxy, NSArray, NSDictionary, NSProgress, NSString, NSURL, NSUUID;\n\n@interface LSApplicationProxy : LSResourceProxy <NSSecureCoding> {\n    NSArray *_UIBackgroundModes;\n    NSString *_applicationType;\n    NSArray *_audioComponents;\n    unsigned int _bundleFlags;\n    NSURL *_bundleURL;\n    NSString *_bundleVersion;\n    NSArray *_directionsModes;\n    NSDictionary *_entitlements;\n    NSDictionary *_envi\n\n\t...\n\t...\n```\n\n这里列举了`LSApplicationProxy `对应的属性和方法。\n\n我们可以用如下代码, 打印下每个属性的值, 找出我们想要的。\n\n``` objc\n2、/* 获取对象的所有属性 以及属性值 */\n- (NSDictionary *)properties_aps\n{\n   NSMutableDictionary *props = [NSMutableDictionary dictionary];   \n   unsigned int outCount, i;   \n   objc_property_t *properties = class_copyPropertyList([self class], &outCount);   \n   for (i = 0; i<outCount; i++)\n    {\n       objc_property_t property = properties[i];\n       const char* char_f =property_getName(property);\n       NSString *propertyName = [NSString stringWithUTF8String:char_f];\n       id propertyValue = [self valueForKey:(NSString *)propertyName];   \n       if (propertyValue) [props setObject:propertyValue forKey:propertyName];   \n    }   \n   free(properties);   \n   return props;   \n} \n```\n\n参考: [IOS 遍历未知对象的属性和方法](http://blog.csdn.net/crazychickone/article/details/36413671)\n\n\n\n然后我们提取出我们需要的, 图标和应用名。\n\n``` objc\n[appsInfoArr enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop)\n        {\n            NSDictionary *boundIconsDictionary = [obj performSelector:@selector(boundIconsDictionary)];\n\n            NSString *iconPath = [NSString stringWithFormat:@\"%@/%@.png\", [[obj performSelector:@selector(resourcesDirectoryURL)] path], [[[boundIconsDictionary objectForKey:@\"CFBundlePrimaryIcon\"] objectForKey:@\"CFBundleIconFiles\"]lastObject]];\n\n             UIImage *image = [[[UIImage alloc]initWithContentsOfFile:iconPath] TransformtoSize:CGSizeMake(65, 65)];\n            if (image)\n            {\n                [self.appsIconArr addObject:image];\n                [self.appsNameArr addObject:[obj performSelector:@selector(localizedName)]];\n            }\n        }];\n```\n\n如此, `_self.appsIconArr` 和 `_appsNameArr`中存储的就是我们需要的App数据了。\n\n\n\n### 越狱\n\n.. 这里我也不懂, 也没去研究。 感兴趣的可以看看 `MobileInstallation.framework`\n\n************\n\n## 扫描动画的实现\n\n这里主要有两个动画。\n\n1. 利用UIScrollView, 实现每个App自动滚动。\n2. Animation动画, 中间扫描线的往返运动。\n\n至于动画, 这里我不想介绍太多。 源码里面都写清楚了。(当然, 写的比较粗糙...)\n\n简单带一下扫描线的动画实现:\n\n``` objc\n/* 向左移动 */\n    CABasicAnimation *animationLeft = [CABasicAnimation animationWithKeyPath:@\"transform.translation.x\"];\n\n    // 动画选项的设定\n    animationLeft.duration = 0.5f; // 持续时间\n    animationLeft.beginTime = 0.0f;\n    animationLeft.autoreverses = YES; // 结束后执行逆动画\n    // 动画先加速后减速\n    animationLeft.timingFunction =\n    [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseInEaseOut];\n\n    // 终了帧\n    animationLeft.toValue = [NSNumber numberWithFloat:-40];;\n\n\n\n    /* 向右移动 */\n    CABasicAnimation *animationRight = [CABasicAnimation animationWithKeyPath:@\"transform.translation.x\"];\n\n    // 动画选项的设定\n    animationRight.duration = 0.5f; // 持续时间\n    animationRight.beginTime = 1.0f;\n    animationRight.autoreverses = YES; // 结束后执行逆动画\n    // 动画先加速后减速\n    animationRight.timingFunction =\n    [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseInEaseOut];\n\n    // 终了帧\n    animationRight.toValue = [NSNumber numberWithFloat:40];;\n\n\n\n    /* 动画组 */\n    CAAnimationGroup *group = [CAAnimationGroup animation];\n    group.delegate = self;\n    group.duration = 2.0;\n    group.repeatCount = 15;\n\n\n    // 动画结束后不变回初始状态\n    group.removedOnCompletion = NO;\n    group.fillMode = kCAFillModeForwards;\n\n    // 添加动画\n    group.animations = [NSArray arrayWithObjects:animationLeft, animationRight, nil];\n    [mySL.layer addAnimation:group forKey:@\"moveLeft-moveRight-layer\"];\n\n```\n\n******\n\n## 获取已用存储和可用存储\n\n这个没什么好说的了.. Apple提供了API, 直接用就是了。\n\n\n\n``` objc\n// 获取占用内存\n-(void)usedSpaceAndfreeSpace\n{\n    NSString* path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] ;\n    NSFileManager* fileManager = [[NSFileManager alloc ]init];\n    NSDictionary *fileSysAttributes = [fileManager attributesOfFileSystemForPath:path error:nil];\n    NSNumber *freeSpace = [fileSysAttributes objectForKey:NSFileSystemFreeSize];\n    NSNumber *totalSpace = [fileSysAttributes objectForKey:NSFileSystemSize];\n    NSString  * str= [NSString stringWithFormat:@\"已占用%0.1f G / 剩余%0.1f MB\",([totalSpace longLongValue] - [freeSpace longLongValue])/1024.0/1024.0/1024.0,[freeSpace longLongValue]/1024.0/1024.0];\n    NSLog(@\"--------%@\",str);\n}\n```\n\n## 垃圾清理\n\n这里我本来是不想提的，毕竟这个功能，苹果是不能接受的。\n\n之前提到了, 猎豹在清理过程中, 会出现“存储已满的提示”。然后我开始考虑了。\n\n1. 为什么要弹出提示？\n2. 存储真的在某一刻满了吗？\n3. 它清理的时候, QQ直接被杀死, 应用名变成\"正在清理...\"（和安装中一个状态）。 真有这么厉害? !!!!!!\n4. 这个好像在哪里见过...\n\n最后, 我确定了猎豹的实现方式。它只不过是触发了Apple自己的垃圾回收机制而已。\n\n当存储满的时候, 系统会自动帮我们进行垃圾清理, 并弹出提示说明存储已满。\n\n所以, 猎豹只不过是计算了剩余多少存储, 然后制造了一个与之差不多大小的垃圾文件。 然后触发苹果的清理机制。清理完后, 删除之前生成的垃圾文件。再次统计当前可用存储, 差值即为本次清理的垃圾大小。 \n\n是吧, 其实也没那么神~\n\n至于如何快速制造几百M, 甚至几G的垃圾文件? \n\n``` objc\n// 将文件的长度设定为offset \n -(void)truncateFileAtOffset:offset \n```\n\n`truncateFileAtOffset:offset`就能搞定了。 感兴趣的可以自己研究下。\n\n\n\n**********\n\n至此, 猎豹垃圾清理分析完毕。\n\n当然, 这只是我个人的看法。如果有更好的方式, 或者文章中存在任何错误。 欢迎交流指正。","source":"_posts/Imitation-Clean-Master.md","raw":"layout: \"iOS开发小记\"\n\ntitle: 仿猎豹垃圾清理\n\ndate: 2015-07-13 10:14:52\n\ntags:\n\n- iOS开发\n- 教程\n\n---\n\n> 前几天无意打开猎豹内存大师, 发现它的垃圾清理很强大, 效果也不错, 闲着就研究了下。 不过.. 结果貌似和我想象的不太一样。怎么说呢, 听我下文一一分析。\n\n效果图:\n\n<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_0.PNG\">\n\n<!--more-->\n\n<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_1.PNG\">\n\n\n\n从效果图, 我们可以看出它有以下几个功能:\n\n1. 获取设备上已安装的所有App\n2. 获取App的信息, 包括图标和名称\n3. 获取当前已用存储和可用存储\n4. 扫描App动画效果\n5. 清除所有App垃圾文件\n\n看到这里, 你是不是也觉得很强大?\n\n然后然后, 感叹的同时, 我有几点疑惑。\n\n1. 获取到所有已安装的App, 这个功能能通过审核?(我是去年在App Store上下载的这个App)\n2. App的图标如何获取到的? (因为扫描到的App包括我自己没上架的demo, icon只能是本地获取, 从其他App沙盒拿？)\n3. 垃圾清理过程, 为什么会出现“存储容量已满”这个提示？ 明明是清理垃圾, 中途还会出现存储满的情况?\n\n困惑, 不解..~ 于是乎, 折腾呗。 花了两天时间。写了个小demo。\n\n效果如下:\n\n<img src=\"http://img.my.csdn.net/uploads/201505/28/1432801698_3530.gif\" width=400>\n\n\n\n接下去, 我会介绍以下各个功能的实现过程, 包括:\n\n1. 获取设备已安装App列表已经App信息\n2. 扫描动画的实现\n3. 获取已用存储和可用存储\n4. 垃圾清理\n\n不过, 分析之前, 说明以下, 该功能不能够上传到App Store上! 也就是说, 它通不过审核的。原因有二:\n\n1. 使用了私有API\n2. 苹果不允许App有处理内存相关功能\n\n至于猎豹内存大师这个App、它也早已经被下架了。我怀疑它利用混淆代码通过的审核。至于功能的实现, 我觉得和猎豹的实现思路应该是一样的。\n\n至此, 如果你还对这篇文章感兴趣, 欢迎继续往下阅读。\n\n本文参考源码: [CSDN下载_防猎豹垃圾清理](http://download.csdn.net/detail/hitwhylz/8748739)\n\n\n\n**********\n\n## 获取设备已安装App列表已经App信息\n\n\n\n### 不越狱, 非私有API\n\n没有越狱的设备，官方没有提供api，所以只能用一些技巧，但是获取内容不全。\n\n这里主要有两种办法:\n\n> 方法一：利用URL scheme，看对于某一应用特有的url scheme，有没有响应。如果有响应，就说明安装了这个特定的app。\n\n说实在.. 这个办法比较傻。 App Store几百万的App, 如何枚举的过来? 并且, 也无法扫描到自己的demo。 不过, 还真有人这么干..\n\n这是对应的demo, 感兴趣可以看看。 [iHasApp](https://github.com/danielamitay/iHasApp)\n\n[官方教程: iPhoneURLScheme_Reference](http://developer.apple.com/library/ios/#featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html)\n\n\n\n> 方法二：利用一些方法获得当前正在运行的进程信息，从进程信息中获得安装的app信息。\n\n[参考: UIDevice_Category_For_Processes](http://forrst.com/posts/UIDevice_Category_For_Processes-h1H)\n\n总的来说, 不越狱, 非私有API, 想获得完整列表, 基本没什么可能。\n\n\n\n### 不越狱, 私有API。\n\n这里就是我demo所采用的办法, 比较简单。\n\n``` objc\n#include <objc/runtime.h>\n\nClass LSApplicationWorkspace_class = objc_getClass(\"LSApplicationWorkspace\");  \nNSObject* workspace = [LSApplicationWorkspace_class performSelector:@selector(defaultWorkspace)];  \nNSLog(@\"apps: %@\", [workspace performSelector:@selector(allApplications)]);  \n```\n\n**返回结果**\n\n``` objc\n\n\t\"LSApplicationProxy: com.qunar.iphoneclient8\",\n    \"LSApplicationProxy: com.apple.mobilemail\",\n    \"LSApplicationProxy: com.apple.mobilenotes\",\n    \"LSApplicationProxy: com.apple.compass\",\n    \"LSApplicationProxy: com.tencent.happymj\",\n    \"LSApplicationProxy: com.apple.mobilesafari\",\n    \"LSApplicationProxy: com.apple.reminders\"\n```\n\n返回的是个数据, 每个元素都是`LSApplicationProxy `.它的description只返回了 它的bundle id。然而这并不是我们想要的。\n\n\n\n接下去我们看\n\n[LSApplicationProxy.h](https://searchcode.com/codesearch/view/15673930/)\n\n形如:\n\n``` objc\n@class LSApplicationProxy, NSArray, NSDictionary, NSProgress, NSString, NSURL, NSUUID;\n\n@interface LSApplicationProxy : LSResourceProxy <NSSecureCoding> {\n    NSArray *_UIBackgroundModes;\n    NSString *_applicationType;\n    NSArray *_audioComponents;\n    unsigned int _bundleFlags;\n    NSURL *_bundleURL;\n    NSString *_bundleVersion;\n    NSArray *_directionsModes;\n    NSDictionary *_entitlements;\n    NSDictionary *_envi\n\n\t...\n\t...\n```\n\n这里列举了`LSApplicationProxy `对应的属性和方法。\n\n我们可以用如下代码, 打印下每个属性的值, 找出我们想要的。\n\n``` objc\n2、/* 获取对象的所有属性 以及属性值 */\n- (NSDictionary *)properties_aps\n{\n   NSMutableDictionary *props = [NSMutableDictionary dictionary];   \n   unsigned int outCount, i;   \n   objc_property_t *properties = class_copyPropertyList([self class], &outCount);   \n   for (i = 0; i<outCount; i++)\n    {\n       objc_property_t property = properties[i];\n       const char* char_f =property_getName(property);\n       NSString *propertyName = [NSString stringWithUTF8String:char_f];\n       id propertyValue = [self valueForKey:(NSString *)propertyName];   \n       if (propertyValue) [props setObject:propertyValue forKey:propertyName];   \n    }   \n   free(properties);   \n   return props;   \n} \n```\n\n参考: [IOS 遍历未知对象的属性和方法](http://blog.csdn.net/crazychickone/article/details/36413671)\n\n\n\n然后我们提取出我们需要的, 图标和应用名。\n\n``` objc\n[appsInfoArr enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop)\n        {\n            NSDictionary *boundIconsDictionary = [obj performSelector:@selector(boundIconsDictionary)];\n\n            NSString *iconPath = [NSString stringWithFormat:@\"%@/%@.png\", [[obj performSelector:@selector(resourcesDirectoryURL)] path], [[[boundIconsDictionary objectForKey:@\"CFBundlePrimaryIcon\"] objectForKey:@\"CFBundleIconFiles\"]lastObject]];\n\n             UIImage *image = [[[UIImage alloc]initWithContentsOfFile:iconPath] TransformtoSize:CGSizeMake(65, 65)];\n            if (image)\n            {\n                [self.appsIconArr addObject:image];\n                [self.appsNameArr addObject:[obj performSelector:@selector(localizedName)]];\n            }\n        }];\n```\n\n如此, `_self.appsIconArr` 和 `_appsNameArr`中存储的就是我们需要的App数据了。\n\n\n\n### 越狱\n\n.. 这里我也不懂, 也没去研究。 感兴趣的可以看看 `MobileInstallation.framework`\n\n************\n\n## 扫描动画的实现\n\n这里主要有两个动画。\n\n1. 利用UIScrollView, 实现每个App自动滚动。\n2. Animation动画, 中间扫描线的往返运动。\n\n至于动画, 这里我不想介绍太多。 源码里面都写清楚了。(当然, 写的比较粗糙...)\n\n简单带一下扫描线的动画实现:\n\n``` objc\n/* 向左移动 */\n    CABasicAnimation *animationLeft = [CABasicAnimation animationWithKeyPath:@\"transform.translation.x\"];\n\n    // 动画选项的设定\n    animationLeft.duration = 0.5f; // 持续时间\n    animationLeft.beginTime = 0.0f;\n    animationLeft.autoreverses = YES; // 结束后执行逆动画\n    // 动画先加速后减速\n    animationLeft.timingFunction =\n    [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseInEaseOut];\n\n    // 终了帧\n    animationLeft.toValue = [NSNumber numberWithFloat:-40];;\n\n\n\n    /* 向右移动 */\n    CABasicAnimation *animationRight = [CABasicAnimation animationWithKeyPath:@\"transform.translation.x\"];\n\n    // 动画选项的设定\n    animationRight.duration = 0.5f; // 持续时间\n    animationRight.beginTime = 1.0f;\n    animationRight.autoreverses = YES; // 结束后执行逆动画\n    // 动画先加速后减速\n    animationRight.timingFunction =\n    [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseInEaseOut];\n\n    // 终了帧\n    animationRight.toValue = [NSNumber numberWithFloat:40];;\n\n\n\n    /* 动画组 */\n    CAAnimationGroup *group = [CAAnimationGroup animation];\n    group.delegate = self;\n    group.duration = 2.0;\n    group.repeatCount = 15;\n\n\n    // 动画结束后不变回初始状态\n    group.removedOnCompletion = NO;\n    group.fillMode = kCAFillModeForwards;\n\n    // 添加动画\n    group.animations = [NSArray arrayWithObjects:animationLeft, animationRight, nil];\n    [mySL.layer addAnimation:group forKey:@\"moveLeft-moveRight-layer\"];\n\n```\n\n******\n\n## 获取已用存储和可用存储\n\n这个没什么好说的了.. Apple提供了API, 直接用就是了。\n\n\n\n``` objc\n// 获取占用内存\n-(void)usedSpaceAndfreeSpace\n{\n    NSString* path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] ;\n    NSFileManager* fileManager = [[NSFileManager alloc ]init];\n    NSDictionary *fileSysAttributes = [fileManager attributesOfFileSystemForPath:path error:nil];\n    NSNumber *freeSpace = [fileSysAttributes objectForKey:NSFileSystemFreeSize];\n    NSNumber *totalSpace = [fileSysAttributes objectForKey:NSFileSystemSize];\n    NSString  * str= [NSString stringWithFormat:@\"已占用%0.1f G / 剩余%0.1f MB\",([totalSpace longLongValue] - [freeSpace longLongValue])/1024.0/1024.0/1024.0,[freeSpace longLongValue]/1024.0/1024.0];\n    NSLog(@\"--------%@\",str);\n}\n```\n\n## 垃圾清理\n\n这里我本来是不想提的，毕竟这个功能，苹果是不能接受的。\n\n之前提到了, 猎豹在清理过程中, 会出现“存储已满的提示”。然后我开始考虑了。\n\n1. 为什么要弹出提示？\n2. 存储真的在某一刻满了吗？\n3. 它清理的时候, QQ直接被杀死, 应用名变成\"正在清理...\"（和安装中一个状态）。 真有这么厉害? !!!!!!\n4. 这个好像在哪里见过...\n\n最后, 我确定了猎豹的实现方式。它只不过是触发了Apple自己的垃圾回收机制而已。\n\n当存储满的时候, 系统会自动帮我们进行垃圾清理, 并弹出提示说明存储已满。\n\n所以, 猎豹只不过是计算了剩余多少存储, 然后制造了一个与之差不多大小的垃圾文件。 然后触发苹果的清理机制。清理完后, 删除之前生成的垃圾文件。再次统计当前可用存储, 差值即为本次清理的垃圾大小。 \n\n是吧, 其实也没那么神~\n\n至于如何快速制造几百M, 甚至几G的垃圾文件? \n\n``` objc\n// 将文件的长度设定为offset \n -(void)truncateFileAtOffset:offset \n```\n\n`truncateFileAtOffset:offset`就能搞定了。 感兴趣的可以自己研究下。\n\n\n\n**********\n\n至此, 猎豹垃圾清理分析完毕。\n\n当然, 这只是我个人的看法。如果有更好的方式, 或者文章中存在任何错误。 欢迎交流指正。","slug":"Imitation-Clean-Master","published":1,"updated":"2019-12-23T01:02:31.285Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1mr0018zwlnj2xm7pgn","content":"<blockquote>\n<p>前几天无意打开猎豹内存大师, 发现它的垃圾清理很强大, 效果也不错, 闲着就研究了下。 不过.. 结果貌似和我想象的不太一样。怎么说呢, 听我下文一一分析。</p>\n</blockquote>\n<p>效果图:</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_0.PNG\"></p>\n<a id=\"more\"></a>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_1.PNG\"></p>\n<p>从效果图, 我们可以看出它有以下几个功能:</p>\n<ol>\n<li>获取设备上已安装的所有App</li>\n<li>获取App的信息, 包括图标和名称</li>\n<li>获取当前已用存储和可用存储</li>\n<li>扫描App动画效果</li>\n<li>清除所有App垃圾文件</li>\n</ol>\n<p>看到这里, 你是不是也觉得很强大?</p>\n<p>然后然后, 感叹的同时, 我有几点疑惑。</p>\n<ol>\n<li>获取到所有已安装的App, 这个功能能通过审核?(我是去年在App Store上下载的这个App)</li>\n<li>App的图标如何获取到的? (因为扫描到的App包括我自己没上架的demo, icon只能是本地获取, 从其他App沙盒拿？)</li>\n<li>垃圾清理过程, 为什么会出现“存储容量已满”这个提示？ 明明是清理垃圾, 中途还会出现存储满的情况?</li>\n</ol>\n<p>困惑, 不解..~ 于是乎, 折腾呗。 花了两天时间。写了个小demo。</p>\n<p>效果如下:</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201505/28/1432801698_3530.gif\" width=\"400\"></p>\n<p>接下去, 我会介绍以下各个功能的实现过程, 包括:</p>\n<ol>\n<li>获取设备已安装App列表已经App信息</li>\n<li>扫描动画的实现</li>\n<li>获取已用存储和可用存储</li>\n<li>垃圾清理</li>\n</ol>\n<p>不过, 分析之前, 说明以下, 该功能不能够上传到App Store上! 也就是说, 它通不过审核的。原因有二:</p>\n<ol>\n<li>使用了私有API</li>\n<li>苹果不允许App有处理内存相关功能</li>\n</ol>\n<p>至于猎豹内存大师这个App、它也早已经被下架了。我怀疑它利用混淆代码通过的审核。至于功能的实现, 我觉得和猎豹的实现思路应该是一样的。</p>\n<p>至此, 如果你还对这篇文章感兴趣, 欢迎继续往下阅读。</p>\n<p>本文参考源码: <a href=\"http://download.csdn.net/detail/hitwhylz/8748739\" target=\"_blank\" rel=\"external\">CSDN下载_防猎豹垃圾清理</a></p>\n<hr>\n<h2 id=\"获取设备已安装App列表已经App信息\">获取设备已安装App列表已经App信息</h2><h3 id=\"不越狱,_非私有API\">不越狱, 非私有API</h3><p>没有越狱的设备，官方没有提供api，所以只能用一些技巧，但是获取内容不全。</p>\n<p>这里主要有两种办法:</p>\n<blockquote>\n<p>方法一：利用URL scheme，看对于某一应用特有的url scheme，有没有响应。如果有响应，就说明安装了这个特定的app。</p>\n</blockquote>\n<p>说实在.. 这个办法比较傻。 App Store几百万的App, 如何枚举的过来? 并且, 也无法扫描到自己的demo。 不过, 还真有人这么干..</p>\n<p>这是对应的demo, 感兴趣可以看看。 <a href=\"https://github.com/danielamitay/iHasApp\" target=\"_blank\" rel=\"external\">iHasApp</a></p>\n<p><a href=\"http://developer.apple.com/library/ios/#featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html\" target=\"_blank\" rel=\"external\">官方教程: iPhoneURLScheme_Reference</a></p>\n<blockquote>\n<p>方法二：利用一些方法获得当前正在运行的进程信息，从进程信息中获得安装的app信息。</p>\n</blockquote>\n<p><a href=\"http://forrst.com/posts/UIDevice_Category_For_Processes-h1H\" target=\"_blank\" rel=\"external\">参考: UIDevice_Category_For_Processes</a></p>\n<p>总的来说, 不越狱, 非私有API, 想获得完整列表, 基本没什么可能。</p>\n<h3 id=\"不越狱,_私有API。\">不越狱, 私有API。</h3><p>这里就是我demo所采用的办法, 比较简单。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">Class LSApplicationWorkspace_class = objc_getClass(<span class=\"string\">\"LSApplicationWorkspace\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">NSObject</span>* workspace = [LSApplicationWorkspace_class performSelector:<span class=\"keyword\">@selector</span>(defaultWorkspace)];  </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"apps: %@\"</span>, [workspace performSelector:<span class=\"keyword\">@selector</span>(allApplications)]);</span><br></pre></td></tr></table></figure>\n<p><strong>返回结果</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"LSApplicationProxy: com.qunar.iphoneclient8\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.mobilemail\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.mobilenotes\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.compass\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.tencent.happymj\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.mobilesafari\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.reminders\"</span></span><br></pre></td></tr></table></figure>\n<p>返回的是个数据, 每个元素都是<code>LSApplicationProxy</code>.它的description只返回了 它的bundle id。然而这并不是我们想要的。</p>\n<p>接下去我们看</p>\n<p><a href=\"https://searchcode.com/codesearch/view/15673930/\" target=\"_blank\" rel=\"external\">LSApplicationProxy.h</a></p>\n<p>形如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">LSApplicationProxy</span>, <span class=\"title\">NSArray</span>, <span class=\"title\">NSDictionary</span>, <span class=\"title\">NSProgress</span>, <span class=\"title\">NSString</span>, <span class=\"title\">NSURL</span>, <span class=\"title\">NSUUID</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSApplicationProxy</span> : <span class=\"title\">LSResourceProxy</span> &lt;<span class=\"title\">NSSecureCoding</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *_<span class=\"built_in\">UIBackgroundModes</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_applicationType;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *_audioComponents;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> _bundleFlags;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *_bundleURL;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_bundleVersion;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *_directionsModes;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *_entitlements;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *_envi</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>这里列举了<code>LSApplicationProxy</code>对应的属性和方法。</p>\n<p>我们可以用如下代码, 打印下每个属性的值, 找出我们想要的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>、<span class=\"comment\">/* 获取对象的所有属性 以及属性值 */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)properties_aps</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSMutableDictionary</span> *props = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];   </span><br><span class=\"line\">   <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount, i;   </span><br><span class=\"line\">   objc_property_t *properties = class_copyPropertyList([<span class=\"keyword\">self</span> class], &amp;outCount);   </span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i&lt;outCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       objc_property_t property = properties[i];</span><br><span class=\"line\">       <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* char_f =property_getName(property);</span><br><span class=\"line\">       <span class=\"built_in\">NSString</span> *propertyName = [<span class=\"built_in\">NSString</span> stringWithUTF8String:char_f];</span><br><span class=\"line\">       <span class=\"keyword\">id</span> propertyValue = [<span class=\"keyword\">self</span> valueForKey:(<span class=\"built_in\">NSString</span> *)propertyName];   </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (propertyValue) [props setObject:propertyValue forKey:propertyName];   </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">   free(properties);   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> props;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考: <a href=\"http://blog.csdn.net/crazychickone/article/details/36413671\" target=\"_blank\" rel=\"external\">IOS 遍历未知对象的属性和方法</a></p>\n<p>然后我们提取出我们需要的, 图标和应用名。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[appsInfoArr enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSDictionary</span> *boundIconsDictionary = [obj performSelector:<span class=\"keyword\">@selector</span>(boundIconsDictionary)];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> *iconPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/%@.png\"</span>, [[obj performSelector:<span class=\"keyword\">@selector</span>(resourcesDirectoryURL)] path], [[[boundIconsDictionary objectForKey:<span class=\"string\">@\"CFBundlePrimaryIcon\"</span>] objectForKey:<span class=\"string\">@\"CFBundleIconFiles\"</span>]lastObject]];</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"built_in\">UIImage</span> *image = [[[<span class=\"built_in\">UIImage</span> alloc]initWithContentsOfFile:iconPath] TransformtoSize:<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">65</span>, <span class=\"number\">65</span>)];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (image)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.appsIconArr addObject:image];</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.appsNameArr addObject:[obj performSelector:<span class=\"keyword\">@selector</span>(localizedName)]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br></pre></td></tr></table></figure>\n<p>如此, <code>_self.appsIconArr</code> 和 <code>_appsNameArr</code>中存储的就是我们需要的App数据了。</p>\n<h3 id=\"越狱\">越狱</h3><p>.. 这里我也不懂, 也没去研究。 感兴趣的可以看看 <code>MobileInstallation.framework</code></p>\n<hr>\n<h2 id=\"扫描动画的实现\">扫描动画的实现</h2><p>这里主要有两个动画。</p>\n<ol>\n<li>利用UIScrollView, 实现每个App自动滚动。</li>\n<li>Animation动画, 中间扫描线的往返运动。</li>\n</ol>\n<p>至于动画, 这里我不想介绍太多。 源码里面都写清楚了。(当然, 写的比较粗糙…)</p>\n<p>简单带一下扫描线的动画实现:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 向左移动 */</span></span><br><span class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *animationLeft = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"transform.translation.x\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动画选项的设定</span></span><br><span class=\"line\">    animationLeft.duration = <span class=\"number\">0.5</span>f; <span class=\"comment\">// 持续时间</span></span><br><span class=\"line\">    animationLeft.beginTime = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\">    animationLeft.autoreverses = <span class=\"literal\">YES</span>; <span class=\"comment\">// 结束后执行逆动画</span></span><br><span class=\"line\">    <span class=\"comment\">// 动画先加速后减速</span></span><br><span class=\"line\">    animationLeft.timingFunction =</span><br><span class=\"line\">    [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName: k<span class=\"built_in\">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 终了帧</span></span><br><span class=\"line\">    animationLeft.toValue = [<span class=\"built_in\">NSNumber</span> numberWithFloat:<span class=\"number\">-40</span>];;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 向右移动 */</span></span><br><span class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *animationRight = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"transform.translation.x\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动画选项的设定</span></span><br><span class=\"line\">    animationRight.duration = <span class=\"number\">0.5</span>f; <span class=\"comment\">// 持续时间</span></span><br><span class=\"line\">    animationRight.beginTime = <span class=\"number\">1.0</span>f;</span><br><span class=\"line\">    animationRight.autoreverses = <span class=\"literal\">YES</span>; <span class=\"comment\">// 结束后执行逆动画</span></span><br><span class=\"line\">    <span class=\"comment\">// 动画先加速后减速</span></span><br><span class=\"line\">    animationRight.timingFunction =</span><br><span class=\"line\">    [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName: k<span class=\"built_in\">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 终了帧</span></span><br><span class=\"line\">    animationRight.toValue = [<span class=\"built_in\">NSNumber</span> numberWithFloat:<span class=\"number\">40</span>];;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 动画组 */</span></span><br><span class=\"line\">    <span class=\"built_in\">CAAnimationGroup</span> *group = [<span class=\"built_in\">CAAnimationGroup</span> animation];</span><br><span class=\"line\">    group.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    group.duration = <span class=\"number\">2.0</span>;</span><br><span class=\"line\">    group.repeatCount = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动画结束后不变回初始状态</span></span><br><span class=\"line\">    group.removedOnCompletion = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    group.fillMode = k<span class=\"built_in\">CAFillModeForwards</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加动画</span></span><br><span class=\"line\">    group.animations = [<span class=\"built_in\">NSArray</span> arrayWithObjects:animationLeft, animationRight, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [mySL.layer addAnimation:group forKey:<span class=\"string\">@\"moveLeft-moveRight-layer\"</span>];</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"获取已用存储和可用存储\">获取已用存储和可用存储</h2><p>这个没什么好说的了.. Apple提供了API, 直接用就是了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取占用内存</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)usedSpaceAndfreeSpace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span>* path = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>) objectAtIndex:<span class=\"number\">0</span>] ;</span><br><span class=\"line\">    <span class=\"built_in\">NSFileManager</span>* fileManager = [[<span class=\"built_in\">NSFileManager</span> alloc ]init];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *fileSysAttributes = [fileManager attributesOfFileSystemForPath:path error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *freeSpace = [fileSysAttributes objectForKey:<span class=\"built_in\">NSFileSystemFreeSize</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *totalSpace = [fileSysAttributes objectForKey:<span class=\"built_in\">NSFileSystemSize</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span>  * str= [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"已占用%0.1f G / 剩余%0.1f MB\"</span>,([totalSpace longLongValue] - [freeSpace longLongValue])/<span class=\"number\">1024.0</span>/<span class=\"number\">1024.0</span>/<span class=\"number\">1024.0</span>,[freeSpace longLongValue]/<span class=\"number\">1024.0</span>/<span class=\"number\">1024.0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"--------%@\"</span>,str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"垃圾清理\">垃圾清理</h2><p>这里我本来是不想提的，毕竟这个功能，苹果是不能接受的。</p>\n<p>之前提到了, 猎豹在清理过程中, 会出现“存储已满的提示”。然后我开始考虑了。</p>\n<ol>\n<li>为什么要弹出提示？</li>\n<li>存储真的在某一刻满了吗？</li>\n<li>它清理的时候, QQ直接被杀死, 应用名变成”正在清理…”（和安装中一个状态）。 真有这么厉害? !!!!!!</li>\n<li>这个好像在哪里见过…</li>\n</ol>\n<p>最后, 我确定了猎豹的实现方式。它只不过是触发了Apple自己的垃圾回收机制而已。</p>\n<p>当存储满的时候, 系统会自动帮我们进行垃圾清理, 并弹出提示说明存储已满。</p>\n<p>所以, 猎豹只不过是计算了剩余多少存储, 然后制造了一个与之差不多大小的垃圾文件。 然后触发苹果的清理机制。清理完后, 删除之前生成的垃圾文件。再次统计当前可用存储, 差值即为本次清理的垃圾大小。 </p>\n<p>是吧, 其实也没那么神~</p>\n<p>至于如何快速制造几百M, 甚至几G的垃圾文件? </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将文件的长度设定为offset </span></span><br><span class=\"line\"> -(<span class=\"keyword\">void</span>)truncateFileAtOffset:offset</span><br></pre></td></tr></table></figure>\n<p><code>truncateFileAtOffset:offset</code>就能搞定了。 感兴趣的可以自己研究下。</p>\n<hr>\n<p>至此, 猎豹垃圾清理分析完毕。</p>\n<p>当然, 这只是我个人的看法。如果有更好的方式, 或者文章中存在任何错误。 欢迎交流指正。</p>\n","excerpt":"<blockquote>\n<p>前几天无意打开猎豹内存大师, 发现它的垃圾清理很强大, 效果也不错, 闲着就研究了下。 不过.. 结果貌似和我想象的不太一样。怎么说呢, 听我下文一一分析。</p>\n</blockquote>\n<p>效果图:</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_0.PNG\"></p>","more":"<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/Other/imageliebao_1.PNG\"></p>\n<p>从效果图, 我们可以看出它有以下几个功能:</p>\n<ol>\n<li>获取设备上已安装的所有App</li>\n<li>获取App的信息, 包括图标和名称</li>\n<li>获取当前已用存储和可用存储</li>\n<li>扫描App动画效果</li>\n<li>清除所有App垃圾文件</li>\n</ol>\n<p>看到这里, 你是不是也觉得很强大?</p>\n<p>然后然后, 感叹的同时, 我有几点疑惑。</p>\n<ol>\n<li>获取到所有已安装的App, 这个功能能通过审核?(我是去年在App Store上下载的这个App)</li>\n<li>App的图标如何获取到的? (因为扫描到的App包括我自己没上架的demo, icon只能是本地获取, 从其他App沙盒拿？)</li>\n<li>垃圾清理过程, 为什么会出现“存储容量已满”这个提示？ 明明是清理垃圾, 中途还会出现存储满的情况?</li>\n</ol>\n<p>困惑, 不解..~ 于是乎, 折腾呗。 花了两天时间。写了个小demo。</p>\n<p>效果如下:</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201505/28/1432801698_3530.gif\" width=400></p>\n<p>接下去, 我会介绍以下各个功能的实现过程, 包括:</p>\n<ol>\n<li>获取设备已安装App列表已经App信息</li>\n<li>扫描动画的实现</li>\n<li>获取已用存储和可用存储</li>\n<li>垃圾清理</li>\n</ol>\n<p>不过, 分析之前, 说明以下, 该功能不能够上传到App Store上! 也就是说, 它通不过审核的。原因有二:</p>\n<ol>\n<li>使用了私有API</li>\n<li>苹果不允许App有处理内存相关功能</li>\n</ol>\n<p>至于猎豹内存大师这个App、它也早已经被下架了。我怀疑它利用混淆代码通过的审核。至于功能的实现, 我觉得和猎豹的实现思路应该是一样的。</p>\n<p>至此, 如果你还对这篇文章感兴趣, 欢迎继续往下阅读。</p>\n<p>本文参考源码: <a href=\"http://download.csdn.net/detail/hitwhylz/8748739\">CSDN下载_防猎豹垃圾清理</a></p>\n<hr>\n<h2 id=\"获取设备已安装App列表已经App信息\">获取设备已安装App列表已经App信息</h2><h3 id=\"不越狱,_非私有API\">不越狱, 非私有API</h3><p>没有越狱的设备，官方没有提供api，所以只能用一些技巧，但是获取内容不全。</p>\n<p>这里主要有两种办法:</p>\n<blockquote>\n<p>方法一：利用URL scheme，看对于某一应用特有的url scheme，有没有响应。如果有响应，就说明安装了这个特定的app。</p>\n</blockquote>\n<p>说实在.. 这个办法比较傻。 App Store几百万的App, 如何枚举的过来? 并且, 也无法扫描到自己的demo。 不过, 还真有人这么干..</p>\n<p>这是对应的demo, 感兴趣可以看看。 <a href=\"https://github.com/danielamitay/iHasApp\">iHasApp</a></p>\n<p><a href=\"http://developer.apple.com/library/ios/#featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html\">官方教程: iPhoneURLScheme_Reference</a></p>\n<blockquote>\n<p>方法二：利用一些方法获得当前正在运行的进程信息，从进程信息中获得安装的app信息。</p>\n</blockquote>\n<p><a href=\"http://forrst.com/posts/UIDevice_Category_For_Processes-h1H\">参考: UIDevice_Category_For_Processes</a></p>\n<p>总的来说, 不越狱, 非私有API, 想获得完整列表, 基本没什么可能。</p>\n<h3 id=\"不越狱,_私有API。\">不越狱, 私有API。</h3><p>这里就是我demo所采用的办法, 比较简单。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">Class LSApplicationWorkspace_class = objc_getClass(<span class=\"string\">\"LSApplicationWorkspace\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">NSObject</span>* workspace = [LSApplicationWorkspace_class performSelector:<span class=\"keyword\">@selector</span>(defaultWorkspace)];  </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"apps: %@\"</span>, [workspace performSelector:<span class=\"keyword\">@selector</span>(allApplications)]);</span><br></pre></td></tr></table></figure>\n<p><strong>返回结果</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"LSApplicationProxy: com.qunar.iphoneclient8\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.mobilemail\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.mobilenotes\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.compass\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.tencent.happymj\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.mobilesafari\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"LSApplicationProxy: com.apple.reminders\"</span></span><br></pre></td></tr></table></figure>\n<p>返回的是个数据, 每个元素都是<code>LSApplicationProxy</code>.它的description只返回了 它的bundle id。然而这并不是我们想要的。</p>\n<p>接下去我们看</p>\n<p><a href=\"https://searchcode.com/codesearch/view/15673930/\">LSApplicationProxy.h</a></p>\n<p>形如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">LSApplicationProxy</span>, <span class=\"title\">NSArray</span>, <span class=\"title\">NSDictionary</span>, <span class=\"title\">NSProgress</span>, <span class=\"title\">NSString</span>, <span class=\"title\">NSURL</span>, <span class=\"title\">NSUUID</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSApplicationProxy</span> : <span class=\"title\">LSResourceProxy</span> &lt;<span class=\"title\">NSSecureCoding</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *_<span class=\"built_in\">UIBackgroundModes</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_applicationType;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *_audioComponents;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> _bundleFlags;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *_bundleURL;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_bundleVersion;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *_directionsModes;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *_entitlements;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *_envi</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>这里列举了<code>LSApplicationProxy</code>对应的属性和方法。</p>\n<p>我们可以用如下代码, 打印下每个属性的值, 找出我们想要的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>、<span class=\"comment\">/* 获取对象的所有属性 以及属性值 */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)properties_aps</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSMutableDictionary</span> *props = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];   </span><br><span class=\"line\">   <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount, i;   </span><br><span class=\"line\">   objc_property_t *properties = class_copyPropertyList([<span class=\"keyword\">self</span> class], &amp;outCount);   </span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i&lt;outCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       objc_property_t property = properties[i];</span><br><span class=\"line\">       <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* char_f =property_getName(property);</span><br><span class=\"line\">       <span class=\"built_in\">NSString</span> *propertyName = [<span class=\"built_in\">NSString</span> stringWithUTF8String:char_f];</span><br><span class=\"line\">       <span class=\"keyword\">id</span> propertyValue = [<span class=\"keyword\">self</span> valueForKey:(<span class=\"built_in\">NSString</span> *)propertyName];   </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (propertyValue) [props setObject:propertyValue forKey:propertyName];   </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">   free(properties);   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> props;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考: <a href=\"http://blog.csdn.net/crazychickone/article/details/36413671\">IOS 遍历未知对象的属性和方法</a></p>\n<p>然后我们提取出我们需要的, 图标和应用名。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[appsInfoArr enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSDictionary</span> *boundIconsDictionary = [obj performSelector:<span class=\"keyword\">@selector</span>(boundIconsDictionary)];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> *iconPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/%@.png\"</span>, [[obj performSelector:<span class=\"keyword\">@selector</span>(resourcesDirectoryURL)] path], [[[boundIconsDictionary objectForKey:<span class=\"string\">@\"CFBundlePrimaryIcon\"</span>] objectForKey:<span class=\"string\">@\"CFBundleIconFiles\"</span>]lastObject]];</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"built_in\">UIImage</span> *image = [[[<span class=\"built_in\">UIImage</span> alloc]initWithContentsOfFile:iconPath] TransformtoSize:<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">65</span>, <span class=\"number\">65</span>)];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (image)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.appsIconArr addObject:image];</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.appsNameArr addObject:[obj performSelector:<span class=\"keyword\">@selector</span>(localizedName)]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br></pre></td></tr></table></figure>\n<p>如此, <code>_self.appsIconArr</code> 和 <code>_appsNameArr</code>中存储的就是我们需要的App数据了。</p>\n<h3 id=\"越狱\">越狱</h3><p>.. 这里我也不懂, 也没去研究。 感兴趣的可以看看 <code>MobileInstallation.framework</code></p>\n<hr>\n<h2 id=\"扫描动画的实现\">扫描动画的实现</h2><p>这里主要有两个动画。</p>\n<ol>\n<li>利用UIScrollView, 实现每个App自动滚动。</li>\n<li>Animation动画, 中间扫描线的往返运动。</li>\n</ol>\n<p>至于动画, 这里我不想介绍太多。 源码里面都写清楚了。(当然, 写的比较粗糙…)</p>\n<p>简单带一下扫描线的动画实现:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 向左移动 */</span></span><br><span class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *animationLeft = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"transform.translation.x\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动画选项的设定</span></span><br><span class=\"line\">    animationLeft.duration = <span class=\"number\">0.5</span>f; <span class=\"comment\">// 持续时间</span></span><br><span class=\"line\">    animationLeft.beginTime = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\">    animationLeft.autoreverses = <span class=\"literal\">YES</span>; <span class=\"comment\">// 结束后执行逆动画</span></span><br><span class=\"line\">    <span class=\"comment\">// 动画先加速后减速</span></span><br><span class=\"line\">    animationLeft.timingFunction =</span><br><span class=\"line\">    [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName: k<span class=\"built_in\">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 终了帧</span></span><br><span class=\"line\">    animationLeft.toValue = [<span class=\"built_in\">NSNumber</span> numberWithFloat:<span class=\"number\">-40</span>];;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 向右移动 */</span></span><br><span class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *animationRight = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"transform.translation.x\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动画选项的设定</span></span><br><span class=\"line\">    animationRight.duration = <span class=\"number\">0.5</span>f; <span class=\"comment\">// 持续时间</span></span><br><span class=\"line\">    animationRight.beginTime = <span class=\"number\">1.0</span>f;</span><br><span class=\"line\">    animationRight.autoreverses = <span class=\"literal\">YES</span>; <span class=\"comment\">// 结束后执行逆动画</span></span><br><span class=\"line\">    <span class=\"comment\">// 动画先加速后减速</span></span><br><span class=\"line\">    animationRight.timingFunction =</span><br><span class=\"line\">    [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName: k<span class=\"built_in\">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 终了帧</span></span><br><span class=\"line\">    animationRight.toValue = [<span class=\"built_in\">NSNumber</span> numberWithFloat:<span class=\"number\">40</span>];;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 动画组 */</span></span><br><span class=\"line\">    <span class=\"built_in\">CAAnimationGroup</span> *group = [<span class=\"built_in\">CAAnimationGroup</span> animation];</span><br><span class=\"line\">    group.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    group.duration = <span class=\"number\">2.0</span>;</span><br><span class=\"line\">    group.repeatCount = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动画结束后不变回初始状态</span></span><br><span class=\"line\">    group.removedOnCompletion = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    group.fillMode = k<span class=\"built_in\">CAFillModeForwards</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加动画</span></span><br><span class=\"line\">    group.animations = [<span class=\"built_in\">NSArray</span> arrayWithObjects:animationLeft, animationRight, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [mySL.layer addAnimation:group forKey:<span class=\"string\">@\"moveLeft-moveRight-layer\"</span>];</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"获取已用存储和可用存储\">获取已用存储和可用存储</h2><p>这个没什么好说的了.. Apple提供了API, 直接用就是了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取占用内存</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)usedSpaceAndfreeSpace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span>* path = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>) objectAtIndex:<span class=\"number\">0</span>] ;</span><br><span class=\"line\">    <span class=\"built_in\">NSFileManager</span>* fileManager = [[<span class=\"built_in\">NSFileManager</span> alloc ]init];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *fileSysAttributes = [fileManager attributesOfFileSystemForPath:path error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *freeSpace = [fileSysAttributes objectForKey:<span class=\"built_in\">NSFileSystemFreeSize</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *totalSpace = [fileSysAttributes objectForKey:<span class=\"built_in\">NSFileSystemSize</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span>  * str= [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"已占用%0.1f G / 剩余%0.1f MB\"</span>,([totalSpace longLongValue] - [freeSpace longLongValue])/<span class=\"number\">1024.0</span>/<span class=\"number\">1024.0</span>/<span class=\"number\">1024.0</span>,[freeSpace longLongValue]/<span class=\"number\">1024.0</span>/<span class=\"number\">1024.0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"--------%@\"</span>,str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"垃圾清理\">垃圾清理</h2><p>这里我本来是不想提的，毕竟这个功能，苹果是不能接受的。</p>\n<p>之前提到了, 猎豹在清理过程中, 会出现“存储已满的提示”。然后我开始考虑了。</p>\n<ol>\n<li>为什么要弹出提示？</li>\n<li>存储真的在某一刻满了吗？</li>\n<li>它清理的时候, QQ直接被杀死, 应用名变成”正在清理…”（和安装中一个状态）。 真有这么厉害? !!!!!!</li>\n<li>这个好像在哪里见过…</li>\n</ol>\n<p>最后, 我确定了猎豹的实现方式。它只不过是触发了Apple自己的垃圾回收机制而已。</p>\n<p>当存储满的时候, 系统会自动帮我们进行垃圾清理, 并弹出提示说明存储已满。</p>\n<p>所以, 猎豹只不过是计算了剩余多少存储, 然后制造了一个与之差不多大小的垃圾文件。 然后触发苹果的清理机制。清理完后, 删除之前生成的垃圾文件。再次统计当前可用存储, 差值即为本次清理的垃圾大小。 </p>\n<p>是吧, 其实也没那么神~</p>\n<p>至于如何快速制造几百M, 甚至几G的垃圾文件? </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将文件的长度设定为offset </span></span><br><span class=\"line\"> -(<span class=\"keyword\">void</span>)truncateFileAtOffset:offset</span><br></pre></td></tr></table></figure>\n<p><code>truncateFileAtOffset:offset</code>就能搞定了。 感兴趣的可以自己研究下。</p>\n<hr>\n<p>至此, 猎豹垃圾清理分析完毕。</p>\n<p>当然, 这只是我个人的看法。如果有更好的方式, 或者文章中存在任何错误。 欢迎交流指正。</p>"},{"layout":"iOS开发小记","title":"Jazzhands, 交互动画就是这么简单","date":"2016-03-16T09:11:00.000Z","_content":"\n>  [Jazz Hands](https://github.com/IFTTT/JazzHands)是IFTTT发布的一个基于关键帧的动画框架, 可以用于手势，滚动视图，KVO或者ReactiveCocoa, 十分方便。\n\nbut, 到底有多方便呢 ?\n\n看看官方给出的一个demo效果:\n\n![Jazzhandsjazzhands-demo](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhandsjazzhands-demo.gif)\n\n<!--more-->\n\n如果 `设计` 要你做出这样一个效果的引导页, 有没有觉得头大 ?\n\n![emoji](http://wanzao2.b0.upaiyun.com/system/pictures/54/original/8.png)\n\n然而, 在 `Jazzhands` 里, 我们需要做的, 就是规划好各个组件需要展示的时机以及对应的位置。中间的衔接动画, 完全交给 `Jazzhands` 去处理。 这样的感觉很爽有没有~ \n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/789/original/%E9%87%91%E5%A4%A7%E7%88%B79.jpg)\n\n\n\n然而, `Jazzhands` 具体为我们做了什么, 它是怎么做的 ?  它适用于哪些场景 ? 下文我们一一分析~\n\n\n\n## Jazzhands原理分析\n\n先看一下源工程目录: \n\n![](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhands_1.png)\n\n\n\n这一大串看下来, 貌似很复杂, 实则不然。\n\n我们可以简单的归为 三大类 文件来看。\n\n1. `IFTTTAnimation, IFTTTAnimatable, IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …`  之类的动画类型。\n2. `IFTTTAnimator` 动画执行者\n3. `IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController` 封装好的控制器类型。\n\n\n\n### 动画类型\n\n动画类型, 我们拿最简单的  `alpha` 变化动画来分析。 \n\n`IFTTTAlphaAnimation.m`\n\n``` objc\n//\n//  IFTTTAlphaAnimation.m\n//  JazzHands\n//\n//  Created by Devin Foley on 9/27/13.\n//  Copyright (c) 2013 IFTTT Inc. All rights reserved.\n//\n\n#import \"IFTTTAlphaAnimation.h\"\n\n@implementation IFTTTAlphaAnimation\n\n- (void)addKeyframeForTime:(CGFloat)time alpha:(CGFloat)alpha\n{\n    if (![self validAlpha:alpha]) return;\n    [self addKeyframeForTime:time value:@(alpha)];\n}\n\n- (void)addKeyframeForTime:(CGFloat)time alpha:(CGFloat)alpha withEasingFunction:(IFTTTEasingFunction)easingFunction\n{\n    if (![self validAlpha:alpha]) return;\n    [self addKeyframeForTime:time value:@(alpha) withEasingFunction:easingFunction];\n}\n\n- (BOOL)validAlpha:(CGFloat)alpha\n{\n    NSAssert((alpha >= 0.f) && (alpha <= 1.f), @\"Alpha values must be between zero and one.\");\n    if ((alpha < 0.f) || (alpha > 1.f)) return NO;\n    return YES;\n}\n\n- (void)animate:(CGFloat)time\n{\n    if (!self.hasKeyframes) return;\n    self.view.alpha = (CGFloat)[(NSNumber *)[self valueAtTime:time] floatValue];\n}\n\n@end\n```\n\n`IFTTTAlphaAnimation` 基础自基类 `IFTTTAnimation` , 重写了对应的 \n\n``` objc\n- (void)addKeyframeForTime:(CGFloat)time value:(id<IFTTTInterpolatable>)value;\n- (void)addKeyframeForTime:(CGFloat)time value:(id<IFTTTInterpolatable>)value withEasingFunction:(IFTTTEasingFunction)easingFunction;\n- (id<IFTTTInterpolatable>)valueAtTime:(CGFloat)time;\n```\n\n这里所有的动画, 强调一个 `time - value` 键值对。 这也是关键帧动画的重点。\n\n我们需要做的, 就是维护这样一个 `keyframes (NSMutableArray)` , 里面的元素代表一个个存储了位置的时刻。\n\n以 `alpha` 动画为例, 这里的 `time` 就是对应的关键帧, `value` 就是对应的alpha值。\n\n比如: \n\n``` objc\n    IFTTTAlphaAnimation *alphaAnimation = [IFTTTAlphaAnimation animationWithView:aView];\n    [alphaAnimation addKeyframeForTime:100 alpha:0.5];\n\t.....\t\n```\n\n这里表示了在 100 帧处, 他对应的 alpha 值是 0.5。\n\n所以, 对于动画的设定, 我们需要做的就是:\n\n1. 选择动画类型。 `IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …`\n2. 添加关键帧。 `    [alphaAnimation addKeyframeForTime:100 alpha:0.5];`\n3. 把动画添加到执行者上面。 `[self.animator addAnimation:alphaAnimation];  (这个后面再介绍, 放心, so eazy~)`\n4. 抱歉, 没有了~\n\n\n\n没错, 就是这么简单。 但是这里有个疑惑, 所谓的关键帧动画, 就是我们提供足够多的关键帧, 然后去逐帧执行。 这是否意味着, 我们需要提供足够多的帧数, 来保证动画的流畅性 ?\n\n如果是这样, 那我们写出来的代码岂不是:\n\n``` objc\n    [alphaAnimation addKeyframeForTime:1 alpha:0.1];\n    [alphaAnimation addKeyframeForTime:2 alpha:0.15];\n    [alphaAnimation addKeyframeForTime:3 alpha:0.2];\n    [alphaAnimation addKeyframeForTime:4 alpha:0.25];\n........\n```\n\n![EMOJI](http://wanzao2.b0.upaiyun.com/system/pictures/599/original/%E6%82%B2%E5%82%AC8.png)\n\n\n\n**NO, NO, NO**, 前面我们已经说过了, 这很简单~ 简单意味着, 你只需要提供几个关键点的位置 (起始点, 转折点, 终点), 再设置下它们之间的过渡类型 (Linear, EaseInQuad, EaseInOutQuad…) ，然后, 动画就做完了~ 至于中间各个关键帧的值, 是怎么确定的呢 ？ 放心, `Jazzhands` 已经帮我们做好咯~\n\n``` objc\n- (id<IFTTTInterpolatable>)valueAtTime:(CGFloat)time\n{\n    NSAssert(!self.isEmpty, @\"At least one KeyFrame must be set before animation begins.\");\n    id value;\n    NSUInteger indexAfter = [self indexOfKeyframeAfterTime:time];\n    if (indexAfter == 0) {\n        value = ((IFTTTKeyframe *)self.keyframes[0]).value;\n    } else if (indexAfter < self.keyframes.count) {\n        IFTTTKeyframe *keyframeBefore = (IFTTTKeyframe *)self.keyframes[indexAfter - 1];\n        IFTTTKeyframe *keyframeAfter = (IFTTTKeyframe *)self.keyframes[indexAfter];\n        CGFloat progress = [self progressFromTime:keyframeBefore.time toTime:keyframeAfter.time atTime:time withEasingFunction:keyframeBefore.easingFunction];\n        value = [keyframeBefore.value interpolateTo:keyframeAfter.value withProgress:progress];\n    } else {\n        value = ((IFTTTKeyframe *)self.keyframes.lastObject).value;\n    }\n    return value;\n}\n```\n\n\n\n### 动画执行者\n\n动画执行者, 看着就很牛x, 然而它的实现实际上非常简单， 就几行代码。 它负责 `管理动画对象` 和 `在对应位置执行动画` 。\n\n简单来说, 就这两个方法:\n\n``` objc\n- (void)addAnimation:(id<IFTTTAnimatable>)animation\n{\n    [self.animations addObject:animation];\n}\n\n- (void)animate:(CGFloat)time\n{\n    for (id<IFTTTAnimatable> animation in self.animations) {\n        [animation animate:time];\n    }\n}\n```\n\n很简洁有没有。\n\n上文提到了 把动画添加到执行者上面。 `[self.animator addAnimation:alphaAnimation];`\n\n这也就是 `IFTTTAnimator` 的第一个作用, 管理动画对象。animations(NSMutableArray) 里面存储着所有设定的动画。\n\n\n\n然后 `[self.animator animate:0];` 就是执行对应的动画了。 这个方法就是在交互的时候, 调用。比如:\n\n``` objc\n// 滚动视图\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n{\n  [super scrollViewDidScroll:scrollView];\n  [self.animator animate:scrollView.contentOffset.x];\n}\n\n// 手势\n- (IBAction)handlePan:(UIPanGestureRecognizer *)recognizer\n{\n    [self.animator animate:[recognizer locationOfTouch:0 inView:self.view].x];\n}\n```\n\n\n\n### 控制器类型\n\n`Jazzhands` 帮我们封装好了两种控制器类型 (IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController)。 我们可以直接基于此, 做相应的动画。 这是十分方便的\b。比如官方的demo就是基于 `IFTTTAnimatedPagingScrollViewController` 来实现的。\n\n它实现了 `scrollViewDidScroll` 等方法。\n\n``` objc\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n{\n    [self updatePageOffset];\n    [self animateCurrentFrame];\n}\n```\n\n 并且把 `time` 关键帧的概念, 进一步转化为 `page` 的概念。 也就是说, 你只要指定某个动画, 它在第几个page, 第几个page存在, 各自存在什么位置即可。十分方便~\n\n``` objc\n- (void)keepView:(UIView *)view onPage:(CGFloat)page withAttribute:(IFTTTHorizontalPositionAttribute)attribute\n{\n    [self keepView:view onPage:page withAttribute:attribute offset:0.f];\n}\n```\n\n\n\n## 使用场景 (Demo)\n\n说了这么多, 想必大家对 `Jazzhands` 的实现原理都有一定了解。 那什么时候该用到它呢 ?\n\n我觉得 `引导页` 是不二选择 ~ 毕竟类似的视差动画, 在引导页的应用是最广的。\n\n至于是否需要基于封装好的控制器来实现, 这就要根据具体的需求来定了。\n\n比如官方Demo这样, 所有动画, 在相同的关键帧位置, 有重叠部分。(两个page 可以同时存在), 那基于 `IFTTTAnimatedPagingScrollViewController` 再合适不过了。\n\n\n\n不过如果动画有阻尼效果, 也就是当前界面只能存在一个page, 那就建议直接用 `UIViewController` 撸, 然后借助 `手势` , 来实现对应的效果。\n\n比如可以仿照下美图秀秀的引导页, 写个简单demo, 效果如下:\n\n![MTXX_DEMO](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/JazzhandsunityResult2.gif)\n\n\n\n具体 源码 就不上传了。 相信大家利用 Jazzhands 不难做出类似的效果。(有需要的可以私下交流~)\n\n\n\n## 总结\n\n总体来说, 这个开源库还是非常精简，而且思路非常清晰，依然基于Core Animation之上，因为它只是针对于UIKit上去做帧的配置，对帧的封装上更加灵活，但是缺点是实现复杂的动画时，代码量比较大。另外布局约束呢, 都得手撸,,\n\n还是很赞的~ \n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/801/original/%E9%87%91%E5%A4%A7%E7%88%B721.jpg)\n\n","source":"_posts/Interactive-animation-is-so-simple.md","raw":"layout: 'iOS开发小记'\n\ntitle: Jazzhands, 交互动画就是这么简单\n\ndate: 2016-03-16 17:11:00\n\ntags:\n\n- iOS开发\n- 教程\n\n------\n\n>  [Jazz Hands](https://github.com/IFTTT/JazzHands)是IFTTT发布的一个基于关键帧的动画框架, 可以用于手势，滚动视图，KVO或者ReactiveCocoa, 十分方便。\n\nbut, 到底有多方便呢 ?\n\n看看官方给出的一个demo效果:\n\n![Jazzhandsjazzhands-demo](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhandsjazzhands-demo.gif)\n\n<!--more-->\n\n如果 `设计` 要你做出这样一个效果的引导页, 有没有觉得头大 ?\n\n![emoji](http://wanzao2.b0.upaiyun.com/system/pictures/54/original/8.png)\n\n然而, 在 `Jazzhands` 里, 我们需要做的, 就是规划好各个组件需要展示的时机以及对应的位置。中间的衔接动画, 完全交给 `Jazzhands` 去处理。 这样的感觉很爽有没有~ \n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/789/original/%E9%87%91%E5%A4%A7%E7%88%B79.jpg)\n\n\n\n然而, `Jazzhands` 具体为我们做了什么, 它是怎么做的 ?  它适用于哪些场景 ? 下文我们一一分析~\n\n\n\n## Jazzhands原理分析\n\n先看一下源工程目录: \n\n![](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhands_1.png)\n\n\n\n这一大串看下来, 貌似很复杂, 实则不然。\n\n我们可以简单的归为 三大类 文件来看。\n\n1. `IFTTTAnimation, IFTTTAnimatable, IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …`  之类的动画类型。\n2. `IFTTTAnimator` 动画执行者\n3. `IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController` 封装好的控制器类型。\n\n\n\n### 动画类型\n\n动画类型, 我们拿最简单的  `alpha` 变化动画来分析。 \n\n`IFTTTAlphaAnimation.m`\n\n``` objc\n//\n//  IFTTTAlphaAnimation.m\n//  JazzHands\n//\n//  Created by Devin Foley on 9/27/13.\n//  Copyright (c) 2013 IFTTT Inc. All rights reserved.\n//\n\n#import \"IFTTTAlphaAnimation.h\"\n\n@implementation IFTTTAlphaAnimation\n\n- (void)addKeyframeForTime:(CGFloat)time alpha:(CGFloat)alpha\n{\n    if (![self validAlpha:alpha]) return;\n    [self addKeyframeForTime:time value:@(alpha)];\n}\n\n- (void)addKeyframeForTime:(CGFloat)time alpha:(CGFloat)alpha withEasingFunction:(IFTTTEasingFunction)easingFunction\n{\n    if (![self validAlpha:alpha]) return;\n    [self addKeyframeForTime:time value:@(alpha) withEasingFunction:easingFunction];\n}\n\n- (BOOL)validAlpha:(CGFloat)alpha\n{\n    NSAssert((alpha >= 0.f) && (alpha <= 1.f), @\"Alpha values must be between zero and one.\");\n    if ((alpha < 0.f) || (alpha > 1.f)) return NO;\n    return YES;\n}\n\n- (void)animate:(CGFloat)time\n{\n    if (!self.hasKeyframes) return;\n    self.view.alpha = (CGFloat)[(NSNumber *)[self valueAtTime:time] floatValue];\n}\n\n@end\n```\n\n`IFTTTAlphaAnimation` 基础自基类 `IFTTTAnimation` , 重写了对应的 \n\n``` objc\n- (void)addKeyframeForTime:(CGFloat)time value:(id<IFTTTInterpolatable>)value;\n- (void)addKeyframeForTime:(CGFloat)time value:(id<IFTTTInterpolatable>)value withEasingFunction:(IFTTTEasingFunction)easingFunction;\n- (id<IFTTTInterpolatable>)valueAtTime:(CGFloat)time;\n```\n\n这里所有的动画, 强调一个 `time - value` 键值对。 这也是关键帧动画的重点。\n\n我们需要做的, 就是维护这样一个 `keyframes (NSMutableArray)` , 里面的元素代表一个个存储了位置的时刻。\n\n以 `alpha` 动画为例, 这里的 `time` 就是对应的关键帧, `value` 就是对应的alpha值。\n\n比如: \n\n``` objc\n    IFTTTAlphaAnimation *alphaAnimation = [IFTTTAlphaAnimation animationWithView:aView];\n    [alphaAnimation addKeyframeForTime:100 alpha:0.5];\n\t.....\t\n```\n\n这里表示了在 100 帧处, 他对应的 alpha 值是 0.5。\n\n所以, 对于动画的设定, 我们需要做的就是:\n\n1. 选择动画类型。 `IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …`\n2. 添加关键帧。 `    [alphaAnimation addKeyframeForTime:100 alpha:0.5];`\n3. 把动画添加到执行者上面。 `[self.animator addAnimation:alphaAnimation];  (这个后面再介绍, 放心, so eazy~)`\n4. 抱歉, 没有了~\n\n\n\n没错, 就是这么简单。 但是这里有个疑惑, 所谓的关键帧动画, 就是我们提供足够多的关键帧, 然后去逐帧执行。 这是否意味着, 我们需要提供足够多的帧数, 来保证动画的流畅性 ?\n\n如果是这样, 那我们写出来的代码岂不是:\n\n``` objc\n    [alphaAnimation addKeyframeForTime:1 alpha:0.1];\n    [alphaAnimation addKeyframeForTime:2 alpha:0.15];\n    [alphaAnimation addKeyframeForTime:3 alpha:0.2];\n    [alphaAnimation addKeyframeForTime:4 alpha:0.25];\n........\n```\n\n![EMOJI](http://wanzao2.b0.upaiyun.com/system/pictures/599/original/%E6%82%B2%E5%82%AC8.png)\n\n\n\n**NO, NO, NO**, 前面我们已经说过了, 这很简单~ 简单意味着, 你只需要提供几个关键点的位置 (起始点, 转折点, 终点), 再设置下它们之间的过渡类型 (Linear, EaseInQuad, EaseInOutQuad…) ，然后, 动画就做完了~ 至于中间各个关键帧的值, 是怎么确定的呢 ？ 放心, `Jazzhands` 已经帮我们做好咯~\n\n``` objc\n- (id<IFTTTInterpolatable>)valueAtTime:(CGFloat)time\n{\n    NSAssert(!self.isEmpty, @\"At least one KeyFrame must be set before animation begins.\");\n    id value;\n    NSUInteger indexAfter = [self indexOfKeyframeAfterTime:time];\n    if (indexAfter == 0) {\n        value = ((IFTTTKeyframe *)self.keyframes[0]).value;\n    } else if (indexAfter < self.keyframes.count) {\n        IFTTTKeyframe *keyframeBefore = (IFTTTKeyframe *)self.keyframes[indexAfter - 1];\n        IFTTTKeyframe *keyframeAfter = (IFTTTKeyframe *)self.keyframes[indexAfter];\n        CGFloat progress = [self progressFromTime:keyframeBefore.time toTime:keyframeAfter.time atTime:time withEasingFunction:keyframeBefore.easingFunction];\n        value = [keyframeBefore.value interpolateTo:keyframeAfter.value withProgress:progress];\n    } else {\n        value = ((IFTTTKeyframe *)self.keyframes.lastObject).value;\n    }\n    return value;\n}\n```\n\n\n\n### 动画执行者\n\n动画执行者, 看着就很牛x, 然而它的实现实际上非常简单， 就几行代码。 它负责 `管理动画对象` 和 `在对应位置执行动画` 。\n\n简单来说, 就这两个方法:\n\n``` objc\n- (void)addAnimation:(id<IFTTTAnimatable>)animation\n{\n    [self.animations addObject:animation];\n}\n\n- (void)animate:(CGFloat)time\n{\n    for (id<IFTTTAnimatable> animation in self.animations) {\n        [animation animate:time];\n    }\n}\n```\n\n很简洁有没有。\n\n上文提到了 把动画添加到执行者上面。 `[self.animator addAnimation:alphaAnimation];`\n\n这也就是 `IFTTTAnimator` 的第一个作用, 管理动画对象。animations(NSMutableArray) 里面存储着所有设定的动画。\n\n\n\n然后 `[self.animator animate:0];` 就是执行对应的动画了。 这个方法就是在交互的时候, 调用。比如:\n\n``` objc\n// 滚动视图\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n{\n  [super scrollViewDidScroll:scrollView];\n  [self.animator animate:scrollView.contentOffset.x];\n}\n\n// 手势\n- (IBAction)handlePan:(UIPanGestureRecognizer *)recognizer\n{\n    [self.animator animate:[recognizer locationOfTouch:0 inView:self.view].x];\n}\n```\n\n\n\n### 控制器类型\n\n`Jazzhands` 帮我们封装好了两种控制器类型 (IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController)。 我们可以直接基于此, 做相应的动画。 这是十分方便的\b。比如官方的demo就是基于 `IFTTTAnimatedPagingScrollViewController` 来实现的。\n\n它实现了 `scrollViewDidScroll` 等方法。\n\n``` objc\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n{\n    [self updatePageOffset];\n    [self animateCurrentFrame];\n}\n```\n\n 并且把 `time` 关键帧的概念, 进一步转化为 `page` 的概念。 也就是说, 你只要指定某个动画, 它在第几个page, 第几个page存在, 各自存在什么位置即可。十分方便~\n\n``` objc\n- (void)keepView:(UIView *)view onPage:(CGFloat)page withAttribute:(IFTTTHorizontalPositionAttribute)attribute\n{\n    [self keepView:view onPage:page withAttribute:attribute offset:0.f];\n}\n```\n\n\n\n## 使用场景 (Demo)\n\n说了这么多, 想必大家对 `Jazzhands` 的实现原理都有一定了解。 那什么时候该用到它呢 ?\n\n我觉得 `引导页` 是不二选择 ~ 毕竟类似的视差动画, 在引导页的应用是最广的。\n\n至于是否需要基于封装好的控制器来实现, 这就要根据具体的需求来定了。\n\n比如官方Demo这样, 所有动画, 在相同的关键帧位置, 有重叠部分。(两个page 可以同时存在), 那基于 `IFTTTAnimatedPagingScrollViewController` 再合适不过了。\n\n\n\n不过如果动画有阻尼效果, 也就是当前界面只能存在一个page, 那就建议直接用 `UIViewController` 撸, 然后借助 `手势` , 来实现对应的效果。\n\n比如可以仿照下美图秀秀的引导页, 写个简单demo, 效果如下:\n\n![MTXX_DEMO](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/JazzhandsunityResult2.gif)\n\n\n\n具体 源码 就不上传了。 相信大家利用 Jazzhands 不难做出类似的效果。(有需要的可以私下交流~)\n\n\n\n## 总结\n\n总体来说, 这个开源库还是非常精简，而且思路非常清晰，依然基于Core Animation之上，因为它只是针对于UIKit上去做帧的配置，对帧的封装上更加灵活，但是缺点是实现复杂的动画时，代码量比较大。另外布局约束呢, 都得手撸,,\n\n还是很赞的~ \n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/801/original/%E9%87%91%E5%A4%A7%E7%88%B721.jpg)\n\n","slug":"Interactive-animation-is-so-simple","published":1,"updated":"2019-12-23T01:02:31.285Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1ms001azwlnf3g1tl6r","content":"<blockquote>\n<p> <a href=\"https://github.com/IFTTT/JazzHands\" target=\"_blank\" rel=\"external\">Jazz Hands</a>是IFTTT发布的一个基于关键帧的动画框架, 可以用于手势，滚动视图，KVO或者ReactiveCocoa, 十分方便。</p>\n</blockquote>\n<p>but, 到底有多方便呢 ?</p>\n<p>看看官方给出的一个demo效果:</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhandsjazzhands-demo.gif\" alt=\"Jazzhandsjazzhands-demo\"></p>\n<a id=\"more\"></a>\n<p>如果 <code>设计</code> 要你做出这样一个效果的引导页, 有没有觉得头大 ?</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/54/original/8.png\" alt=\"emoji\"></p>\n<p>然而, 在 <code>Jazzhands</code> 里, 我们需要做的, 就是规划好各个组件需要展示的时机以及对应的位置。中间的衔接动画, 完全交给 <code>Jazzhands</code> 去处理。 这样的感觉很爽有没有~ </p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/789/original/%E9%87%91%E5%A4%A7%E7%88%B79.jpg\" alt=\"\"></p>\n<p>然而, <code>Jazzhands</code> 具体为我们做了什么, 它是怎么做的 ?  它适用于哪些场景 ? 下文我们一一分析~</p>\n<h2 id=\"Jazzhands原理分析\">Jazzhands原理分析</h2><p>先看一下源工程目录: </p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhands_1.png\" alt=\"\"></p>\n<p>这一大串看下来, 貌似很复杂, 实则不然。</p>\n<p>我们可以简单的归为 三大类 文件来看。</p>\n<ol>\n<li><code>IFTTTAnimation, IFTTTAnimatable, IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …</code>  之类的动画类型。</li>\n<li><code>IFTTTAnimator</code> 动画执行者</li>\n<li><code>IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController</code> 封装好的控制器类型。</li>\n</ol>\n<h3 id=\"动画类型\">动画类型</h3><p>动画类型, 我们拿最简单的  <code>alpha</code> 变化动画来分析。 </p>\n<p><code>IFTTTAlphaAnimation.m</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  IFTTTAlphaAnimation.m</span></span><br><span class=\"line\"><span class=\"comment\">//  JazzHands</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Created by Devin Foley on 9/27/13.</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright (c) 2013 IFTTT Inc. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"IFTTTAlphaAnimation.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">IFTTTAlphaAnimation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time alpha:(<span class=\"built_in\">CGFloat</span>)alpha</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> validAlpha:alpha]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addKeyframeForTime:time value:@(alpha)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time alpha:(<span class=\"built_in\">CGFloat</span>)alpha withEasingFunction:(IFTTTEasingFunction)easingFunction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> validAlpha:alpha]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addKeyframeForTime:time value:@(alpha) withEasingFunction:easingFunction];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)validAlpha:(<span class=\"built_in\">CGFloat</span>)alpha</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>((alpha &gt;= <span class=\"number\">0.</span>f) &amp;&amp; (alpha &lt;= <span class=\"number\">1.</span>f), <span class=\"string\">@\"Alpha values must be between zero and one.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((alpha &lt; <span class=\"number\">0.</span>f) || (alpha &gt; <span class=\"number\">1.</span>f)) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)animate:(<span class=\"built_in\">CGFloat</span>)time</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.hasKeyframes) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.view.alpha = (<span class=\"built_in\">CGFloat</span>)[(<span class=\"built_in\">NSNumber</span> *)[<span class=\"keyword\">self</span> valueAtTime:time] floatValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>IFTTTAlphaAnimation</code> 基础自基类 <code>IFTTTAnimation</code> , 重写了对应的 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time value:(<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)value;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time value:(<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)value withEasingFunction:(IFTTTEasingFunction)easingFunction;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)valueAtTime:(<span class=\"built_in\">CGFloat</span>)time;</span><br></pre></td></tr></table></figure>\n<p>这里所有的动画, 强调一个 <code>time - value</code> 键值对。 这也是关键帧动画的重点。</p>\n<p>我们需要做的, 就是维护这样一个 <code>keyframes (NSMutableArray)</code> , 里面的元素代表一个个存储了位置的时刻。</p>\n<p>以 <code>alpha</code> 动画为例, 这里的 <code>time</code> 就是对应的关键帧, <code>value</code> 就是对应的alpha值。</p>\n<p>比如: </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   IFTTTAlphaAnimation *alphaAnimation = [IFTTTAlphaAnimation animationWithView:aView];</span><br><span class=\"line\">   [alphaAnimation addKeyframeForTime:<span class=\"number\">100</span> alpha:<span class=\"number\">0.5</span>];</span><br><span class=\"line\">.....</span><br></pre></td></tr></table></figure>\n<p>这里表示了在 100 帧处, 他对应的 alpha 值是 0.5。</p>\n<p>所以, 对于动画的设定, 我们需要做的就是:</p>\n<ol>\n<li>选择动画类型。 <code>IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …</code></li>\n<li>添加关键帧。 <code>[alphaAnimation addKeyframeForTime:100 alpha:0.5];</code></li>\n<li>把动画添加到执行者上面。 <code>[self.animator addAnimation:alphaAnimation];  (这个后面再介绍, 放心, so eazy~)</code></li>\n<li>抱歉, 没有了~</li>\n</ol>\n<p>没错, 就是这么简单。 但是这里有个疑惑, 所谓的关键帧动画, 就是我们提供足够多的关键帧, 然后去逐帧执行。 这是否意味着, 我们需要提供足够多的帧数, 来保证动画的流畅性 ?</p>\n<p>如果是这样, 那我们写出来的代码岂不是:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">1</span> alpha:<span class=\"number\">0.1</span>];</span><br><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">2</span> alpha:<span class=\"number\">0.15</span>];</span><br><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">3</span> alpha:<span class=\"number\">0.2</span>];</span><br><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">4</span> alpha:<span class=\"number\">0.25</span>];</span><br><span class=\"line\">........</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/599/original/%E6%82%B2%E5%82%AC8.png\" alt=\"EMOJI\"></p>\n<p><strong>NO, NO, NO</strong>, 前面我们已经说过了, 这很简单~ 简单意味着, 你只需要提供几个关键点的位置 (起始点, 转折点, 终点), 再设置下它们之间的过渡类型 (Linear, EaseInQuad, EaseInOutQuad…) ，然后, 动画就做完了~ 至于中间各个关键帧的值, 是怎么确定的呢 ？ 放心, <code>Jazzhands</code> 已经帮我们做好咯~</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)valueAtTime:(<span class=\"built_in\">CGFloat</span>)time</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(!<span class=\"keyword\">self</span>.isEmpty, <span class=\"string\">@\"At least one KeyFrame must be set before animation begins.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">id</span> value;</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> indexAfter = [<span class=\"keyword\">self</span> indexOfKeyframeAfterTime:time];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (indexAfter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        value = ((IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes[<span class=\"number\">0</span>]).value;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (indexAfter &lt; <span class=\"keyword\">self</span>.keyframes.count) &#123;</span><br><span class=\"line\">        IFTTTKeyframe *keyframeBefore = (IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes[indexAfter - <span class=\"number\">1</span>];</span><br><span class=\"line\">        IFTTTKeyframe *keyframeAfter = (IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes[indexAfter];</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> progress = [<span class=\"keyword\">self</span> progressFromTime:keyframeBefore.time toTime:keyframeAfter.time atTime:time withEasingFunction:keyframeBefore.easingFunction];</span><br><span class=\"line\">        value = [keyframeBefore.value interpolateTo:keyframeAfter.value withProgress:progress];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        value = ((IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes.lastObject).value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动画执行者\">动画执行者</h3><p>动画执行者, 看着就很牛x, 然而它的实现实际上非常简单， 就几行代码。 它负责 <code>管理动画对象</code> 和 <code>在对应位置执行动画</code> 。</p>\n<p>简单来说, 就这两个方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addAnimation:(<span class=\"keyword\">id</span>&lt;IFTTTAnimatable&gt;)animation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.animations addObject:animation];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)animate:(<span class=\"built_in\">CGFloat</span>)time</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span>&lt;IFTTTAnimatable&gt; animation <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.animations) &#123;</span><br><span class=\"line\">        [animation animate:time];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简洁有没有。</p>\n<p>上文提到了 把动画添加到执行者上面。 <code>[self.animator addAnimation:alphaAnimation];</code></p>\n<p>这也就是 <code>IFTTTAnimator</code> 的第一个作用, 管理动画对象。animations(NSMutableArray) 里面存储着所有设定的动画。</p>\n<p>然后 <code>[self.animator animate:0];</code> 就是执行对应的动画了。 这个方法就是在交互的时候, 调用。比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 滚动视图</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [<span class=\"keyword\">super</span> scrollViewDidScroll:scrollView];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.animator animate:scrollView.contentOffset.x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手势</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)handlePan:(<span class=\"built_in\">UIPanGestureRecognizer</span> *)recognizer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.animator animate:[recognizer locationOfTouch:<span class=\"number\">0</span> inView:<span class=\"keyword\">self</span>.view].x];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"控制器类型\">控制器类型</h3><p><code>Jazzhands</code> 帮我们封装好了两种控制器类型 (IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController)。 我们可以直接基于此, 做相应的动画。 这是十分方便的\b。比如官方的demo就是基于 <code>IFTTTAnimatedPagingScrollViewController</code> 来实现的。</p>\n<p>它实现了 <code>scrollViewDidScroll</code> 等方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updatePageOffset];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> animateCurrentFrame];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 并且把 <code>time</code> 关键帧的概念, 进一步转化为 <code>page</code> 的概念。 也就是说, 你只要指定某个动画, 它在第几个page, 第几个page存在, 各自存在什么位置即可。十分方便~</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)keepView:(<span class=\"built_in\">UIView</span> *)view onPage:(<span class=\"built_in\">CGFloat</span>)page withAttribute:(IFTTTHorizontalPositionAttribute)attribute</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> keepView:view onPage:page withAttribute:attribute offset:<span class=\"number\">0.</span>f];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用场景_(Demo)\">使用场景 (Demo)</h2><p>说了这么多, 想必大家对 <code>Jazzhands</code> 的实现原理都有一定了解。 那什么时候该用到它呢 ?</p>\n<p>我觉得 <code>引导页</code> 是不二选择 ~ 毕竟类似的视差动画, 在引导页的应用是最广的。</p>\n<p>至于是否需要基于封装好的控制器来实现, 这就要根据具体的需求来定了。</p>\n<p>比如官方Demo这样, 所有动画, 在相同的关键帧位置, 有重叠部分。(两个page 可以同时存在), 那基于 <code>IFTTTAnimatedPagingScrollViewController</code> 再合适不过了。</p>\n<p>不过如果动画有阻尼效果, 也就是当前界面只能存在一个page, 那就建议直接用 <code>UIViewController</code> 撸, 然后借助 <code>手势</code> , 来实现对应的效果。</p>\n<p>比如可以仿照下美图秀秀的引导页, 写个简单demo, 效果如下:</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/JazzhandsunityResult2.gif\" alt=\"MTXX_DEMO\"></p>\n<p>具体 源码 就不上传了。 相信大家利用 Jazzhands 不难做出类似的效果。(有需要的可以私下交流~)</p>\n<h2 id=\"总结\">总结</h2><p>总体来说, 这个开源库还是非常精简，而且思路非常清晰，依然基于Core Animation之上，因为它只是针对于UIKit上去做帧的配置，对帧的封装上更加灵活，但是缺点是实现复杂的动画时，代码量比较大。另外布局约束呢, 都得手撸,,</p>\n<p>还是很赞的~ </p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/801/original/%E9%87%91%E5%A4%A7%E7%88%B721.jpg\" alt=\"\"></p>\n","excerpt":"<blockquote>\n<p> <a href=\"https://github.com/IFTTT/JazzHands\">Jazz Hands</a>是IFTTT发布的一个基于关键帧的动画框架, 可以用于手势，滚动视图，KVO或者ReactiveCocoa, 十分方便。</p>\n</blockquote>\n<p>but, 到底有多方便呢 ?</p>\n<p>看看官方给出的一个demo效果:</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhandsjazzhands-demo.gif\" alt=\"Jazzhandsjazzhands-demo\"></p>","more":"<p>如果 <code>设计</code> 要你做出这样一个效果的引导页, 有没有觉得头大 ?</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/54/original/8.png\" alt=\"emoji\"></p>\n<p>然而, 在 <code>Jazzhands</code> 里, 我们需要做的, 就是规划好各个组件需要展示的时机以及对应的位置。中间的衔接动画, 完全交给 <code>Jazzhands</code> 去处理。 这样的感觉很爽有没有~ </p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/789/original/%E9%87%91%E5%A4%A7%E7%88%B79.jpg\" alt=\"\"></p>\n<p>然而, <code>Jazzhands</code> 具体为我们做了什么, 它是怎么做的 ?  它适用于哪些场景 ? 下文我们一一分析~</p>\n<h2 id=\"Jazzhands原理分析\">Jazzhands原理分析</h2><p>先看一下源工程目录: </p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/Jazzhands_1.png\" alt=\"\"></p>\n<p>这一大串看下来, 貌似很复杂, 实则不然。</p>\n<p>我们可以简单的归为 三大类 文件来看。</p>\n<ol>\n<li><code>IFTTTAnimation, IFTTTAnimatable, IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …</code>  之类的动画类型。</li>\n<li><code>IFTTTAnimator</code> 动画执行者</li>\n<li><code>IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController</code> 封装好的控制器类型。</li>\n</ol>\n<h3 id=\"动画类型\">动画类型</h3><p>动画类型, 我们拿最简单的  <code>alpha</code> 变化动画来分析。 </p>\n<p><code>IFTTTAlphaAnimation.m</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  IFTTTAlphaAnimation.m</span></span><br><span class=\"line\"><span class=\"comment\">//  JazzHands</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Created by Devin Foley on 9/27/13.</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright (c) 2013 IFTTT Inc. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"IFTTTAlphaAnimation.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">IFTTTAlphaAnimation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time alpha:(<span class=\"built_in\">CGFloat</span>)alpha</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> validAlpha:alpha]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addKeyframeForTime:time value:@(alpha)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time alpha:(<span class=\"built_in\">CGFloat</span>)alpha withEasingFunction:(IFTTTEasingFunction)easingFunction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> validAlpha:alpha]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addKeyframeForTime:time value:@(alpha) withEasingFunction:easingFunction];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)validAlpha:(<span class=\"built_in\">CGFloat</span>)alpha</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>((alpha &gt;= <span class=\"number\">0.</span>f) &amp;&amp; (alpha &lt;= <span class=\"number\">1.</span>f), <span class=\"string\">@\"Alpha values must be between zero and one.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((alpha &lt; <span class=\"number\">0.</span>f) || (alpha &gt; <span class=\"number\">1.</span>f)) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)animate:(<span class=\"built_in\">CGFloat</span>)time</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.hasKeyframes) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.view.alpha = (<span class=\"built_in\">CGFloat</span>)[(<span class=\"built_in\">NSNumber</span> *)[<span class=\"keyword\">self</span> valueAtTime:time] floatValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>IFTTTAlphaAnimation</code> 基础自基类 <code>IFTTTAnimation</code> , 重写了对应的 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time value:(<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)value;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addKeyframeForTime:(<span class=\"built_in\">CGFloat</span>)time value:(<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)value withEasingFunction:(IFTTTEasingFunction)easingFunction;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)valueAtTime:(<span class=\"built_in\">CGFloat</span>)time;</span><br></pre></td></tr></table></figure>\n<p>这里所有的动画, 强调一个 <code>time - value</code> 键值对。 这也是关键帧动画的重点。</p>\n<p>我们需要做的, 就是维护这样一个 <code>keyframes (NSMutableArray)</code> , 里面的元素代表一个个存储了位置的时刻。</p>\n<p>以 <code>alpha</code> 动画为例, 这里的 <code>time</code> 就是对应的关键帧, <code>value</code> 就是对应的alpha值。</p>\n<p>比如: </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   IFTTTAlphaAnimation *alphaAnimation = [IFTTTAlphaAnimation animationWithView:aView];</span><br><span class=\"line\">   [alphaAnimation addKeyframeForTime:<span class=\"number\">100</span> alpha:<span class=\"number\">0.5</span>];</span><br><span class=\"line\">.....</span><br></pre></td></tr></table></figure>\n<p>这里表示了在 100 帧处, 他对应的 alpha 值是 0.5。</p>\n<p>所以, 对于动画的设定, 我们需要做的就是:</p>\n<ol>\n<li>选择动画类型。 <code>IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …</code></li>\n<li>添加关键帧。 <code>[alphaAnimation addKeyframeForTime:100 alpha:0.5];</code></li>\n<li>把动画添加到执行者上面。 <code>[self.animator addAnimation:alphaAnimation];  (这个后面再介绍, 放心, so eazy~)</code></li>\n<li>抱歉, 没有了~</li>\n</ol>\n<p>没错, 就是这么简单。 但是这里有个疑惑, 所谓的关键帧动画, 就是我们提供足够多的关键帧, 然后去逐帧执行。 这是否意味着, 我们需要提供足够多的帧数, 来保证动画的流畅性 ?</p>\n<p>如果是这样, 那我们写出来的代码岂不是:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">1</span> alpha:<span class=\"number\">0.1</span>];</span><br><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">2</span> alpha:<span class=\"number\">0.15</span>];</span><br><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">3</span> alpha:<span class=\"number\">0.2</span>];</span><br><span class=\"line\">    [alphaAnimation addKeyframeForTime:<span class=\"number\">4</span> alpha:<span class=\"number\">0.25</span>];</span><br><span class=\"line\">........</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/599/original/%E6%82%B2%E5%82%AC8.png\" alt=\"EMOJI\"></p>\n<p><strong>NO, NO, NO</strong>, 前面我们已经说过了, 这很简单~ 简单意味着, 你只需要提供几个关键点的位置 (起始点, 转折点, 终点), 再设置下它们之间的过渡类型 (Linear, EaseInQuad, EaseInOutQuad…) ，然后, 动画就做完了~ 至于中间各个关键帧的值, 是怎么确定的呢 ？ 放心, <code>Jazzhands</code> 已经帮我们做好咯~</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>&lt;IFTTTInterpolatable&gt;)valueAtTime:(<span class=\"built_in\">CGFloat</span>)time</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(!<span class=\"keyword\">self</span>.isEmpty, <span class=\"string\">@\"At least one KeyFrame must be set before animation begins.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">id</span> value;</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> indexAfter = [<span class=\"keyword\">self</span> indexOfKeyframeAfterTime:time];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (indexAfter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        value = ((IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes[<span class=\"number\">0</span>]).value;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (indexAfter &lt; <span class=\"keyword\">self</span>.keyframes.count) &#123;</span><br><span class=\"line\">        IFTTTKeyframe *keyframeBefore = (IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes[indexAfter - <span class=\"number\">1</span>];</span><br><span class=\"line\">        IFTTTKeyframe *keyframeAfter = (IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes[indexAfter];</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> progress = [<span class=\"keyword\">self</span> progressFromTime:keyframeBefore.time toTime:keyframeAfter.time atTime:time withEasingFunction:keyframeBefore.easingFunction];</span><br><span class=\"line\">        value = [keyframeBefore.value interpolateTo:keyframeAfter.value withProgress:progress];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        value = ((IFTTTKeyframe *)<span class=\"keyword\">self</span>.keyframes.lastObject).value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动画执行者\">动画执行者</h3><p>动画执行者, 看着就很牛x, 然而它的实现实际上非常简单， 就几行代码。 它负责 <code>管理动画对象</code> 和 <code>在对应位置执行动画</code> 。</p>\n<p>简单来说, 就这两个方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addAnimation:(<span class=\"keyword\">id</span>&lt;IFTTTAnimatable&gt;)animation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.animations addObject:animation];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)animate:(<span class=\"built_in\">CGFloat</span>)time</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span>&lt;IFTTTAnimatable&gt; animation <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.animations) &#123;</span><br><span class=\"line\">        [animation animate:time];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简洁有没有。</p>\n<p>上文提到了 把动画添加到执行者上面。 <code>[self.animator addAnimation:alphaAnimation];</code></p>\n<p>这也就是 <code>IFTTTAnimator</code> 的第一个作用, 管理动画对象。animations(NSMutableArray) 里面存储着所有设定的动画。</p>\n<p>然后 <code>[self.animator animate:0];</code> 就是执行对应的动画了。 这个方法就是在交互的时候, 调用。比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 滚动视图</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [<span class=\"keyword\">super</span> scrollViewDidScroll:scrollView];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.animator animate:scrollView.contentOffset.x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手势</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)handlePan:(<span class=\"built_in\">UIPanGestureRecognizer</span> *)recognizer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.animator animate:[recognizer locationOfTouch:<span class=\"number\">0</span> inView:<span class=\"keyword\">self</span>.view].x];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"控制器类型\">控制器类型</h3><p><code>Jazzhands</code> 帮我们封装好了两种控制器类型 (IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController)。 我们可以直接基于此, 做相应的动画。 这是十分方便的\b。比如官方的demo就是基于 <code>IFTTTAnimatedPagingScrollViewController</code> 来实现的。</p>\n<p>它实现了 <code>scrollViewDidScroll</code> 等方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updatePageOffset];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> animateCurrentFrame];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 并且把 <code>time</code> 关键帧的概念, 进一步转化为 <code>page</code> 的概念。 也就是说, 你只要指定某个动画, 它在第几个page, 第几个page存在, 各自存在什么位置即可。十分方便~</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)keepView:(<span class=\"built_in\">UIView</span> *)view onPage:(<span class=\"built_in\">CGFloat</span>)page withAttribute:(IFTTTHorizontalPositionAttribute)attribute</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> keepView:view onPage:page withAttribute:attribute offset:<span class=\"number\">0.</span>f];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用场景_(Demo)\">使用场景 (Demo)</h2><p>说了这么多, 想必大家对 <code>Jazzhands</code> 的实现原理都有一定了解。 那什么时候该用到它呢 ?</p>\n<p>我觉得 <code>引导页</code> 是不二选择 ~ 毕竟类似的视差动画, 在引导页的应用是最广的。</p>\n<p>至于是否需要基于封装好的控制器来实现, 这就要根据具体的需求来定了。</p>\n<p>比如官方Demo这样, 所有动画, 在相同的关键帧位置, 有重叠部分。(两个page 可以同时存在), 那基于 <code>IFTTTAnimatedPagingScrollViewController</code> 再合适不过了。</p>\n<p>不过如果动画有阻尼效果, 也就是当前界面只能存在一个page, 那就建议直接用 <code>UIViewController</code> 撸, 然后借助 <code>手势</code> , 来实现对应的效果。</p>\n<p>比如可以仿照下美图秀秀的引导页, 写个简单demo, 效果如下:</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/Jazzhands/JazzhandsunityResult2.gif\" alt=\"MTXX_DEMO\"></p>\n<p>具体 源码 就不上传了。 相信大家利用 Jazzhands 不难做出类似的效果。(有需要的可以私下交流~)</p>\n<h2 id=\"总结\">总结</h2><p>总体来说, 这个开源库还是非常精简，而且思路非常清晰，依然基于Core Animation之上，因为它只是针对于UIKit上去做帧的配置，对帧的封装上更加灵活，但是缺点是实现复杂的动画时，代码量比较大。另外布局约束呢, 都得手撸,,</p>\n<p>还是很赞的~ </p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/801/original/%E9%87%91%E5%A4%A7%E7%88%B721.jpg\" alt=\"\"></p>"},{"title":"OpenGL ES 环境搭建","date":"2017-04-09T06:10:10.000Z","_content":"\n在[上篇文章](http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/)中，已经介绍了 OpenGL ES 的一些基础概念以及大致工作流程。\n\n在本文中，我们将会介绍在 iOS 平台上如何接入 OpenGL ES，并搭建好基础环境，实现设置背景色功能。它是之后任何实战的基础模版。在搭建过程中，会针对之前介绍的一些概念，再结合代码讲解。\n\n> PS：这一节是 OpenGL ES 的入门，也是最重要的一部分。再绚丽的特性，都是在此基础上完成的。所以理解它是很有必要的～\n\n设置蓝色背景后，效果如下：\n\n![2017012639178QQ20170126-231448@2x.png](http://7xkc7a.com1.z0.glb.clouddn.com/2017012639178QQ20170126-231448@2x.png)\n\n<!--more-->\n\n\n\n## 0. 初始工程\n\n你可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip)下载到初始工程，避免重复实现一些和本节内容不相干的事情。\n\n在这个初始工程里面，已经实现了新建一个继承自 **UIView** 的 **GLView**，这个自定义的视图将用来显示 OpenGL ES 的渲染内容。然后在 Main.storyboard 中，将 ViewController 的 view 改成 **GLView** 类型，即可。\n\n![2017012663829D0A3C5CE-818A-4C93-8D3E-1C302E29220F.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_3_1.png)\n\n至此，我们的工作都将在 **GLView** 中展开。\n\n在 **GLView.h** 中，先声明一些将要用到的成员变量：\n\n```objc\n@interface GLView : UIView\n{\n    CAEAGLLayer *_eaglLayer;\n    EAGLContext *_context;\n    GLuint       _framebuffer;\n    GLuint       _renderbuffer;\n}\n```\n\n另外，在 **GLView.m** 中，需要导入对应的 OpenGLES 框架（framework），如下：\n\n```objc\n@import OpenGLES;\n```\n\n> PS：\n>\n> `@import `是 iOS 7 之后的新特性语法，这种方式叫 Modules（模块导入） 或者 Semantic import（语义导入）。用这种方式，不用手动添加 framework，系统会自动帮我们 link，是一种更好的头部预处理的执行方式（相比之前的 #import）。\n>\n> - Imports complete semantic description of a framework\n> - Doesn't need to parse the headers\n> - Better way to import a framework’s interface\n> - Loads binary representation\n> - More flexible than precompiled headers\n> - Immune to effects of local macro definitions (e.g. `#define readonly 0x01`)\n> - Enabled for new projects by default\n\n\n\n## 1. CAEAGLLayer\n\nCAEAGLLayer 实现了 **EAGLDrawable** 协议，它是 Apple 专门为 OpenGL ES 准备的一个图层类。\n\n所以想要显示 OpenGL ES 的内容，需要把它默认的 layer 设置为一个特殊的 layer（**CAEAGLLayer**），我们简单的重写 `layerClass` 即可：\n\n```objc\n+ (Class)layerClass {\n    return [CAEAGLLayer class];\n}\n```\n\n另外，为了方便起见，我们使 **_eaglLayer** 这个成员变量指代 **self.layer**，这样除了调用上方便外，可读性也更好。\n\n```objc\n- (void)setupLayer {\n    // 用于显示的layer\n    _eaglLayer = (CAEAGLLayer *)self.layer;\n    \n    // CALayer 默认是透明的（opaque = NO），而透明的层对性能负荷很大。所以将其关闭。\n    _eaglLayer.opaque = YES;\n}\n```\n\n> PS：\n>\n> By default, CALayers are set to non-opaque (i.e. transparent). However, this is bad for performance reasons (especially with OpenGL), so it’s best to set this as opaque when possible.\n>\n> CAEAGLLayer: the default value of the `opaque' property in this class is true, not false as in CALayer.\n>\n> 透明对性能影响较大，CAEAGLLayer 中的 **opaque** 默认值已经是 YES 了。\n\n\n\n至此 layer 的配置已经就绪，下面创建并设置与 OpenGL ES 相关的东西。\n\n\n\n## 2. EAGLContext\n\n上篇已经提到了**上下文**概念，即 **EAGLContext** 对象，这个 context 管理所有使用 OpenGL ES 进行渲染的状态，命令以及资源信息。\n\n通过 `initWithAPI` 创建完 context，然后需要使用 `setCurrentContext` 将它设置为当前 context，因为我们之前提过，context 可以同时存在多个，需要指定当前环境对应的 context。\n\n```objc\n- (void)setupContext {\n    if (!_context) {\n        // 创建GL环境上下文\n        // EAGLContext 管理所有通过 OpenGL ES 进行渲染的信息.\n        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    }\n    \n    NSAssert(_context && [EAGLContext setCurrentContext:_context], @\"初始化GL环境失败\");\n}\n```\n\n这里的 **kEAGLRenderingAPIOpenGLES2** 即对应的 OpenGL ES 版本，它的定义如下：\n\n```objc\n/* EAGL rendering API */\ntypedef NS_ENUM(NSUInteger, EAGLRenderingAPI)\n{\n\tkEAGLRenderingAPIOpenGLES1 = 1,\n\tkEAGLRenderingAPIOpenGLES2 = 2,\n\tkEAGLRenderingAPIOpenGLES3 = 3,\n};\n```\n\n\n\n## 3. Renderbuffer\n\n有了上下文，OpenGL ES 还需要在一块 buffer 上进行渲染，这块 buffer 就是 **Renderbuffer**（OpenGL ES 总共有三大不同用途的 buffer，分别是 **color buffer，depth buffer 和 stencil buffer**，这里是最基本的 color buffer）。可以简单的把 renderbuffer 理解成用于展示的窗口。\n\n它的创建过程如下：\n\n```objc\n- (void)setupRenderBuffer {\n    // 生成 renderbuffer ( renderbuffer = 用于展示的窗口 )\n    glGenRenderbuffers(1, &_renderbuffer);\n    // 绑定 renderbuffer\n    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);\n    // GL_RENDERBUFFER 的内容存储到实现 EAGLDrawable 协议的 CAEAGLLayer\n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];\n}\n```\n\n`glGenRenderbuffers` 用于生成 renderbuffer，并分配 id。它的原型为：\n\n```c\nvoid glGenRenderbuffers (GLsizei n, GLuint* renderbuffers)\n```\n\n- n：表示申请生成 renderbuffer 的个数。\n- renderbuffers：返回分配给 renderbuffer 的 id。\n\n> PS：返回的 id 不会为 0，0 是OpenGL ES 保留的，0 则表示这个 buffer 这个不存在或者创建失败。\n\n所以，一般会通过 id 来判断某个 buffer 是否存在，执行对应的操作。比如在 gen 之前，释放旧的 renderbuffer，确保之后的操作无误。\n\n```objc\n// 释放旧的 renderbuffer\nif (_renderbuffer) {\n    glDeleteRenderbuffers(1, &_renderbuffer);\n    _renderbuffer = 0;\n}\n```\n\n`glBindRenderbuffer` 用于绑定 renderbuffer，将指定 id 的 renderbuffer 设置为当前 renderbuffer。它的原型为：\n\n```c\nvoid glBindRenderbuffer (GLenum target, GLuint renderbuffer) \n```\n\n- target：表示当前 renderbuffer，必须是 **GL_RENDERBUFFER**。\n- renderbuffer：某个 renderbuffer 对应的 id（比如使用 glGenRenderbuffers 生成的 id）。\n\n`renderbufferStorage` 用于将 GL_RENDERBUFFER 的内容存储到实现 **EAGLDrawable** 协议的 CAEAGLLayer。它的原型为：\n\n```objc\n/* Attaches an EAGLDrawable as storage for the OpenGL ES renderbuffer object bound to <target> */\n- (BOOL)renderbufferStorage:(NSUInteger)target fromDrawable:(id<EAGLDrawable>)drawable;\n```\n\n> PS：\n>\n> 这个函数内部，会使用 drawable（_eaglLayer）的相关信息（设置存储在 drawableProperties 属性中）作为参数，调用 glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);\n>\n>  `glRenderbufferStorage` 指定存储在 renderbuffer 中图像的宽高以及颜色格式，并按照此规格为之分配存储空间。\n\n至此，我们的第一个 buffer 创建完毕了。注意理解 **gen** 和 **bind** 这两个概念，它将会贯穿我们 OpenGL ES 的整个学习过程。\n\n\n\n## 4. Framebuffer\n\n接下去我们将会创建 framebuffer object，它通常也被称之为 **FBO**。\n\n我们之前提到过了，它相当于 buffer（color, depth, stencil）的管理者，三大 buffer 可以附加到一个  FBO 上。\n\n它的创建过程如下：\n\n```objc\n- (void)setupFrameBuffer {\n    // 释放旧的 framebuffer\n    if (_framebuffer) {\n        glDeleteFramebuffers(1, &_framebuffer);\n        _framebuffer = 0;\n    }\n    \n    // 生成 framebuffer ( framebuffer = 画布 )\n    glGenFramebuffers(1, &_framebuffer);\n    // 绑定 fraembuffer\n    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);\n    \n    // framebuffer 不对渲染的内容做存储, 所以这一步是将 framebuffer 绑定到 renderbuffer ( 渲染的结果就存在 renderbuffer )\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n                              GL_RENDERBUFFER, _renderbuffer);\n}\n```\n\n之前的 gen，bin 操作和 renderbuffer 中对应的都是一致的，只是做相应的替换，比如 renderbuffer 改成 framebuffer 即可，这里就不细说，重点看一下 `glFramebufferRenderbuffer`。\n\n之前说过，framebuffer 不对渲染的内容做存储，而 `glFramebufferRenderbuffer` 的作用正是将相关的 buffer（三大 buffer 之一）装配到 framebuffer 上，使得 framebuffer 能索引到对应的渲染内容。它的原型为：\n\n```c\nvoid glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)\n```\n\n- target：表示当前 framebuffer，必须是 GL_FRAMEBUFFER。\n- attachment：指定 renderbuffer 被装配到那个装配点上，其值是 GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT，GL_STENCIL_ATTACHMENT 中的一个，分别对应 color，depth 和  stencil 三大 buffer。\n- renderbuffertarget：表示当前 renderbuffer，必须是 **GL_RENDERBUFFER**。\n- renderbuffer：某个 renderbuffer 对应的 id，表示需要装配的 renderbuffer。\n\n> PS：\n>\n> 为了安全起见，可以通过 `glCheckFramebufferStatus` 来检查 framebuffer 的创建情况，并根据对应的 log，来排查错误。\n\n```objc\n- (BOOL)checkFramebuffer:(NSError *__autoreleasing *)error {\n    // 检查 framebuffer 是否创建成功\n    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n    NSString *errorMessage = nil;\n    BOOL result = NO;\n    \n    switch (status)\n    {\n        case GL_FRAMEBUFFER_UNSUPPORTED:\n            errorMessage = @\"framebuffer不支持该格式\";\n            result = NO;\n            break;\n        case GL_FRAMEBUFFER_COMPLETE:\n            NSLog(@\"framebuffer 创建成功\");\n            result = YES;\n            break;\n        case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            errorMessage = @\"Framebuffer不完整 缺失组件\";\n            result = NO;\n            break;\n        case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            errorMessage = @\"Framebuffer 不完整, 附加图片必须要指定大小\";\n            result = NO;\n            break;\n        default:\n            // 一般是超出GL纹理的最大限制\n            errorMessage = @\"未知错误 error !!!!\";\n            result = NO;\n            break;\n    }\n    \n    NSLog(@\"%@\",errorMessage ? errorMessage : @\"\");\n    *error = errorMessage ? [NSError errorWithDomain:@\"com.colin.error\"\n                                                code:status\n                                            userInfo:@{@\"ErrorMessage\" : errorMessage}] : nil;\n    \n    return result;\n}\n```\n\n\n\n至此，我们需要的环境配置以及相关 buffer 资源都已经准备好了，接下去就是渲染部分了。\n\n\n\n## 5. 最简单的渲染，设置背景色\n\n```objc\n- (void)render {\n    glClearColor(0, 1, 1, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // 做完所有绘制操作后，最终呈现到屏幕上\n    [_context presentRenderbuffer:GL_RENDERBUFFER];\n}\n```\n\n`glClearColor` 用来设置清屏颜色，它的原型为：\n\n```c\nvoid glClearColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);\n```\n\n`glClear (GLbitfield mask)` 用来指定要用清屏颜色来清除由 mask 指定的 buffer，mask 可以是 GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT 和 GL_STENCIL_BUFFER_BIT 的自由组合。\n\n在这里我们只使用到 color buffer，所以清除的就是 clolor buffer。\n\n`presentRenderbuffer` 是将指定 renderbuffer 呈现在屏幕上。\n\n> PS：\n>\n> 在此之前，建议使用 `glBindFramebuffer`，`glBindRenderbuffer` 来重新绑定当前 buffer 对象。因为 GL 的所有 API 都是基于最后一次绑定的对象作为作用对象。所以每次在修改 GL 对象时，先绑定一次要修改的对象。有很多错误是因为没有绑定或者绑定了错误的对象导致得到了错误的结果。\n\n\n\n## 6. 收工，检验\n\n至此，关于 OpenGL ES 环境搭建的相关准备东西都已就绪，接下去只要按需调用相关方法，即可。\n\n```objc\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if ((self = [super initWithCoder:aDecoder])) {\n        [self setup];\n    }\n    return self;\n}\n\n- (void)didMoveToWindow {\n    [super didMoveToWindow];\n    [self render];\n}\n\n#pragma mark - Setup\n- (void)setup {\n    [self setupLayer];\n    [self setupContext];\n    [self setupRenderBuffer];\n    [self setupFrameBuffer];\n    \n    NSError *error;\n    NSAssert1([self checkFramebuffer:&error], @\"%@\",error.userInfo[@\"ErrorMessage\"]);\n}\n```\n\n\n\n这里不出意外的话，你将会看到开头的那个纯色背景。\n\n你可能注意到了，这个过程我们并没有涉及到所谓的图形渲染管线，如果你试着使用 kEAGLRenderingAPIOpenGLES1 来创建 context，会发现这是完成可以的。\n\n\n\n最终的工程可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip)下载。有了这个基础，模版，接下去，我们将会围绕渲染管线，实现一系列的炫酷效果，一起期待吧～","source":"_posts/OpenGLES-Lesson02.md","raw":"title: OpenGL ES 环境搭建\n\ndate: 2017-04-09 14:10:10\n\ntags:\n\n- iOS开发\n- OpenGLES\n- 图像处理\n\n------\n\n在[上篇文章](http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/)中，已经介绍了 OpenGL ES 的一些基础概念以及大致工作流程。\n\n在本文中，我们将会介绍在 iOS 平台上如何接入 OpenGL ES，并搭建好基础环境，实现设置背景色功能。它是之后任何实战的基础模版。在搭建过程中，会针对之前介绍的一些概念，再结合代码讲解。\n\n> PS：这一节是 OpenGL ES 的入门，也是最重要的一部分。再绚丽的特性，都是在此基础上完成的。所以理解它是很有必要的～\n\n设置蓝色背景后，效果如下：\n\n![2017012639178QQ20170126-231448@2x.png](http://7xkc7a.com1.z0.glb.clouddn.com/2017012639178QQ20170126-231448@2x.png)\n\n<!--more-->\n\n\n\n## 0. 初始工程\n\n你可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip)下载到初始工程，避免重复实现一些和本节内容不相干的事情。\n\n在这个初始工程里面，已经实现了新建一个继承自 **UIView** 的 **GLView**，这个自定义的视图将用来显示 OpenGL ES 的渲染内容。然后在 Main.storyboard 中，将 ViewController 的 view 改成 **GLView** 类型，即可。\n\n![2017012663829D0A3C5CE-818A-4C93-8D3E-1C302E29220F.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_3_1.png)\n\n至此，我们的工作都将在 **GLView** 中展开。\n\n在 **GLView.h** 中，先声明一些将要用到的成员变量：\n\n```objc\n@interface GLView : UIView\n{\n    CAEAGLLayer *_eaglLayer;\n    EAGLContext *_context;\n    GLuint       _framebuffer;\n    GLuint       _renderbuffer;\n}\n```\n\n另外，在 **GLView.m** 中，需要导入对应的 OpenGLES 框架（framework），如下：\n\n```objc\n@import OpenGLES;\n```\n\n> PS：\n>\n> `@import `是 iOS 7 之后的新特性语法，这种方式叫 Modules（模块导入） 或者 Semantic import（语义导入）。用这种方式，不用手动添加 framework，系统会自动帮我们 link，是一种更好的头部预处理的执行方式（相比之前的 #import）。\n>\n> - Imports complete semantic description of a framework\n> - Doesn't need to parse the headers\n> - Better way to import a framework’s interface\n> - Loads binary representation\n> - More flexible than precompiled headers\n> - Immune to effects of local macro definitions (e.g. `#define readonly 0x01`)\n> - Enabled for new projects by default\n\n\n\n## 1. CAEAGLLayer\n\nCAEAGLLayer 实现了 **EAGLDrawable** 协议，它是 Apple 专门为 OpenGL ES 准备的一个图层类。\n\n所以想要显示 OpenGL ES 的内容，需要把它默认的 layer 设置为一个特殊的 layer（**CAEAGLLayer**），我们简单的重写 `layerClass` 即可：\n\n```objc\n+ (Class)layerClass {\n    return [CAEAGLLayer class];\n}\n```\n\n另外，为了方便起见，我们使 **_eaglLayer** 这个成员变量指代 **self.layer**，这样除了调用上方便外，可读性也更好。\n\n```objc\n- (void)setupLayer {\n    // 用于显示的layer\n    _eaglLayer = (CAEAGLLayer *)self.layer;\n    \n    // CALayer 默认是透明的（opaque = NO），而透明的层对性能负荷很大。所以将其关闭。\n    _eaglLayer.opaque = YES;\n}\n```\n\n> PS：\n>\n> By default, CALayers are set to non-opaque (i.e. transparent). However, this is bad for performance reasons (especially with OpenGL), so it’s best to set this as opaque when possible.\n>\n> CAEAGLLayer: the default value of the `opaque' property in this class is true, not false as in CALayer.\n>\n> 透明对性能影响较大，CAEAGLLayer 中的 **opaque** 默认值已经是 YES 了。\n\n\n\n至此 layer 的配置已经就绪，下面创建并设置与 OpenGL ES 相关的东西。\n\n\n\n## 2. EAGLContext\n\n上篇已经提到了**上下文**概念，即 **EAGLContext** 对象，这个 context 管理所有使用 OpenGL ES 进行渲染的状态，命令以及资源信息。\n\n通过 `initWithAPI` 创建完 context，然后需要使用 `setCurrentContext` 将它设置为当前 context，因为我们之前提过，context 可以同时存在多个，需要指定当前环境对应的 context。\n\n```objc\n- (void)setupContext {\n    if (!_context) {\n        // 创建GL环境上下文\n        // EAGLContext 管理所有通过 OpenGL ES 进行渲染的信息.\n        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    }\n    \n    NSAssert(_context && [EAGLContext setCurrentContext:_context], @\"初始化GL环境失败\");\n}\n```\n\n这里的 **kEAGLRenderingAPIOpenGLES2** 即对应的 OpenGL ES 版本，它的定义如下：\n\n```objc\n/* EAGL rendering API */\ntypedef NS_ENUM(NSUInteger, EAGLRenderingAPI)\n{\n\tkEAGLRenderingAPIOpenGLES1 = 1,\n\tkEAGLRenderingAPIOpenGLES2 = 2,\n\tkEAGLRenderingAPIOpenGLES3 = 3,\n};\n```\n\n\n\n## 3. Renderbuffer\n\n有了上下文，OpenGL ES 还需要在一块 buffer 上进行渲染，这块 buffer 就是 **Renderbuffer**（OpenGL ES 总共有三大不同用途的 buffer，分别是 **color buffer，depth buffer 和 stencil buffer**，这里是最基本的 color buffer）。可以简单的把 renderbuffer 理解成用于展示的窗口。\n\n它的创建过程如下：\n\n```objc\n- (void)setupRenderBuffer {\n    // 生成 renderbuffer ( renderbuffer = 用于展示的窗口 )\n    glGenRenderbuffers(1, &_renderbuffer);\n    // 绑定 renderbuffer\n    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);\n    // GL_RENDERBUFFER 的内容存储到实现 EAGLDrawable 协议的 CAEAGLLayer\n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];\n}\n```\n\n`glGenRenderbuffers` 用于生成 renderbuffer，并分配 id。它的原型为：\n\n```c\nvoid glGenRenderbuffers (GLsizei n, GLuint* renderbuffers)\n```\n\n- n：表示申请生成 renderbuffer 的个数。\n- renderbuffers：返回分配给 renderbuffer 的 id。\n\n> PS：返回的 id 不会为 0，0 是OpenGL ES 保留的，0 则表示这个 buffer 这个不存在或者创建失败。\n\n所以，一般会通过 id 来判断某个 buffer 是否存在，执行对应的操作。比如在 gen 之前，释放旧的 renderbuffer，确保之后的操作无误。\n\n```objc\n// 释放旧的 renderbuffer\nif (_renderbuffer) {\n    glDeleteRenderbuffers(1, &_renderbuffer);\n    _renderbuffer = 0;\n}\n```\n\n`glBindRenderbuffer` 用于绑定 renderbuffer，将指定 id 的 renderbuffer 设置为当前 renderbuffer。它的原型为：\n\n```c\nvoid glBindRenderbuffer (GLenum target, GLuint renderbuffer) \n```\n\n- target：表示当前 renderbuffer，必须是 **GL_RENDERBUFFER**。\n- renderbuffer：某个 renderbuffer 对应的 id（比如使用 glGenRenderbuffers 生成的 id）。\n\n`renderbufferStorage` 用于将 GL_RENDERBUFFER 的内容存储到实现 **EAGLDrawable** 协议的 CAEAGLLayer。它的原型为：\n\n```objc\n/* Attaches an EAGLDrawable as storage for the OpenGL ES renderbuffer object bound to <target> */\n- (BOOL)renderbufferStorage:(NSUInteger)target fromDrawable:(id<EAGLDrawable>)drawable;\n```\n\n> PS：\n>\n> 这个函数内部，会使用 drawable（_eaglLayer）的相关信息（设置存储在 drawableProperties 属性中）作为参数，调用 glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);\n>\n>  `glRenderbufferStorage` 指定存储在 renderbuffer 中图像的宽高以及颜色格式，并按照此规格为之分配存储空间。\n\n至此，我们的第一个 buffer 创建完毕了。注意理解 **gen** 和 **bind** 这两个概念，它将会贯穿我们 OpenGL ES 的整个学习过程。\n\n\n\n## 4. Framebuffer\n\n接下去我们将会创建 framebuffer object，它通常也被称之为 **FBO**。\n\n我们之前提到过了，它相当于 buffer（color, depth, stencil）的管理者，三大 buffer 可以附加到一个  FBO 上。\n\n它的创建过程如下：\n\n```objc\n- (void)setupFrameBuffer {\n    // 释放旧的 framebuffer\n    if (_framebuffer) {\n        glDeleteFramebuffers(1, &_framebuffer);\n        _framebuffer = 0;\n    }\n    \n    // 生成 framebuffer ( framebuffer = 画布 )\n    glGenFramebuffers(1, &_framebuffer);\n    // 绑定 fraembuffer\n    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);\n    \n    // framebuffer 不对渲染的内容做存储, 所以这一步是将 framebuffer 绑定到 renderbuffer ( 渲染的结果就存在 renderbuffer )\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n                              GL_RENDERBUFFER, _renderbuffer);\n}\n```\n\n之前的 gen，bin 操作和 renderbuffer 中对应的都是一致的，只是做相应的替换，比如 renderbuffer 改成 framebuffer 即可，这里就不细说，重点看一下 `glFramebufferRenderbuffer`。\n\n之前说过，framebuffer 不对渲染的内容做存储，而 `glFramebufferRenderbuffer` 的作用正是将相关的 buffer（三大 buffer 之一）装配到 framebuffer 上，使得 framebuffer 能索引到对应的渲染内容。它的原型为：\n\n```c\nvoid glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)\n```\n\n- target：表示当前 framebuffer，必须是 GL_FRAMEBUFFER。\n- attachment：指定 renderbuffer 被装配到那个装配点上，其值是 GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT，GL_STENCIL_ATTACHMENT 中的一个，分别对应 color，depth 和  stencil 三大 buffer。\n- renderbuffertarget：表示当前 renderbuffer，必须是 **GL_RENDERBUFFER**。\n- renderbuffer：某个 renderbuffer 对应的 id，表示需要装配的 renderbuffer。\n\n> PS：\n>\n> 为了安全起见，可以通过 `glCheckFramebufferStatus` 来检查 framebuffer 的创建情况，并根据对应的 log，来排查错误。\n\n```objc\n- (BOOL)checkFramebuffer:(NSError *__autoreleasing *)error {\n    // 检查 framebuffer 是否创建成功\n    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n    NSString *errorMessage = nil;\n    BOOL result = NO;\n    \n    switch (status)\n    {\n        case GL_FRAMEBUFFER_UNSUPPORTED:\n            errorMessage = @\"framebuffer不支持该格式\";\n            result = NO;\n            break;\n        case GL_FRAMEBUFFER_COMPLETE:\n            NSLog(@\"framebuffer 创建成功\");\n            result = YES;\n            break;\n        case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            errorMessage = @\"Framebuffer不完整 缺失组件\";\n            result = NO;\n            break;\n        case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            errorMessage = @\"Framebuffer 不完整, 附加图片必须要指定大小\";\n            result = NO;\n            break;\n        default:\n            // 一般是超出GL纹理的最大限制\n            errorMessage = @\"未知错误 error !!!!\";\n            result = NO;\n            break;\n    }\n    \n    NSLog(@\"%@\",errorMessage ? errorMessage : @\"\");\n    *error = errorMessage ? [NSError errorWithDomain:@\"com.colin.error\"\n                                                code:status\n                                            userInfo:@{@\"ErrorMessage\" : errorMessage}] : nil;\n    \n    return result;\n}\n```\n\n\n\n至此，我们需要的环境配置以及相关 buffer 资源都已经准备好了，接下去就是渲染部分了。\n\n\n\n## 5. 最简单的渲染，设置背景色\n\n```objc\n- (void)render {\n    glClearColor(0, 1, 1, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // 做完所有绘制操作后，最终呈现到屏幕上\n    [_context presentRenderbuffer:GL_RENDERBUFFER];\n}\n```\n\n`glClearColor` 用来设置清屏颜色，它的原型为：\n\n```c\nvoid glClearColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);\n```\n\n`glClear (GLbitfield mask)` 用来指定要用清屏颜色来清除由 mask 指定的 buffer，mask 可以是 GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT 和 GL_STENCIL_BUFFER_BIT 的自由组合。\n\n在这里我们只使用到 color buffer，所以清除的就是 clolor buffer。\n\n`presentRenderbuffer` 是将指定 renderbuffer 呈现在屏幕上。\n\n> PS：\n>\n> 在此之前，建议使用 `glBindFramebuffer`，`glBindRenderbuffer` 来重新绑定当前 buffer 对象。因为 GL 的所有 API 都是基于最后一次绑定的对象作为作用对象。所以每次在修改 GL 对象时，先绑定一次要修改的对象。有很多错误是因为没有绑定或者绑定了错误的对象导致得到了错误的结果。\n\n\n\n## 6. 收工，检验\n\n至此，关于 OpenGL ES 环境搭建的相关准备东西都已就绪，接下去只要按需调用相关方法，即可。\n\n```objc\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if ((self = [super initWithCoder:aDecoder])) {\n        [self setup];\n    }\n    return self;\n}\n\n- (void)didMoveToWindow {\n    [super didMoveToWindow];\n    [self render];\n}\n\n#pragma mark - Setup\n- (void)setup {\n    [self setupLayer];\n    [self setupContext];\n    [self setupRenderBuffer];\n    [self setupFrameBuffer];\n    \n    NSError *error;\n    NSAssert1([self checkFramebuffer:&error], @\"%@\",error.userInfo[@\"ErrorMessage\"]);\n}\n```\n\n\n\n这里不出意外的话，你将会看到开头的那个纯色背景。\n\n你可能注意到了，这个过程我们并没有涉及到所谓的图形渲染管线，如果你试着使用 kEAGLRenderingAPIOpenGLES1 来创建 context，会发现这是完成可以的。\n\n\n\n最终的工程可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip)下载。有了这个基础，模版，接下去，我们将会围绕渲染管线，实现一系列的炫酷效果，一起期待吧～","slug":"OpenGLES-Lesson02","published":1,"updated":"2019-12-23T01:02:31.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1mt001czwlnw646c7ks","content":"<p>在<a href=\"http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/\" target=\"_blank\" rel=\"external\">上篇文章</a>中，已经介绍了 OpenGL ES 的一些基础概念以及大致工作流程。</p>\n<p>在本文中，我们将会介绍在 iOS 平台上如何接入 OpenGL ES，并搭建好基础环境，实现设置背景色功能。它是之后任何实战的基础模版。在搭建过程中，会针对之前介绍的一些概念，再结合代码讲解。</p>\n<blockquote>\n<p>PS：这一节是 OpenGL ES 的入门，也是最重要的一部分。再绚丽的特性，都是在此基础上完成的。所以理解它是很有必要的～</p>\n</blockquote>\n<p>设置蓝色背景后，效果如下：</p>\n<p><img src=\"http://7xkc7a.com1.z0.glb.clouddn.com/2017012639178QQ20170126-231448@2x.png\" alt=\"2017012639178QQ20170126-231448@2x.png\"></p>\n<a id=\"more\"></a>\n<h2 id=\"0-_初始工程\">0. 初始工程</h2><p>你可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip\" target=\"_blank\" rel=\"external\">这里</a>下载到初始工程，避免重复实现一些和本节内容不相干的事情。</p>\n<p>在这个初始工程里面，已经实现了新建一个继承自 <strong>UIView</strong> 的 <strong>GLView</strong>，这个自定义的视图将用来显示 OpenGL ES 的渲染内容。然后在 Main.storyboard 中，将 ViewController 的 view 改成 <strong>GLView</strong> 类型，即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_3_1.png\" alt=\"2017012663829D0A3C5CE-818A-4C93-8D3E-1C302E29220F.png\"></p>\n<p>至此，我们的工作都将在 <strong>GLView</strong> 中展开。</p>\n<p>在 <strong>GLView.h</strong> 中，先声明一些将要用到的成员变量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">GLView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CAEAGLLayer</span> *_eaglLayer;</span><br><span class=\"line\">    EAGLContext *_context;</span><br><span class=\"line\">    GLuint       _framebuffer;</span><br><span class=\"line\">    GLuint       _renderbuffer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，在 <strong>GLView.m</strong> 中，需要导入对应的 OpenGLES 框架（framework），如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import OpenGLES;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p><code>@import</code>是 iOS 7 之后的新特性语法，这种方式叫 Modules（模块导入） 或者 Semantic import（语义导入）。用这种方式，不用手动添加 framework，系统会自动帮我们 link，是一种更好的头部预处理的执行方式（相比之前的 #import）。</p>\n<ul>\n<li>Imports complete semantic description of a framework</li>\n<li>Doesn’t need to parse the headers</li>\n<li>Better way to import a framework’s interface</li>\n<li>Loads binary representation</li>\n<li>More flexible than precompiled headers</li>\n<li>Immune to effects of local macro definitions (e.g. <code>#define readonly 0x01</code>)</li>\n<li>Enabled for new projects by default</li>\n</ul>\n</blockquote>\n<h2 id=\"1-_CAEAGLLayer\">1. CAEAGLLayer</h2><p>CAEAGLLayer 实现了 <strong>EAGLDrawable</strong> 协议，它是 Apple 专门为 OpenGL ES 准备的一个图层类。</p>\n<p>所以想要显示 OpenGL ES 的内容，需要把它默认的 layer 设置为一个特殊的 layer（<strong>CAEAGLLayer</strong>），我们简单的重写 <code>layerClass</code> 即可：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)layerClass &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">CAEAGLLayer</span> class];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，为了方便起见，我们使 <strong>_eaglLayer</strong> 这个成员变量指代 <strong>self.layer</strong>，这样除了调用上方便外，可读性也更好。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于显示的layer</span></span><br><span class=\"line\">    _eaglLayer = (<span class=\"built_in\">CAEAGLLayer</span> *)<span class=\"keyword\">self</span>.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// CALayer 默认是透明的（opaque = NO），而透明的层对性能负荷很大。所以将其关闭。</span></span><br><span class=\"line\">    _eaglLayer.opaque = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>By default, CALayers are set to non-opaque (i.e. transparent). However, this is bad for performance reasons (especially with OpenGL), so it’s best to set this as opaque when possible.</p>\n<p>CAEAGLLayer: the default value of the `opaque’ property in this class is true, not false as in CALayer.</p>\n<p>透明对性能影响较大，CAEAGLLayer 中的 <strong>opaque</strong> 默认值已经是 YES 了。</p>\n</blockquote>\n<p>至此 layer 的配置已经就绪，下面创建并设置与 OpenGL ES 相关的东西。</p>\n<h2 id=\"2-_EAGLContext\">2. EAGLContext</h2><p>上篇已经提到了<strong>上下文</strong>概念，即 <strong>EAGLContext</strong> 对象，这个 context 管理所有使用 OpenGL ES 进行渲染的状态，命令以及资源信息。</p>\n<p>通过 <code>initWithAPI</code> 创建完 context，然后需要使用 <code>setCurrentContext</code> 将它设置为当前 context，因为我们之前提过，context 可以同时存在多个，需要指定当前环境对应的 context。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupContext &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建GL环境上下文</span></span><br><span class=\"line\">        <span class=\"comment\">// EAGLContext 管理所有通过 OpenGL ES 进行渲染的信息.</span></span><br><span class=\"line\">        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(_context &amp;&amp; [EAGLContext setCurrentContext:_context], <span class=\"string\">@\"初始化GL环境失败\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <strong>kEAGLRenderingAPIOpenGLES2</strong> 即对应的 OpenGL ES 版本，它的定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* EAGL rendering API */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, EAGLRenderingAPI)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tkEAGLRenderingAPIOpenGLES1 = <span class=\"number\">1</span>,</span><br><span class=\"line\">\tkEAGLRenderingAPIOpenGLES2 = <span class=\"number\">2</span>,</span><br><span class=\"line\">\tkEAGLRenderingAPIOpenGLES3 = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-_Renderbuffer\">3. Renderbuffer</h2><p>有了上下文，OpenGL ES 还需要在一块 buffer 上进行渲染，这块 buffer 就是 <strong>Renderbuffer</strong>（OpenGL ES 总共有三大不同用途的 buffer，分别是 <strong>color buffer，depth buffer 和 stencil buffer</strong>，这里是最基本的 color buffer）。可以简单的把 renderbuffer 理解成用于展示的窗口。</p>\n<p>它的创建过程如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupRenderBuffer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 生成 renderbuffer ( renderbuffer = 用于展示的窗口 )</span></span><br><span class=\"line\">    glGenRenderbuffers(<span class=\"number\">1</span>, &amp;_renderbuffer);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定 renderbuffer</span></span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);</span><br><span class=\"line\">    <span class=\"comment\">// GL_RENDERBUFFER 的内容存储到实现 EAGLDrawable 协议的 CAEAGLLayer</span></span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glGenRenderbuffers</code> 用于生成 renderbuffer，并分配 id。它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glGenRenderbuffers</span> <span class=\"params\">(GLsizei n, GLuint* renderbuffers)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>n：表示申请生成 renderbuffer 的个数。</li>\n<li>renderbuffers：返回分配给 renderbuffer 的 id。</li>\n</ul>\n<blockquote>\n<p>PS：返回的 id 不会为 0，0 是OpenGL ES 保留的，0 则表示这个 buffer 这个不存在或者创建失败。</p>\n</blockquote>\n<p>所以，一般会通过 id 来判断某个 buffer 是否存在，执行对应的操作。比如在 gen 之前，释放旧的 renderbuffer，确保之后的操作无误。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 释放旧的 renderbuffer</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (_renderbuffer) &#123;</span><br><span class=\"line\">    glDeleteRenderbuffers(<span class=\"number\">1</span>, &amp;_renderbuffer);</span><br><span class=\"line\">    _renderbuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glBindRenderbuffer</code> 用于绑定 renderbuffer，将指定 id 的 renderbuffer 设置为当前 renderbuffer。它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glBindRenderbuffer</span> <span class=\"params\">(GLenum target, GLuint renderbuffer)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>target：表示当前 renderbuffer，必须是 <strong>GL_RENDERBUFFER</strong>。</li>\n<li>renderbuffer：某个 renderbuffer 对应的 id（比如使用 glGenRenderbuffers 生成的 id）。</li>\n</ul>\n<p><code>renderbufferStorage</code> 用于将 GL_RENDERBUFFER 的内容存储到实现 <strong>EAGLDrawable</strong> 协议的 CAEAGLLayer。它的原型为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Attaches an EAGLDrawable as storage for the OpenGL ES renderbuffer object bound to &lt;target&gt; */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)renderbufferStorage:(<span class=\"built_in\">NSUInteger</span>)target fromDrawable:(<span class=\"keyword\">id</span>&lt;EAGLDrawable&gt;)drawable;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>这个函数内部，会使用 drawable（_eaglLayer）的相关信息（设置存储在 drawableProperties 属性中）作为参数，调用 glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</p>\n<p> <code>glRenderbufferStorage</code> 指定存储在 renderbuffer 中图像的宽高以及颜色格式，并按照此规格为之分配存储空间。</p>\n</blockquote>\n<p>至此，我们的第一个 buffer 创建完毕了。注意理解 <strong>gen</strong> 和 <strong>bind</strong> 这两个概念，它将会贯穿我们 OpenGL ES 的整个学习过程。</p>\n<h2 id=\"4-_Framebuffer\">4. Framebuffer</h2><p>接下去我们将会创建 framebuffer object，它通常也被称之为 <strong>FBO</strong>。</p>\n<p>我们之前提到过了，它相当于 buffer（color, depth, stencil）的管理者，三大 buffer 可以附加到一个  FBO 上。</p>\n<p>它的创建过程如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupFrameBuffer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放旧的 framebuffer</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_framebuffer) &#123;</span><br><span class=\"line\">        glDeleteFramebuffers(<span class=\"number\">1</span>, &amp;_framebuffer);</span><br><span class=\"line\">        _framebuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 生成 framebuffer ( framebuffer = 画布 )</span></span><br><span class=\"line\">    glGenFramebuffers(<span class=\"number\">1</span>, &amp;_framebuffer);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定 fraembuffer</span></span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// framebuffer 不对渲染的内容做存储, 所以这一步是将 framebuffer 绑定到 renderbuffer ( 渲染的结果就存在 renderbuffer )</span></span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">                              GL_RENDERBUFFER, _renderbuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前的 gen，bin 操作和 renderbuffer 中对应的都是一致的，只是做相应的替换，比如 renderbuffer 改成 framebuffer 即可，这里就不细说，重点看一下 <code>glFramebufferRenderbuffer</code>。</p>\n<p>之前说过，framebuffer 不对渲染的内容做存储，而 <code>glFramebufferRenderbuffer</code> 的作用正是将相关的 buffer（三大 buffer 之一）装配到 framebuffer 上，使得 framebuffer 能索引到对应的渲染内容。它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glFramebufferRenderbuffer</span> <span class=\"params\">(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>target：表示当前 framebuffer，必须是 GL_FRAMEBUFFER。</li>\n<li>attachment：指定 renderbuffer 被装配到那个装配点上，其值是 GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT，GL_STENCIL_ATTACHMENT 中的一个，分别对应 color，depth 和  stencil 三大 buffer。</li>\n<li>renderbuffertarget：表示当前 renderbuffer，必须是 <strong>GL_RENDERBUFFER</strong>。</li>\n<li>renderbuffer：某个 renderbuffer 对应的 id，表示需要装配的 renderbuffer。</li>\n</ul>\n<blockquote>\n<p>PS：</p>\n<p>为了安全起见，可以通过 <code>glCheckFramebufferStatus</code> 来检查 framebuffer 的创建情况，并根据对应的 log，来排查错误。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)checkFramebuffer:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查 framebuffer 是否创建成功</span></span><br><span class=\"line\">    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *errorMessage = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (status)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_U<span class=\"built_in\">NSUPPORTED</span>:</span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"framebuffer不支持该格式\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_CO<span class=\"built_in\">MPLETE</span>:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"framebuffer 创建成功\"</span>);</span><br><span class=\"line\">            result = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_INCO<span class=\"built_in\">MPLETE_MISSING_ATTACHMENT</span>:</span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"Framebuffer不完整 缺失组件\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_INCO<span class=\"built_in\">MPLETE_DIMENSIONS</span>:</span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"Framebuffer 不完整, 附加图片必须要指定大小\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 一般是超出GL纹理的最大限制</span></span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"未知错误 error !!!!\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,errorMessage ? errorMessage : <span class=\"string\">@\"\"</span>);</span><br><span class=\"line\">    *error = errorMessage ? [<span class=\"built_in\">NSError</span> errorWithDomain:<span class=\"string\">@\"com.colin.error\"</span></span><br><span class=\"line\">                                                code:status</span><br><span class=\"line\">                                            userInfo:@&#123;<span class=\"string\">@\"ErrorMessage\"</span> : errorMessage&#125;] : <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们需要的环境配置以及相关 buffer 资源都已经准备好了，接下去就是渲染部分了。</p>\n<h2 id=\"5-_最简单的渲染，设置背景色\">5. 最简单的渲染，设置背景色</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)render &#123;</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 做完所有绘制操作后，最终呈现到屏幕上</span></span><br><span class=\"line\">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glClearColor</code> 用来设置清屏颜色，它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glClearColor</span> <span class=\"params\">(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>glClear (GLbitfield mask)</code> 用来指定要用清屏颜色来清除由 mask 指定的 buffer，mask 可以是 GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT 和 GL_STENCIL_BUFFER_BIT 的自由组合。</p>\n<p>在这里我们只使用到 color buffer，所以清除的就是 clolor buffer。</p>\n<p><code>presentRenderbuffer</code> 是将指定 renderbuffer 呈现在屏幕上。</p>\n<blockquote>\n<p>PS：</p>\n<p>在此之前，建议使用 <code>glBindFramebuffer</code>，<code>glBindRenderbuffer</code> 来重新绑定当前 buffer 对象。因为 GL 的所有 API 都是基于最后一次绑定的对象作为作用对象。所以每次在修改 GL 对象时，先绑定一次要修改的对象。有很多错误是因为没有绑定或者绑定了错误的对象导致得到了错误的结果。</p>\n</blockquote>\n<h2 id=\"6-_收工，检验\">6. 收工，检验</h2><p>至此，关于 OpenGL ES 环境搭建的相关准备东西都已就绪，接下去只要按需调用相关方法，即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithCoder:aDecoder])) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setup];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didMoveToWindow &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> didMoveToWindow];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> render];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Setup</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setup &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupLayer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupContext];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupRenderBuffer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupFrameBuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert1</span>([<span class=\"keyword\">self</span> checkFramebuffer:&amp;error], <span class=\"string\">@\"%@\"</span>,error.userInfo[<span class=\"string\">@\"ErrorMessage\"</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里不出意外的话，你将会看到开头的那个纯色背景。</p>\n<p>你可能注意到了，这个过程我们并没有涉及到所谓的图形渲染管线，如果你试着使用 kEAGLRenderingAPIOpenGLES1 来创建 context，会发现这是完成可以的。</p>\n<p>最终的工程可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip\" target=\"_blank\" rel=\"external\">这里</a>下载。有了这个基础，模版，接下去，我们将会围绕渲染管线，实现一系列的炫酷效果，一起期待吧～</p>\n","excerpt":"<p>在<a href=\"http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/\">上篇文章</a>中，已经介绍了 OpenGL ES 的一些基础概念以及大致工作流程。</p>\n<p>在本文中，我们将会介绍在 iOS 平台上如何接入 OpenGL ES，并搭建好基础环境，实现设置背景色功能。它是之后任何实战的基础模版。在搭建过程中，会针对之前介绍的一些概念，再结合代码讲解。</p>\n<blockquote>\n<p>PS：这一节是 OpenGL ES 的入门，也是最重要的一部分。再绚丽的特性，都是在此基础上完成的。所以理解它是很有必要的～</p>\n</blockquote>\n<p>设置蓝色背景后，效果如下：</p>\n<p><img src=\"http://7xkc7a.com1.z0.glb.clouddn.com/2017012639178QQ20170126-231448@2x.png\" alt=\"2017012639178QQ20170126-231448@2x.png\"></p>","more":"<h2 id=\"0-_初始工程\">0. 初始工程</h2><p>你可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip\">这里</a>下载到初始工程，避免重复实现一些和本节内容不相干的事情。</p>\n<p>在这个初始工程里面，已经实现了新建一个继承自 <strong>UIView</strong> 的 <strong>GLView</strong>，这个自定义的视图将用来显示 OpenGL ES 的渲染内容。然后在 Main.storyboard 中，将 ViewController 的 view 改成 <strong>GLView</strong> 类型，即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_3_1.png\" alt=\"2017012663829D0A3C5CE-818A-4C93-8D3E-1C302E29220F.png\"></p>\n<p>至此，我们的工作都将在 <strong>GLView</strong> 中展开。</p>\n<p>在 <strong>GLView.h</strong> 中，先声明一些将要用到的成员变量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">GLView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CAEAGLLayer</span> *_eaglLayer;</span><br><span class=\"line\">    EAGLContext *_context;</span><br><span class=\"line\">    GLuint       _framebuffer;</span><br><span class=\"line\">    GLuint       _renderbuffer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，在 <strong>GLView.m</strong> 中，需要导入对应的 OpenGLES 框架（framework），如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import OpenGLES;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p><code>@import</code>是 iOS 7 之后的新特性语法，这种方式叫 Modules（模块导入） 或者 Semantic import（语义导入）。用这种方式，不用手动添加 framework，系统会自动帮我们 link，是一种更好的头部预处理的执行方式（相比之前的 #import）。</p>\n<ul>\n<li>Imports complete semantic description of a framework</li>\n<li>Doesn’t need to parse the headers</li>\n<li>Better way to import a framework’s interface</li>\n<li>Loads binary representation</li>\n<li>More flexible than precompiled headers</li>\n<li>Immune to effects of local macro definitions (e.g. <code>#define readonly 0x01</code>)</li>\n<li>Enabled for new projects by default</li>\n</ul>\n</blockquote>\n<h2 id=\"1-_CAEAGLLayer\">1. CAEAGLLayer</h2><p>CAEAGLLayer 实现了 <strong>EAGLDrawable</strong> 协议，它是 Apple 专门为 OpenGL ES 准备的一个图层类。</p>\n<p>所以想要显示 OpenGL ES 的内容，需要把它默认的 layer 设置为一个特殊的 layer（<strong>CAEAGLLayer</strong>），我们简单的重写 <code>layerClass</code> 即可：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)layerClass &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">CAEAGLLayer</span> class];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，为了方便起见，我们使 <strong>_eaglLayer</strong> 这个成员变量指代 <strong>self.layer</strong>，这样除了调用上方便外，可读性也更好。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于显示的layer</span></span><br><span class=\"line\">    _eaglLayer = (<span class=\"built_in\">CAEAGLLayer</span> *)<span class=\"keyword\">self</span>.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// CALayer 默认是透明的（opaque = NO），而透明的层对性能负荷很大。所以将其关闭。</span></span><br><span class=\"line\">    _eaglLayer.opaque = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>By default, CALayers are set to non-opaque (i.e. transparent). However, this is bad for performance reasons (especially with OpenGL), so it’s best to set this as opaque when possible.</p>\n<p>CAEAGLLayer: the default value of the `opaque’ property in this class is true, not false as in CALayer.</p>\n<p>透明对性能影响较大，CAEAGLLayer 中的 <strong>opaque</strong> 默认值已经是 YES 了。</p>\n</blockquote>\n<p>至此 layer 的配置已经就绪，下面创建并设置与 OpenGL ES 相关的东西。</p>\n<h2 id=\"2-_EAGLContext\">2. EAGLContext</h2><p>上篇已经提到了<strong>上下文</strong>概念，即 <strong>EAGLContext</strong> 对象，这个 context 管理所有使用 OpenGL ES 进行渲染的状态，命令以及资源信息。</p>\n<p>通过 <code>initWithAPI</code> 创建完 context，然后需要使用 <code>setCurrentContext</code> 将它设置为当前 context，因为我们之前提过，context 可以同时存在多个，需要指定当前环境对应的 context。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupContext &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建GL环境上下文</span></span><br><span class=\"line\">        <span class=\"comment\">// EAGLContext 管理所有通过 OpenGL ES 进行渲染的信息.</span></span><br><span class=\"line\">        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(_context &amp;&amp; [EAGLContext setCurrentContext:_context], <span class=\"string\">@\"初始化GL环境失败\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <strong>kEAGLRenderingAPIOpenGLES2</strong> 即对应的 OpenGL ES 版本，它的定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* EAGL rendering API */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, EAGLRenderingAPI)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tkEAGLRenderingAPIOpenGLES1 = <span class=\"number\">1</span>,</span><br><span class=\"line\">\tkEAGLRenderingAPIOpenGLES2 = <span class=\"number\">2</span>,</span><br><span class=\"line\">\tkEAGLRenderingAPIOpenGLES3 = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-_Renderbuffer\">3. Renderbuffer</h2><p>有了上下文，OpenGL ES 还需要在一块 buffer 上进行渲染，这块 buffer 就是 <strong>Renderbuffer</strong>（OpenGL ES 总共有三大不同用途的 buffer，分别是 <strong>color buffer，depth buffer 和 stencil buffer</strong>，这里是最基本的 color buffer）。可以简单的把 renderbuffer 理解成用于展示的窗口。</p>\n<p>它的创建过程如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupRenderBuffer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 生成 renderbuffer ( renderbuffer = 用于展示的窗口 )</span></span><br><span class=\"line\">    glGenRenderbuffers(<span class=\"number\">1</span>, &amp;_renderbuffer);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定 renderbuffer</span></span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);</span><br><span class=\"line\">    <span class=\"comment\">// GL_RENDERBUFFER 的内容存储到实现 EAGLDrawable 协议的 CAEAGLLayer</span></span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glGenRenderbuffers</code> 用于生成 renderbuffer，并分配 id。它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glGenRenderbuffers</span> <span class=\"params\">(GLsizei n, GLuint* renderbuffers)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>n：表示申请生成 renderbuffer 的个数。</li>\n<li>renderbuffers：返回分配给 renderbuffer 的 id。</li>\n</ul>\n<blockquote>\n<p>PS：返回的 id 不会为 0，0 是OpenGL ES 保留的，0 则表示这个 buffer 这个不存在或者创建失败。</p>\n</blockquote>\n<p>所以，一般会通过 id 来判断某个 buffer 是否存在，执行对应的操作。比如在 gen 之前，释放旧的 renderbuffer，确保之后的操作无误。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 释放旧的 renderbuffer</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (_renderbuffer) &#123;</span><br><span class=\"line\">    glDeleteRenderbuffers(<span class=\"number\">1</span>, &amp;_renderbuffer);</span><br><span class=\"line\">    _renderbuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glBindRenderbuffer</code> 用于绑定 renderbuffer，将指定 id 的 renderbuffer 设置为当前 renderbuffer。它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glBindRenderbuffer</span> <span class=\"params\">(GLenum target, GLuint renderbuffer)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>target：表示当前 renderbuffer，必须是 <strong>GL_RENDERBUFFER</strong>。</li>\n<li>renderbuffer：某个 renderbuffer 对应的 id（比如使用 glGenRenderbuffers 生成的 id）。</li>\n</ul>\n<p><code>renderbufferStorage</code> 用于将 GL_RENDERBUFFER 的内容存储到实现 <strong>EAGLDrawable</strong> 协议的 CAEAGLLayer。它的原型为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Attaches an EAGLDrawable as storage for the OpenGL ES renderbuffer object bound to &lt;target&gt; */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)renderbufferStorage:(<span class=\"built_in\">NSUInteger</span>)target fromDrawable:(<span class=\"keyword\">id</span>&lt;EAGLDrawable&gt;)drawable;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>这个函数内部，会使用 drawable（_eaglLayer）的相关信息（设置存储在 drawableProperties 属性中）作为参数，调用 glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</p>\n<p> <code>glRenderbufferStorage</code> 指定存储在 renderbuffer 中图像的宽高以及颜色格式，并按照此规格为之分配存储空间。</p>\n</blockquote>\n<p>至此，我们的第一个 buffer 创建完毕了。注意理解 <strong>gen</strong> 和 <strong>bind</strong> 这两个概念，它将会贯穿我们 OpenGL ES 的整个学习过程。</p>\n<h2 id=\"4-_Framebuffer\">4. Framebuffer</h2><p>接下去我们将会创建 framebuffer object，它通常也被称之为 <strong>FBO</strong>。</p>\n<p>我们之前提到过了，它相当于 buffer（color, depth, stencil）的管理者，三大 buffer 可以附加到一个  FBO 上。</p>\n<p>它的创建过程如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupFrameBuffer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放旧的 framebuffer</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_framebuffer) &#123;</span><br><span class=\"line\">        glDeleteFramebuffers(<span class=\"number\">1</span>, &amp;_framebuffer);</span><br><span class=\"line\">        _framebuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 生成 framebuffer ( framebuffer = 画布 )</span></span><br><span class=\"line\">    glGenFramebuffers(<span class=\"number\">1</span>, &amp;_framebuffer);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定 fraembuffer</span></span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// framebuffer 不对渲染的内容做存储, 所以这一步是将 framebuffer 绑定到 renderbuffer ( 渲染的结果就存在 renderbuffer )</span></span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">                              GL_RENDERBUFFER, _renderbuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前的 gen，bin 操作和 renderbuffer 中对应的都是一致的，只是做相应的替换，比如 renderbuffer 改成 framebuffer 即可，这里就不细说，重点看一下 <code>glFramebufferRenderbuffer</code>。</p>\n<p>之前说过，framebuffer 不对渲染的内容做存储，而 <code>glFramebufferRenderbuffer</code> 的作用正是将相关的 buffer（三大 buffer 之一）装配到 framebuffer 上，使得 framebuffer 能索引到对应的渲染内容。它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glFramebufferRenderbuffer</span> <span class=\"params\">(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>target：表示当前 framebuffer，必须是 GL_FRAMEBUFFER。</li>\n<li>attachment：指定 renderbuffer 被装配到那个装配点上，其值是 GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT，GL_STENCIL_ATTACHMENT 中的一个，分别对应 color，depth 和  stencil 三大 buffer。</li>\n<li>renderbuffertarget：表示当前 renderbuffer，必须是 <strong>GL_RENDERBUFFER</strong>。</li>\n<li>renderbuffer：某个 renderbuffer 对应的 id，表示需要装配的 renderbuffer。</li>\n</ul>\n<blockquote>\n<p>PS：</p>\n<p>为了安全起见，可以通过 <code>glCheckFramebufferStatus</code> 来检查 framebuffer 的创建情况，并根据对应的 log，来排查错误。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)checkFramebuffer:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查 framebuffer 是否创建成功</span></span><br><span class=\"line\">    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *errorMessage = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (status)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_U<span class=\"built_in\">NSUPPORTED</span>:</span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"framebuffer不支持该格式\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_CO<span class=\"built_in\">MPLETE</span>:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"framebuffer 创建成功\"</span>);</span><br><span class=\"line\">            result = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_INCO<span class=\"built_in\">MPLETE_MISSING_ATTACHMENT</span>:</span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"Framebuffer不完整 缺失组件\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GL_FRAMEBUFFER_INCO<span class=\"built_in\">MPLETE_DIMENSIONS</span>:</span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"Framebuffer 不完整, 附加图片必须要指定大小\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 一般是超出GL纹理的最大限制</span></span><br><span class=\"line\">            errorMessage = <span class=\"string\">@\"未知错误 error !!!!\"</span>;</span><br><span class=\"line\">            result = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,errorMessage ? errorMessage : <span class=\"string\">@\"\"</span>);</span><br><span class=\"line\">    *error = errorMessage ? [<span class=\"built_in\">NSError</span> errorWithDomain:<span class=\"string\">@\"com.colin.error\"</span></span><br><span class=\"line\">                                                code:status</span><br><span class=\"line\">                                            userInfo:@&#123;<span class=\"string\">@\"ErrorMessage\"</span> : errorMessage&#125;] : <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们需要的环境配置以及相关 buffer 资源都已经准备好了，接下去就是渲染部分了。</p>\n<h2 id=\"5-_最简单的渲染，设置背景色\">5. 最简单的渲染，设置背景色</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)render &#123;</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 做完所有绘制操作后，最终呈现到屏幕上</span></span><br><span class=\"line\">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glClearColor</code> 用来设置清屏颜色，它的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glClearColor</span> <span class=\"params\">(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>glClear (GLbitfield mask)</code> 用来指定要用清屏颜色来清除由 mask 指定的 buffer，mask 可以是 GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT 和 GL_STENCIL_BUFFER_BIT 的自由组合。</p>\n<p>在这里我们只使用到 color buffer，所以清除的就是 clolor buffer。</p>\n<p><code>presentRenderbuffer</code> 是将指定 renderbuffer 呈现在屏幕上。</p>\n<blockquote>\n<p>PS：</p>\n<p>在此之前，建议使用 <code>glBindFramebuffer</code>，<code>glBindRenderbuffer</code> 来重新绑定当前 buffer 对象。因为 GL 的所有 API 都是基于最后一次绑定的对象作为作用对象。所以每次在修改 GL 对象时，先绑定一次要修改的对象。有很多错误是因为没有绑定或者绑定了错误的对象导致得到了错误的结果。</p>\n</blockquote>\n<h2 id=\"6-_收工，检验\">6. 收工，检验</h2><p>至此，关于 OpenGL ES 环境搭建的相关准备东西都已就绪，接下去只要按需调用相关方法，即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithCoder:aDecoder])) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setup];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didMoveToWindow &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> didMoveToWindow];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> render];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Setup</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setup &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupLayer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupContext];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupRenderBuffer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupFrameBuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert1</span>([<span class=\"keyword\">self</span> checkFramebuffer:&amp;error], <span class=\"string\">@\"%@\"</span>,error.userInfo[<span class=\"string\">@\"ErrorMessage\"</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里不出意外的话，你将会看到开头的那个纯色背景。</p>\n<p>你可能注意到了，这个过程我们并没有涉及到所谓的图形渲染管线，如果你试着使用 kEAGLRenderingAPIOpenGLES1 来创建 context，会发现这是完成可以的。</p>\n<p>最终的工程可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip\">这里</a>下载。有了这个基础，模版，接下去，我们将会围绕渲染管线，实现一系列的炫酷效果，一起期待吧～</p>"},{"title":"iOS 单元测试","date":"2017-08-31T12:10:15.000Z","_content":"\n\n\n## 什么是单元测试\n\n**形象版：**\n\n> 工厂在组装一台机器之前，会**对每个元件都进行测试**。这，就是单元测试。\n\n**官方版：**\n\n> 单元测试是指对软件中的**最小可测试单元**进行**检查和验证**。\n\n\n\n<!--more-->\n\n**特点：FIRST 原则**\n\n- **Fast**：测试的运行速度要快，这样就不介意运行它们。\n- **Independent / Isolated**：一个测试不应当依赖于另一个测试，不依赖外部环境。\n- **Repeatable**：同一个测试，每次都应当获得相同的结果。\n- **Self-validating**：测试应当是完全自动化的，输出结果要么是 pass 要么是 fail，而不是依靠程序员对日志文件的解释。\n- **Timely**：理想情况下，测试的编写，应当在编写要测试的产品代码之前。\n\n\n\n**Q：单元测试和其他的测试方法有什么不同呢？**\n\n**A：单元测试是在软件开发过程中要进行的最低级别的测试活动。**\n\n这里我们和常见的集成测试，系统测试做对比，如下：\n\n| 测试方式 | 类别   | 察范围                              | 基准       |\n| ---- | ---- | -------------------------------- | -------- |\n| 单元测试 | 白盒测试 | 单元内部的数据结构、逻辑控制、异常处理..            | 逻辑覆盖率    |\n| 集成测试 | 灰盒测试 | 模块之间的接口和接口数据传递的关系，以及模块组合后的整体功能.. | 接口覆盖率    |\n| 系统测试 | 黑盒测试 | 整个系统相对于需求的符合度                    | 需求规格的覆盖率 |\n\n\n\n------\n\n\n\n## 是否需要单元测试\n\n首先我们要知道，写代码的最终目标有两个：\n\n- **实现需求**\n- **提高代码质量和可维护性。**\n\n> PS：代码的可维护性是指增加一个新功能，或改变现有功能的成本。**成本越低，可维护性即越高**。\n\n那，在保证完成需求的前提下，单元测试能否提高代码质量和可维护性，则关系到我们是否需要采用它。\n\n\n\n> 先划个重点，**单元测试能提高代码质量和可维护性**。\n\n如果要加入单元测试这个环节，那么前提就得保证，代码是\"**可测试**\"的。所谓可测试，就是要满足之前提到的那几个基本特性。\n\n单元测试，要求你能 mock 掉**数据库**、**线程操作**、**文件操作**、**网络操作**、**UI**等等，它是可以独立工作，不依赖其他单元。不难想象，一份能独立进行这种 mock 的代码，耦合程度肯定很低。\n\n所以单元测试其实本身最重要的不是测试的那个阶段，而是**代码最初设计结构**的那个阶段。不是为了发现 Bug，而是为了提高开发效率，为了我们的代码健康可持续发展。写单元测试会让你**更好地去思考模块划分是否合理，解耦是否到位**。\n\n\n\n总结来说，执行单元测试有如下好处：\n\n- 可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。（因为每次修改，都要保证测试用例能通过）\n- 帮助反思模块划分的合理性，解耦是否到位。（如果一个单元测试写得逻辑非常复杂、或者说一个函数复杂到无法写单测，那就说明模块的抽象有问题)\n- 使得软件具备更好的可维护性、具备更好的可读性。对于团队的新人来说，可以从单元测试入手，比文档更容易被程序员接受。\n- 保证代码被测试，更容易及早发现问题，降低风险。\n\n\n\n> PS：单元测试不是万能的，它也是存在一些弊端的：\n>\n> - 不能减少研发的代码量，反而会花费很多精力在编写单元测试上，增加了开发成本，而且对开发人员的要求也会更高。\n> - 对于小项目来说，是否执行单元测试意义不大。\n> - 单元测试聚焦的是一个模块单元的功能完整性和鲁棒性，但是模块间互动可能带来的问题并不属于单元测试的范畴，同时也有很大部分的界面测试和功能测试仍旧离不开测试工程。\n\n\n\n**Q：为什么不用 UI 测试？**\n**A：**\n\n- 耗时长。特别是需要运行多个 case 的时候\n- 无法测试内部的具体逻辑，比如 URL 是否正确\n\n\n\n\n------\n\n\n\n## iOS 上的单元测试\n\n### XCTest 能做什么\n\nXCTest 是 Apple 提供的测试框架，和 Xcode 无缝结合。使用它，可以很方便的进行 **UI 测试，测试点录制，单元测试，性能测试，调试测试点，查看代码覆盖率，集成自动化测试..**\n\n![](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-results-srceditor_2x.png)\n\n![](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-runtst-10_2x.png)\n\n![](http://upload-images.jianshu.io/upload_images/465386-6bfe56ab9062ffb9.gif?imageMogr2/auto-orient/strip)\n\n\n\n![2017081632121A35A7F5A-553B-48B0-9608-CD12A98D4CED.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_1.png)\n\n![2017081627419EC435EE6-6007-4FD4-BA3C-73C12435D254.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_2.png)\n\n至于如何使用 XCTest，这不是本文要讨论的内容，直接对照官方文档 [Testing with Xcode](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1) 就能上手了。\n\n\n\n### 应该测试什么\n\n那么，讲了这么久的单元测试，在 iOS 上，我们到底应该要测哪些内容呢？\n\n单元测试侧重的是**逻辑测试和接口测试**。在我看来，以下几部分是可以进行测试的：\n\n- 公共类中的公开方法\n- 网络数据层\n- 业务逻辑层\n- 修复 Bug 的测试\n\n实际操作过程中，要**自下而上**进行。从最基础的 Base 层，往上写测试。确保基础的 Model，Manager 测试通过，才开始为 Controller 编写测试，因为这部分业务是最复杂的，也是最容易改变的。\n\n\n\n> PS：编写单元测试需要注意的一点是**责任分离**。即你的测试**只需要针对特定单元内部的逻辑**，至于其他模块是否正确，是由该模块的编写者来负责测试的。\n>\n> 把这一点应用到实际场景，就能看出 HTTP 通信的实现并不属于我们网络请求类的逻辑。不管是用第三方的 AFNetworking，还是用系统的 NSURLConnection，这些类本身的接口不需要我们来写单元测试。\n\n\n\n------\n\n\n\n## 可测试的代码（Swift)\n\n先来看一段基本的测试代码：\n\n```swift\nfunc testArraySorting() {\n    // Given\n\tlet input = [1, 7, 6, 3, 10]\n\t// When\n\tlet output = input.sorted()\n\t// Then\n\tXCTAssertEqual(output, [1, 3, 6, 7, 10])\n}\n```\n\n\n\n![20170823150345694914363.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_3.png)\n\n\n\n总结来说，测试用例可以按以下三步执行：\n\n1. **Given**：配置测试的初始状态\n2. **When**：对要测试的目标执行代码\n3. **Then**：对测试结果进行断言（成功 or 失败）\n\n这样我们一眼扫过去就可以清晰的看出一个 case 大体上都在干什么。\n\n> PS：同样一个方法，要写多个测试用例，确保每一种，每一条路径都执行到，特别是边界值。另外 Bugfix 也需要补上对应的 case。确保验证通过。\n>\n> 另外，确保一个 case 只测试一种情况。可能我们调用的一个 API 内部有一个 if…else…。建议 if 一个case，else 一个 case。分两个不同的 case 来作测试，这样每个 case 就很清晰自己在测试什么东西。当然，如果存在大量的 if…else…，那就要考虑下代码设计上，是否存在问题了。\n\n但是实际上，我们的项目中很少有这样单一，中规中矩的方法。很多时候，项目中难免发生多个类之间的交互处理，耦合度高，而这种操作非常的不好调试。单元测试的原则之一就在于我们用来**测试的代码要求功能很单一**，这其实与良好的代码设计的思想是非常相符的。\n\n那，如何保证每一个方法都是可测试的呢？\n\n下面通过一个例子，来介绍 Swift 应该如何让代码变的可测试：\n\n```swift\nclass Phone {\n    func call(number: String){\n        print (\"Real phone calling to \\(number)\")\n    }\n}\nclass PersonalAssitant {\n    let phone = Phone()\n    let bossNumber = \"12345678\"\n\n    func callBoss(){\n        phone.call(number: bossNumber)\n    }\n}\n```\n\n这段代码也很简单，但是，我们要怎么进行测试呢？\n\n```swift\nclass PersonalAssistantTestClass: XCTestCase {\n    func testCallingBoss(){\n        let assistant = PersonalAssistant()\n        assistant.callBoss()\n        \n        // Asset ？？\n    }\n}\n```\n\n这里存在这么几个问题：\n\n1. phone，bossNumber 都是不可控的，由 PersonalAssitant 内部自己管理，他们的**耦合度很高**。\n2. 我们没法验证 callBoss **是否正确执行**了。\n3. 这只是测试用例，难道每次测试，都需要**真正调用** phone.call，给 boss 打电话？（小心人才网）\n4. 没法**快速执行**\n\n\n\n#### Dependency Injection\n\n为了降低代码本身的耦合，也为了让代码更好测试，这里我们需要引入 DI（Dependency Injection，依赖注入）。\n\n```swift\nprotocol PhoneProtocol {\n    func call(number: String)\n}\n\nclass Phone: PhoneProtocol {\n    func call(number: String){\n        print (\"Real phone calling to \\(number)\")\n    }\n}\n\nclass PersonalAssistant {\n    let phone: PhoneProtocol\n    let bossNumber: String\n    \n    init(aPhone: PhoneProtocol, myBossNumber: String) {\n        phone = aPhone\n        bossNumber = myBossNumber\n    }\n    \n    func callBoss(){\n        phone.call(number: bossNumber)\n    }\n} \n```\n\n甚至可以**提供默认值**： \n\n```swift\ninit(aPhone: PhoneProtocol = Phone(), myBossNumber: String = \"12345678\")\n```\n\n\n\n通过 DI，我们获得了对 phone 和 number 的完全控制，我们可以传人任意的号码，任意的通讯设备，这使得整个代码的扩展性更好了。同时，也解决了我们提到的第一个问题，降低耦合度。\n\n**Q：为什么说这降低了耦合度呢？**\n\nA：这里，依赖注入通过声明 phone 这个属性就可以获得对这个对象的控制权，而对该对象的依赖关系管理、加载、配置都由外部完成。\n\n更具体来说，依赖注入使得你不用关心对象的生命周期，什么时候被创建，怎么创建的，什么时候销毁。只需直接使用即可，对象的生命周期由提供依赖注入的框架来管理。\n\n**总之，依赖注入的意思是你需要的东西不是由你创建的，而是第三方，或者说容器提供给你的。这样的设计符合正交性，即所谓的松耦合。**\n\n上面的前后代码，可以这样比喻：\n前：在原始社会里，几乎没有社会分工。需要斧子的人只能自己去磨一把斧子。\n\n后：进入工业社会，工厂出现了，斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人找到工厂，购买斧子，无须关心斧子的制造过程。\n\n\n\n#### Mock\n\n至于剩下的三个问题，其实本质上是一个问题，归纳起来就是：如何快速的模拟 phone.call 这个操作，并验证它是否成功调用。\n\n> 有的人可能有疑惑，我们现在是在测 assistant.callBoss 这个方法，但是为什么变成验证 phone.call 是否调用成功？我们之前说过。当前模块的测试，只需要关注该模块本身，所以 phone.call 的测试，应该是 Phone 模块自己需要完成的。所以，如果 phone.call 被正常调用了。 那是不是就变相意味着，assistant.callBoss 这个方法测试通过？（至于调用后，是否拨打成功，这个应该是 Phone 模块应该关心的）\n\n\n\n所以，这里我们引入 Mock 这个概念，来完成这个操作。\n\n> 所谓 mock，即模拟出我们想要的内容。\n\n```swift\nclass MockPhone: PhoneProtocol {\n    var wasCalled = false\n    \n    func call(number: String) {\n        wasCalled = true\n    }\n}\n\nfunc testCallingBoss() {\n    let mockPhone = MockPhone()\n    let assistant = PersonalAssistant(aPhone: mockPhone, myBossNumber: \"12345678\") \n    assistant.callBoss()\n    XCTAssertTrue(mockPhone.wasCalled, \"Assistant should have called the boss\")\n}\n```\n\n这里我们模拟出了一个专门用来测试的 “Phone”。（它应该声明在 test 文件里。test bundle 的内容，不会包含在正式包里头）。它也实现了 call 方法，但是并不是真正的拨打电话，而是标记已经调用了 call，拨打出去了。这使得，我们的 asset 得以书写。\n\n至此，这个简单的例子，就介绍完了。通过 Protocol 依赖注入，使得我们代码的耦合度更低，扩展性更好，可测试。所以，良好的代码设计是很有必要的。\n\n\n\n------\n\n\n\n## 自测\n\n如果说，下面一个例子，能通过重构代码，写出对应的 case，那么，我这篇文章也就没白写..\n\n```swift\n@IBAction func openTapped(_ sender: Any) {\n    let mode: String\n\n    switch segmentedControl.selectedSegmentIndex {\n    case 0:\n        mode = \"view\"\n    case 1:\n        mode = \"edit\"\n    default:\n        fatalError(\"Impossible Case\")\n    }\n\n    let url = URL(string: \"myappscheme://open?id=\\(document!.identifier)&mode=\\(mode)\")!\n\n    if UIApplication.shared.canOpenURL(url) {\n        UIApplication.shared.open(url, options: [:], completionHandler: nil)\n    } else {\n        print(\"url error\")\n    }\n}\n\n// Test\nfunc testOpensDocumentURLWhenButtonIsTapped() {\n    let controller = UIStoryboard(name: \"Main\", bundle: nil).instantiateViewController(withIdentifier: \"Preview\") as! PreviewViewController\n    controller.loadViewIfNeeded()\n    controller.segmentedControl.selectedSegmentIndex = 1\n    controller.document = Document(identifier: \"TheID\")\n\n    controller.openTapped(controller.button)\n    \n    // Asset ??\n}\n```\n\n\n\nEnjoy it～\n\n\n\n------\n\n\n\n## 参考链接\n\n[Testing with Xcode](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1)\n\n[What should we Unit Test in our iOS apps?](https://medium.com/practical-ios-development/what-should-we-unit-test-in-our-ios-apps-769d55a2423b)\n\n[Better Unit Testing with Swift](http://masilotti.com/better-swift-unit-testing/)\n\n[Practical Protocol-Oriented-Programming](https://academy.realm.io/posts/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/)\n\n\n\n[单元测试准则](https://github.com/yangyubo/zh-unit-testing-guidelines)\n\n[12 个单元测试秘籍和实践](https://www.oschina.net/translate/12-unit-testing-myths-and-practices)\n\n[面向协议编程与 Cocoa 的邂逅](https://onevcat.com/2016/11/pop-cocoa-1/)","source":"_posts/iOS-Unit-Testing.md","raw":"title: iOS 单元测试\ndate: 2017-08-31 20:10:15\n\ntags:\n\n- iOS开发\n- 设计思想\n- 测试\n\n------\n\n\n\n## 什么是单元测试\n\n**形象版：**\n\n> 工厂在组装一台机器之前，会**对每个元件都进行测试**。这，就是单元测试。\n\n**官方版：**\n\n> 单元测试是指对软件中的**最小可测试单元**进行**检查和验证**。\n\n\n\n<!--more-->\n\n**特点：FIRST 原则**\n\n- **Fast**：测试的运行速度要快，这样就不介意运行它们。\n- **Independent / Isolated**：一个测试不应当依赖于另一个测试，不依赖外部环境。\n- **Repeatable**：同一个测试，每次都应当获得相同的结果。\n- **Self-validating**：测试应当是完全自动化的，输出结果要么是 pass 要么是 fail，而不是依靠程序员对日志文件的解释。\n- **Timely**：理想情况下，测试的编写，应当在编写要测试的产品代码之前。\n\n\n\n**Q：单元测试和其他的测试方法有什么不同呢？**\n\n**A：单元测试是在软件开发过程中要进行的最低级别的测试活动。**\n\n这里我们和常见的集成测试，系统测试做对比，如下：\n\n| 测试方式 | 类别   | 察范围                              | 基准       |\n| ---- | ---- | -------------------------------- | -------- |\n| 单元测试 | 白盒测试 | 单元内部的数据结构、逻辑控制、异常处理..            | 逻辑覆盖率    |\n| 集成测试 | 灰盒测试 | 模块之间的接口和接口数据传递的关系，以及模块组合后的整体功能.. | 接口覆盖率    |\n| 系统测试 | 黑盒测试 | 整个系统相对于需求的符合度                    | 需求规格的覆盖率 |\n\n\n\n------\n\n\n\n## 是否需要单元测试\n\n首先我们要知道，写代码的最终目标有两个：\n\n- **实现需求**\n- **提高代码质量和可维护性。**\n\n> PS：代码的可维护性是指增加一个新功能，或改变现有功能的成本。**成本越低，可维护性即越高**。\n\n那，在保证完成需求的前提下，单元测试能否提高代码质量和可维护性，则关系到我们是否需要采用它。\n\n\n\n> 先划个重点，**单元测试能提高代码质量和可维护性**。\n\n如果要加入单元测试这个环节，那么前提就得保证，代码是\"**可测试**\"的。所谓可测试，就是要满足之前提到的那几个基本特性。\n\n单元测试，要求你能 mock 掉**数据库**、**线程操作**、**文件操作**、**网络操作**、**UI**等等，它是可以独立工作，不依赖其他单元。不难想象，一份能独立进行这种 mock 的代码，耦合程度肯定很低。\n\n所以单元测试其实本身最重要的不是测试的那个阶段，而是**代码最初设计结构**的那个阶段。不是为了发现 Bug，而是为了提高开发效率，为了我们的代码健康可持续发展。写单元测试会让你**更好地去思考模块划分是否合理，解耦是否到位**。\n\n\n\n总结来说，执行单元测试有如下好处：\n\n- 可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。（因为每次修改，都要保证测试用例能通过）\n- 帮助反思模块划分的合理性，解耦是否到位。（如果一个单元测试写得逻辑非常复杂、或者说一个函数复杂到无法写单测，那就说明模块的抽象有问题)\n- 使得软件具备更好的可维护性、具备更好的可读性。对于团队的新人来说，可以从单元测试入手，比文档更容易被程序员接受。\n- 保证代码被测试，更容易及早发现问题，降低风险。\n\n\n\n> PS：单元测试不是万能的，它也是存在一些弊端的：\n>\n> - 不能减少研发的代码量，反而会花费很多精力在编写单元测试上，增加了开发成本，而且对开发人员的要求也会更高。\n> - 对于小项目来说，是否执行单元测试意义不大。\n> - 单元测试聚焦的是一个模块单元的功能完整性和鲁棒性，但是模块间互动可能带来的问题并不属于单元测试的范畴，同时也有很大部分的界面测试和功能测试仍旧离不开测试工程。\n\n\n\n**Q：为什么不用 UI 测试？**\n**A：**\n\n- 耗时长。特别是需要运行多个 case 的时候\n- 无法测试内部的具体逻辑，比如 URL 是否正确\n\n\n\n\n------\n\n\n\n## iOS 上的单元测试\n\n### XCTest 能做什么\n\nXCTest 是 Apple 提供的测试框架，和 Xcode 无缝结合。使用它，可以很方便的进行 **UI 测试，测试点录制，单元测试，性能测试，调试测试点，查看代码覆盖率，集成自动化测试..**\n\n![](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-results-srceditor_2x.png)\n\n![](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-runtst-10_2x.png)\n\n![](http://upload-images.jianshu.io/upload_images/465386-6bfe56ab9062ffb9.gif?imageMogr2/auto-orient/strip)\n\n\n\n![2017081632121A35A7F5A-553B-48B0-9608-CD12A98D4CED.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_1.png)\n\n![2017081627419EC435EE6-6007-4FD4-BA3C-73C12435D254.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_2.png)\n\n至于如何使用 XCTest，这不是本文要讨论的内容，直接对照官方文档 [Testing with Xcode](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1) 就能上手了。\n\n\n\n### 应该测试什么\n\n那么，讲了这么久的单元测试，在 iOS 上，我们到底应该要测哪些内容呢？\n\n单元测试侧重的是**逻辑测试和接口测试**。在我看来，以下几部分是可以进行测试的：\n\n- 公共类中的公开方法\n- 网络数据层\n- 业务逻辑层\n- 修复 Bug 的测试\n\n实际操作过程中，要**自下而上**进行。从最基础的 Base 层，往上写测试。确保基础的 Model，Manager 测试通过，才开始为 Controller 编写测试，因为这部分业务是最复杂的，也是最容易改变的。\n\n\n\n> PS：编写单元测试需要注意的一点是**责任分离**。即你的测试**只需要针对特定单元内部的逻辑**，至于其他模块是否正确，是由该模块的编写者来负责测试的。\n>\n> 把这一点应用到实际场景，就能看出 HTTP 通信的实现并不属于我们网络请求类的逻辑。不管是用第三方的 AFNetworking，还是用系统的 NSURLConnection，这些类本身的接口不需要我们来写单元测试。\n\n\n\n------\n\n\n\n## 可测试的代码（Swift)\n\n先来看一段基本的测试代码：\n\n```swift\nfunc testArraySorting() {\n    // Given\n\tlet input = [1, 7, 6, 3, 10]\n\t// When\n\tlet output = input.sorted()\n\t// Then\n\tXCTAssertEqual(output, [1, 3, 6, 7, 10])\n}\n```\n\n\n\n![20170823150345694914363.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_3.png)\n\n\n\n总结来说，测试用例可以按以下三步执行：\n\n1. **Given**：配置测试的初始状态\n2. **When**：对要测试的目标执行代码\n3. **Then**：对测试结果进行断言（成功 or 失败）\n\n这样我们一眼扫过去就可以清晰的看出一个 case 大体上都在干什么。\n\n> PS：同样一个方法，要写多个测试用例，确保每一种，每一条路径都执行到，特别是边界值。另外 Bugfix 也需要补上对应的 case。确保验证通过。\n>\n> 另外，确保一个 case 只测试一种情况。可能我们调用的一个 API 内部有一个 if…else…。建议 if 一个case，else 一个 case。分两个不同的 case 来作测试，这样每个 case 就很清晰自己在测试什么东西。当然，如果存在大量的 if…else…，那就要考虑下代码设计上，是否存在问题了。\n\n但是实际上，我们的项目中很少有这样单一，中规中矩的方法。很多时候，项目中难免发生多个类之间的交互处理，耦合度高，而这种操作非常的不好调试。单元测试的原则之一就在于我们用来**测试的代码要求功能很单一**，这其实与良好的代码设计的思想是非常相符的。\n\n那，如何保证每一个方法都是可测试的呢？\n\n下面通过一个例子，来介绍 Swift 应该如何让代码变的可测试：\n\n```swift\nclass Phone {\n    func call(number: String){\n        print (\"Real phone calling to \\(number)\")\n    }\n}\nclass PersonalAssitant {\n    let phone = Phone()\n    let bossNumber = \"12345678\"\n\n    func callBoss(){\n        phone.call(number: bossNumber)\n    }\n}\n```\n\n这段代码也很简单，但是，我们要怎么进行测试呢？\n\n```swift\nclass PersonalAssistantTestClass: XCTestCase {\n    func testCallingBoss(){\n        let assistant = PersonalAssistant()\n        assistant.callBoss()\n        \n        // Asset ？？\n    }\n}\n```\n\n这里存在这么几个问题：\n\n1. phone，bossNumber 都是不可控的，由 PersonalAssitant 内部自己管理，他们的**耦合度很高**。\n2. 我们没法验证 callBoss **是否正确执行**了。\n3. 这只是测试用例，难道每次测试，都需要**真正调用** phone.call，给 boss 打电话？（小心人才网）\n4. 没法**快速执行**\n\n\n\n#### Dependency Injection\n\n为了降低代码本身的耦合，也为了让代码更好测试，这里我们需要引入 DI（Dependency Injection，依赖注入）。\n\n```swift\nprotocol PhoneProtocol {\n    func call(number: String)\n}\n\nclass Phone: PhoneProtocol {\n    func call(number: String){\n        print (\"Real phone calling to \\(number)\")\n    }\n}\n\nclass PersonalAssistant {\n    let phone: PhoneProtocol\n    let bossNumber: String\n    \n    init(aPhone: PhoneProtocol, myBossNumber: String) {\n        phone = aPhone\n        bossNumber = myBossNumber\n    }\n    \n    func callBoss(){\n        phone.call(number: bossNumber)\n    }\n} \n```\n\n甚至可以**提供默认值**： \n\n```swift\ninit(aPhone: PhoneProtocol = Phone(), myBossNumber: String = \"12345678\")\n```\n\n\n\n通过 DI，我们获得了对 phone 和 number 的完全控制，我们可以传人任意的号码，任意的通讯设备，这使得整个代码的扩展性更好了。同时，也解决了我们提到的第一个问题，降低耦合度。\n\n**Q：为什么说这降低了耦合度呢？**\n\nA：这里，依赖注入通过声明 phone 这个属性就可以获得对这个对象的控制权，而对该对象的依赖关系管理、加载、配置都由外部完成。\n\n更具体来说，依赖注入使得你不用关心对象的生命周期，什么时候被创建，怎么创建的，什么时候销毁。只需直接使用即可，对象的生命周期由提供依赖注入的框架来管理。\n\n**总之，依赖注入的意思是你需要的东西不是由你创建的，而是第三方，或者说容器提供给你的。这样的设计符合正交性，即所谓的松耦合。**\n\n上面的前后代码，可以这样比喻：\n前：在原始社会里，几乎没有社会分工。需要斧子的人只能自己去磨一把斧子。\n\n后：进入工业社会，工厂出现了，斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人找到工厂，购买斧子，无须关心斧子的制造过程。\n\n\n\n#### Mock\n\n至于剩下的三个问题，其实本质上是一个问题，归纳起来就是：如何快速的模拟 phone.call 这个操作，并验证它是否成功调用。\n\n> 有的人可能有疑惑，我们现在是在测 assistant.callBoss 这个方法，但是为什么变成验证 phone.call 是否调用成功？我们之前说过。当前模块的测试，只需要关注该模块本身，所以 phone.call 的测试，应该是 Phone 模块自己需要完成的。所以，如果 phone.call 被正常调用了。 那是不是就变相意味着，assistant.callBoss 这个方法测试通过？（至于调用后，是否拨打成功，这个应该是 Phone 模块应该关心的）\n\n\n\n所以，这里我们引入 Mock 这个概念，来完成这个操作。\n\n> 所谓 mock，即模拟出我们想要的内容。\n\n```swift\nclass MockPhone: PhoneProtocol {\n    var wasCalled = false\n    \n    func call(number: String) {\n        wasCalled = true\n    }\n}\n\nfunc testCallingBoss() {\n    let mockPhone = MockPhone()\n    let assistant = PersonalAssistant(aPhone: mockPhone, myBossNumber: \"12345678\") \n    assistant.callBoss()\n    XCTAssertTrue(mockPhone.wasCalled, \"Assistant should have called the boss\")\n}\n```\n\n这里我们模拟出了一个专门用来测试的 “Phone”。（它应该声明在 test 文件里。test bundle 的内容，不会包含在正式包里头）。它也实现了 call 方法，但是并不是真正的拨打电话，而是标记已经调用了 call，拨打出去了。这使得，我们的 asset 得以书写。\n\n至此，这个简单的例子，就介绍完了。通过 Protocol 依赖注入，使得我们代码的耦合度更低，扩展性更好，可测试。所以，良好的代码设计是很有必要的。\n\n\n\n------\n\n\n\n## 自测\n\n如果说，下面一个例子，能通过重构代码，写出对应的 case，那么，我这篇文章也就没白写..\n\n```swift\n@IBAction func openTapped(_ sender: Any) {\n    let mode: String\n\n    switch segmentedControl.selectedSegmentIndex {\n    case 0:\n        mode = \"view\"\n    case 1:\n        mode = \"edit\"\n    default:\n        fatalError(\"Impossible Case\")\n    }\n\n    let url = URL(string: \"myappscheme://open?id=\\(document!.identifier)&mode=\\(mode)\")!\n\n    if UIApplication.shared.canOpenURL(url) {\n        UIApplication.shared.open(url, options: [:], completionHandler: nil)\n    } else {\n        print(\"url error\")\n    }\n}\n\n// Test\nfunc testOpensDocumentURLWhenButtonIsTapped() {\n    let controller = UIStoryboard(name: \"Main\", bundle: nil).instantiateViewController(withIdentifier: \"Preview\") as! PreviewViewController\n    controller.loadViewIfNeeded()\n    controller.segmentedControl.selectedSegmentIndex = 1\n    controller.document = Document(identifier: \"TheID\")\n\n    controller.openTapped(controller.button)\n    \n    // Asset ??\n}\n```\n\n\n\nEnjoy it～\n\n\n\n------\n\n\n\n## 参考链接\n\n[Testing with Xcode](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1)\n\n[What should we Unit Test in our iOS apps?](https://medium.com/practical-ios-development/what-should-we-unit-test-in-our-ios-apps-769d55a2423b)\n\n[Better Unit Testing with Swift](http://masilotti.com/better-swift-unit-testing/)\n\n[Practical Protocol-Oriented-Programming](https://academy.realm.io/posts/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/)\n\n\n\n[单元测试准则](https://github.com/yangyubo/zh-unit-testing-guidelines)\n\n[12 个单元测试秘籍和实践](https://www.oschina.net/translate/12-unit-testing-myths-and-practices)\n\n[面向协议编程与 Cocoa 的邂逅](https://onevcat.com/2016/11/pop-cocoa-1/)","slug":"iOS-Unit-Testing","published":1,"updated":"2019-12-23T01:02:31.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1mu001fzwlnrstml56r","content":"<h2 id=\"什么是单元测试\">什么是单元测试</h2><p><strong>形象版：</strong></p>\n<blockquote>\n<p>工厂在组装一台机器之前，会<strong>对每个元件都进行测试</strong>。这，就是单元测试。</p>\n</blockquote>\n<p><strong>官方版：</strong></p>\n<blockquote>\n<p>单元测试是指对软件中的<strong>最小可测试单元</strong>进行<strong>检查和验证</strong>。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>特点：FIRST 原则</strong></p>\n<ul>\n<li><strong>Fast</strong>：测试的运行速度要快，这样就不介意运行它们。</li>\n<li><strong>Independent / Isolated</strong>：一个测试不应当依赖于另一个测试，不依赖外部环境。</li>\n<li><strong>Repeatable</strong>：同一个测试，每次都应当获得相同的结果。</li>\n<li><strong>Self-validating</strong>：测试应当是完全自动化的，输出结果要么是 pass 要么是 fail，而不是依靠程序员对日志文件的解释。</li>\n<li><strong>Timely</strong>：理想情况下，测试的编写，应当在编写要测试的产品代码之前。</li>\n</ul>\n<p><strong>Q：单元测试和其他的测试方法有什么不同呢？</strong></p>\n<p><strong>A：单元测试是在软件开发过程中要进行的最低级别的测试活动。</strong></p>\n<p>这里我们和常见的集成测试，系统测试做对比，如下：</p>\n<table>\n<thead>\n<tr>\n<th>测试方式</th>\n<th>类别</th>\n<th>察范围</th>\n<th>基准</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单元测试</td>\n<td>白盒测试</td>\n<td>单元内部的数据结构、逻辑控制、异常处理..</td>\n<td>逻辑覆盖率</td>\n</tr>\n<tr>\n<td>集成测试</td>\n<td>灰盒测试</td>\n<td>模块之间的接口和接口数据传递的关系，以及模块组合后的整体功能..</td>\n<td>接口覆盖率</td>\n</tr>\n<tr>\n<td>系统测试</td>\n<td>黑盒测试</td>\n<td>整个系统相对于需求的符合度</td>\n<td>需求规格的覆盖率</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"是否需要单元测试\">是否需要单元测试</h2><p>首先我们要知道，写代码的最终目标有两个：</p>\n<ul>\n<li><strong>实现需求</strong></li>\n<li><strong>提高代码质量和可维护性。</strong></li>\n</ul>\n<blockquote>\n<p>PS：代码的可维护性是指增加一个新功能，或改变现有功能的成本。<strong>成本越低，可维护性即越高</strong>。</p>\n</blockquote>\n<p>那，在保证完成需求的前提下，单元测试能否提高代码质量和可维护性，则关系到我们是否需要采用它。</p>\n<blockquote>\n<p>先划个重点，<strong>单元测试能提高代码质量和可维护性</strong>。</p>\n</blockquote>\n<p>如果要加入单元测试这个环节，那么前提就得保证，代码是”<strong>可测试</strong>“的。所谓可测试，就是要满足之前提到的那几个基本特性。</p>\n<p>单元测试，要求你能 mock 掉<strong>数据库</strong>、<strong>线程操作</strong>、<strong>文件操作</strong>、<strong>网络操作</strong>、<strong>UI</strong>等等，它是可以独立工作，不依赖其他单元。不难想象，一份能独立进行这种 mock 的代码，耦合程度肯定很低。</p>\n<p>所以单元测试其实本身最重要的不是测试的那个阶段，而是<strong>代码最初设计结构</strong>的那个阶段。不是为了发现 Bug，而是为了提高开发效率，为了我们的代码健康可持续发展。写单元测试会让你<strong>更好地去思考模块划分是否合理，解耦是否到位</strong>。</p>\n<p>总结来说，执行单元测试有如下好处：</p>\n<ul>\n<li>可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。（因为每次修改，都要保证测试用例能通过）</li>\n<li>帮助反思模块划分的合理性，解耦是否到位。（如果一个单元测试写得逻辑非常复杂、或者说一个函数复杂到无法写单测，那就说明模块的抽象有问题)</li>\n<li>使得软件具备更好的可维护性、具备更好的可读性。对于团队的新人来说，可以从单元测试入手，比文档更容易被程序员接受。</li>\n<li>保证代码被测试，更容易及早发现问题，降低风险。</li>\n</ul>\n<blockquote>\n<p>PS：单元测试不是万能的，它也是存在一些弊端的：</p>\n<ul>\n<li>不能减少研发的代码量，反而会花费很多精力在编写单元测试上，增加了开发成本，而且对开发人员的要求也会更高。</li>\n<li>对于小项目来说，是否执行单元测试意义不大。</li>\n<li>单元测试聚焦的是一个模块单元的功能完整性和鲁棒性，但是模块间互动可能带来的问题并不属于单元测试的范畴，同时也有很大部分的界面测试和功能测试仍旧离不开测试工程。</li>\n</ul>\n</blockquote>\n<p><strong>Q：为什么不用 UI 测试？</strong><br><strong>A：</strong></p>\n<ul>\n<li>耗时长。特别是需要运行多个 case 的时候</li>\n<li>无法测试内部的具体逻辑，比如 URL 是否正确</li>\n</ul>\n<hr>\n<h2 id=\"iOS_上的单元测试\">iOS 上的单元测试</h2><h3 id=\"XCTest_能做什么\">XCTest 能做什么</h3><p>XCTest 是 Apple 提供的测试框架，和 Xcode 无缝结合。使用它，可以很方便的进行 <strong>UI 测试，测试点录制，单元测试，性能测试，调试测试点，查看代码覆盖率，集成自动化测试..</strong></p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-results-srceditor_2x.png\" alt=\"\"></p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-runtst-10_2x.png\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/465386-6bfe56ab9062ffb9.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_1.png\" alt=\"2017081632121A35A7F5A-553B-48B0-9608-CD12A98D4CED.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_2.png\" alt=\"2017081627419EC435EE6-6007-4FD4-BA3C-73C12435D254.png\"></p>\n<p>至于如何使用 XCTest，这不是本文要讨论的内容，直接对照官方文档 <a href=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1\" target=\"_blank\" rel=\"external\">Testing with Xcode</a> 就能上手了。</p>\n<h3 id=\"应该测试什么\">应该测试什么</h3><p>那么，讲了这么久的单元测试，在 iOS 上，我们到底应该要测哪些内容呢？</p>\n<p>单元测试侧重的是<strong>逻辑测试和接口测试</strong>。在我看来，以下几部分是可以进行测试的：</p>\n<ul>\n<li>公共类中的公开方法</li>\n<li>网络数据层</li>\n<li>业务逻辑层</li>\n<li>修复 Bug 的测试</li>\n</ul>\n<p>实际操作过程中，要<strong>自下而上</strong>进行。从最基础的 Base 层，往上写测试。确保基础的 Model，Manager 测试通过，才开始为 Controller 编写测试，因为这部分业务是最复杂的，也是最容易改变的。</p>\n<blockquote>\n<p>PS：编写单元测试需要注意的一点是<strong>责任分离</strong>。即你的测试<strong>只需要针对特定单元内部的逻辑</strong>，至于其他模块是否正确，是由该模块的编写者来负责测试的。</p>\n<p>把这一点应用到实际场景，就能看出 HTTP 通信的实现并不属于我们网络请求类的逻辑。不管是用第三方的 AFNetworking，还是用系统的 NSURLConnection，这些类本身的接口不需要我们来写单元测试。</p>\n</blockquote>\n<hr>\n<h2 id=\"可测试的代码（Swift)\">可测试的代码（Swift)</h2><p>先来看一段基本的测试代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testArraySorting</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Given</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">\t<span class=\"comment\">// When</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> output = input.sorted()</span><br><span class=\"line\">\t<span class=\"comment\">// Then</span></span><br><span class=\"line\">\t<span class=\"type\">XCTAssertEqual</span>(output, [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_3.png\" alt=\"20170823150345694914363.jpg\"></p>\n<p>总结来说，测试用例可以按以下三步执行：</p>\n<ol>\n<li><strong>Given</strong>：配置测试的初始状态</li>\n<li><strong>When</strong>：对要测试的目标执行代码</li>\n<li><strong>Then</strong>：对测试结果进行断言（成功 or 失败）</li>\n</ol>\n<p>这样我们一眼扫过去就可以清晰的看出一个 case 大体上都在干什么。</p>\n<blockquote>\n<p>PS：同样一个方法，要写多个测试用例，确保每一种，每一条路径都执行到，特别是边界值。另外 Bugfix 也需要补上对应的 case。确保验证通过。</p>\n<p>另外，确保一个 case 只测试一种情况。可能我们调用的一个 API 内部有一个 if…else…。建议 if 一个case，else 一个 case。分两个不同的 case 来作测试，这样每个 case 就很清晰自己在测试什么东西。当然，如果存在大量的 if…else…，那就要考虑下代码设计上，是否存在问题了。</p>\n</blockquote>\n<p>但是实际上，我们的项目中很少有这样单一，中规中矩的方法。很多时候，项目中难免发生多个类之间的交互处理，耦合度高，而这种操作非常的不好调试。单元测试的原则之一就在于我们用来<strong>测试的代码要求功能很单一</strong>，这其实与良好的代码设计的思想是非常相符的。</p>\n<p>那，如何保证每一个方法都是可测试的呢？</p>\n<p>下面通过一个例子，来介绍 Swift 应该如何让代码变的可测试：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Phone</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span> (<span class=\"string\">\"Real phone calling to \\(number)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonalAssitant</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> phone = <span class=\"type\">Phone</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bossNumber = <span class=\"string\">\"12345678\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callBoss</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        phone.call(number: bossNumber)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码也很简单，但是，我们要怎么进行测试呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonalAssistantTestClass</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testCallingBoss</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> assistant = <span class=\"type\">PersonalAssistant</span>()</span><br><span class=\"line\">        assistant.callBoss()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Asset ？？</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里存在这么几个问题：</p>\n<ol>\n<li>phone，bossNumber 都是不可控的，由 PersonalAssitant 内部自己管理，他们的<strong>耦合度很高</strong>。</li>\n<li>我们没法验证 callBoss <strong>是否正确执行</strong>了。</li>\n<li>这只是测试用例，难道每次测试，都需要<strong>真正调用</strong> phone.call，给 boss 打电话？（小心人才网）</li>\n<li>没法<strong>快速执行</strong></li>\n</ol>\n<h4 id=\"Dependency_Injection\">Dependency Injection</h4><p>为了降低代码本身的耦合，也为了让代码更好测试，这里我们需要引入 DI（Dependency Injection，依赖注入）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PhoneProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Phone</span>: <span class=\"title\">PhoneProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span> (<span class=\"string\">\"Real phone calling to \\(number)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonalAssistant</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> phone: <span class=\"type\">PhoneProtocol</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bossNumber: <span class=\"type\">String</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(aPhone: <span class=\"type\">PhoneProtocol</span>, myBossNumber: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        phone = aPhone</span><br><span class=\"line\">        bossNumber = myBossNumber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callBoss</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        phone.call(number: bossNumber)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>甚至可以<strong>提供默认值</strong>： </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span>(aPhone: <span class=\"type\">PhoneProtocol</span> = <span class=\"type\">Phone</span>(), myBossNumber: <span class=\"type\">String</span> = <span class=\"string\">\"12345678\"</span>)</span><br></pre></td></tr></table></figure>\n<p>通过 DI，我们获得了对 phone 和 number 的完全控制，我们可以传人任意的号码，任意的通讯设备，这使得整个代码的扩展性更好了。同时，也解决了我们提到的第一个问题，降低耦合度。</p>\n<p><strong>Q：为什么说这降低了耦合度呢？</strong></p>\n<p>A：这里，依赖注入通过声明 phone 这个属性就可以获得对这个对象的控制权，而对该对象的依赖关系管理、加载、配置都由外部完成。</p>\n<p>更具体来说，依赖注入使得你不用关心对象的生命周期，什么时候被创建，怎么创建的，什么时候销毁。只需直接使用即可，对象的生命周期由提供依赖注入的框架来管理。</p>\n<p><strong>总之，依赖注入的意思是你需要的东西不是由你创建的，而是第三方，或者说容器提供给你的。这样的设计符合正交性，即所谓的松耦合。</strong></p>\n<p>上面的前后代码，可以这样比喻：<br>前：在原始社会里，几乎没有社会分工。需要斧子的人只能自己去磨一把斧子。</p>\n<p>后：进入工业社会，工厂出现了，斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人找到工厂，购买斧子，无须关心斧子的制造过程。</p>\n<h4 id=\"Mock\">Mock</h4><p>至于剩下的三个问题，其实本质上是一个问题，归纳起来就是：如何快速的模拟 phone.call 这个操作，并验证它是否成功调用。</p>\n<blockquote>\n<p>有的人可能有疑惑，我们现在是在测 assistant.callBoss 这个方法，但是为什么变成验证 phone.call 是否调用成功？我们之前说过。当前模块的测试，只需要关注该模块本身，所以 phone.call 的测试，应该是 Phone 模块自己需要完成的。所以，如果 phone.call 被正常调用了。 那是不是就变相意味着，assistant.callBoss 这个方法测试通过？（至于调用后，是否拨打成功，这个应该是 Phone 模块应该关心的）</p>\n</blockquote>\n<p>所以，这里我们引入 Mock 这个概念，来完成这个操作。</p>\n<blockquote>\n<p>所谓 mock，即模拟出我们想要的内容。</p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MockPhone</span>: <span class=\"title\">PhoneProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wasCalled = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span> &#123;</span><br><span class=\"line\">        wasCalled = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testCallingBoss</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mockPhone = <span class=\"type\">MockPhone</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> assistant = <span class=\"type\">PersonalAssistant</span>(aPhone: mockPhone, myBossNumber: <span class=\"string\">\"12345678\"</span>) </span><br><span class=\"line\">    assistant.callBoss()</span><br><span class=\"line\">    <span class=\"type\">XCTAssertTrue</span>(mockPhone.wasCalled, <span class=\"string\">\"Assistant should have called the boss\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们模拟出了一个专门用来测试的 “Phone”。（它应该声明在 test 文件里。test bundle 的内容，不会包含在正式包里头）。它也实现了 call 方法，但是并不是真正的拨打电话，而是标记已经调用了 call，拨打出去了。这使得，我们的 asset 得以书写。</p>\n<p>至此，这个简单的例子，就介绍完了。通过 Protocol 依赖注入，使得我们代码的耦合度更低，扩展性更好，可测试。所以，良好的代码设计是很有必要的。</p>\n<hr>\n<h2 id=\"自测\">自测</h2><p>如果说，下面一个例子，能通过重构代码，写出对应的 case，那么，我这篇文章也就没白写..</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">openTapped</span><span class=\"params\">(<span class=\"number\">_</span> sender: Any)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mode: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> segmentedControl.selectedSegmentIndex &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        mode = <span class=\"string\">\"view\"</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        mode = <span class=\"string\">\"edit\"</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"Impossible Case\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = <span class=\"type\">URL</span>(string: <span class=\"string\">\"myappscheme://open?id=\\(document!.identifier)&amp;mode=\\(mode)\"</span>)!</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"type\">UIApplication</span>.shared.canOpenURL(url) &#123;</span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.shared.open(url, options: [:], completionHandler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"url error\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testOpensDocumentURLWhenButtonIsTapped</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> controller = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>).instantiateViewController(withIdentifier: <span class=\"string\">\"Preview\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">PreviewViewController</span></span><br><span class=\"line\">    controller.loadViewIfNeeded()</span><br><span class=\"line\">    controller.segmentedControl.selectedSegmentIndex = <span class=\"number\">1</span></span><br><span class=\"line\">    controller.document = <span class=\"type\">Document</span>(identifier: <span class=\"string\">\"TheID\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    controller.openTapped(controller.button)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Asset ??</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Enjoy it～</p>\n<hr>\n<h2 id=\"参考链接\">参考链接</h2><p><a href=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1\" target=\"_blank\" rel=\"external\">Testing with Xcode</a></p>\n<p><a href=\"https://medium.com/practical-ios-development/what-should-we-unit-test-in-our-ios-apps-769d55a2423b\" target=\"_blank\" rel=\"external\">What should we Unit Test in our iOS apps?</a></p>\n<p><a href=\"http://masilotti.com/better-swift-unit-testing/\" target=\"_blank\" rel=\"external\">Better Unit Testing with Swift</a></p>\n<p><a href=\"https://academy.realm.io/posts/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/\" target=\"_blank\" rel=\"external\">Practical Protocol-Oriented-Programming</a></p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\" target=\"_blank\" rel=\"external\">单元测试准则</a></p>\n<p><a href=\"https://www.oschina.net/translate/12-unit-testing-myths-and-practices\" target=\"_blank\" rel=\"external\">12 个单元测试秘籍和实践</a></p>\n<p><a href=\"https://onevcat.com/2016/11/pop-cocoa-1/\" target=\"_blank\" rel=\"external\">面向协议编程与 Cocoa 的邂逅</a></p>\n","excerpt":"<h2 id=\"什么是单元测试\">什么是单元测试</h2><p><strong>形象版：</strong></p>\n<blockquote>\n<p>工厂在组装一台机器之前，会<strong>对每个元件都进行测试</strong>。这，就是单元测试。</p>\n</blockquote>\n<p><strong>官方版：</strong></p>\n<blockquote>\n<p>单元测试是指对软件中的<strong>最小可测试单元</strong>进行<strong>检查和验证</strong>。</p>\n</blockquote>","more":"<p><strong>特点：FIRST 原则</strong></p>\n<ul>\n<li><strong>Fast</strong>：测试的运行速度要快，这样就不介意运行它们。</li>\n<li><strong>Independent / Isolated</strong>：一个测试不应当依赖于另一个测试，不依赖外部环境。</li>\n<li><strong>Repeatable</strong>：同一个测试，每次都应当获得相同的结果。</li>\n<li><strong>Self-validating</strong>：测试应当是完全自动化的，输出结果要么是 pass 要么是 fail，而不是依靠程序员对日志文件的解释。</li>\n<li><strong>Timely</strong>：理想情况下，测试的编写，应当在编写要测试的产品代码之前。</li>\n</ul>\n<p><strong>Q：单元测试和其他的测试方法有什么不同呢？</strong></p>\n<p><strong>A：单元测试是在软件开发过程中要进行的最低级别的测试活动。</strong></p>\n<p>这里我们和常见的集成测试，系统测试做对比，如下：</p>\n<table>\n<thead>\n<tr>\n<th>测试方式</th>\n<th>类别</th>\n<th>察范围</th>\n<th>基准</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单元测试</td>\n<td>白盒测试</td>\n<td>单元内部的数据结构、逻辑控制、异常处理..</td>\n<td>逻辑覆盖率</td>\n</tr>\n<tr>\n<td>集成测试</td>\n<td>灰盒测试</td>\n<td>模块之间的接口和接口数据传递的关系，以及模块组合后的整体功能..</td>\n<td>接口覆盖率</td>\n</tr>\n<tr>\n<td>系统测试</td>\n<td>黑盒测试</td>\n<td>整个系统相对于需求的符合度</td>\n<td>需求规格的覆盖率</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"是否需要单元测试\">是否需要单元测试</h2><p>首先我们要知道，写代码的最终目标有两个：</p>\n<ul>\n<li><strong>实现需求</strong></li>\n<li><strong>提高代码质量和可维护性。</strong></li>\n</ul>\n<blockquote>\n<p>PS：代码的可维护性是指增加一个新功能，或改变现有功能的成本。<strong>成本越低，可维护性即越高</strong>。</p>\n</blockquote>\n<p>那，在保证完成需求的前提下，单元测试能否提高代码质量和可维护性，则关系到我们是否需要采用它。</p>\n<blockquote>\n<p>先划个重点，<strong>单元测试能提高代码质量和可维护性</strong>。</p>\n</blockquote>\n<p>如果要加入单元测试这个环节，那么前提就得保证，代码是”<strong>可测试</strong>“的。所谓可测试，就是要满足之前提到的那几个基本特性。</p>\n<p>单元测试，要求你能 mock 掉<strong>数据库</strong>、<strong>线程操作</strong>、<strong>文件操作</strong>、<strong>网络操作</strong>、<strong>UI</strong>等等，它是可以独立工作，不依赖其他单元。不难想象，一份能独立进行这种 mock 的代码，耦合程度肯定很低。</p>\n<p>所以单元测试其实本身最重要的不是测试的那个阶段，而是<strong>代码最初设计结构</strong>的那个阶段。不是为了发现 Bug，而是为了提高开发效率，为了我们的代码健康可持续发展。写单元测试会让你<strong>更好地去思考模块划分是否合理，解耦是否到位</strong>。</p>\n<p>总结来说，执行单元测试有如下好处：</p>\n<ul>\n<li>可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。（因为每次修改，都要保证测试用例能通过）</li>\n<li>帮助反思模块划分的合理性，解耦是否到位。（如果一个单元测试写得逻辑非常复杂、或者说一个函数复杂到无法写单测，那就说明模块的抽象有问题)</li>\n<li>使得软件具备更好的可维护性、具备更好的可读性。对于团队的新人来说，可以从单元测试入手，比文档更容易被程序员接受。</li>\n<li>保证代码被测试，更容易及早发现问题，降低风险。</li>\n</ul>\n<blockquote>\n<p>PS：单元测试不是万能的，它也是存在一些弊端的：</p>\n<ul>\n<li>不能减少研发的代码量，反而会花费很多精力在编写单元测试上，增加了开发成本，而且对开发人员的要求也会更高。</li>\n<li>对于小项目来说，是否执行单元测试意义不大。</li>\n<li>单元测试聚焦的是一个模块单元的功能完整性和鲁棒性，但是模块间互动可能带来的问题并不属于单元测试的范畴，同时也有很大部分的界面测试和功能测试仍旧离不开测试工程。</li>\n</ul>\n</blockquote>\n<p><strong>Q：为什么不用 UI 测试？</strong><br><strong>A：</strong></p>\n<ul>\n<li>耗时长。特别是需要运行多个 case 的时候</li>\n<li>无法测试内部的具体逻辑，比如 URL 是否正确</li>\n</ul>\n<hr>\n<h2 id=\"iOS_上的单元测试\">iOS 上的单元测试</h2><h3 id=\"XCTest_能做什么\">XCTest 能做什么</h3><p>XCTest 是 Apple 提供的测试框架，和 Xcode 无缝结合。使用它，可以很方便的进行 <strong>UI 测试，测试点录制，单元测试，性能测试，调试测试点，查看代码覆盖率，集成自动化测试..</strong></p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-results-srceditor_2x.png\" alt=\"\"></p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/Art/twx-runtst-10_2x.png\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/465386-6bfe56ab9062ffb9.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_1.png\" alt=\"2017081632121A35A7F5A-553B-48B0-9608-CD12A98D4CED.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_2.png\" alt=\"2017081627419EC435EE6-6007-4FD4-BA3C-73C12435D254.png\"></p>\n<p>至于如何使用 XCTest，这不是本文要讨论的内容，直接对照官方文档 <a href=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1\">Testing with Xcode</a> 就能上手了。</p>\n<h3 id=\"应该测试什么\">应该测试什么</h3><p>那么，讲了这么久的单元测试，在 iOS 上，我们到底应该要测哪些内容呢？</p>\n<p>单元测试侧重的是<strong>逻辑测试和接口测试</strong>。在我看来，以下几部分是可以进行测试的：</p>\n<ul>\n<li>公共类中的公开方法</li>\n<li>网络数据层</li>\n<li>业务逻辑层</li>\n<li>修复 Bug 的测试</li>\n</ul>\n<p>实际操作过程中，要<strong>自下而上</strong>进行。从最基础的 Base 层，往上写测试。确保基础的 Model，Manager 测试通过，才开始为 Controller 编写测试，因为这部分业务是最复杂的，也是最容易改变的。</p>\n<blockquote>\n<p>PS：编写单元测试需要注意的一点是<strong>责任分离</strong>。即你的测试<strong>只需要针对特定单元内部的逻辑</strong>，至于其他模块是否正确，是由该模块的编写者来负责测试的。</p>\n<p>把这一点应用到实际场景，就能看出 HTTP 通信的实现并不属于我们网络请求类的逻辑。不管是用第三方的 AFNetworking，还是用系统的 NSURLConnection，这些类本身的接口不需要我们来写单元测试。</p>\n</blockquote>\n<hr>\n<h2 id=\"可测试的代码（Swift)\">可测试的代码（Swift)</h2><p>先来看一段基本的测试代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testArraySorting</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Given</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">\t<span class=\"comment\">// When</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> output = input.sorted()</span><br><span class=\"line\">\t<span class=\"comment\">// Then</span></span><br><span class=\"line\">\t<span class=\"type\">XCTAssertEqual</span>(output, [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/UnitTest/unitTest_3.png\" alt=\"20170823150345694914363.jpg\"></p>\n<p>总结来说，测试用例可以按以下三步执行：</p>\n<ol>\n<li><strong>Given</strong>：配置测试的初始状态</li>\n<li><strong>When</strong>：对要测试的目标执行代码</li>\n<li><strong>Then</strong>：对测试结果进行断言（成功 or 失败）</li>\n</ol>\n<p>这样我们一眼扫过去就可以清晰的看出一个 case 大体上都在干什么。</p>\n<blockquote>\n<p>PS：同样一个方法，要写多个测试用例，确保每一种，每一条路径都执行到，特别是边界值。另外 Bugfix 也需要补上对应的 case。确保验证通过。</p>\n<p>另外，确保一个 case 只测试一种情况。可能我们调用的一个 API 内部有一个 if…else…。建议 if 一个case，else 一个 case。分两个不同的 case 来作测试，这样每个 case 就很清晰自己在测试什么东西。当然，如果存在大量的 if…else…，那就要考虑下代码设计上，是否存在问题了。</p>\n</blockquote>\n<p>但是实际上，我们的项目中很少有这样单一，中规中矩的方法。很多时候，项目中难免发生多个类之间的交互处理，耦合度高，而这种操作非常的不好调试。单元测试的原则之一就在于我们用来<strong>测试的代码要求功能很单一</strong>，这其实与良好的代码设计的思想是非常相符的。</p>\n<p>那，如何保证每一个方法都是可测试的呢？</p>\n<p>下面通过一个例子，来介绍 Swift 应该如何让代码变的可测试：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Phone</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span> (<span class=\"string\">\"Real phone calling to \\(number)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonalAssitant</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> phone = <span class=\"type\">Phone</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bossNumber = <span class=\"string\">\"12345678\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callBoss</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        phone.call(number: bossNumber)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码也很简单，但是，我们要怎么进行测试呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonalAssistantTestClass</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testCallingBoss</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> assistant = <span class=\"type\">PersonalAssistant</span>()</span><br><span class=\"line\">        assistant.callBoss()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Asset ？？</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里存在这么几个问题：</p>\n<ol>\n<li>phone，bossNumber 都是不可控的，由 PersonalAssitant 内部自己管理，他们的<strong>耦合度很高</strong>。</li>\n<li>我们没法验证 callBoss <strong>是否正确执行</strong>了。</li>\n<li>这只是测试用例，难道每次测试，都需要<strong>真正调用</strong> phone.call，给 boss 打电话？（小心人才网）</li>\n<li>没法<strong>快速执行</strong></li>\n</ol>\n<h4 id=\"Dependency_Injection\">Dependency Injection</h4><p>为了降低代码本身的耦合，也为了让代码更好测试，这里我们需要引入 DI（Dependency Injection，依赖注入）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PhoneProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Phone</span>: <span class=\"title\">PhoneProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span> (<span class=\"string\">\"Real phone calling to \\(number)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonalAssistant</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> phone: <span class=\"type\">PhoneProtocol</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bossNumber: <span class=\"type\">String</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(aPhone: <span class=\"type\">PhoneProtocol</span>, myBossNumber: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        phone = aPhone</span><br><span class=\"line\">        bossNumber = myBossNumber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callBoss</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        phone.call(number: bossNumber)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>甚至可以<strong>提供默认值</strong>： </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span>(aPhone: <span class=\"type\">PhoneProtocol</span> = <span class=\"type\">Phone</span>(), myBossNumber: <span class=\"type\">String</span> = <span class=\"string\">\"12345678\"</span>)</span><br></pre></td></tr></table></figure>\n<p>通过 DI，我们获得了对 phone 和 number 的完全控制，我们可以传人任意的号码，任意的通讯设备，这使得整个代码的扩展性更好了。同时，也解决了我们提到的第一个问题，降低耦合度。</p>\n<p><strong>Q：为什么说这降低了耦合度呢？</strong></p>\n<p>A：这里，依赖注入通过声明 phone 这个属性就可以获得对这个对象的控制权，而对该对象的依赖关系管理、加载、配置都由外部完成。</p>\n<p>更具体来说，依赖注入使得你不用关心对象的生命周期，什么时候被创建，怎么创建的，什么时候销毁。只需直接使用即可，对象的生命周期由提供依赖注入的框架来管理。</p>\n<p><strong>总之，依赖注入的意思是你需要的东西不是由你创建的，而是第三方，或者说容器提供给你的。这样的设计符合正交性，即所谓的松耦合。</strong></p>\n<p>上面的前后代码，可以这样比喻：<br>前：在原始社会里，几乎没有社会分工。需要斧子的人只能自己去磨一把斧子。</p>\n<p>后：进入工业社会，工厂出现了，斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人找到工厂，购买斧子，无须关心斧子的制造过程。</p>\n<h4 id=\"Mock\">Mock</h4><p>至于剩下的三个问题，其实本质上是一个问题，归纳起来就是：如何快速的模拟 phone.call 这个操作，并验证它是否成功调用。</p>\n<blockquote>\n<p>有的人可能有疑惑，我们现在是在测 assistant.callBoss 这个方法，但是为什么变成验证 phone.call 是否调用成功？我们之前说过。当前模块的测试，只需要关注该模块本身，所以 phone.call 的测试，应该是 Phone 模块自己需要完成的。所以，如果 phone.call 被正常调用了。 那是不是就变相意味着，assistant.callBoss 这个方法测试通过？（至于调用后，是否拨打成功，这个应该是 Phone 模块应该关心的）</p>\n</blockquote>\n<p>所以，这里我们引入 Mock 这个概念，来完成这个操作。</p>\n<blockquote>\n<p>所谓 mock，即模拟出我们想要的内容。</p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MockPhone</span>: <span class=\"title\">PhoneProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wasCalled = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">call</span><span class=\"params\">(number: String)</span></span> &#123;</span><br><span class=\"line\">        wasCalled = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testCallingBoss</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mockPhone = <span class=\"type\">MockPhone</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> assistant = <span class=\"type\">PersonalAssistant</span>(aPhone: mockPhone, myBossNumber: <span class=\"string\">\"12345678\"</span>) </span><br><span class=\"line\">    assistant.callBoss()</span><br><span class=\"line\">    <span class=\"type\">XCTAssertTrue</span>(mockPhone.wasCalled, <span class=\"string\">\"Assistant should have called the boss\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们模拟出了一个专门用来测试的 “Phone”。（它应该声明在 test 文件里。test bundle 的内容，不会包含在正式包里头）。它也实现了 call 方法，但是并不是真正的拨打电话，而是标记已经调用了 call，拨打出去了。这使得，我们的 asset 得以书写。</p>\n<p>至此，这个简单的例子，就介绍完了。通过 Protocol 依赖注入，使得我们代码的耦合度更低，扩展性更好，可测试。所以，良好的代码设计是很有必要的。</p>\n<hr>\n<h2 id=\"自测\">自测</h2><p>如果说，下面一个例子，能通过重构代码，写出对应的 case，那么，我这篇文章也就没白写..</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">openTapped</span><span class=\"params\">(<span class=\"number\">_</span> sender: Any)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mode: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> segmentedControl.selectedSegmentIndex &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        mode = <span class=\"string\">\"view\"</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        mode = <span class=\"string\">\"edit\"</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"Impossible Case\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = <span class=\"type\">URL</span>(string: <span class=\"string\">\"myappscheme://open?id=\\(document!.identifier)&amp;mode=\\(mode)\"</span>)!</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"type\">UIApplication</span>.shared.canOpenURL(url) &#123;</span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.shared.open(url, options: [:], completionHandler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"url error\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testOpensDocumentURLWhenButtonIsTapped</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> controller = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>).instantiateViewController(withIdentifier: <span class=\"string\">\"Preview\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">PreviewViewController</span></span><br><span class=\"line\">    controller.loadViewIfNeeded()</span><br><span class=\"line\">    controller.segmentedControl.selectedSegmentIndex = <span class=\"number\">1</span></span><br><span class=\"line\">    controller.document = <span class=\"type\">Document</span>(identifier: <span class=\"string\">\"TheID\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    controller.openTapped(controller.button)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Asset ??</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Enjoy it～</p>\n<hr>\n<h2 id=\"参考链接\">参考链接</h2><p><a href=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1\">Testing with Xcode</a></p>\n<p><a href=\"https://medium.com/practical-ios-development/what-should-we-unit-test-in-our-ios-apps-769d55a2423b\">What should we Unit Test in our iOS apps?</a></p>\n<p><a href=\"http://masilotti.com/better-swift-unit-testing/\">Better Unit Testing with Swift</a></p>\n<p><a href=\"https://academy.realm.io/posts/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/\">Practical Protocol-Oriented-Programming</a></p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">单元测试准则</a></p>\n<p><a href=\"https://www.oschina.net/translate/12-unit-testing-myths-and-practices\">12 个单元测试秘籍和实践</a></p>\n<p><a href=\"https://onevcat.com/2016/11/pop-cocoa-1/\">面向协议编程与 Cocoa 的邂逅</a></p>"},{"layout":"面试总结","title":"阿里, 网易, 腾讯","date":"2015-07-11T02:14:52.000Z","_content":"\n#一个多月来的面试总结(阿里, 网易, 腾讯)\n\n> 想必关注我的朋友都发现了, 最近我发表原创文章的数量和质量大大不如以前了, 也不怎么活跃了。主要原因是现在大三了, 7月份就能离校实习了, 所以前段时间也在为找实习忙碌着。接下去应该就能恢复正常, 继续为大家分享一些iOS开发上的小技巧, 毕竟, 也算拿到了心仪的offer。\n\n\n<!--more-->\n\n\n**接下去, 就围绕这一个多月来参加的几场面试, 做一个总结。 设计的公司主要包括阿里研发部分, 网易邮件, 腾讯微信。希望能给同样在为找实习努力的战友提供一些帮助。(`已经拿到网易和微信的offer`)**\n\nPS: 总结不是空穴来风, 每次面试完, 我都会坐着认真总结之前的面试, 记录每道题, 每个答案的关键点, 再比对下自己的回答是否完整。\n\n<img src='http://img.my.csdn.net/uploads/201504/25/1429944250_1723.jpeg' width=900>\n\n\n**另外, 博客篇幅有限, 并且题目并不是适合每一位同学(我是iOS开发相关, 题目主要都是iOS相关), 所以不适合把完整的题目都描述出来, 文章主要是一些经验交流。 `如果需要完整面试题目的, 麻烦留下邮箱, 我看到了会一一发送`。**\n\n\n> 以下按参加的时间先后来描述, 另外我的个人主页 [Colin's Nest](http://colin1994.xyz), 里面有我的一些介绍, 包括简历。感兴趣的可以瞅瞅。\n\n\n\n#阿里_研发部门\n\n阿里是最早投的一家公司, 3月初那会, 本来还在学习科二的, 然后在阿里的学长, 催着要简历, 说内推已经开始了。于是乎, 我就借机把科二给退了(被教练骂成狗的滋味真不好受, 还好及时跑了)。学长给内推的部门是和o2o相关, iOS开发。\n\n\n##阿里一面_电话\n\n然后等了几天, `3月9号`, 一面开始了, 节奏很快, 总共通话时候是`26分钟`..\n\n\n电话来的比较突然, 那会还在看文章呢。一面过了, 但是具体表现并不是很理想。\n\n1. 先是自我介绍。\n2. 问iOS相关。 比如:\n\n\t1. Category支持添加属性与成员变量吗\n\t2. iOS7之后, 蓝牙的围栏功能\n\t3. 说说Cell重用原理\n\t...\n\t\n\t\n3. 设计模式。这里主要问了iOS常用的设计模式, 以及如何应用到实际需求中去。\n\t\n\t1. MVC是否了解?介绍下使用情况。\n\t2. MVC里面, View怎么通知到Model\n\t3. 了解delegate吗?并介绍\n\t4. 如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么\n\t\n4. 然后就是再交流, 对o2o有什么看法, 有没有想问他的...\n\n\n\n##阿里二面_电话\n\n然后又过了两天, 二面如约来了, 36分钟, 感觉比上次好, 不过结果...\n\n二面和一面一样, 都围绕iOS, 问了objc相关, 内存管理, 设计模式等。\n\n但是更多的, 询问了我平时的一些开发习惯, 以及一些设计题。\n\n比如:\n\n* 如果让你设计KVO, 要怎么设计\n* 现在你是如何适配的\n* 比较下storyboard和全代码\n* 如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动\n* 平时是怎么进行测试的, 内存方面怎么测试\n* 平时自己有没有封装过比较复杂的控件\n* 平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析..\n* 如何实现类似 \"Find My iPhone\" 这样功能\n\n\n二面相比一面来说, 准备的更充分了。回答问题上, 也比较积极, 考虑的也比较多。不过二面结束没多久, 内推状态就变成\"待回绝\"。 Over了...\n\n学长询问了面试官, 结果是: \"整体还不错, 但总感觉少了点什么..\"\n\n经历完阿里这一次, 总体来说, 对我打击还挺大的。毕竟, 第一次就跪了..  同时, 更多的是对自我的总结。\n\n首先应该是准备不够充分, 然后就是基础不够扎实。从面试官问的问题来看, `大公司还是对基础要求比较高`。\n\n\n##阿里校招_在线笔试\n\n之后, 又投了阿里校招, 参加了在线笔试。具体题目可以在这里看到:[阿里笔试题](http://www.nowcoder.com/companyCenterTerminal_134)\n\n虽然笔试通过了, 不过现场面试的时间和课程冲突了, 然后就没有跑去杭州面试。\n\n于是乎, 和阿里就这样不了了之了。\n\n\n#网易_邮件部门(拿到offer)\n\n在结束阿里内推没多久, 偶然在网上看到网易的一个招聘。 因为方式比较新颖, 就关注了下。\n\n<img src='http://img.my.csdn.net/uploads/201504/25/1429947172_7894.jpg' width=900>\n\n**答案就在门的背后！(至于如何解题欢迎大家交流)**\n\n解开这个题目后, 拿到了面试官的邮箱.. 然后抱着侥幸的心理, 就投了。\n\n##网易一面_电话\n\n没想到, 第二天就来电话了。效率很高。 `55分钟`.. 感觉被虐哭了。\n\n\n网易考核的主要是`objc, iOS, 设计模式, 算法`。 \n\n主要如下:\n\n1. autorelease 和 @autoreleasepool区别\n2. unsafe_unretained , weak, assign 区别\n3. 在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗\n4. 在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok\n5. NSThread, NSOperation, GCD区别\n6. runtime什么时候用\n7. 通知和KVO区别\n8. 深度遍历和广度遍历使用场景\n9. 常用的设计模式\n10. 算法题 * 2\n11. 自己有什么优点\n\n\n...\n\n面完之后, 感觉整个人都不好了。`内存管理`部分, 都能说出那么一些, 但是一说多了, 就不知道怎么回答了。总体来说, 还是基础不够扎实。研究不够透彻。\n\n然后面试完, 一个很大的感受就是, `一次面试, 学到的, 比自己闷头看书一个月, 学到的还多`。`面试很直观的反应出了自己的不足`。于是乎, 针对内存管理, 多线程等知识上的不足。 我重新把那本狮子头的书认真看了遍。\n\nPS: 如果觉得这方面知识也有所欠缺的话, 可以到这里下载`Objective-C高级编程 iOS与OS X多线程和内存管理.pdf`这本书, 极力推荐。\n\n下载链接: [电子书分享](http://pan.baidu.com/s/1pJsno7p)\n\n本以为, 网易也就是这么结束了。 没想到过了几天, 人力资源部的妹子打电话来, 约去杭州面试。\n\n于是乎于是乎, 去杭州浪了~\n\n##网易二面_现场\n\n初到杭州, 很巧的是在机场大巴上碰到了一个去H3C培训的大叔, 更巧的是, 他也住我那个酒店。 然后就跟着他, 一路聊到酒店.. 挺好。\n\n第二天网易面试, 还是挺紧张的。9点多到了待客大厅, 填了表, 然后等面试官。然后网易给我的一个感觉就是, 很`内敛, 低调`, 感觉挺好。\n\n之后一下来了两个面试官, 领我到单独的小隔间面试.. 一次两个, 有点虚。\n\n不过没多久, 就适应了这种气氛, 然后和面试官交流也比较开心。\n\n主要问题如下:\n\n1. 我是上次和你通电话的那位, 你觉得自己上次表现怎么样\n2. 这段时间, 都在干嘛\n3. 我们认真看了你的github, 感觉还不错\n\n\n然后给我一张纸, 问了几个算法题:\n\n1. 如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3]\n2. 实现连连看算法\n3. T9算法如何实现, 全拼算法\n\n总的来说, 问的都是`算法`相关, 没有再涉及iOS部分。 然后就算法来说, 回答的还不错。虽然每道题不是一步到位, 但是在与面试官沟通过程中, 最后都逐步完善了自己的算法。\n\n然后就是和面试官聊天了, 两位面试官都很平易近人, 聊得也比较开心。 然后就约了下午HR面。\n\n...面试完后, 包括面试官已经人力管理的妹子都邀请我去网易食堂吃饭, 不过毕竟腼腆, 我给拒绝了。出来才发现.. 找个饭店真不容易.. 早知道就厚着脸皮试试\"丁家猪\"了。\n\n##网易HR面_现场\n\n下午HR面, HR是个很漂亮的妹子.. 整个过程都比较欢乐， 虽然一些问题上可能有不同看法。\n\nHR问的主要是一些职业规划, 抗压能力, 学习习惯, 别人怎么看待自己等等..\n\n面试完以后, HR问我接下去准备干嘛, 我说我要一路玩到萧山机场(那天酒店在萧山机场附近)。然后她打趣到:\"真潇洒阿..\"\n\n杭州确实很美, 不够时间关系, 就在西湖附近逛了会。 附带两张图片。\n\n<img src='http://img.my.csdn.net/uploads/201504/25/1429949156_7015.JPG' width=900>\n<img src='http://img.my.csdn.net/uploads/201504/25/1429949125_2851.JPG' width=900>\n\n\n3.31参加完网易杭州的现场面试. 4月23号收到网易的正式offer。 总算, 踏实了...\n\n\n#腾讯_微信事业部(拿到offer)\n\n之前腾讯校招的时候, 投了简历。 不过一直到周围同学都参加了在线笔试, 我仍然没收到通知的时候, 我基本上已经放弃了。觉得自己应该在简历环节就被刷了, 比较凄凉..\n\n\n##微信一面_电话\n不过4月20的时候, 突然来了个电话, 对方说是腾讯微信事业部的。 很突然, 完全没想到。 可以说， 幸福来的太突然了..\n\n电话用时`1小时10分`.. 中间把院长的课给翘了.. - -!\n\n主要还是围绕这几个方面: 项目, 设计模式, 算法..\n\n问题包括:\n\n1. 如何保证软件质量, 怎么分析Crash日志\n2. 谈谈你觉得最重要的一个项目\n3. 你的个人主页是怎么写的\n4. 假如我是一名初学者, 你会向我推荐哪些第三方库\n5. 使用了第三方库, 有看他们是怎么实现的吗\n6. 有没有看过大型项目的源码\n7. 强连通量算法\n8. 最短路径算法\n9. 排序算法\n10. 25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名\n\n腾讯给我的感觉就是, 很靠谱。 `这几轮面试, 就腾讯当场就给出了结果, 不管是一面, 二面, 还是HR面 而不是说让你再等通知。 给我的感觉非常好`。\n\n一面最后, 这个面试官就说, 他这里通过了, 问我明天什么时候有时间, 给我约下另外一个面试官。\n\n##微信二面_collabedit+电话\n\n第二天微信二面如约来了, 面试官很好。提前打电话问我有没有时间, 我表示想午睡一会, 一个小时后开始。他答应了。\n\n然后一个小时后, 另外一个面试官打电话来了, 要我登录 http://collabedit.com/xxxx 答题。\n\ncollabedit可以在线共享。 就是说, 我这里敲什么, 面试官那里就能同步显示。 主要是考核编码能力。\n\n主要是两个算法题, 第一道要求写出完整代码, 第二道思路交流。\n\n1. 求两个整数的最大公约数\n2. 微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分。\n\n完了之后, 面试官问了我实习时间, 然后问我对深圳和广州的看法(因为我第一志愿填的是深圳, 微信本部在广州), 问我愿意去广州吗。 之后就表示他这里也通过了。 这一两天给我约HR。\n\n##微信HR面_电话\n\n果然, 两天后, 微信HR来电话了。\n\n和她聊天很轻松, 从头到尾都是喊我'龙泽 .. 龙泽', 感觉很亲切。 主要也是围绕职业规划等展开。\n\n然后最后就问我, 是否愿意来微信实习, 如果愿意, 马上就给我offer, 如果还犹豫, 考虑清楚再联系她。\n\n当然, 我表示愿意。 然后hr留了微信号, 说安排同事给我发确认函。\n\n当天晚上, 另外一个人力资源的妹子打电话, 和我讨论薪资等问题..\n\n\n总的来说, 微信从一面, 到最后确定下来, 就经历了4天。 非常效率。 中间也很愉快。\n\n说来也巧, 网易和微信是同时发来来的offer。网易电话刚放下没多久, 微信hr就来电话了。所以当时两边是先都允诺能去实习了，毕竟时间太紧, 还没考虑好。\n\n之后还是因为个人原因, 选择了微信, 所以当天下午就打电话给网易, 告知了他们。多少也有些遗憾, 毕竟网易也是我很向往的一家公司。\n\n\n好了。 到此, 这段时间的面试总结就写好了。下面就我个人来说, 提几点建议:\n\n1. 基础。 不管是哪个方向, 基础很重要。就比如iOS, objc的方方面面都必须了解。\n2. 全面。 有些东西, 虽然不见得能答好, 但你至少应该懂。\n3. 设计模式。 主流的那些设计模式非常有必要了解。\n4. 算法。 这个不是说恶补能补好的。建议大家长期积累。 另外推荐<剑指offer>这本书。同时, 可以在这里线上答题: [牛客网-剑指offer](http://www.nowcoder.com/books/coding-interviews)\n5. 简历一定要真实! 基本上面试官都是围绕简历展开交流的。 懂或不懂, 一问就知道, 没必要搬起石头砸自己的脚\n6. 提前准备。 比如自我介绍, 项目介绍, 职业规划等等。基本都是必问的题目，能提前准备就提前准备好。\n7. 开源, 分享, 积累。 我一直认为, 分享和开源是程序员进步的不二法门。 我建议每个程序员都应该有自己的Github, 有自己的博客。就这几次面试来说, 博客和Github帮了我多。 网易面试官直言, 他们认真看过我的Github, 微信HR问我要CSDN博客ID, 说她很感兴趣。帮助别人, 也是帮助自己。\n8. 沟通。 有时候一个问题, 可能不懂, 甚至题目都不理解。不要害怕, 主动与面试官沟通。 我在网易面试的时候, 关于全拼算法的实现, 我当时连全拼都没一个完整的概念, 它要满足哪些条件更加不清楚。我跟面试官坦诚我不懂这个概念, 与他们的一步步沟通中实现了自己的算法。 所以沟通, 远比闷头写, 到头来还可能错误来的实在。\n9. 自信。 能得到面试机会, 最起码证明, 你很优秀。 我觉得自信很重要。 如果一开始, 就表现的慌慌张张, 畏首畏尾, 那么不管是你自己的发挥, 还是面试官对你的看法, 我觉得都不会很好。 \n\n\n敲了一下午.. 真累。\n\n`希望和我一样大三找实习的朋友, 都能拿到自己心仪的offer!`\n\n**学习的路上, 与君共勉。**\n\n\n\n\n\n","source":"_posts/interview-summary.md","raw":"layout: \"面试总结\"\ntitle: 阿里, 网易, 腾讯\ndate: 2015-07-11 10:14:52\ntags:\n- 面试\n- 随笔\n---\n\n#一个多月来的面试总结(阿里, 网易, 腾讯)\n\n> 想必关注我的朋友都发现了, 最近我发表原创文章的数量和质量大大不如以前了, 也不怎么活跃了。主要原因是现在大三了, 7月份就能离校实习了, 所以前段时间也在为找实习忙碌着。接下去应该就能恢复正常, 继续为大家分享一些iOS开发上的小技巧, 毕竟, 也算拿到了心仪的offer。\n\n\n<!--more-->\n\n\n**接下去, 就围绕这一个多月来参加的几场面试, 做一个总结。 设计的公司主要包括阿里研发部分, 网易邮件, 腾讯微信。希望能给同样在为找实习努力的战友提供一些帮助。(`已经拿到网易和微信的offer`)**\n\nPS: 总结不是空穴来风, 每次面试完, 我都会坐着认真总结之前的面试, 记录每道题, 每个答案的关键点, 再比对下自己的回答是否完整。\n\n<img src='http://img.my.csdn.net/uploads/201504/25/1429944250_1723.jpeg' width=900>\n\n\n**另外, 博客篇幅有限, 并且题目并不是适合每一位同学(我是iOS开发相关, 题目主要都是iOS相关), 所以不适合把完整的题目都描述出来, 文章主要是一些经验交流。 `如果需要完整面试题目的, 麻烦留下邮箱, 我看到了会一一发送`。**\n\n\n> 以下按参加的时间先后来描述, 另外我的个人主页 [Colin's Nest](http://colin1994.xyz), 里面有我的一些介绍, 包括简历。感兴趣的可以瞅瞅。\n\n\n\n#阿里_研发部门\n\n阿里是最早投的一家公司, 3月初那会, 本来还在学习科二的, 然后在阿里的学长, 催着要简历, 说内推已经开始了。于是乎, 我就借机把科二给退了(被教练骂成狗的滋味真不好受, 还好及时跑了)。学长给内推的部门是和o2o相关, iOS开发。\n\n\n##阿里一面_电话\n\n然后等了几天, `3月9号`, 一面开始了, 节奏很快, 总共通话时候是`26分钟`..\n\n\n电话来的比较突然, 那会还在看文章呢。一面过了, 但是具体表现并不是很理想。\n\n1. 先是自我介绍。\n2. 问iOS相关。 比如:\n\n\t1. Category支持添加属性与成员变量吗\n\t2. iOS7之后, 蓝牙的围栏功能\n\t3. 说说Cell重用原理\n\t...\n\t\n\t\n3. 设计模式。这里主要问了iOS常用的设计模式, 以及如何应用到实际需求中去。\n\t\n\t1. MVC是否了解?介绍下使用情况。\n\t2. MVC里面, View怎么通知到Model\n\t3. 了解delegate吗?并介绍\n\t4. 如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么\n\t\n4. 然后就是再交流, 对o2o有什么看法, 有没有想问他的...\n\n\n\n##阿里二面_电话\n\n然后又过了两天, 二面如约来了, 36分钟, 感觉比上次好, 不过结果...\n\n二面和一面一样, 都围绕iOS, 问了objc相关, 内存管理, 设计模式等。\n\n但是更多的, 询问了我平时的一些开发习惯, 以及一些设计题。\n\n比如:\n\n* 如果让你设计KVO, 要怎么设计\n* 现在你是如何适配的\n* 比较下storyboard和全代码\n* 如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动\n* 平时是怎么进行测试的, 内存方面怎么测试\n* 平时自己有没有封装过比较复杂的控件\n* 平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析..\n* 如何实现类似 \"Find My iPhone\" 这样功能\n\n\n二面相比一面来说, 准备的更充分了。回答问题上, 也比较积极, 考虑的也比较多。不过二面结束没多久, 内推状态就变成\"待回绝\"。 Over了...\n\n学长询问了面试官, 结果是: \"整体还不错, 但总感觉少了点什么..\"\n\n经历完阿里这一次, 总体来说, 对我打击还挺大的。毕竟, 第一次就跪了..  同时, 更多的是对自我的总结。\n\n首先应该是准备不够充分, 然后就是基础不够扎实。从面试官问的问题来看, `大公司还是对基础要求比较高`。\n\n\n##阿里校招_在线笔试\n\n之后, 又投了阿里校招, 参加了在线笔试。具体题目可以在这里看到:[阿里笔试题](http://www.nowcoder.com/companyCenterTerminal_134)\n\n虽然笔试通过了, 不过现场面试的时间和课程冲突了, 然后就没有跑去杭州面试。\n\n于是乎, 和阿里就这样不了了之了。\n\n\n#网易_邮件部门(拿到offer)\n\n在结束阿里内推没多久, 偶然在网上看到网易的一个招聘。 因为方式比较新颖, 就关注了下。\n\n<img src='http://img.my.csdn.net/uploads/201504/25/1429947172_7894.jpg' width=900>\n\n**答案就在门的背后！(至于如何解题欢迎大家交流)**\n\n解开这个题目后, 拿到了面试官的邮箱.. 然后抱着侥幸的心理, 就投了。\n\n##网易一面_电话\n\n没想到, 第二天就来电话了。效率很高。 `55分钟`.. 感觉被虐哭了。\n\n\n网易考核的主要是`objc, iOS, 设计模式, 算法`。 \n\n主要如下:\n\n1. autorelease 和 @autoreleasepool区别\n2. unsafe_unretained , weak, assign 区别\n3. 在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗\n4. 在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok\n5. NSThread, NSOperation, GCD区别\n6. runtime什么时候用\n7. 通知和KVO区别\n8. 深度遍历和广度遍历使用场景\n9. 常用的设计模式\n10. 算法题 * 2\n11. 自己有什么优点\n\n\n...\n\n面完之后, 感觉整个人都不好了。`内存管理`部分, 都能说出那么一些, 但是一说多了, 就不知道怎么回答了。总体来说, 还是基础不够扎实。研究不够透彻。\n\n然后面试完, 一个很大的感受就是, `一次面试, 学到的, 比自己闷头看书一个月, 学到的还多`。`面试很直观的反应出了自己的不足`。于是乎, 针对内存管理, 多线程等知识上的不足。 我重新把那本狮子头的书认真看了遍。\n\nPS: 如果觉得这方面知识也有所欠缺的话, 可以到这里下载`Objective-C高级编程 iOS与OS X多线程和内存管理.pdf`这本书, 极力推荐。\n\n下载链接: [电子书分享](http://pan.baidu.com/s/1pJsno7p)\n\n本以为, 网易也就是这么结束了。 没想到过了几天, 人力资源部的妹子打电话来, 约去杭州面试。\n\n于是乎于是乎, 去杭州浪了~\n\n##网易二面_现场\n\n初到杭州, 很巧的是在机场大巴上碰到了一个去H3C培训的大叔, 更巧的是, 他也住我那个酒店。 然后就跟着他, 一路聊到酒店.. 挺好。\n\n第二天网易面试, 还是挺紧张的。9点多到了待客大厅, 填了表, 然后等面试官。然后网易给我的一个感觉就是, 很`内敛, 低调`, 感觉挺好。\n\n之后一下来了两个面试官, 领我到单独的小隔间面试.. 一次两个, 有点虚。\n\n不过没多久, 就适应了这种气氛, 然后和面试官交流也比较开心。\n\n主要问题如下:\n\n1. 我是上次和你通电话的那位, 你觉得自己上次表现怎么样\n2. 这段时间, 都在干嘛\n3. 我们认真看了你的github, 感觉还不错\n\n\n然后给我一张纸, 问了几个算法题:\n\n1. 如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3]\n2. 实现连连看算法\n3. T9算法如何实现, 全拼算法\n\n总的来说, 问的都是`算法`相关, 没有再涉及iOS部分。 然后就算法来说, 回答的还不错。虽然每道题不是一步到位, 但是在与面试官沟通过程中, 最后都逐步完善了自己的算法。\n\n然后就是和面试官聊天了, 两位面试官都很平易近人, 聊得也比较开心。 然后就约了下午HR面。\n\n...面试完后, 包括面试官已经人力管理的妹子都邀请我去网易食堂吃饭, 不过毕竟腼腆, 我给拒绝了。出来才发现.. 找个饭店真不容易.. 早知道就厚着脸皮试试\"丁家猪\"了。\n\n##网易HR面_现场\n\n下午HR面, HR是个很漂亮的妹子.. 整个过程都比较欢乐， 虽然一些问题上可能有不同看法。\n\nHR问的主要是一些职业规划, 抗压能力, 学习习惯, 别人怎么看待自己等等..\n\n面试完以后, HR问我接下去准备干嘛, 我说我要一路玩到萧山机场(那天酒店在萧山机场附近)。然后她打趣到:\"真潇洒阿..\"\n\n杭州确实很美, 不够时间关系, 就在西湖附近逛了会。 附带两张图片。\n\n<img src='http://img.my.csdn.net/uploads/201504/25/1429949156_7015.JPG' width=900>\n<img src='http://img.my.csdn.net/uploads/201504/25/1429949125_2851.JPG' width=900>\n\n\n3.31参加完网易杭州的现场面试. 4月23号收到网易的正式offer。 总算, 踏实了...\n\n\n#腾讯_微信事业部(拿到offer)\n\n之前腾讯校招的时候, 投了简历。 不过一直到周围同学都参加了在线笔试, 我仍然没收到通知的时候, 我基本上已经放弃了。觉得自己应该在简历环节就被刷了, 比较凄凉..\n\n\n##微信一面_电话\n不过4月20的时候, 突然来了个电话, 对方说是腾讯微信事业部的。 很突然, 完全没想到。 可以说， 幸福来的太突然了..\n\n电话用时`1小时10分`.. 中间把院长的课给翘了.. - -!\n\n主要还是围绕这几个方面: 项目, 设计模式, 算法..\n\n问题包括:\n\n1. 如何保证软件质量, 怎么分析Crash日志\n2. 谈谈你觉得最重要的一个项目\n3. 你的个人主页是怎么写的\n4. 假如我是一名初学者, 你会向我推荐哪些第三方库\n5. 使用了第三方库, 有看他们是怎么实现的吗\n6. 有没有看过大型项目的源码\n7. 强连通量算法\n8. 最短路径算法\n9. 排序算法\n10. 25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名\n\n腾讯给我的感觉就是, 很靠谱。 `这几轮面试, 就腾讯当场就给出了结果, 不管是一面, 二面, 还是HR面 而不是说让你再等通知。 给我的感觉非常好`。\n\n一面最后, 这个面试官就说, 他这里通过了, 问我明天什么时候有时间, 给我约下另外一个面试官。\n\n##微信二面_collabedit+电话\n\n第二天微信二面如约来了, 面试官很好。提前打电话问我有没有时间, 我表示想午睡一会, 一个小时后开始。他答应了。\n\n然后一个小时后, 另外一个面试官打电话来了, 要我登录 http://collabedit.com/xxxx 答题。\n\ncollabedit可以在线共享。 就是说, 我这里敲什么, 面试官那里就能同步显示。 主要是考核编码能力。\n\n主要是两个算法题, 第一道要求写出完整代码, 第二道思路交流。\n\n1. 求两个整数的最大公约数\n2. 微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分。\n\n完了之后, 面试官问了我实习时间, 然后问我对深圳和广州的看法(因为我第一志愿填的是深圳, 微信本部在广州), 问我愿意去广州吗。 之后就表示他这里也通过了。 这一两天给我约HR。\n\n##微信HR面_电话\n\n果然, 两天后, 微信HR来电话了。\n\n和她聊天很轻松, 从头到尾都是喊我'龙泽 .. 龙泽', 感觉很亲切。 主要也是围绕职业规划等展开。\n\n然后最后就问我, 是否愿意来微信实习, 如果愿意, 马上就给我offer, 如果还犹豫, 考虑清楚再联系她。\n\n当然, 我表示愿意。 然后hr留了微信号, 说安排同事给我发确认函。\n\n当天晚上, 另外一个人力资源的妹子打电话, 和我讨论薪资等问题..\n\n\n总的来说, 微信从一面, 到最后确定下来, 就经历了4天。 非常效率。 中间也很愉快。\n\n说来也巧, 网易和微信是同时发来来的offer。网易电话刚放下没多久, 微信hr就来电话了。所以当时两边是先都允诺能去实习了，毕竟时间太紧, 还没考虑好。\n\n之后还是因为个人原因, 选择了微信, 所以当天下午就打电话给网易, 告知了他们。多少也有些遗憾, 毕竟网易也是我很向往的一家公司。\n\n\n好了。 到此, 这段时间的面试总结就写好了。下面就我个人来说, 提几点建议:\n\n1. 基础。 不管是哪个方向, 基础很重要。就比如iOS, objc的方方面面都必须了解。\n2. 全面。 有些东西, 虽然不见得能答好, 但你至少应该懂。\n3. 设计模式。 主流的那些设计模式非常有必要了解。\n4. 算法。 这个不是说恶补能补好的。建议大家长期积累。 另外推荐<剑指offer>这本书。同时, 可以在这里线上答题: [牛客网-剑指offer](http://www.nowcoder.com/books/coding-interviews)\n5. 简历一定要真实! 基本上面试官都是围绕简历展开交流的。 懂或不懂, 一问就知道, 没必要搬起石头砸自己的脚\n6. 提前准备。 比如自我介绍, 项目介绍, 职业规划等等。基本都是必问的题目，能提前准备就提前准备好。\n7. 开源, 分享, 积累。 我一直认为, 分享和开源是程序员进步的不二法门。 我建议每个程序员都应该有自己的Github, 有自己的博客。就这几次面试来说, 博客和Github帮了我多。 网易面试官直言, 他们认真看过我的Github, 微信HR问我要CSDN博客ID, 说她很感兴趣。帮助别人, 也是帮助自己。\n8. 沟通。 有时候一个问题, 可能不懂, 甚至题目都不理解。不要害怕, 主动与面试官沟通。 我在网易面试的时候, 关于全拼算法的实现, 我当时连全拼都没一个完整的概念, 它要满足哪些条件更加不清楚。我跟面试官坦诚我不懂这个概念, 与他们的一步步沟通中实现了自己的算法。 所以沟通, 远比闷头写, 到头来还可能错误来的实在。\n9. 自信。 能得到面试机会, 最起码证明, 你很优秀。 我觉得自信很重要。 如果一开始, 就表现的慌慌张张, 畏首畏尾, 那么不管是你自己的发挥, 还是面试官对你的看法, 我觉得都不会很好。 \n\n\n敲了一下午.. 真累。\n\n`希望和我一样大三找实习的朋友, 都能拿到自己心仪的offer!`\n\n**学习的路上, 与君共勉。**\n\n\n\n\n\n","slug":"interview-summary","published":1,"updated":"2019-12-23T01:02:31.290Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1mv001hzwlnhk9z21g6","content":"<h1 id=\"一个多月来的面试总结(阿里,_网易,_腾讯)\">一个多月来的面试总结(阿里, 网易, 腾讯)</h1><blockquote>\n<p>想必关注我的朋友都发现了, 最近我发表原创文章的数量和质量大大不如以前了, 也不怎么活跃了。主要原因是现在大三了, 7月份就能离校实习了, 所以前段时间也在为找实习忙碌着。接下去应该就能恢复正常, 继续为大家分享一些iOS开发上的小技巧, 毕竟, 也算拿到了心仪的offer。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>接下去, 就围绕这一个多月来参加的几场面试, 做一个总结。 设计的公司主要包括阿里研发部分, 网易邮件, 腾讯微信。希望能给同样在为找实习努力的战友提供一些帮助。(<code>已经拿到网易和微信的offer</code>)</strong></p>\n<p>PS: 总结不是空穴来风, 每次面试完, 我都会坐着认真总结之前的面试, 记录每道题, 每个答案的关键点, 再比对下自己的回答是否完整。</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201504/25/1429944250_1723.jpeg\" width=\"900\"></p>\n<p><strong>另外, 博客篇幅有限, 并且题目并不是适合每一位同学(我是iOS开发相关, 题目主要都是iOS相关), 所以不适合把完整的题目都描述出来, 文章主要是一些经验交流。 <code>如果需要完整面试题目的, 麻烦留下邮箱, 我看到了会一一发送</code>。</strong></p>\n<blockquote>\n<p>以下按参加的时间先后来描述, 另外我的个人主页 <a href=\"http://colin1994.xyz\" target=\"_blank\" rel=\"external\">Colin’s Nest</a>, 里面有我的一些介绍, 包括简历。感兴趣的可以瞅瞅。</p>\n</blockquote>\n<h1 id=\"阿里_研发部门\">阿里_研发部门</h1><p>阿里是最早投的一家公司, 3月初那会, 本来还在学习科二的, 然后在阿里的学长, 催着要简历, 说内推已经开始了。于是乎, 我就借机把科二给退了(被教练骂成狗的滋味真不好受, 还好及时跑了)。学长给内推的部门是和o2o相关, iOS开发。</p>\n<h2 id=\"阿里一面_电话\">阿里一面_电话</h2><p>然后等了几天, <code>3月9号</code>, 一面开始了, 节奏很快, 总共通话时候是<code>26分钟</code>..</p>\n<p>电话来的比较突然, 那会还在看文章呢。一面过了, 但是具体表现并不是很理想。</p>\n<ol>\n<li>先是自我介绍。</li>\n<li><p>问iOS相关。 比如:</p>\n<ol>\n<li>Category支持添加属性与成员变量吗</li>\n<li>iOS7之后, 蓝牙的围栏功能</li>\n<li>说说Cell重用原理<br>…</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>设计模式。这里主要问了iOS常用的设计模式, 以及如何应用到实际需求中去。</p>\n<ol>\n<li>MVC是否了解?介绍下使用情况。</li>\n<li>MVC里面, View怎么通知到Model</li>\n<li>了解delegate吗?并介绍</li>\n<li>如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么</li>\n</ol>\n</li>\n<li><p>然后就是再交流, 对o2o有什么看法, 有没有想问他的…</p>\n</li>\n</ol>\n<h2 id=\"阿里二面_电话\">阿里二面_电话</h2><p>然后又过了两天, 二面如约来了, 36分钟, 感觉比上次好, 不过结果…</p>\n<p>二面和一面一样, 都围绕iOS, 问了objc相关, 内存管理, 设计模式等。</p>\n<p>但是更多的, 询问了我平时的一些开发习惯, 以及一些设计题。</p>\n<p>比如:</p>\n<ul>\n<li>如果让你设计KVO, 要怎么设计</li>\n<li>现在你是如何适配的</li>\n<li>比较下storyboard和全代码</li>\n<li>如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动</li>\n<li>平时是怎么进行测试的, 内存方面怎么测试</li>\n<li>平时自己有没有封装过比较复杂的控件</li>\n<li>平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析..</li>\n<li>如何实现类似 “Find My iPhone” 这样功能</li>\n</ul>\n<p>二面相比一面来说, 准备的更充分了。回答问题上, 也比较积极, 考虑的也比较多。不过二面结束没多久, 内推状态就变成”待回绝”。 Over了…</p>\n<p>学长询问了面试官, 结果是: “整体还不错, 但总感觉少了点什么..”</p>\n<p>经历完阿里这一次, 总体来说, 对我打击还挺大的。毕竟, 第一次就跪了..  同时, 更多的是对自我的总结。</p>\n<p>首先应该是准备不够充分, 然后就是基础不够扎实。从面试官问的问题来看, <code>大公司还是对基础要求比较高</code>。</p>\n<h2 id=\"阿里校招_在线笔试\">阿里校招_在线笔试</h2><p>之后, 又投了阿里校招, 参加了在线笔试。具体题目可以在这里看到:<a href=\"http://www.nowcoder.com/companyCenterTerminal_134\" target=\"_blank\" rel=\"external\">阿里笔试题</a></p>\n<p>虽然笔试通过了, 不过现场面试的时间和课程冲突了, 然后就没有跑去杭州面试。</p>\n<p>于是乎, 和阿里就这样不了了之了。</p>\n<h1 id=\"网易_邮件部门(拿到offer)\">网易_邮件部门(拿到offer)</h1><p>在结束阿里内推没多久, 偶然在网上看到网易的一个招聘。 因为方式比较新颖, 就关注了下。</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201504/25/1429947172_7894.jpg\" width=\"900\"></p>\n<p><strong>答案就在门的背后！(至于如何解题欢迎大家交流)</strong></p>\n<p>解开这个题目后, 拿到了面试官的邮箱.. 然后抱着侥幸的心理, 就投了。</p>\n<h2 id=\"网易一面_电话\">网易一面_电话</h2><p>没想到, 第二天就来电话了。效率很高。 <code>55分钟</code>.. 感觉被虐哭了。</p>\n<p>网易考核的主要是<code>objc, iOS, 设计模式, 算法</code>。 </p>\n<p>主要如下:</p>\n<ol>\n<li>autorelease 和 @autoreleasepool区别</li>\n<li>unsafe_unretained , weak, assign 区别</li>\n<li>在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗</li>\n<li>在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok</li>\n<li>NSThread, NSOperation, GCD区别</li>\n<li>runtime什么时候用</li>\n<li>通知和KVO区别</li>\n<li>深度遍历和广度遍历使用场景</li>\n<li>常用的设计模式</li>\n<li>算法题 * 2</li>\n<li>自己有什么优点</li>\n</ol>\n<p>…</p>\n<p>面完之后, 感觉整个人都不好了。<code>内存管理</code>部分, 都能说出那么一些, 但是一说多了, 就不知道怎么回答了。总体来说, 还是基础不够扎实。研究不够透彻。</p>\n<p>然后面试完, 一个很大的感受就是, <code>一次面试, 学到的, 比自己闷头看书一个月, 学到的还多</code>。<code>面试很直观的反应出了自己的不足</code>。于是乎, 针对内存管理, 多线程等知识上的不足。 我重新把那本狮子头的书认真看了遍。</p>\n<p>PS: 如果觉得这方面知识也有所欠缺的话, 可以到这里下载<code>Objective-C高级编程 iOS与OS X多线程和内存管理.pdf</code>这本书, 极力推荐。</p>\n<p>下载链接: <a href=\"http://pan.baidu.com/s/1pJsno7p\" target=\"_blank\" rel=\"external\">电子书分享</a></p>\n<p>本以为, 网易也就是这么结束了。 没想到过了几天, 人力资源部的妹子打电话来, 约去杭州面试。</p>\n<p>于是乎于是乎, 去杭州浪了~</p>\n<h2 id=\"网易二面_现场\">网易二面_现场</h2><p>初到杭州, 很巧的是在机场大巴上碰到了一个去H3C培训的大叔, 更巧的是, 他也住我那个酒店。 然后就跟着他, 一路聊到酒店.. 挺好。</p>\n<p>第二天网易面试, 还是挺紧张的。9点多到了待客大厅, 填了表, 然后等面试官。然后网易给我的一个感觉就是, 很<code>内敛, 低调</code>, 感觉挺好。</p>\n<p>之后一下来了两个面试官, 领我到单独的小隔间面试.. 一次两个, 有点虚。</p>\n<p>不过没多久, 就适应了这种气氛, 然后和面试官交流也比较开心。</p>\n<p>主要问题如下:</p>\n<ol>\n<li>我是上次和你通电话的那位, 你觉得自己上次表现怎么样</li>\n<li>这段时间, 都在干嘛</li>\n<li>我们认真看了你的github, 感觉还不错</li>\n</ol>\n<p>然后给我一张纸, 问了几个算法题:</p>\n<ol>\n<li>如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3]</li>\n<li>实现连连看算法</li>\n<li>T9算法如何实现, 全拼算法</li>\n</ol>\n<p>总的来说, 问的都是<code>算法</code>相关, 没有再涉及iOS部分。 然后就算法来说, 回答的还不错。虽然每道题不是一步到位, 但是在与面试官沟通过程中, 最后都逐步完善了自己的算法。</p>\n<p>然后就是和面试官聊天了, 两位面试官都很平易近人, 聊得也比较开心。 然后就约了下午HR面。</p>\n<p>…面试完后, 包括面试官已经人力管理的妹子都邀请我去网易食堂吃饭, 不过毕竟腼腆, 我给拒绝了。出来才发现.. 找个饭店真不容易.. 早知道就厚着脸皮试试”丁家猪”了。</p>\n<h2 id=\"网易HR面_现场\">网易HR面_现场</h2><p>下午HR面, HR是个很漂亮的妹子.. 整个过程都比较欢乐， 虽然一些问题上可能有不同看法。</p>\n<p>HR问的主要是一些职业规划, 抗压能力, 学习习惯, 别人怎么看待自己等等..</p>\n<p>面试完以后, HR问我接下去准备干嘛, 我说我要一路玩到萧山机场(那天酒店在萧山机场附近)。然后她打趣到:”真潇洒阿..”</p>\n<p>杭州确实很美, 不够时间关系, 就在西湖附近逛了会。 附带两张图片。</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201504/25/1429949156_7015.JPG\" width=\"900\"><br><img src=\"http://img.my.csdn.net/uploads/201504/25/1429949125_2851.JPG\" width=\"900\"></p>\n<p>3.31参加完网易杭州的现场面试. 4月23号收到网易的正式offer。 总算, 踏实了…</p>\n<h1 id=\"腾讯_微信事业部(拿到offer)\">腾讯_微信事业部(拿到offer)</h1><p>之前腾讯校招的时候, 投了简历。 不过一直到周围同学都参加了在线笔试, 我仍然没收到通知的时候, 我基本上已经放弃了。觉得自己应该在简历环节就被刷了, 比较凄凉..</p>\n<h2 id=\"微信一面_电话\">微信一面_电话</h2><p>不过4月20的时候, 突然来了个电话, 对方说是腾讯微信事业部的。 很突然, 完全没想到。 可以说， 幸福来的太突然了..</p>\n<p>电话用时<code>1小时10分</code>.. 中间把院长的课给翘了.. - -!</p>\n<p>主要还是围绕这几个方面: 项目, 设计模式, 算法..</p>\n<p>问题包括:</p>\n<ol>\n<li>如何保证软件质量, 怎么分析Crash日志</li>\n<li>谈谈你觉得最重要的一个项目</li>\n<li>你的个人主页是怎么写的</li>\n<li>假如我是一名初学者, 你会向我推荐哪些第三方库</li>\n<li>使用了第三方库, 有看他们是怎么实现的吗</li>\n<li>有没有看过大型项目的源码</li>\n<li>强连通量算法</li>\n<li>最短路径算法</li>\n<li>排序算法</li>\n<li>25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名</li>\n</ol>\n<p>腾讯给我的感觉就是, 很靠谱。 <code>这几轮面试, 就腾讯当场就给出了结果, 不管是一面, 二面, 还是HR面 而不是说让你再等通知。 给我的感觉非常好</code>。</p>\n<p>一面最后, 这个面试官就说, 他这里通过了, 问我明天什么时候有时间, 给我约下另外一个面试官。</p>\n<h2 id=\"微信二面_collabedit+电话\">微信二面_collabedit+电话</h2><p>第二天微信二面如约来了, 面试官很好。提前打电话问我有没有时间, 我表示想午睡一会, 一个小时后开始。他答应了。</p>\n<p>然后一个小时后, 另外一个面试官打电话来了, 要我登录 <a href=\"http://collabedit.com/xxxx\" target=\"_blank\" rel=\"external\">http://collabedit.com/xxxx</a> 答题。</p>\n<p>collabedit可以在线共享。 就是说, 我这里敲什么, 面试官那里就能同步显示。 主要是考核编码能力。</p>\n<p>主要是两个算法题, 第一道要求写出完整代码, 第二道思路交流。</p>\n<ol>\n<li>求两个整数的最大公约数</li>\n<li>微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分。</li>\n</ol>\n<p>完了之后, 面试官问了我实习时间, 然后问我对深圳和广州的看法(因为我第一志愿填的是深圳, 微信本部在广州), 问我愿意去广州吗。 之后就表示他这里也通过了。 这一两天给我约HR。</p>\n<h2 id=\"微信HR面_电话\">微信HR面_电话</h2><p>果然, 两天后, 微信HR来电话了。</p>\n<p>和她聊天很轻松, 从头到尾都是喊我’龙泽 .. 龙泽’, 感觉很亲切。 主要也是围绕职业规划等展开。</p>\n<p>然后最后就问我, 是否愿意来微信实习, 如果愿意, 马上就给我offer, 如果还犹豫, 考虑清楚再联系她。</p>\n<p>当然, 我表示愿意。 然后hr留了微信号, 说安排同事给我发确认函。</p>\n<p>当天晚上, 另外一个人力资源的妹子打电话, 和我讨论薪资等问题..</p>\n<p>总的来说, 微信从一面, 到最后确定下来, 就经历了4天。 非常效率。 中间也很愉快。</p>\n<p>说来也巧, 网易和微信是同时发来来的offer。网易电话刚放下没多久, 微信hr就来电话了。所以当时两边是先都允诺能去实习了，毕竟时间太紧, 还没考虑好。</p>\n<p>之后还是因为个人原因, 选择了微信, 所以当天下午就打电话给网易, 告知了他们。多少也有些遗憾, 毕竟网易也是我很向往的一家公司。</p>\n<p>好了。 到此, 这段时间的面试总结就写好了。下面就我个人来说, 提几点建议:</p>\n<ol>\n<li>基础。 不管是哪个方向, 基础很重要。就比如iOS, objc的方方面面都必须了解。</li>\n<li>全面。 有些东西, 虽然不见得能答好, 但你至少应该懂。</li>\n<li>设计模式。 主流的那些设计模式非常有必要了解。</li>\n<li>算法。 这个不是说恶补能补好的。建议大家长期积累。 另外推荐&lt;剑指offer&gt;这本书。同时, 可以在这里线上答题: <a href=\"http://www.nowcoder.com/books/coding-interviews\" target=\"_blank\" rel=\"external\">牛客网-剑指offer</a></li>\n<li>简历一定要真实! 基本上面试官都是围绕简历展开交流的。 懂或不懂, 一问就知道, 没必要搬起石头砸自己的脚</li>\n<li>提前准备。 比如自我介绍, 项目介绍, 职业规划等等。基本都是必问的题目，能提前准备就提前准备好。</li>\n<li>开源, 分享, 积累。 我一直认为, 分享和开源是程序员进步的不二法门。 我建议每个程序员都应该有自己的Github, 有自己的博客。就这几次面试来说, 博客和Github帮了我多。 网易面试官直言, 他们认真看过我的Github, 微信HR问我要CSDN博客ID, 说她很感兴趣。帮助别人, 也是帮助自己。</li>\n<li>沟通。 有时候一个问题, 可能不懂, 甚至题目都不理解。不要害怕, 主动与面试官沟通。 我在网易面试的时候, 关于全拼算法的实现, 我当时连全拼都没一个完整的概念, 它要满足哪些条件更加不清楚。我跟面试官坦诚我不懂这个概念, 与他们的一步步沟通中实现了自己的算法。 所以沟通, 远比闷头写, 到头来还可能错误来的实在。</li>\n<li>自信。 能得到面试机会, 最起码证明, 你很优秀。 我觉得自信很重要。 如果一开始, 就表现的慌慌张张, 畏首畏尾, 那么不管是你自己的发挥, 还是面试官对你的看法, 我觉得都不会很好。 </li>\n</ol>\n<p>敲了一下午.. 真累。</p>\n<p><code>希望和我一样大三找实习的朋友, 都能拿到自己心仪的offer!</code></p>\n<p><strong>学习的路上, 与君共勉。</strong></p>\n","excerpt":"<h1 id=\"一个多月来的面试总结(阿里,_网易,_腾讯)\">一个多月来的面试总结(阿里, 网易, 腾讯)</h1><blockquote>\n<p>想必关注我的朋友都发现了, 最近我发表原创文章的数量和质量大大不如以前了, 也不怎么活跃了。主要原因是现在大三了, 7月份就能离校实习了, 所以前段时间也在为找实习忙碌着。接下去应该就能恢复正常, 继续为大家分享一些iOS开发上的小技巧, 毕竟, 也算拿到了心仪的offer。</p>\n</blockquote>","more":"<p><strong>接下去, 就围绕这一个多月来参加的几场面试, 做一个总结。 设计的公司主要包括阿里研发部分, 网易邮件, 腾讯微信。希望能给同样在为找实习努力的战友提供一些帮助。(<code>已经拿到网易和微信的offer</code>)</strong></p>\n<p>PS: 总结不是空穴来风, 每次面试完, 我都会坐着认真总结之前的面试, 记录每道题, 每个答案的关键点, 再比对下自己的回答是否完整。</p>\n<p><img src='http://img.my.csdn.net/uploads/201504/25/1429944250_1723.jpeg' width=900></p>\n<p><strong>另外, 博客篇幅有限, 并且题目并不是适合每一位同学(我是iOS开发相关, 题目主要都是iOS相关), 所以不适合把完整的题目都描述出来, 文章主要是一些经验交流。 <code>如果需要完整面试题目的, 麻烦留下邮箱, 我看到了会一一发送</code>。</strong></p>\n<blockquote>\n<p>以下按参加的时间先后来描述, 另外我的个人主页 <a href=\"http://colin1994.xyz\">Colin’s Nest</a>, 里面有我的一些介绍, 包括简历。感兴趣的可以瞅瞅。</p>\n</blockquote>\n<h1 id=\"阿里_研发部门\">阿里_研发部门</h1><p>阿里是最早投的一家公司, 3月初那会, 本来还在学习科二的, 然后在阿里的学长, 催着要简历, 说内推已经开始了。于是乎, 我就借机把科二给退了(被教练骂成狗的滋味真不好受, 还好及时跑了)。学长给内推的部门是和o2o相关, iOS开发。</p>\n<h2 id=\"阿里一面_电话\">阿里一面_电话</h2><p>然后等了几天, <code>3月9号</code>, 一面开始了, 节奏很快, 总共通话时候是<code>26分钟</code>..</p>\n<p>电话来的比较突然, 那会还在看文章呢。一面过了, 但是具体表现并不是很理想。</p>\n<ol>\n<li>先是自我介绍。</li>\n<li><p>问iOS相关。 比如:</p>\n<ol>\n<li>Category支持添加属性与成员变量吗</li>\n<li>iOS7之后, 蓝牙的围栏功能</li>\n<li>说说Cell重用原理<br>…</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>设计模式。这里主要问了iOS常用的设计模式, 以及如何应用到实际需求中去。</p>\n<ol>\n<li>MVC是否了解?介绍下使用情况。</li>\n<li>MVC里面, View怎么通知到Model</li>\n<li>了解delegate吗?并介绍</li>\n<li>如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么</li>\n</ol>\n</li>\n<li><p>然后就是再交流, 对o2o有什么看法, 有没有想问他的…</p>\n</li>\n</ol>\n<h2 id=\"阿里二面_电话\">阿里二面_电话</h2><p>然后又过了两天, 二面如约来了, 36分钟, 感觉比上次好, 不过结果…</p>\n<p>二面和一面一样, 都围绕iOS, 问了objc相关, 内存管理, 设计模式等。</p>\n<p>但是更多的, 询问了我平时的一些开发习惯, 以及一些设计题。</p>\n<p>比如:</p>\n<ul>\n<li>如果让你设计KVO, 要怎么设计</li>\n<li>现在你是如何适配的</li>\n<li>比较下storyboard和全代码</li>\n<li>如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动</li>\n<li>平时是怎么进行测试的, 内存方面怎么测试</li>\n<li>平时自己有没有封装过比较复杂的控件</li>\n<li>平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析..</li>\n<li>如何实现类似 “Find My iPhone” 这样功能</li>\n</ul>\n<p>二面相比一面来说, 准备的更充分了。回答问题上, 也比较积极, 考虑的也比较多。不过二面结束没多久, 内推状态就变成”待回绝”。 Over了…</p>\n<p>学长询问了面试官, 结果是: “整体还不错, 但总感觉少了点什么..”</p>\n<p>经历完阿里这一次, 总体来说, 对我打击还挺大的。毕竟, 第一次就跪了..  同时, 更多的是对自我的总结。</p>\n<p>首先应该是准备不够充分, 然后就是基础不够扎实。从面试官问的问题来看, <code>大公司还是对基础要求比较高</code>。</p>\n<h2 id=\"阿里校招_在线笔试\">阿里校招_在线笔试</h2><p>之后, 又投了阿里校招, 参加了在线笔试。具体题目可以在这里看到:<a href=\"http://www.nowcoder.com/companyCenterTerminal_134\">阿里笔试题</a></p>\n<p>虽然笔试通过了, 不过现场面试的时间和课程冲突了, 然后就没有跑去杭州面试。</p>\n<p>于是乎, 和阿里就这样不了了之了。</p>\n<h1 id=\"网易_邮件部门(拿到offer)\">网易_邮件部门(拿到offer)</h1><p>在结束阿里内推没多久, 偶然在网上看到网易的一个招聘。 因为方式比较新颖, 就关注了下。</p>\n<p><img src='http://img.my.csdn.net/uploads/201504/25/1429947172_7894.jpg' width=900></p>\n<p><strong>答案就在门的背后！(至于如何解题欢迎大家交流)</strong></p>\n<p>解开这个题目后, 拿到了面试官的邮箱.. 然后抱着侥幸的心理, 就投了。</p>\n<h2 id=\"网易一面_电话\">网易一面_电话</h2><p>没想到, 第二天就来电话了。效率很高。 <code>55分钟</code>.. 感觉被虐哭了。</p>\n<p>网易考核的主要是<code>objc, iOS, 设计模式, 算法</code>。 </p>\n<p>主要如下:</p>\n<ol>\n<li>autorelease 和 @autoreleasepool区别</li>\n<li>unsafe_unretained , weak, assign 区别</li>\n<li>在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗</li>\n<li>在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok</li>\n<li>NSThread, NSOperation, GCD区别</li>\n<li>runtime什么时候用</li>\n<li>通知和KVO区别</li>\n<li>深度遍历和广度遍历使用场景</li>\n<li>常用的设计模式</li>\n<li>算法题 * 2</li>\n<li>自己有什么优点</li>\n</ol>\n<p>…</p>\n<p>面完之后, 感觉整个人都不好了。<code>内存管理</code>部分, 都能说出那么一些, 但是一说多了, 就不知道怎么回答了。总体来说, 还是基础不够扎实。研究不够透彻。</p>\n<p>然后面试完, 一个很大的感受就是, <code>一次面试, 学到的, 比自己闷头看书一个月, 学到的还多</code>。<code>面试很直观的反应出了自己的不足</code>。于是乎, 针对内存管理, 多线程等知识上的不足。 我重新把那本狮子头的书认真看了遍。</p>\n<p>PS: 如果觉得这方面知识也有所欠缺的话, 可以到这里下载<code>Objective-C高级编程 iOS与OS X多线程和内存管理.pdf</code>这本书, 极力推荐。</p>\n<p>下载链接: <a href=\"http://pan.baidu.com/s/1pJsno7p\">电子书分享</a></p>\n<p>本以为, 网易也就是这么结束了。 没想到过了几天, 人力资源部的妹子打电话来, 约去杭州面试。</p>\n<p>于是乎于是乎, 去杭州浪了~</p>\n<h2 id=\"网易二面_现场\">网易二面_现场</h2><p>初到杭州, 很巧的是在机场大巴上碰到了一个去H3C培训的大叔, 更巧的是, 他也住我那个酒店。 然后就跟着他, 一路聊到酒店.. 挺好。</p>\n<p>第二天网易面试, 还是挺紧张的。9点多到了待客大厅, 填了表, 然后等面试官。然后网易给我的一个感觉就是, 很<code>内敛, 低调</code>, 感觉挺好。</p>\n<p>之后一下来了两个面试官, 领我到单独的小隔间面试.. 一次两个, 有点虚。</p>\n<p>不过没多久, 就适应了这种气氛, 然后和面试官交流也比较开心。</p>\n<p>主要问题如下:</p>\n<ol>\n<li>我是上次和你通电话的那位, 你觉得自己上次表现怎么样</li>\n<li>这段时间, 都在干嘛</li>\n<li>我们认真看了你的github, 感觉还不错</li>\n</ol>\n<p>然后给我一张纸, 问了几个算法题:</p>\n<ol>\n<li>如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3]</li>\n<li>实现连连看算法</li>\n<li>T9算法如何实现, 全拼算法</li>\n</ol>\n<p>总的来说, 问的都是<code>算法</code>相关, 没有再涉及iOS部分。 然后就算法来说, 回答的还不错。虽然每道题不是一步到位, 但是在与面试官沟通过程中, 最后都逐步完善了自己的算法。</p>\n<p>然后就是和面试官聊天了, 两位面试官都很平易近人, 聊得也比较开心。 然后就约了下午HR面。</p>\n<p>…面试完后, 包括面试官已经人力管理的妹子都邀请我去网易食堂吃饭, 不过毕竟腼腆, 我给拒绝了。出来才发现.. 找个饭店真不容易.. 早知道就厚着脸皮试试”丁家猪”了。</p>\n<h2 id=\"网易HR面_现场\">网易HR面_现场</h2><p>下午HR面, HR是个很漂亮的妹子.. 整个过程都比较欢乐， 虽然一些问题上可能有不同看法。</p>\n<p>HR问的主要是一些职业规划, 抗压能力, 学习习惯, 别人怎么看待自己等等..</p>\n<p>面试完以后, HR问我接下去准备干嘛, 我说我要一路玩到萧山机场(那天酒店在萧山机场附近)。然后她打趣到:”真潇洒阿..”</p>\n<p>杭州确实很美, 不够时间关系, 就在西湖附近逛了会。 附带两张图片。</p>\n<p><img src='http://img.my.csdn.net/uploads/201504/25/1429949156_7015.JPG' width=900><br><img src='http://img.my.csdn.net/uploads/201504/25/1429949125_2851.JPG' width=900></p>\n<p>3.31参加完网易杭州的现场面试. 4月23号收到网易的正式offer。 总算, 踏实了…</p>\n<h1 id=\"腾讯_微信事业部(拿到offer)\">腾讯_微信事业部(拿到offer)</h1><p>之前腾讯校招的时候, 投了简历。 不过一直到周围同学都参加了在线笔试, 我仍然没收到通知的时候, 我基本上已经放弃了。觉得自己应该在简历环节就被刷了, 比较凄凉..</p>\n<h2 id=\"微信一面_电话\">微信一面_电话</h2><p>不过4月20的时候, 突然来了个电话, 对方说是腾讯微信事业部的。 很突然, 完全没想到。 可以说， 幸福来的太突然了..</p>\n<p>电话用时<code>1小时10分</code>.. 中间把院长的课给翘了.. - -!</p>\n<p>主要还是围绕这几个方面: 项目, 设计模式, 算法..</p>\n<p>问题包括:</p>\n<ol>\n<li>如何保证软件质量, 怎么分析Crash日志</li>\n<li>谈谈你觉得最重要的一个项目</li>\n<li>你的个人主页是怎么写的</li>\n<li>假如我是一名初学者, 你会向我推荐哪些第三方库</li>\n<li>使用了第三方库, 有看他们是怎么实现的吗</li>\n<li>有没有看过大型项目的源码</li>\n<li>强连通量算法</li>\n<li>最短路径算法</li>\n<li>排序算法</li>\n<li>25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名</li>\n</ol>\n<p>腾讯给我的感觉就是, 很靠谱。 <code>这几轮面试, 就腾讯当场就给出了结果, 不管是一面, 二面, 还是HR面 而不是说让你再等通知。 给我的感觉非常好</code>。</p>\n<p>一面最后, 这个面试官就说, 他这里通过了, 问我明天什么时候有时间, 给我约下另外一个面试官。</p>\n<h2 id=\"微信二面_collabedit+电话\">微信二面_collabedit+电话</h2><p>第二天微信二面如约来了, 面试官很好。提前打电话问我有没有时间, 我表示想午睡一会, 一个小时后开始。他答应了。</p>\n<p>然后一个小时后, 另外一个面试官打电话来了, 要我登录 <a href=\"http://collabedit.com/xxxx\">http://collabedit.com/xxxx</a> 答题。</p>\n<p>collabedit可以在线共享。 就是说, 我这里敲什么, 面试官那里就能同步显示。 主要是考核编码能力。</p>\n<p>主要是两个算法题, 第一道要求写出完整代码, 第二道思路交流。</p>\n<ol>\n<li>求两个整数的最大公约数</li>\n<li>微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分。</li>\n</ol>\n<p>完了之后, 面试官问了我实习时间, 然后问我对深圳和广州的看法(因为我第一志愿填的是深圳, 微信本部在广州), 问我愿意去广州吗。 之后就表示他这里也通过了。 这一两天给我约HR。</p>\n<h2 id=\"微信HR面_电话\">微信HR面_电话</h2><p>果然, 两天后, 微信HR来电话了。</p>\n<p>和她聊天很轻松, 从头到尾都是喊我’龙泽 .. 龙泽’, 感觉很亲切。 主要也是围绕职业规划等展开。</p>\n<p>然后最后就问我, 是否愿意来微信实习, 如果愿意, 马上就给我offer, 如果还犹豫, 考虑清楚再联系她。</p>\n<p>当然, 我表示愿意。 然后hr留了微信号, 说安排同事给我发确认函。</p>\n<p>当天晚上, 另外一个人力资源的妹子打电话, 和我讨论薪资等问题..</p>\n<p>总的来说, 微信从一面, 到最后确定下来, 就经历了4天。 非常效率。 中间也很愉快。</p>\n<p>说来也巧, 网易和微信是同时发来来的offer。网易电话刚放下没多久, 微信hr就来电话了。所以当时两边是先都允诺能去实习了，毕竟时间太紧, 还没考虑好。</p>\n<p>之后还是因为个人原因, 选择了微信, 所以当天下午就打电话给网易, 告知了他们。多少也有些遗憾, 毕竟网易也是我很向往的一家公司。</p>\n<p>好了。 到此, 这段时间的面试总结就写好了。下面就我个人来说, 提几点建议:</p>\n<ol>\n<li>基础。 不管是哪个方向, 基础很重要。就比如iOS, objc的方方面面都必须了解。</li>\n<li>全面。 有些东西, 虽然不见得能答好, 但你至少应该懂。</li>\n<li>设计模式。 主流的那些设计模式非常有必要了解。</li>\n<li>算法。 这个不是说恶补能补好的。建议大家长期积累。 另外推荐&lt;剑指offer&gt;这本书。同时, 可以在这里线上答题: <a href=\"http://www.nowcoder.com/books/coding-interviews\">牛客网-剑指offer</a></li>\n<li>简历一定要真实! 基本上面试官都是围绕简历展开交流的。 懂或不懂, 一问就知道, 没必要搬起石头砸自己的脚</li>\n<li>提前准备。 比如自我介绍, 项目介绍, 职业规划等等。基本都是必问的题目，能提前准备就提前准备好。</li>\n<li>开源, 分享, 积累。 我一直认为, 分享和开源是程序员进步的不二法门。 我建议每个程序员都应该有自己的Github, 有自己的博客。就这几次面试来说, 博客和Github帮了我多。 网易面试官直言, 他们认真看过我的Github, 微信HR问我要CSDN博客ID, 说她很感兴趣。帮助别人, 也是帮助自己。</li>\n<li>沟通。 有时候一个问题, 可能不懂, 甚至题目都不理解。不要害怕, 主动与面试官沟通。 我在网易面试的时候, 关于全拼算法的实现, 我当时连全拼都没一个完整的概念, 它要满足哪些条件更加不清楚。我跟面试官坦诚我不懂这个概念, 与他们的一步步沟通中实现了自己的算法。 所以沟通, 远比闷头写, 到头来还可能错误来的实在。</li>\n<li>自信。 能得到面试机会, 最起码证明, 你很优秀。 我觉得自信很重要。 如果一开始, 就表现的慌慌张张, 畏首畏尾, 那么不管是你自己的发挥, 还是面试官对你的看法, 我觉得都不会很好。 </li>\n</ol>\n<p>敲了一下午.. 真累。</p>\n<p><code>希望和我一样大三找实习的朋友, 都能拿到自己心仪的offer!</code></p>\n<p><strong>学习的路上, 与君共勉。</strong></p>"},{"title":"OpenGL ES 基础概念","date":"2017-04-01T14:30:10.000Z","_content":"\n这里主要描述一些 OpenGL ES 必须先了解的一些概念，为之后的实战铺路。\n\n\n\n## 状态机\n\n> OpenGL 是一个状态机，它维持自己的状态，并根据用户调用的函数来改变自己的状态。\n>\n> 根据状态的不同，调用同样的函数也可能产生不同的效果。\n\n在 OpenGL 的世界里，**大多数元素都可以用状态来描述**，比如：\n\n<!--more-->\n\n- 颜色、纹理坐标、光源的各种参数...\n- 是否启用了光照、是否启用了纹理、是否启用了混合、是否启用了深度测试...\n- ...\n\n**OpenGL 会保持状态，除非我们调用 OpenGL 函数来改变它。**\n\n- 比如你用 `glEnablexxx` 开启了一个状态，在以后的渲染中将一直保留并应用这个状态，除非你调用 `glDisablexxx` 及同类函数来改变该状态或程序退出。\n\n\n- 又或者当前颜色是一个状态变量，可以把当前颜色设置为白色、红色或其他任何颜色，在此之后绘制的所有物体都将使用这种颜色，直到把当前颜色设置为其他颜色。\n\n理解了状态机这个概念，我们再来看 OpenGL ES 提供的 API，就会非常明了，因为OpenGL 当中很多 API，其实仅仅是向 OpenGL 这个状态机传数据或者读数据。\n\n![201701114141530D41464-66AF-4A71-80E5-9BF8AABC016F.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_1.png)\n\n100 来个接口，如果按照不同的数据类型（GLfloat，GLint，GLsize ...），不同的元素（Uniform，Color，Texture...）划分开来，再看各个分类的接口，（~~无法~~）无非就是围绕状态展开的。\n\n比如：`glClearColor` 函数是一个状态设置函数，而 `glClear` 函数则是一个状态应用的函数。\n\n\n\n## 上下文\n\n上面提到的各种状态值，将保存在对应的上下文（**Context**）中。\n\n> OpenGL ES 上下文（EAGLContext） : 管理所有 iOS 要绘制的 OpenGL ES 信息。\n>\n> 类似在 Core Graphics 中做任何事情都需要一个 Core Graphics 上下文。\n\n通过放置这些状态到上下文中，上下文可以跟踪用于渲染的帧缓存、用于几何数据、颜色等的缓存。还会决定是否使用如纹理、灯光等功能以及会为渲染定义当前的坐标系统等。并且在多任务的情况下，就能很容易的共享硬件设备，而互不影响各自的状态。\n\n因此渲染的时候，要**指定对应的当前上下文**。\n\n\n\n## 渲染管线\n\n在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：**第一部分把你的3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素。**\n\n> 2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。\n\n图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。**它的工作过程和车间流水线一致，各个模块各司其职但是又相互依赖。**\n\n下图就是渲染管线：\n\n![20170112148420103614414.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_2.jpg)\n\n\n\n> PS：OpenGL ES 采用**服务器/客户端编程模型**，客户端运行在 CPU 上，服务端运行在 GPU 上，调用 OpenGL ES 函数的时，由客户端发送至服务器端，并被服务端转换成底层图形硬件支持的绘制命令。\n>\n> ![20170111148411873373682.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_3.jpg)\n\n\n\n左边的客户端程序通过调用 OpenGL ES 接口，将顶点，着色器程序，纹理，以及其他一些 GL 状态参数传入右边的 GL 服务端， 然后在客户端调用绘制命令的时候， GL 便会将输入的图元，逐一执行渲染管线的每个阶段，然后将每个像素的颜色值写入到帧缓存中， 最后视窗系统就可以将帧缓存中的颜色值显示在屏幕上。 此外，应用程序也可以从帧缓存中读取数据到客户端。\n\n在整个管线中，**顶点着色器和片段着色器是可编程的部分**，应用程序可以通过提供着色器程序在 GPU 中被作用于渲染管线，可编程就是说这个操作可以动态编程实现而不必固定写死在代码中。可动态编程实现这一功能一般都是脚本提供的，在 OpenGL ES 中也一样，编写这样脚本的能力是由 OpenGL 着色语言（OpenGL Shading Language, GLSL）提供的。\n\n那可编程管线有什么好处呢？**方便我们动态修改渲染过程，而无需重写编译代码**。当然也和很多脚本语言一样，调试起来不太方便。其他阶段则只能使用一些固定的 GL 命令来影响该阶段的执行。\n\n\n\n下面以**绘制一个三角形为例**，针对渲染管线的各个阶段，详细分析。\n\n### 1. 顶点数组\n\n为了渲染一个三角形，我们以数组的形式传递3个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data）；**顶点数据是一系列顶点的集合。**一个顶点（Vertex）是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性（Vertex Attribute）表示的，它可以包含任何我们想用的数据，但是简单起见，我们假定每个顶点只由一个 3D 位置和一些颜色值组成。\n\n至此，你可能会疑惑，\n\n- 我们仅仅是传递了三个点，但是 OpenGL ES 是怎么知道它们用来组成三角形呢？\n- 加入我要绘制一个 3D 模型，那么要怎么传入顶点数据？\n\n为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元（Primitive），任何一个绘制指令的调用都将把图元传递给 OpenGL 。OpenGL 支持三种基本图元：点，线和三角形。\n\n当然，OpenGL ES 并不提供对 3D 模型的定义，在传入 OpenGL ES 之前应用程序应该首先将 3D 模型转换为一组图元的集合。每个模型是独立绘制的，修改其中一个模型的一些设置并不会影响其他模型。\n\n![20170112148420555397978.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_4.jpg)\n\n\n\n每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据，这些数据首先被上传到 GL 服务端，然后就可以进行绘制。\n\n> PS：OpenGL 中的命令总是按照它被接收到的顺序执行，这意味着一组图元必须被全部绘制完毕才会开始绘制下一组图元。同时也意味着程序对帧缓冲的像素读取的结果一定是该命令之前所有 OpenGL 命令执行的结果。\n\n\n\n### 2. 顶点着色器\n\n![2017011229641BBC4CB30-3B94-4F28-8FAB-AF502E37E641.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_5.png)\n\n\n\n**顶点着色器对每个顶点执行一次运算**，它可以使用顶点数据来计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。\n\n在顶点着色器中最重要的任务是执行顶点坐标变换，应用程序中设置的图元顶点坐标通常是针对本地坐标系的。本地坐标系简化了程序中的坐标计算，但是 GL 并不识别本地坐标系，所以在顶点着色器中要对本地坐标执行模型视图变换，将本地坐标转化为裁剪坐标系的坐标值。\n\n顶点着色器的另一个功能是向后面的片段着色器提供一组易变变量（varying）。易变变量会在图元装配阶段之后被执行插值计算，如果是单重采样，其插值点为片段的中心，如果多重采样，其插值点可能为多个采样片段中的任意一个位置。易变变量可以用来保存插值计算片段的颜色，纹理坐标等信息。\n\n\n\n### 3. 图元装配\n\n![2017011250662FC720569-D123-4FC5-9F0D-C99287364AC7.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_6.png)\n\n\n\n在顶点着色器程序输出顶点坐标之后，各个顶点被按照绘制命令中的图元类型参数，以及顶点索引数组被组装成一个个图元。\n\n![20170112148421538042641.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_7.jpg)\n\n\n\n顶点数组首先通过 GL 命令输入到 GL 渲染管线中，此时顶点坐标位于应用程序的本地坐标系；在经过顶点着色器的计算之后，顶点坐标被转化到裁剪坐标系中，这通常通过向顶点着色器传入一个模型视图变换矩阵，然后在顶点着色器中执行坐标变换。\n\n裁剪坐标系被定义在一个视锥体裁剪的空间里，视锥体是游戏场景的一个可视空间，它由6个裁剪平面构成，分别是：近平面，远平面，左平面，右平面，上平面和下平面。\n\n视锥体在 3D 应用程序中通常表现为一个摄像机，其观察点为裁剪坐标系的原点，方向为穿过远近平面的中点。\n\n![20170112148421539517039.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_8.jpg)\n\n\n\n处于视锥体以外的图元将被丢弃，如果该图元与视锥体相交则会发生裁剪产生新的图元。值得注意的是透视裁剪是一个比较影响性能的过程，因为每个图元都需要和 6 个面进行相交计算，并产生新的图元。但是一般在x，y方向超出屏幕之外的，则无需产生新的图元，这些顶点能在视口变换的时候被更高效的丢弃。\n\n**通过图元装配，所有 3D 的图元已经被转化为屏幕上 2D 的图元。**\n\n\n\n### 4. 光栅化\n\n![20170112706113F85123B-6006-4633-9D8C-C4C4DB4BA3AC.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_9.png)\n\n\n\n**在光栅化阶段，基本图元被转换为供片段着色器使用的片段**（Fragment），Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。**这是从顶点数据到可渲染在显示设备上的像素的质变过程。**\n\n在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。\n\n\n\n### 5. 片段着色器\n\n![20170112997054573CDB0-956C-4A00-837F-6BDA9BA4F550.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_10.png)\n\n\n\n可编程的片段着色器是实现一些高级特效如纹理贴图，光照，环境光，阴影等功能的基础。**片段着色器的主要作用是计算每一个片段最终的颜色值（或者丢弃该片段）。**\n\n在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。在 3D 图形程序开发中，贴图是最重要的部分，程序可以通过 GL 命令上传纹理数据至 GL 内存中，这些纹理可以被片段着色器使用。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值。\n\n另外，片段着色器也是执行光照等高级特效的地方，比如可以传给片段着色器一个光源位置和光源颜色，可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。\n\n\n\n### 6. 片段测试\n\n![2017011371566F6C27776-D170-48EF-8877-E0E541F6F193.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_11.png)\n\n片段着色器输出的颜色值，还要经过几个阶段的片段操作，这些操作可能会修改片段的颜色值，或者丢弃该片段，**最终的片段颜色值才会被写入到帧缓冲中。**\n\n![2017011214842168484373.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_12.jpg)\n\n像素所有权测试用来判断帧缓冲区中该位置的像素是否属于当前 OpenGL ES，例如在窗口系统中该位置可能会被其他应用程序窗口遮挡，此时该像素则不会被显示。\n\n在片段测试之后，片段要么被丢弃，要么每个片段对应的颜色，深度，模板值会被写入帧缓冲区，最终呈现在设备屏幕上。帧缓冲区中的颜色值也可以被读回到客户端应用程序中，这样可以实现绘制到纹理的效果。\n\n至此，OpenGL ES 渲染管道最终将每个像素点的颜色，深度，模板等数据输送到帧缓存中（Framebuffer）。\n\n\n\n## 帧缓存 / 渲染缓存\n\n那么，帧缓存和渲染缓存到底代表什么，又用来做什么呢？\n\n总的来说，**帧缓存是接收渲染结果的缓冲区，为GPU指定存储渲染结果的区域**。它存储着 OpenGL ES 绘制每个像素点最终的所有信息：颜色，深度和模板值。更通俗点，可以理解成存储屏幕上最终显示的一帧画面的区域。\n\n![20170112148423006492580.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_13.jpg)\n\n而**渲染缓存则存储呈现在屏幕上的渲染图像，它也被称作颜色缓冲区**，因为它本质上是存储要显示的颜色。多个纹理对象或多个渲染缓存对象，可通过连接点（attachment points）连接到帧缓存对象上。\n\n可以同时存在很多帧缓存，并且可以通过 OpenGL ES 让 GPU 把渲染结果存储到任意数量的帧缓存中。但是，只有将内容绘制到视窗体提供的帧缓存中，才能将内容输出到显示设备。视图系统提供的帧缓存通常由两个缓存对象组成，一个前端缓存，一个后端缓存。\n\n前帧缓存决定了屏幕上显示的像素颜色。程序的渲染结果通常保存在后帧缓存在内的其他帧缓存，当渲染后的后帧缓存包含一个完成的图像时，前后帧缓存会立即互换，前帧缓存变成新的后帧缓存，后帧缓存变成新的前帧缓存。\n\n![20170113188548B1802A3-32BF-465F-A4E0-DDC1A4D6CFF2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_14.png)\n\n\n\n但是前后帧我们无法去操纵，它是由系统控制的。我们只能显式的告诉系统，要展示哪个帧缓存了，然后由系统去完成前后帧的切换。\n\n\n\n## 纹理\n\n**纹理是一个用来保存图像的色值的 OpenGL ES 缓存。**\n\n现实生活中，纹理最通常的作用是装饰我们的物体模型，它就像是贴纸一样贴在物体表面，使得物体表面拥有图案。\n\n但实际上在 OpenGL 中，纹理的作用不仅限于此，它可以用来存储大量的数据。一个典型的例子就是利用纹理存储画笔笔刷的 mask 信息。\n\n\n\n## 坐标系\n\n![20170116148453735421681.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_15.jpg)\n\n\n\nOpenGL 渲染管线整个流程中，涉及了多个坐标系变化，看起来非常繁琐。但是针对 2D 图像处理，我们其实不需要关心这些变化，我们只需要了解**标准化设备坐标**即可。\n\n标准化设备坐标是一个 x、y 和 z 值在 -1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃／裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形（忽略 z 轴，仅处理 2D 图像，z 轴设置为 0.0）：\n\n\n\n![20170116148453238386304.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_16.jpg)\n\n\n\n与通常的屏幕（UIKit）坐标不同，y 轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。\n\n为了方便记忆，可以借助右手左边系。\n\n按照惯例，OpenGL 是一个右手坐标系。简单来说，就是正 x 轴在你的右手边，正 y 轴朝上，而正 z 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 z 轴穿过你的屏幕朝向你。坐标系画起来如下：\n\n![20170116148453800669809.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_17.jpg)\n\n![20170116148453810158450.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_18.jpg)\n\n\n\n\n\n另外，为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值。\n\n纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样。纹理坐标起始于（0, 0），也就是纹理图片的左下角，终始于（1, 1），即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上。\n\n![20170116148453793035367.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_19.jpg)\n\n","source":"_posts/OpenGLES-Lesson01.md","raw":"title: OpenGL ES 基础概念\n\ndate: 2017-04-01 22:30:10\n\ntags:\n\n- iOS开发\n- OpenGLES\n- 图像处理\n\n------\n\n这里主要描述一些 OpenGL ES 必须先了解的一些概念，为之后的实战铺路。\n\n\n\n## 状态机\n\n> OpenGL 是一个状态机，它维持自己的状态，并根据用户调用的函数来改变自己的状态。\n>\n> 根据状态的不同，调用同样的函数也可能产生不同的效果。\n\n在 OpenGL 的世界里，**大多数元素都可以用状态来描述**，比如：\n\n<!--more-->\n\n- 颜色、纹理坐标、光源的各种参数...\n- 是否启用了光照、是否启用了纹理、是否启用了混合、是否启用了深度测试...\n- ...\n\n**OpenGL 会保持状态，除非我们调用 OpenGL 函数来改变它。**\n\n- 比如你用 `glEnablexxx` 开启了一个状态，在以后的渲染中将一直保留并应用这个状态，除非你调用 `glDisablexxx` 及同类函数来改变该状态或程序退出。\n\n\n- 又或者当前颜色是一个状态变量，可以把当前颜色设置为白色、红色或其他任何颜色，在此之后绘制的所有物体都将使用这种颜色，直到把当前颜色设置为其他颜色。\n\n理解了状态机这个概念，我们再来看 OpenGL ES 提供的 API，就会非常明了，因为OpenGL 当中很多 API，其实仅仅是向 OpenGL 这个状态机传数据或者读数据。\n\n![201701114141530D41464-66AF-4A71-80E5-9BF8AABC016F.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_1.png)\n\n100 来个接口，如果按照不同的数据类型（GLfloat，GLint，GLsize ...），不同的元素（Uniform，Color，Texture...）划分开来，再看各个分类的接口，（~~无法~~）无非就是围绕状态展开的。\n\n比如：`glClearColor` 函数是一个状态设置函数，而 `glClear` 函数则是一个状态应用的函数。\n\n\n\n## 上下文\n\n上面提到的各种状态值，将保存在对应的上下文（**Context**）中。\n\n> OpenGL ES 上下文（EAGLContext） : 管理所有 iOS 要绘制的 OpenGL ES 信息。\n>\n> 类似在 Core Graphics 中做任何事情都需要一个 Core Graphics 上下文。\n\n通过放置这些状态到上下文中，上下文可以跟踪用于渲染的帧缓存、用于几何数据、颜色等的缓存。还会决定是否使用如纹理、灯光等功能以及会为渲染定义当前的坐标系统等。并且在多任务的情况下，就能很容易的共享硬件设备，而互不影响各自的状态。\n\n因此渲染的时候，要**指定对应的当前上下文**。\n\n\n\n## 渲染管线\n\n在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：**第一部分把你的3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素。**\n\n> 2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。\n\n图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。**它的工作过程和车间流水线一致，各个模块各司其职但是又相互依赖。**\n\n下图就是渲染管线：\n\n![20170112148420103614414.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_2.jpg)\n\n\n\n> PS：OpenGL ES 采用**服务器/客户端编程模型**，客户端运行在 CPU 上，服务端运行在 GPU 上，调用 OpenGL ES 函数的时，由客户端发送至服务器端，并被服务端转换成底层图形硬件支持的绘制命令。\n>\n> ![20170111148411873373682.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_3.jpg)\n\n\n\n左边的客户端程序通过调用 OpenGL ES 接口，将顶点，着色器程序，纹理，以及其他一些 GL 状态参数传入右边的 GL 服务端， 然后在客户端调用绘制命令的时候， GL 便会将输入的图元，逐一执行渲染管线的每个阶段，然后将每个像素的颜色值写入到帧缓存中， 最后视窗系统就可以将帧缓存中的颜色值显示在屏幕上。 此外，应用程序也可以从帧缓存中读取数据到客户端。\n\n在整个管线中，**顶点着色器和片段着色器是可编程的部分**，应用程序可以通过提供着色器程序在 GPU 中被作用于渲染管线，可编程就是说这个操作可以动态编程实现而不必固定写死在代码中。可动态编程实现这一功能一般都是脚本提供的，在 OpenGL ES 中也一样，编写这样脚本的能力是由 OpenGL 着色语言（OpenGL Shading Language, GLSL）提供的。\n\n那可编程管线有什么好处呢？**方便我们动态修改渲染过程，而无需重写编译代码**。当然也和很多脚本语言一样，调试起来不太方便。其他阶段则只能使用一些固定的 GL 命令来影响该阶段的执行。\n\n\n\n下面以**绘制一个三角形为例**，针对渲染管线的各个阶段，详细分析。\n\n### 1. 顶点数组\n\n为了渲染一个三角形，我们以数组的形式传递3个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data）；**顶点数据是一系列顶点的集合。**一个顶点（Vertex）是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性（Vertex Attribute）表示的，它可以包含任何我们想用的数据，但是简单起见，我们假定每个顶点只由一个 3D 位置和一些颜色值组成。\n\n至此，你可能会疑惑，\n\n- 我们仅仅是传递了三个点，但是 OpenGL ES 是怎么知道它们用来组成三角形呢？\n- 加入我要绘制一个 3D 模型，那么要怎么传入顶点数据？\n\n为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元（Primitive），任何一个绘制指令的调用都将把图元传递给 OpenGL 。OpenGL 支持三种基本图元：点，线和三角形。\n\n当然，OpenGL ES 并不提供对 3D 模型的定义，在传入 OpenGL ES 之前应用程序应该首先将 3D 模型转换为一组图元的集合。每个模型是独立绘制的，修改其中一个模型的一些设置并不会影响其他模型。\n\n![20170112148420555397978.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_4.jpg)\n\n\n\n每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据，这些数据首先被上传到 GL 服务端，然后就可以进行绘制。\n\n> PS：OpenGL 中的命令总是按照它被接收到的顺序执行，这意味着一组图元必须被全部绘制完毕才会开始绘制下一组图元。同时也意味着程序对帧缓冲的像素读取的结果一定是该命令之前所有 OpenGL 命令执行的结果。\n\n\n\n### 2. 顶点着色器\n\n![2017011229641BBC4CB30-3B94-4F28-8FAB-AF502E37E641.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_5.png)\n\n\n\n**顶点着色器对每个顶点执行一次运算**，它可以使用顶点数据来计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。\n\n在顶点着色器中最重要的任务是执行顶点坐标变换，应用程序中设置的图元顶点坐标通常是针对本地坐标系的。本地坐标系简化了程序中的坐标计算，但是 GL 并不识别本地坐标系，所以在顶点着色器中要对本地坐标执行模型视图变换，将本地坐标转化为裁剪坐标系的坐标值。\n\n顶点着色器的另一个功能是向后面的片段着色器提供一组易变变量（varying）。易变变量会在图元装配阶段之后被执行插值计算，如果是单重采样，其插值点为片段的中心，如果多重采样，其插值点可能为多个采样片段中的任意一个位置。易变变量可以用来保存插值计算片段的颜色，纹理坐标等信息。\n\n\n\n### 3. 图元装配\n\n![2017011250662FC720569-D123-4FC5-9F0D-C99287364AC7.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_6.png)\n\n\n\n在顶点着色器程序输出顶点坐标之后，各个顶点被按照绘制命令中的图元类型参数，以及顶点索引数组被组装成一个个图元。\n\n![20170112148421538042641.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_7.jpg)\n\n\n\n顶点数组首先通过 GL 命令输入到 GL 渲染管线中，此时顶点坐标位于应用程序的本地坐标系；在经过顶点着色器的计算之后，顶点坐标被转化到裁剪坐标系中，这通常通过向顶点着色器传入一个模型视图变换矩阵，然后在顶点着色器中执行坐标变换。\n\n裁剪坐标系被定义在一个视锥体裁剪的空间里，视锥体是游戏场景的一个可视空间，它由6个裁剪平面构成，分别是：近平面，远平面，左平面，右平面，上平面和下平面。\n\n视锥体在 3D 应用程序中通常表现为一个摄像机，其观察点为裁剪坐标系的原点，方向为穿过远近平面的中点。\n\n![20170112148421539517039.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_8.jpg)\n\n\n\n处于视锥体以外的图元将被丢弃，如果该图元与视锥体相交则会发生裁剪产生新的图元。值得注意的是透视裁剪是一个比较影响性能的过程，因为每个图元都需要和 6 个面进行相交计算，并产生新的图元。但是一般在x，y方向超出屏幕之外的，则无需产生新的图元，这些顶点能在视口变换的时候被更高效的丢弃。\n\n**通过图元装配，所有 3D 的图元已经被转化为屏幕上 2D 的图元。**\n\n\n\n### 4. 光栅化\n\n![20170112706113F85123B-6006-4633-9D8C-C4C4DB4BA3AC.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_9.png)\n\n\n\n**在光栅化阶段，基本图元被转换为供片段着色器使用的片段**（Fragment），Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。**这是从顶点数据到可渲染在显示设备上的像素的质变过程。**\n\n在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。\n\n\n\n### 5. 片段着色器\n\n![20170112997054573CDB0-956C-4A00-837F-6BDA9BA4F550.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_10.png)\n\n\n\n可编程的片段着色器是实现一些高级特效如纹理贴图，光照，环境光，阴影等功能的基础。**片段着色器的主要作用是计算每一个片段最终的颜色值（或者丢弃该片段）。**\n\n在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。在 3D 图形程序开发中，贴图是最重要的部分，程序可以通过 GL 命令上传纹理数据至 GL 内存中，这些纹理可以被片段着色器使用。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值。\n\n另外，片段着色器也是执行光照等高级特效的地方，比如可以传给片段着色器一个光源位置和光源颜色，可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。\n\n\n\n### 6. 片段测试\n\n![2017011371566F6C27776-D170-48EF-8877-E0E541F6F193.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_11.png)\n\n片段着色器输出的颜色值，还要经过几个阶段的片段操作，这些操作可能会修改片段的颜色值，或者丢弃该片段，**最终的片段颜色值才会被写入到帧缓冲中。**\n\n![2017011214842168484373.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_12.jpg)\n\n像素所有权测试用来判断帧缓冲区中该位置的像素是否属于当前 OpenGL ES，例如在窗口系统中该位置可能会被其他应用程序窗口遮挡，此时该像素则不会被显示。\n\n在片段测试之后，片段要么被丢弃，要么每个片段对应的颜色，深度，模板值会被写入帧缓冲区，最终呈现在设备屏幕上。帧缓冲区中的颜色值也可以被读回到客户端应用程序中，这样可以实现绘制到纹理的效果。\n\n至此，OpenGL ES 渲染管道最终将每个像素点的颜色，深度，模板等数据输送到帧缓存中（Framebuffer）。\n\n\n\n## 帧缓存 / 渲染缓存\n\n那么，帧缓存和渲染缓存到底代表什么，又用来做什么呢？\n\n总的来说，**帧缓存是接收渲染结果的缓冲区，为GPU指定存储渲染结果的区域**。它存储着 OpenGL ES 绘制每个像素点最终的所有信息：颜色，深度和模板值。更通俗点，可以理解成存储屏幕上最终显示的一帧画面的区域。\n\n![20170112148423006492580.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_13.jpg)\n\n而**渲染缓存则存储呈现在屏幕上的渲染图像，它也被称作颜色缓冲区**，因为它本质上是存储要显示的颜色。多个纹理对象或多个渲染缓存对象，可通过连接点（attachment points）连接到帧缓存对象上。\n\n可以同时存在很多帧缓存，并且可以通过 OpenGL ES 让 GPU 把渲染结果存储到任意数量的帧缓存中。但是，只有将内容绘制到视窗体提供的帧缓存中，才能将内容输出到显示设备。视图系统提供的帧缓存通常由两个缓存对象组成，一个前端缓存，一个后端缓存。\n\n前帧缓存决定了屏幕上显示的像素颜色。程序的渲染结果通常保存在后帧缓存在内的其他帧缓存，当渲染后的后帧缓存包含一个完成的图像时，前后帧缓存会立即互换，前帧缓存变成新的后帧缓存，后帧缓存变成新的前帧缓存。\n\n![20170113188548B1802A3-32BF-465F-A4E0-DDC1A4D6CFF2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_14.png)\n\n\n\n但是前后帧我们无法去操纵，它是由系统控制的。我们只能显式的告诉系统，要展示哪个帧缓存了，然后由系统去完成前后帧的切换。\n\n\n\n## 纹理\n\n**纹理是一个用来保存图像的色值的 OpenGL ES 缓存。**\n\n现实生活中，纹理最通常的作用是装饰我们的物体模型，它就像是贴纸一样贴在物体表面，使得物体表面拥有图案。\n\n但实际上在 OpenGL 中，纹理的作用不仅限于此，它可以用来存储大量的数据。一个典型的例子就是利用纹理存储画笔笔刷的 mask 信息。\n\n\n\n## 坐标系\n\n![20170116148453735421681.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_15.jpg)\n\n\n\nOpenGL 渲染管线整个流程中，涉及了多个坐标系变化，看起来非常繁琐。但是针对 2D 图像处理，我们其实不需要关心这些变化，我们只需要了解**标准化设备坐标**即可。\n\n标准化设备坐标是一个 x、y 和 z 值在 -1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃／裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形（忽略 z 轴，仅处理 2D 图像，z 轴设置为 0.0）：\n\n\n\n![20170116148453238386304.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_16.jpg)\n\n\n\n与通常的屏幕（UIKit）坐标不同，y 轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。\n\n为了方便记忆，可以借助右手左边系。\n\n按照惯例，OpenGL 是一个右手坐标系。简单来说，就是正 x 轴在你的右手边，正 y 轴朝上，而正 z 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 z 轴穿过你的屏幕朝向你。坐标系画起来如下：\n\n![20170116148453800669809.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_17.jpg)\n\n![20170116148453810158450.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_18.jpg)\n\n\n\n\n\n另外，为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值。\n\n纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样。纹理坐标起始于（0, 0），也就是纹理图片的左下角，终始于（1, 1），即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上。\n\n![20170116148453793035367.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_19.jpg)\n\n","slug":"OpenGLES-Lesson01","published":1,"updated":"2019-12-23T01:02:31.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1n3001xzwln8inne0e7","content":"<p>这里主要描述一些 OpenGL ES 必须先了解的一些概念，为之后的实战铺路。</p>\n<h2 id=\"状态机\">状态机</h2><blockquote>\n<p>OpenGL 是一个状态机，它维持自己的状态，并根据用户调用的函数来改变自己的状态。</p>\n<p>根据状态的不同，调用同样的函数也可能产生不同的效果。</p>\n</blockquote>\n<p>在 OpenGL 的世界里，<strong>大多数元素都可以用状态来描述</strong>，比如：</p>\n<a id=\"more\"></a>\n<ul>\n<li>颜色、纹理坐标、光源的各种参数…</li>\n<li>是否启用了光照、是否启用了纹理、是否启用了混合、是否启用了深度测试…</li>\n<li>…</li>\n</ul>\n<p><strong>OpenGL 会保持状态，除非我们调用 OpenGL 函数来改变它。</strong></p>\n<ul>\n<li>比如你用 <code>glEnablexxx</code> 开启了一个状态，在以后的渲染中将一直保留并应用这个状态，除非你调用 <code>glDisablexxx</code> 及同类函数来改变该状态或程序退出。</li>\n</ul>\n<ul>\n<li>又或者当前颜色是一个状态变量，可以把当前颜色设置为白色、红色或其他任何颜色，在此之后绘制的所有物体都将使用这种颜色，直到把当前颜色设置为其他颜色。</li>\n</ul>\n<p>理解了状态机这个概念，我们再来看 OpenGL ES 提供的 API，就会非常明了，因为OpenGL 当中很多 API，其实仅仅是向 OpenGL 这个状态机传数据或者读数据。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_1.png\" alt=\"201701114141530D41464-66AF-4A71-80E5-9BF8AABC016F.png\"></p>\n<p>100 来个接口，如果按照不同的数据类型（GLfloat，GLint，GLsize …），不同的元素（Uniform，Color，Texture…）划分开来，再看各个分类的接口，（<del>无法</del>）无非就是围绕状态展开的。</p>\n<p>比如：<code>glClearColor</code> 函数是一个状态设置函数，而 <code>glClear</code> 函数则是一个状态应用的函数。</p>\n<h2 id=\"上下文\">上下文</h2><p>上面提到的各种状态值，将保存在对应的上下文（<strong>Context</strong>）中。</p>\n<blockquote>\n<p>OpenGL ES 上下文（EAGLContext） : 管理所有 iOS 要绘制的 OpenGL ES 信息。</p>\n<p>类似在 Core Graphics 中做任何事情都需要一个 Core Graphics 上下文。</p>\n</blockquote>\n<p>通过放置这些状态到上下文中，上下文可以跟踪用于渲染的帧缓存、用于几何数据、颜色等的缓存。还会决定是否使用如纹理、灯光等功能以及会为渲染定义当前的坐标系统等。并且在多任务的情况下，就能很容易的共享硬件设备，而互不影响各自的状态。</p>\n<p>因此渲染的时候，要<strong>指定对应的当前上下文</strong>。</p>\n<h2 id=\"渲染管线\">渲染管线</h2><p>在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：<strong>第一部分把你的3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素。</strong></p>\n<blockquote>\n<p>2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。</p>\n</blockquote>\n<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。<strong>它的工作过程和车间流水线一致，各个模块各司其职但是又相互依赖。</strong></p>\n<p>下图就是渲染管线：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_2.jpg\" alt=\"20170112148420103614414.jpg\"></p>\n<blockquote>\n<p>PS：OpenGL ES 采用<strong>服务器/客户端编程模型</strong>，客户端运行在 CPU 上，服务端运行在 GPU 上，调用 OpenGL ES 函数的时，由客户端发送至服务器端，并被服务端转换成底层图形硬件支持的绘制命令。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_3.jpg\" alt=\"20170111148411873373682.jpg\"></p>\n</blockquote>\n<p>左边的客户端程序通过调用 OpenGL ES 接口，将顶点，着色器程序，纹理，以及其他一些 GL 状态参数传入右边的 GL 服务端， 然后在客户端调用绘制命令的时候， GL 便会将输入的图元，逐一执行渲染管线的每个阶段，然后将每个像素的颜色值写入到帧缓存中， 最后视窗系统就可以将帧缓存中的颜色值显示在屏幕上。 此外，应用程序也可以从帧缓存中读取数据到客户端。</p>\n<p>在整个管线中，<strong>顶点着色器和片段着色器是可编程的部分</strong>，应用程序可以通过提供着色器程序在 GPU 中被作用于渲染管线，可编程就是说这个操作可以动态编程实现而不必固定写死在代码中。可动态编程实现这一功能一般都是脚本提供的，在 OpenGL ES 中也一样，编写这样脚本的能力是由 OpenGL 着色语言（OpenGL Shading Language, GLSL）提供的。</p>\n<p>那可编程管线有什么好处呢？<strong>方便我们动态修改渲染过程，而无需重写编译代码</strong>。当然也和很多脚本语言一样，调试起来不太方便。其他阶段则只能使用一些固定的 GL 命令来影响该阶段的执行。</p>\n<p>下面以<strong>绘制一个三角形为例</strong>，针对渲染管线的各个阶段，详细分析。</p>\n<h3 id=\"1-_顶点数组\">1. 顶点数组</h3><p>为了渲染一个三角形，我们以数组的形式传递3个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data）；<strong>顶点数据是一系列顶点的集合。</strong>一个顶点（Vertex）是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性（Vertex Attribute）表示的，它可以包含任何我们想用的数据，但是简单起见，我们假定每个顶点只由一个 3D 位置和一些颜色值组成。</p>\n<p>至此，你可能会疑惑，</p>\n<ul>\n<li>我们仅仅是传递了三个点，但是 OpenGL ES 是怎么知道它们用来组成三角形呢？</li>\n<li>加入我要绘制一个 3D 模型，那么要怎么传入顶点数据？</li>\n</ul>\n<p>为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元（Primitive），任何一个绘制指令的调用都将把图元传递给 OpenGL 。OpenGL 支持三种基本图元：点，线和三角形。</p>\n<p>当然，OpenGL ES 并不提供对 3D 模型的定义，在传入 OpenGL ES 之前应用程序应该首先将 3D 模型转换为一组图元的集合。每个模型是独立绘制的，修改其中一个模型的一些设置并不会影响其他模型。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_4.jpg\" alt=\"20170112148420555397978.jpg\"></p>\n<p>每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据，这些数据首先被上传到 GL 服务端，然后就可以进行绘制。</p>\n<blockquote>\n<p>PS：OpenGL 中的命令总是按照它被接收到的顺序执行，这意味着一组图元必须被全部绘制完毕才会开始绘制下一组图元。同时也意味着程序对帧缓冲的像素读取的结果一定是该命令之前所有 OpenGL 命令执行的结果。</p>\n</blockquote>\n<h3 id=\"2-_顶点着色器\">2. 顶点着色器</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_5.png\" alt=\"2017011229641BBC4CB30-3B94-4F28-8FAB-AF502E37E641.png\"></p>\n<p><strong>顶点着色器对每个顶点执行一次运算</strong>，它可以使用顶点数据来计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。</p>\n<p>在顶点着色器中最重要的任务是执行顶点坐标变换，应用程序中设置的图元顶点坐标通常是针对本地坐标系的。本地坐标系简化了程序中的坐标计算，但是 GL 并不识别本地坐标系，所以在顶点着色器中要对本地坐标执行模型视图变换，将本地坐标转化为裁剪坐标系的坐标值。</p>\n<p>顶点着色器的另一个功能是向后面的片段着色器提供一组易变变量（varying）。易变变量会在图元装配阶段之后被执行插值计算，如果是单重采样，其插值点为片段的中心，如果多重采样，其插值点可能为多个采样片段中的任意一个位置。易变变量可以用来保存插值计算片段的颜色，纹理坐标等信息。</p>\n<h3 id=\"3-_图元装配\">3. 图元装配</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_6.png\" alt=\"2017011250662FC720569-D123-4FC5-9F0D-C99287364AC7.png\"></p>\n<p>在顶点着色器程序输出顶点坐标之后，各个顶点被按照绘制命令中的图元类型参数，以及顶点索引数组被组装成一个个图元。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_7.jpg\" alt=\"20170112148421538042641.jpg\"></p>\n<p>顶点数组首先通过 GL 命令输入到 GL 渲染管线中，此时顶点坐标位于应用程序的本地坐标系；在经过顶点着色器的计算之后，顶点坐标被转化到裁剪坐标系中，这通常通过向顶点着色器传入一个模型视图变换矩阵，然后在顶点着色器中执行坐标变换。</p>\n<p>裁剪坐标系被定义在一个视锥体裁剪的空间里，视锥体是游戏场景的一个可视空间，它由6个裁剪平面构成，分别是：近平面，远平面，左平面，右平面，上平面和下平面。</p>\n<p>视锥体在 3D 应用程序中通常表现为一个摄像机，其观察点为裁剪坐标系的原点，方向为穿过远近平面的中点。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_8.jpg\" alt=\"20170112148421539517039.jpg\"></p>\n<p>处于视锥体以外的图元将被丢弃，如果该图元与视锥体相交则会发生裁剪产生新的图元。值得注意的是透视裁剪是一个比较影响性能的过程，因为每个图元都需要和 6 个面进行相交计算，并产生新的图元。但是一般在x，y方向超出屏幕之外的，则无需产生新的图元，这些顶点能在视口变换的时候被更高效的丢弃。</p>\n<p><strong>通过图元装配，所有 3D 的图元已经被转化为屏幕上 2D 的图元。</strong></p>\n<h3 id=\"4-_光栅化\">4. 光栅化</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_9.png\" alt=\"20170112706113F85123B-6006-4633-9D8C-C4C4DB4BA3AC.png\"></p>\n<p><strong>在光栅化阶段，基本图元被转换为供片段着色器使用的片段</strong>（Fragment），Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。<strong>这是从顶点数据到可渲染在显示设备上的像素的质变过程。</strong></p>\n<p>在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>\n<h3 id=\"5-_片段着色器\">5. 片段着色器</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_10.png\" alt=\"20170112997054573CDB0-956C-4A00-837F-6BDA9BA4F550.png\"></p>\n<p>可编程的片段着色器是实现一些高级特效如纹理贴图，光照，环境光，阴影等功能的基础。<strong>片段着色器的主要作用是计算每一个片段最终的颜色值（或者丢弃该片段）。</strong></p>\n<p>在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。在 3D 图形程序开发中，贴图是最重要的部分，程序可以通过 GL 命令上传纹理数据至 GL 内存中，这些纹理可以被片段着色器使用。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值。</p>\n<p>另外，片段着色器也是执行光照等高级特效的地方，比如可以传给片段着色器一个光源位置和光源颜色，可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。</p>\n<h3 id=\"6-_片段测试\">6. 片段测试</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_11.png\" alt=\"2017011371566F6C27776-D170-48EF-8877-E0E541F6F193.png\"></p>\n<p>片段着色器输出的颜色值，还要经过几个阶段的片段操作，这些操作可能会修改片段的颜色值，或者丢弃该片段，<strong>最终的片段颜色值才会被写入到帧缓冲中。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_12.jpg\" alt=\"2017011214842168484373.jpg\"></p>\n<p>像素所有权测试用来判断帧缓冲区中该位置的像素是否属于当前 OpenGL ES，例如在窗口系统中该位置可能会被其他应用程序窗口遮挡，此时该像素则不会被显示。</p>\n<p>在片段测试之后，片段要么被丢弃，要么每个片段对应的颜色，深度，模板值会被写入帧缓冲区，最终呈现在设备屏幕上。帧缓冲区中的颜色值也可以被读回到客户端应用程序中，这样可以实现绘制到纹理的效果。</p>\n<p>至此，OpenGL ES 渲染管道最终将每个像素点的颜色，深度，模板等数据输送到帧缓存中（Framebuffer）。</p>\n<h2 id=\"帧缓存_/_渲染缓存\">帧缓存 / 渲染缓存</h2><p>那么，帧缓存和渲染缓存到底代表什么，又用来做什么呢？</p>\n<p>总的来说，<strong>帧缓存是接收渲染结果的缓冲区，为GPU指定存储渲染结果的区域</strong>。它存储着 OpenGL ES 绘制每个像素点最终的所有信息：颜色，深度和模板值。更通俗点，可以理解成存储屏幕上最终显示的一帧画面的区域。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_13.jpg\" alt=\"20170112148423006492580.jpg\"></p>\n<p>而<strong>渲染缓存则存储呈现在屏幕上的渲染图像，它也被称作颜色缓冲区</strong>，因为它本质上是存储要显示的颜色。多个纹理对象或多个渲染缓存对象，可通过连接点（attachment points）连接到帧缓存对象上。</p>\n<p>可以同时存在很多帧缓存，并且可以通过 OpenGL ES 让 GPU 把渲染结果存储到任意数量的帧缓存中。但是，只有将内容绘制到视窗体提供的帧缓存中，才能将内容输出到显示设备。视图系统提供的帧缓存通常由两个缓存对象组成，一个前端缓存，一个后端缓存。</p>\n<p>前帧缓存决定了屏幕上显示的像素颜色。程序的渲染结果通常保存在后帧缓存在内的其他帧缓存，当渲染后的后帧缓存包含一个完成的图像时，前后帧缓存会立即互换，前帧缓存变成新的后帧缓存，后帧缓存变成新的前帧缓存。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_14.png\" alt=\"20170113188548B1802A3-32BF-465F-A4E0-DDC1A4D6CFF2.png\"></p>\n<p>但是前后帧我们无法去操纵，它是由系统控制的。我们只能显式的告诉系统，要展示哪个帧缓存了，然后由系统去完成前后帧的切换。</p>\n<h2 id=\"纹理\">纹理</h2><p><strong>纹理是一个用来保存图像的色值的 OpenGL ES 缓存。</strong></p>\n<p>现实生活中，纹理最通常的作用是装饰我们的物体模型，它就像是贴纸一样贴在物体表面，使得物体表面拥有图案。</p>\n<p>但实际上在 OpenGL 中，纹理的作用不仅限于此，它可以用来存储大量的数据。一个典型的例子就是利用纹理存储画笔笔刷的 mask 信息。</p>\n<h2 id=\"坐标系\">坐标系</h2><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_15.jpg\" alt=\"20170116148453735421681.jpg\"></p>\n<p>OpenGL 渲染管线整个流程中，涉及了多个坐标系变化，看起来非常繁琐。但是针对 2D 图像处理，我们其实不需要关心这些变化，我们只需要了解<strong>标准化设备坐标</strong>即可。</p>\n<p>标准化设备坐标是一个 x、y 和 z 值在 -1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃／裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形（忽略 z 轴，仅处理 2D 图像，z 轴设置为 0.0）：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_16.jpg\" alt=\"20170116148453238386304.jpg\"></p>\n<p>与通常的屏幕（UIKit）坐标不同，y 轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。</p>\n<p>为了方便记忆，可以借助右手左边系。</p>\n<p>按照惯例，OpenGL 是一个右手坐标系。简单来说，就是正 x 轴在你的右手边，正 y 轴朝上，而正 z 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 z 轴穿过你的屏幕朝向你。坐标系画起来如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_17.jpg\" alt=\"20170116148453800669809.jpg\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_18.jpg\" alt=\"20170116148453810158450.jpg\"></p>\n<p>另外，为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值。</p>\n<p>纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样。纹理坐标起始于（0, 0），也就是纹理图片的左下角，终始于（1, 1），即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_19.jpg\" alt=\"20170116148453793035367.jpg\"></p>\n","excerpt":"<p>这里主要描述一些 OpenGL ES 必须先了解的一些概念，为之后的实战铺路。</p>\n<h2 id=\"状态机\">状态机</h2><blockquote>\n<p>OpenGL 是一个状态机，它维持自己的状态，并根据用户调用的函数来改变自己的状态。</p>\n<p>根据状态的不同，调用同样的函数也可能产生不同的效果。</p>\n</blockquote>\n<p>在 OpenGL 的世界里，<strong>大多数元素都可以用状态来描述</strong>，比如：</p>","more":"<ul>\n<li>颜色、纹理坐标、光源的各种参数…</li>\n<li>是否启用了光照、是否启用了纹理、是否启用了混合、是否启用了深度测试…</li>\n<li>…</li>\n</ul>\n<p><strong>OpenGL 会保持状态，除非我们调用 OpenGL 函数来改变它。</strong></p>\n<ul>\n<li>比如你用 <code>glEnablexxx</code> 开启了一个状态，在以后的渲染中将一直保留并应用这个状态，除非你调用 <code>glDisablexxx</code> 及同类函数来改变该状态或程序退出。</li>\n</ul>\n<ul>\n<li>又或者当前颜色是一个状态变量，可以把当前颜色设置为白色、红色或其他任何颜色，在此之后绘制的所有物体都将使用这种颜色，直到把当前颜色设置为其他颜色。</li>\n</ul>\n<p>理解了状态机这个概念，我们再来看 OpenGL ES 提供的 API，就会非常明了，因为OpenGL 当中很多 API，其实仅仅是向 OpenGL 这个状态机传数据或者读数据。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_1.png\" alt=\"201701114141530D41464-66AF-4A71-80E5-9BF8AABC016F.png\"></p>\n<p>100 来个接口，如果按照不同的数据类型（GLfloat，GLint，GLsize …），不同的元素（Uniform，Color，Texture…）划分开来，再看各个分类的接口，（<del>无法</del>）无非就是围绕状态展开的。</p>\n<p>比如：<code>glClearColor</code> 函数是一个状态设置函数，而 <code>glClear</code> 函数则是一个状态应用的函数。</p>\n<h2 id=\"上下文\">上下文</h2><p>上面提到的各种状态值，将保存在对应的上下文（<strong>Context</strong>）中。</p>\n<blockquote>\n<p>OpenGL ES 上下文（EAGLContext） : 管理所有 iOS 要绘制的 OpenGL ES 信息。</p>\n<p>类似在 Core Graphics 中做任何事情都需要一个 Core Graphics 上下文。</p>\n</blockquote>\n<p>通过放置这些状态到上下文中，上下文可以跟踪用于渲染的帧缓存、用于几何数据、颜色等的缓存。还会决定是否使用如纹理、灯光等功能以及会为渲染定义当前的坐标系统等。并且在多任务的情况下，就能很容易的共享硬件设备，而互不影响各自的状态。</p>\n<p>因此渲染的时候，要<strong>指定对应的当前上下文</strong>。</p>\n<h2 id=\"渲染管线\">渲染管线</h2><p>在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：<strong>第一部分把你的3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素。</strong></p>\n<blockquote>\n<p>2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。</p>\n</blockquote>\n<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。<strong>它的工作过程和车间流水线一致，各个模块各司其职但是又相互依赖。</strong></p>\n<p>下图就是渲染管线：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_2.jpg\" alt=\"20170112148420103614414.jpg\"></p>\n<blockquote>\n<p>PS：OpenGL ES 采用<strong>服务器/客户端编程模型</strong>，客户端运行在 CPU 上，服务端运行在 GPU 上，调用 OpenGL ES 函数的时，由客户端发送至服务器端，并被服务端转换成底层图形硬件支持的绘制命令。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_3.jpg\" alt=\"20170111148411873373682.jpg\"></p>\n</blockquote>\n<p>左边的客户端程序通过调用 OpenGL ES 接口，将顶点，着色器程序，纹理，以及其他一些 GL 状态参数传入右边的 GL 服务端， 然后在客户端调用绘制命令的时候， GL 便会将输入的图元，逐一执行渲染管线的每个阶段，然后将每个像素的颜色值写入到帧缓存中， 最后视窗系统就可以将帧缓存中的颜色值显示在屏幕上。 此外，应用程序也可以从帧缓存中读取数据到客户端。</p>\n<p>在整个管线中，<strong>顶点着色器和片段着色器是可编程的部分</strong>，应用程序可以通过提供着色器程序在 GPU 中被作用于渲染管线，可编程就是说这个操作可以动态编程实现而不必固定写死在代码中。可动态编程实现这一功能一般都是脚本提供的，在 OpenGL ES 中也一样，编写这样脚本的能力是由 OpenGL 着色语言（OpenGL Shading Language, GLSL）提供的。</p>\n<p>那可编程管线有什么好处呢？<strong>方便我们动态修改渲染过程，而无需重写编译代码</strong>。当然也和很多脚本语言一样，调试起来不太方便。其他阶段则只能使用一些固定的 GL 命令来影响该阶段的执行。</p>\n<p>下面以<strong>绘制一个三角形为例</strong>，针对渲染管线的各个阶段，详细分析。</p>\n<h3 id=\"1-_顶点数组\">1. 顶点数组</h3><p>为了渲染一个三角形，我们以数组的形式传递3个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data）；<strong>顶点数据是一系列顶点的集合。</strong>一个顶点（Vertex）是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性（Vertex Attribute）表示的，它可以包含任何我们想用的数据，但是简单起见，我们假定每个顶点只由一个 3D 位置和一些颜色值组成。</p>\n<p>至此，你可能会疑惑，</p>\n<ul>\n<li>我们仅仅是传递了三个点，但是 OpenGL ES 是怎么知道它们用来组成三角形呢？</li>\n<li>加入我要绘制一个 3D 模型，那么要怎么传入顶点数据？</li>\n</ul>\n<p>为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元（Primitive），任何一个绘制指令的调用都将把图元传递给 OpenGL 。OpenGL 支持三种基本图元：点，线和三角形。</p>\n<p>当然，OpenGL ES 并不提供对 3D 模型的定义，在传入 OpenGL ES 之前应用程序应该首先将 3D 模型转换为一组图元的集合。每个模型是独立绘制的，修改其中一个模型的一些设置并不会影响其他模型。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_4.jpg\" alt=\"20170112148420555397978.jpg\"></p>\n<p>每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据，这些数据首先被上传到 GL 服务端，然后就可以进行绘制。</p>\n<blockquote>\n<p>PS：OpenGL 中的命令总是按照它被接收到的顺序执行，这意味着一组图元必须被全部绘制完毕才会开始绘制下一组图元。同时也意味着程序对帧缓冲的像素读取的结果一定是该命令之前所有 OpenGL 命令执行的结果。</p>\n</blockquote>\n<h3 id=\"2-_顶点着色器\">2. 顶点着色器</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_5.png\" alt=\"2017011229641BBC4CB30-3B94-4F28-8FAB-AF502E37E641.png\"></p>\n<p><strong>顶点着色器对每个顶点执行一次运算</strong>，它可以使用顶点数据来计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。</p>\n<p>在顶点着色器中最重要的任务是执行顶点坐标变换，应用程序中设置的图元顶点坐标通常是针对本地坐标系的。本地坐标系简化了程序中的坐标计算，但是 GL 并不识别本地坐标系，所以在顶点着色器中要对本地坐标执行模型视图变换，将本地坐标转化为裁剪坐标系的坐标值。</p>\n<p>顶点着色器的另一个功能是向后面的片段着色器提供一组易变变量（varying）。易变变量会在图元装配阶段之后被执行插值计算，如果是单重采样，其插值点为片段的中心，如果多重采样，其插值点可能为多个采样片段中的任意一个位置。易变变量可以用来保存插值计算片段的颜色，纹理坐标等信息。</p>\n<h3 id=\"3-_图元装配\">3. 图元装配</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_6.png\" alt=\"2017011250662FC720569-D123-4FC5-9F0D-C99287364AC7.png\"></p>\n<p>在顶点着色器程序输出顶点坐标之后，各个顶点被按照绘制命令中的图元类型参数，以及顶点索引数组被组装成一个个图元。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_7.jpg\" alt=\"20170112148421538042641.jpg\"></p>\n<p>顶点数组首先通过 GL 命令输入到 GL 渲染管线中，此时顶点坐标位于应用程序的本地坐标系；在经过顶点着色器的计算之后，顶点坐标被转化到裁剪坐标系中，这通常通过向顶点着色器传入一个模型视图变换矩阵，然后在顶点着色器中执行坐标变换。</p>\n<p>裁剪坐标系被定义在一个视锥体裁剪的空间里，视锥体是游戏场景的一个可视空间，它由6个裁剪平面构成，分别是：近平面，远平面，左平面，右平面，上平面和下平面。</p>\n<p>视锥体在 3D 应用程序中通常表现为一个摄像机，其观察点为裁剪坐标系的原点，方向为穿过远近平面的中点。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_8.jpg\" alt=\"20170112148421539517039.jpg\"></p>\n<p>处于视锥体以外的图元将被丢弃，如果该图元与视锥体相交则会发生裁剪产生新的图元。值得注意的是透视裁剪是一个比较影响性能的过程，因为每个图元都需要和 6 个面进行相交计算，并产生新的图元。但是一般在x，y方向超出屏幕之外的，则无需产生新的图元，这些顶点能在视口变换的时候被更高效的丢弃。</p>\n<p><strong>通过图元装配，所有 3D 的图元已经被转化为屏幕上 2D 的图元。</strong></p>\n<h3 id=\"4-_光栅化\">4. 光栅化</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_9.png\" alt=\"20170112706113F85123B-6006-4633-9D8C-C4C4DB4BA3AC.png\"></p>\n<p><strong>在光栅化阶段，基本图元被转换为供片段着色器使用的片段</strong>（Fragment），Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。<strong>这是从顶点数据到可渲染在显示设备上的像素的质变过程。</strong></p>\n<p>在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>\n<h3 id=\"5-_片段着色器\">5. 片段着色器</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_10.png\" alt=\"20170112997054573CDB0-956C-4A00-837F-6BDA9BA4F550.png\"></p>\n<p>可编程的片段着色器是实现一些高级特效如纹理贴图，光照，环境光，阴影等功能的基础。<strong>片段着色器的主要作用是计算每一个片段最终的颜色值（或者丢弃该片段）。</strong></p>\n<p>在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。在 3D 图形程序开发中，贴图是最重要的部分，程序可以通过 GL 命令上传纹理数据至 GL 内存中，这些纹理可以被片段着色器使用。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值。</p>\n<p>另外，片段着色器也是执行光照等高级特效的地方，比如可以传给片段着色器一个光源位置和光源颜色，可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。</p>\n<h3 id=\"6-_片段测试\">6. 片段测试</h3><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_11.png\" alt=\"2017011371566F6C27776-D170-48EF-8877-E0E541F6F193.png\"></p>\n<p>片段着色器输出的颜色值，还要经过几个阶段的片段操作，这些操作可能会修改片段的颜色值，或者丢弃该片段，<strong>最终的片段颜色值才会被写入到帧缓冲中。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_12.jpg\" alt=\"2017011214842168484373.jpg\"></p>\n<p>像素所有权测试用来判断帧缓冲区中该位置的像素是否属于当前 OpenGL ES，例如在窗口系统中该位置可能会被其他应用程序窗口遮挡，此时该像素则不会被显示。</p>\n<p>在片段测试之后，片段要么被丢弃，要么每个片段对应的颜色，深度，模板值会被写入帧缓冲区，最终呈现在设备屏幕上。帧缓冲区中的颜色值也可以被读回到客户端应用程序中，这样可以实现绘制到纹理的效果。</p>\n<p>至此，OpenGL ES 渲染管道最终将每个像素点的颜色，深度，模板等数据输送到帧缓存中（Framebuffer）。</p>\n<h2 id=\"帧缓存_/_渲染缓存\">帧缓存 / 渲染缓存</h2><p>那么，帧缓存和渲染缓存到底代表什么，又用来做什么呢？</p>\n<p>总的来说，<strong>帧缓存是接收渲染结果的缓冲区，为GPU指定存储渲染结果的区域</strong>。它存储着 OpenGL ES 绘制每个像素点最终的所有信息：颜色，深度和模板值。更通俗点，可以理解成存储屏幕上最终显示的一帧画面的区域。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_13.jpg\" alt=\"20170112148423006492580.jpg\"></p>\n<p>而<strong>渲染缓存则存储呈现在屏幕上的渲染图像，它也被称作颜色缓冲区</strong>，因为它本质上是存储要显示的颜色。多个纹理对象或多个渲染缓存对象，可通过连接点（attachment points）连接到帧缓存对象上。</p>\n<p>可以同时存在很多帧缓存，并且可以通过 OpenGL ES 让 GPU 把渲染结果存储到任意数量的帧缓存中。但是，只有将内容绘制到视窗体提供的帧缓存中，才能将内容输出到显示设备。视图系统提供的帧缓存通常由两个缓存对象组成，一个前端缓存，一个后端缓存。</p>\n<p>前帧缓存决定了屏幕上显示的像素颜色。程序的渲染结果通常保存在后帧缓存在内的其他帧缓存，当渲染后的后帧缓存包含一个完成的图像时，前后帧缓存会立即互换，前帧缓存变成新的后帧缓存，后帧缓存变成新的前帧缓存。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_14.png\" alt=\"20170113188548B1802A3-32BF-465F-A4E0-DDC1A4D6CFF2.png\"></p>\n<p>但是前后帧我们无法去操纵，它是由系统控制的。我们只能显式的告诉系统，要展示哪个帧缓存了，然后由系统去完成前后帧的切换。</p>\n<h2 id=\"纹理\">纹理</h2><p><strong>纹理是一个用来保存图像的色值的 OpenGL ES 缓存。</strong></p>\n<p>现实生活中，纹理最通常的作用是装饰我们的物体模型，它就像是贴纸一样贴在物体表面，使得物体表面拥有图案。</p>\n<p>但实际上在 OpenGL 中，纹理的作用不仅限于此，它可以用来存储大量的数据。一个典型的例子就是利用纹理存储画笔笔刷的 mask 信息。</p>\n<h2 id=\"坐标系\">坐标系</h2><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_15.jpg\" alt=\"20170116148453735421681.jpg\"></p>\n<p>OpenGL 渲染管线整个流程中，涉及了多个坐标系变化，看起来非常繁琐。但是针对 2D 图像处理，我们其实不需要关心这些变化，我们只需要了解<strong>标准化设备坐标</strong>即可。</p>\n<p>标准化设备坐标是一个 x、y 和 z 值在 -1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃／裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形（忽略 z 轴，仅处理 2D 图像，z 轴设置为 0.0）：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_16.jpg\" alt=\"20170116148453238386304.jpg\"></p>\n<p>与通常的屏幕（UIKit）坐标不同，y 轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。</p>\n<p>为了方便记忆，可以借助右手左边系。</p>\n<p>按照惯例，OpenGL 是一个右手坐标系。简单来说，就是正 x 轴在你的右手边，正 y 轴朝上，而正 z 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 z 轴穿过你的屏幕朝向你。坐标系画起来如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_17.jpg\" alt=\"20170116148453800669809.jpg\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_18.jpg\" alt=\"20170116148453810158450.jpg\"></p>\n<p>另外，为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值。</p>\n<p>纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样。纹理坐标起始于（0, 0），也就是纹理图片的左下角，终始于（1, 1），即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_2_19.jpg\" alt=\"20170116148453793035367.jpg\"></p>"},{"title":"OpenGL ES 渲染基本图元","date":"2017-04-18T10:25:12.000Z","_content":"\n在[上篇文章](http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/)中，已经介绍了 OpenGL ES 的基础环境搭建，并且实现了设置背景色功能。\n\n在本文中，我们将会在上文的基础上，渲染基本图元，三角形。在这个过程中，将会详细介绍可编程图形渲染管线是如何工作的。\n\n最终的效果如下：\n\n![2017013028167QQ20170130-174258@2x.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_1.png)\n\n<!--more-->\n\n## 0. 初始工程\n\n你可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip)下载到初始工程，避免重复实现一些和本节内容不相干的事情。\n\n这是上一节的最终工程，包含了 OpenGL ES 的基础环境搭建。\n\n> PS：\n>\n> 在之后的步骤里，如果你细心观察对比，你会发现其实它就是围绕图形渲染管线展开的，把之前介绍的内容，用代码的方式实现出来，具体流程可以参照下图回顾：![20170112148420103614414.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_2.jpg)\n\n\n\n## 1. 顶点数据\n\n开始渲染图形之前，我们必须先给 OpenGL ES 输入一些顶点数据。\n\n为了渲染一个如图所示的三角形，我们需要以数组的形式传递3个 3D 坐标（之前提到过，在 OpenGL 中，任何事物都在 **3D** 空间中）作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data），**顶点数据是一系列顶点的集合**。\n\n在这个简单的例子里，我们一共要指定三个顶点，每个顶点只由一个 3D 位置和一个颜色值组成。\n\n自定义顶点结构体如下：\n\n```objc\ntypedef struct\n{\n    float position[4]; // 3D 位置\n    float color[4];    // 颜色值\n} CustomVertex;\n```\n\n> PS：\n>\n> **Q：**这里的颜色值，用四维向量表示可以理解（RGBA），那么 3D 位置为什么也是四维向量（XYZW）呢（包含4个元素的数组表示的向量）？\n>\n> **A：** 3D 图形渲染过程中用到了 4x4 的矩阵（4行4列），矩阵乘法要求 nxm * mxp（n行m列 乘 m行p列）才能相乘，注意 m 是相同的，所以 1x4 * 4x4 才能相乘。\n>\n> The w in vec4(x, y, z, w) is used for clipping, and plays its part while linear algebra transformations are applied to the position.\n>\n> By default, this should be set to 1.0.\n>\n> **See here for some more info：**\n>\n> [http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html](http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html)\n\n\n\n针对此三角形，我们可以填充对应的数据如下：\n\n```objc\nstatic const CustomVertex vertices[] =\n{\n    { .position = { -1.0,  1.0, 0, 1 }, .color = { 1, 0, 0, 1 } },\n    { .position = { -1.0, -1.0, 0, 1 }, .color = { 0, 1, 0, 1 } },\n    { .position = {  1.0, -1.0, 0, 1 }, .color = { 0, 0, 1, 1 } }\n};\n```\n\n虽然 OpenGL 是在 3D 空间中工作的，但是我们渲染的是一个 2D 三角形，所以我们可以将它顶点的 z 坐标设置为 0.0。这样子的话三角形每一点的**深度**都是一样的，从而使它看上去像是 2D 的。\n\n> PS：\n>\n> 深度通常可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。\n\n另外，没有特殊操作的情况下，W 轴默认都设置为 1.0。\n\n\n\n## 2. 顶点缓存对象（VBO）\n\n定义了上述顶点数据后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：**顶点着色器**。它会在 GPU 上创建内存用于储存我们的顶点数据。\n\n我们通过顶点缓存对象（Vertex Buffer Objects，**VBO**）管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓存对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。\n\n创建 VBO 的过程如下：\n\n```objc\nGLuint vertexBuffer;\nglGenBuffers(1, &vertexBuffer);\nglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n```\n\n和之前的其它对象一样，OpenGL ES 对象的创建离不开 Gen，Bin 操作。这里记住 VBO 的缓存类型是 **GL_ARRAY_BUFFER** 即可。\n\n这里着重介绍下 `glBufferData` 函数，它会把之前定义的顶点数据复制到缓存的内存中：\n\n它的原型如下：\n\n```c\nvoid GL_APIENTRY glBufferData (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);\n```\n\n- target：缓存类型，这里指定 GL_ARRAY_BUFFER。\n\n- size：传输数据的大小（以字节为单位）。直接通过 `sizeof(vertices)` 计算出顶点数据大小即可。\n\n- data：指向实际传输数据。\n\n- usage：指定我们希望显卡如何管理给定的数据。它有三种形式：\n\n  - GL_STATIC_DRAW ：数据不会或几乎不会改变。\n  - GL_DYNAMIC_DRAW：数据会被改变很多。\n  - GL_STREAM_DRAW ：数据每次绘制时都会改变。\n\n  三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓存中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW 或 GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。\n\n\n\n## 3. 着色器编写\n\n准备好顶点数据后，接下去需要做的就是着色器的编写。关于着色器相关的内容，这节不做过多的解释，下节会针对着色器做详细的介绍。\n\n顶点着色器：\n\n```c\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n```\n\n片段着色器：\n\n```c\nvarying lowp vec4 colorVarying;\n\nvoid main(void) {\n    gl_FragColor = colorVarying;\n}\n```\n\n着色器是用着色器语言 GLSL（OpenGL Shading Language）编写的，它看起来很像C语言。\n\n在本节中，我们需要简单的知道这几个概念就好了：\n\n- 顶点着色器每个顶点执行一次，片段着色器每个片段执行一次。\n- color，position 是变量，和我们自定义的顶点数据对应。\n- colorVarying，顶点着色器和片段着色器中相同的变量，它们是相对应的。\n- vec4 是参数类型，GLSL 内置的向量数据类型，这里我们用到的都是四元向量。\n- attribute，存储类型限定符，表示链接，链接 OpenGL ES 的每一个顶点数据到顶点着色器（一个一个地）。可以简单理解成输入顶点属性。这里我们将 color，position 传入顶点着色器。\n- varying，存储类型限定符，表示链接顶点着色器和片元着色器的内部数据。\n- 着色器由 main 函数开始执行，也可以自定义函数，和 C 都是一样的。\n- lowp，精度限定符。\n- gl_Position，内建变量，顶点着色器的输出值，而且是**必须要赋值**的变量。对 gl_Position 设置的值会成为该顶点着色器的输出。\n- gl_FragColor，和 gl_Position 一样，也是内建变量，对应片段的色值。\n\n理解完这几个概念，再看这两个着色器，就是设置对应顶点的位置和色值，再简单不过了。\n\n至此，你可能会有一些疑惑：\n\n**Q：着色器代码以什么形式存在？**\n\n**A：**创建的时候，是通过传入字符串来实现的。所以着色器代码可以通过任何形式存在，最后加载成 NSString 来使用。这里我们在 Xcode 里头，一般是 **New File —> Empty —> xx.vsh / xx.fsh**。然后在对应的文件里面添加代码。这样有个好处就是编辑起来有高亮，更直观。\n\n\n\n**Q：为什么传入的三个顶点色值是固定的，但是最终的效果却是渐变色？**\n\n**A：**这是因为 **varying** 变量存在**内插（interpolate）**的过程。\n\n之前提到过，varying 变量的作用是从顶点着色器向片段着色器传值，**但是值不是直接传递，会先进行内插**。\n\n所谓内插，就像补间动画一样。比如想要把一系列散点连成平滑曲线，相邻已知点之间缺少很多点，此时就需要通过内插填补缺少的数据，最终平滑曲线上除已知点之外的所有点都是插值得到的。\n\n同样的，三角形的三个角色值给定后，其它的片段则根据插值计算出来，也就呈现来渐变的效果。\n\n\n\n## 4. 编译着色器\n\n我们已经有了着色器源码，但是为了能够让 OpenGL ES 使用它，我们必须在运行时动态编译它的源码。具体代码如下：\n\n```objc\n- (GLuint)compileShader:(NSString *)shaderName withType:(GLenum)shaderType {\n    NSString *shaderPath = [[NSBundle mainBundle] pathForResource:shaderName ofType:nil];\n    NSError *error;\n    NSString *shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&error];\n    if (!shaderString) {\n        exit(1);\n    }\n    \n    const char* shaderStringUFT8 = [shaderString UTF8String];\n    int shaderStringLength = (int)[shaderString length];\n  \n    GLuint shaderHandle = glCreateShader(shaderType);\n    \n    glShaderSource(shaderHandle, 1, &shaderStringUFT8, &shaderStringLength);\n    glCompileShader(shaderHandle);\n    \n    GLint compileSuccess;\n    glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &compileSuccess);\n    if (compileSuccess == GL_FALSE) {\n        GLchar messages[256];\n        glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &messages[0]);\n        NSString *messageString = [NSString stringWithUTF8String:messages];\n        NSLog(@\"glGetShaderiv ShaderIngoLog: %@\", messageString);\n        exit(1);\n    }\n    \n    return shaderHandle;\n}\n```\n\n\n\n获取 **shaderStringUFT8** 的方式就不说明了，下面主要分析 OpenGL ES 相关 API 的调用情况：\n\n我们首先要做的是创建一个着色器对象，还是用 ID 来引用。所以我们储存这个顶点着色器为 `GLuint`，然后用 `glCreateShader` 创建这个着色器，它的原型如下：\n\n```c\nGLuint GL_APIENTRY glCreateShader (GLenum type);\n```\n\n- type：着色器类型，可选值有 **GL_VERTEX_SHADER** 和 **GL_FRAGMENT_SHADER**。\n\n下一步我们需要通过 `glShaderSource` 把着色器源码附加到着色器对象上，它的原型如下：\n\n```c\nvoid GL_APIENTRY glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint* length);\n```\n\n- shader：要编译的着色器对象。\n- count：传递的源码字符串数量，这里只有一个。\n- string：着色器真正的源码。\n- length：着色器源码的长度。\n\n最后，通过 `glCompileShader` 来编译着色器，它的原型如下：\n\n```c\nvoid GL_APIENTRY glCompileShader (GLuint shader);\n```\n\n- shader：待编译的着色器对象。\n\n至此，着色器的编译就完成了。\n\n但是，你可能希望知道在调用 `glCompileShader` 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修正它们。剩余的一部分代码，则是检测编译时是否发生了错误。\n\n首先定义一个变量 **compileSuccess** 来表示是否成功编译。然后用 `glGetShaderiv` 检查是否编译成功。如果编译失败，会用 `glGetShaderInfoLog` 获取错误消息，然后打印它。\n\n\n\n最后，在使用上，我们只需调用 `compileShader`，即可获得对应的着色器对象。\n\n```objc\nGLuint vertexShader = [self compileShader:@\"OpenGLESDemo.vsh\" withType:GL_VERTEX_SHADER];\nGLuint fragmentShader = [self compileShader:@\"OpenGLESDemo.fsh\" withType:GL_FRAGMENT_SHADER];\n```\n\n\n\n## 5. 着色器程序\n\n着色器程序对象（Shader Program Object）是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器，我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序（已激活着色器程序的着色器将在我们发送渲染调用的时候被使用）。\n\n> PS：\n>\n> 当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会得到一个链接错误。\n\n对应的具体代码如下：\n\n```objc\nGLuint programHandle = glCreateProgram();\nglAttachShader(programHandle, vertexShader);\nglAttachShader(programHandle, fragmentShader);\nglLinkProgram(programHandle);\n\nGLint linkSuccess;\nglGetProgramiv(programHandle, GL_LINK_STATUS, &linkSuccess);\nif (linkSuccess == GL_FALSE) {\n    GLchar messages[256];\n    glGetShaderInfoLog(programHandle, sizeof(messages), 0, &messages[0]);\n    NSString *messageString = [NSString stringWithUTF8String:messages];\n    NSLog(@\"glGetProgramiv ShaderIngoLog: %@\", messageString);\n    exit(1);\n}\n\nglUseProgram(programHandle);\n```\n\n创建一个着色器程序对象很简单，直接通过调用 `glCreateProgram` 函数即可，它会返回新创建着色器程序对象的 ID 引用。然后需要通过 `glAttachShader`，把之前编译好的着色器附加到着色器程序对象上。它的原型如下：\n\n```c\nvoid glAttachShader (GLuint program, GLuint shader);\n```\n\n- program：着色器程序对象。\n- shader：需要附加的着色器。\n\n然后用 `glLinkProgram` 链接它们，它的原型如下：\n\n```c\nvoid glLinkProgram (GLuint program);\n```\n\n- program：着色器程序对象。\n\n就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与之前不同，我们不会调用 `glGetShaderiv` 和 `glGetShaderInfoLog`，现在使用 `glGetProgramiv` 和 `glGetProgramInfoLog`，不再赘述。\n\n得到着色器程序对象后，我们可以调用 `glUseProgram` 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象。\n\n\n\n另外，在把着色器对象链接到着色器程序对象以后，不再需要它们，记得删除着色器对象，如下：\n\n```objc\nglDeleteShader(vertexShader);\nglDeleteShader(fragmentShader);\n```\n\n> PS：\n>\n> glDeleteShader 删除不再使用的着色器。如果当前着色器链接到一个程序对象上，那么这个着色器将不会被真正的删除，直到此着色器不再链接到任何程序对象。\n\n\n\n\n\n## 6. 链接顶点属性\n\n现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。但是，OpenGL ES 还不知道它该如何解析内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL ES 怎么做。\n\n我们传入的顶点数据 **vertices**，是这样排布的：\n\n![2017020171966DA004F9B-C0A7-44FE-B747-AA5BEC0ABCF5.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_3.png)\n\n\n\n从这个图上，我们可以很清晰知道我们的顶点数据是如何排布，每个字节对应哪些内容，但是 OpenGL ES 本身并不知道，我们应该告诉它如何解析这些顶点数据。\n\n首先，我们需要定义与着色器脚本相对应的变量，为了方便，可以直接使用枚举。\n\n```objc\nenum\n{\n    ATTRIBUTE_POSITION = 0,\n    ATTRIBUTE_COLOR,\n    NUM_ATTRIBUTES\n};\nGLint glViewAttributes[NUM_ATTRIBUTES];\n\n...\n  \nglViewAttributes[ATTRIBUTE_POSITION] = glGetAttribLocation(programHandle, \"position\");\nglViewAttributes[ATTRIBUTE_COLOR]  = glGetAttribLocation(programHandle, \"color\");\n\nglEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_POSITION]);\nglEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_COLOR]);\n```\n\n\n\n> PS：\n>\n> 通过 NUM_ATTRIBUTES，可以很方便拿到变量的个数。\n\n\n\n然后使用 `glGetAttribLocation`，来获得着色器变量的入口，使之绑定起来。它的原型如下：\n\n```c\nint GL_APIENTRY glGetAttribLocation (GLuint program, const GLchar* name);\n```\n\n- program：着色器程序对象\n- name：着色器中对应的变量名\n\n然后，使用 `glEnableVertexAttribArray` ，以顶点属性值作为参数，启用顶点属性（顶点属性默认是禁用的）。\n\n\n\n至此，顶点属性的绑定已经完成了，之后只需要在渲染的时候，为对应的顶点属性赋值即可。\n\n下面是对应的渲染代码，其中 **/////////** 包围的是本节新增的：\n\n```objc\n- (void)render {\n    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);\n    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);\n    glClearColor(0, 1, 1, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    //////////////////\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_POSITION], 4, GL_FLOAT, GL_FALSE, sizeof(CustomVertex), 0);\n    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_COLOR], 4, GL_FLOAT, GL_FALSE, sizeof(CustomVertex), (GLvoid *)(sizeof(float) * 4));\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n    //////////////////\n  \n    [_context presentRenderbuffer:GL_RENDERBUFFER];\n}\n```\n\n\n\n为了渲染图形，我们需要给定渲染区域（视见区域），即告诉 OpenGL ES 应把渲染之后的图形绘制在窗体的哪个部位。当视见区域是整个窗体时，OpenGL ES 将把渲染结果绘制到整个窗口。\n\n调用 `glViewPort` 函数来决定视见区域，它的原型如下：\n\n```c\nvoid glViewport (GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n- x，y：指定了视见区域的左下角在窗口中的位置。\n- width，height：指定了视见区域的宽度和高度。\n\n这里我们直接设置成窗口的大小即可。\n\n准备工作都完成后，有了这些信息我们就可以使用 glVertexAttribPointer 函数告诉 OpenGL ES 该如何解析顶点数据（应用到逐个顶点属性上）了，它的原型如下：\n\n```c\nvoid GL_APIENTRY glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr);\n```\n\n- indx：指定要配置的顶点属性。\n- size：指定顶点属性的大小（这里不管是位置还是色值，都是四元向量，所以是4）。\n- type：指定属性的类型，这里是 **GL_FLOAT** （GLSL中 `vec*` 都是由浮点数值组成的）。\n- normalized：指定是否希望数据被标准化（Normalize）。如果设置为 GL_TRUE，所有数据都会被映射到0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为GL_FALSE。\n- stride：步长（Stride），它告诉 OpenGL ES 连续的顶点数据组之间的间隔。如上图所示，每个顶点数据大小都是 32 字节（`sizeof(CustomVertex)`），即下组顶点数据数据在一个 `CustomVertex` 之后，所以我们把步长设置为 `sizeof(CustomVertex)`。\n- ptr：表示该属性在缓存中起始位置的偏移量（Offset）。如图，位置属性的偏移量是 0，而对于色值属性，它是紧挨着位置属性之后，所以它相对起始位置的偏移量，应该是一个位置属性的大小，即 16（sizeof(float) * 4）。另外，参数类型是 `GLvoid*`，所以需要进行这个奇怪的强制类型转换。\n\n至此，所有东西都已经设置好了：我们使用一个顶点缓存对象将顶点数据初始化至缓存中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL ES 如何把顶点数据链接到顶点着色器的顶点属性上。\n\n\n\n最后，要想渲染我们想要的图形，OpenGL ES 提供了 `glDrawArrays` 函数，它使用当前激活的着色器，之前定义的顶点属性配置，以及VBO的顶点数据来渲染图元。它的原型如下：\n\n```c\nvoid GL_APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);\n```\n\n- mode：指定渲染的 OpenGL ES 图元的类型。这里渲染的是一个三角形，所以传递 GL_TRIANGLES 给它。\n- first：指定了顶点数据的起始索引，这里为 0。\n- count：指定顶点个数，这里为 3。\n\n> PS：\n>\n> mode 的类型还有其他几种，应用于不同的场景，感兴趣的可以了解下～\n\n\n\n## 7. 测试，运行\n\n最后，在 setup 中添加如下代码：\n\n```objc\n[self compileShaders];\n[self setupVBOs];\n```\n\n\n\n运行，不出意外的话，你将会看到之前的三角形。\n\n\n\n最终的工程可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson03/OpenGLESDemo.zip)下载。下一节，将详细介绍 GLSL，一起期待吧～","source":"_posts/OpenGLES-Lesson03.md","raw":"title: OpenGL ES 渲染基本图元\n\ndate: 2017-04-18 18:25:12\n\ntags:\n\n- iOS开发\n- OpenGLES\n- 图像处理\n\n------\n\n在[上篇文章](http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/)中，已经介绍了 OpenGL ES 的基础环境搭建，并且实现了设置背景色功能。\n\n在本文中，我们将会在上文的基础上，渲染基本图元，三角形。在这个过程中，将会详细介绍可编程图形渲染管线是如何工作的。\n\n最终的效果如下：\n\n![2017013028167QQ20170130-174258@2x.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_1.png)\n\n<!--more-->\n\n## 0. 初始工程\n\n你可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip)下载到初始工程，避免重复实现一些和本节内容不相干的事情。\n\n这是上一节的最终工程，包含了 OpenGL ES 的基础环境搭建。\n\n> PS：\n>\n> 在之后的步骤里，如果你细心观察对比，你会发现其实它就是围绕图形渲染管线展开的，把之前介绍的内容，用代码的方式实现出来，具体流程可以参照下图回顾：![20170112148420103614414.jpg](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_2.jpg)\n\n\n\n## 1. 顶点数据\n\n开始渲染图形之前，我们必须先给 OpenGL ES 输入一些顶点数据。\n\n为了渲染一个如图所示的三角形，我们需要以数组的形式传递3个 3D 坐标（之前提到过，在 OpenGL 中，任何事物都在 **3D** 空间中）作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data），**顶点数据是一系列顶点的集合**。\n\n在这个简单的例子里，我们一共要指定三个顶点，每个顶点只由一个 3D 位置和一个颜色值组成。\n\n自定义顶点结构体如下：\n\n```objc\ntypedef struct\n{\n    float position[4]; // 3D 位置\n    float color[4];    // 颜色值\n} CustomVertex;\n```\n\n> PS：\n>\n> **Q：**这里的颜色值，用四维向量表示可以理解（RGBA），那么 3D 位置为什么也是四维向量（XYZW）呢（包含4个元素的数组表示的向量）？\n>\n> **A：** 3D 图形渲染过程中用到了 4x4 的矩阵（4行4列），矩阵乘法要求 nxm * mxp（n行m列 乘 m行p列）才能相乘，注意 m 是相同的，所以 1x4 * 4x4 才能相乘。\n>\n> The w in vec4(x, y, z, w) is used for clipping, and plays its part while linear algebra transformations are applied to the position.\n>\n> By default, this should be set to 1.0.\n>\n> **See here for some more info：**\n>\n> [http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html](http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html)\n\n\n\n针对此三角形，我们可以填充对应的数据如下：\n\n```objc\nstatic const CustomVertex vertices[] =\n{\n    { .position = { -1.0,  1.0, 0, 1 }, .color = { 1, 0, 0, 1 } },\n    { .position = { -1.0, -1.0, 0, 1 }, .color = { 0, 1, 0, 1 } },\n    { .position = {  1.0, -1.0, 0, 1 }, .color = { 0, 0, 1, 1 } }\n};\n```\n\n虽然 OpenGL 是在 3D 空间中工作的，但是我们渲染的是一个 2D 三角形，所以我们可以将它顶点的 z 坐标设置为 0.0。这样子的话三角形每一点的**深度**都是一样的，从而使它看上去像是 2D 的。\n\n> PS：\n>\n> 深度通常可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。\n\n另外，没有特殊操作的情况下，W 轴默认都设置为 1.0。\n\n\n\n## 2. 顶点缓存对象（VBO）\n\n定义了上述顶点数据后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：**顶点着色器**。它会在 GPU 上创建内存用于储存我们的顶点数据。\n\n我们通过顶点缓存对象（Vertex Buffer Objects，**VBO**）管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓存对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。\n\n创建 VBO 的过程如下：\n\n```objc\nGLuint vertexBuffer;\nglGenBuffers(1, &vertexBuffer);\nglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n```\n\n和之前的其它对象一样，OpenGL ES 对象的创建离不开 Gen，Bin 操作。这里记住 VBO 的缓存类型是 **GL_ARRAY_BUFFER** 即可。\n\n这里着重介绍下 `glBufferData` 函数，它会把之前定义的顶点数据复制到缓存的内存中：\n\n它的原型如下：\n\n```c\nvoid GL_APIENTRY glBufferData (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);\n```\n\n- target：缓存类型，这里指定 GL_ARRAY_BUFFER。\n\n- size：传输数据的大小（以字节为单位）。直接通过 `sizeof(vertices)` 计算出顶点数据大小即可。\n\n- data：指向实际传输数据。\n\n- usage：指定我们希望显卡如何管理给定的数据。它有三种形式：\n\n  - GL_STATIC_DRAW ：数据不会或几乎不会改变。\n  - GL_DYNAMIC_DRAW：数据会被改变很多。\n  - GL_STREAM_DRAW ：数据每次绘制时都会改变。\n\n  三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓存中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW 或 GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。\n\n\n\n## 3. 着色器编写\n\n准备好顶点数据后，接下去需要做的就是着色器的编写。关于着色器相关的内容，这节不做过多的解释，下节会针对着色器做详细的介绍。\n\n顶点着色器：\n\n```c\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n```\n\n片段着色器：\n\n```c\nvarying lowp vec4 colorVarying;\n\nvoid main(void) {\n    gl_FragColor = colorVarying;\n}\n```\n\n着色器是用着色器语言 GLSL（OpenGL Shading Language）编写的，它看起来很像C语言。\n\n在本节中，我们需要简单的知道这几个概念就好了：\n\n- 顶点着色器每个顶点执行一次，片段着色器每个片段执行一次。\n- color，position 是变量，和我们自定义的顶点数据对应。\n- colorVarying，顶点着色器和片段着色器中相同的变量，它们是相对应的。\n- vec4 是参数类型，GLSL 内置的向量数据类型，这里我们用到的都是四元向量。\n- attribute，存储类型限定符，表示链接，链接 OpenGL ES 的每一个顶点数据到顶点着色器（一个一个地）。可以简单理解成输入顶点属性。这里我们将 color，position 传入顶点着色器。\n- varying，存储类型限定符，表示链接顶点着色器和片元着色器的内部数据。\n- 着色器由 main 函数开始执行，也可以自定义函数，和 C 都是一样的。\n- lowp，精度限定符。\n- gl_Position，内建变量，顶点着色器的输出值，而且是**必须要赋值**的变量。对 gl_Position 设置的值会成为该顶点着色器的输出。\n- gl_FragColor，和 gl_Position 一样，也是内建变量，对应片段的色值。\n\n理解完这几个概念，再看这两个着色器，就是设置对应顶点的位置和色值，再简单不过了。\n\n至此，你可能会有一些疑惑：\n\n**Q：着色器代码以什么形式存在？**\n\n**A：**创建的时候，是通过传入字符串来实现的。所以着色器代码可以通过任何形式存在，最后加载成 NSString 来使用。这里我们在 Xcode 里头，一般是 **New File —> Empty —> xx.vsh / xx.fsh**。然后在对应的文件里面添加代码。这样有个好处就是编辑起来有高亮，更直观。\n\n\n\n**Q：为什么传入的三个顶点色值是固定的，但是最终的效果却是渐变色？**\n\n**A：**这是因为 **varying** 变量存在**内插（interpolate）**的过程。\n\n之前提到过，varying 变量的作用是从顶点着色器向片段着色器传值，**但是值不是直接传递，会先进行内插**。\n\n所谓内插，就像补间动画一样。比如想要把一系列散点连成平滑曲线，相邻已知点之间缺少很多点，此时就需要通过内插填补缺少的数据，最终平滑曲线上除已知点之外的所有点都是插值得到的。\n\n同样的，三角形的三个角色值给定后，其它的片段则根据插值计算出来，也就呈现来渐变的效果。\n\n\n\n## 4. 编译着色器\n\n我们已经有了着色器源码，但是为了能够让 OpenGL ES 使用它，我们必须在运行时动态编译它的源码。具体代码如下：\n\n```objc\n- (GLuint)compileShader:(NSString *)shaderName withType:(GLenum)shaderType {\n    NSString *shaderPath = [[NSBundle mainBundle] pathForResource:shaderName ofType:nil];\n    NSError *error;\n    NSString *shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&error];\n    if (!shaderString) {\n        exit(1);\n    }\n    \n    const char* shaderStringUFT8 = [shaderString UTF8String];\n    int shaderStringLength = (int)[shaderString length];\n  \n    GLuint shaderHandle = glCreateShader(shaderType);\n    \n    glShaderSource(shaderHandle, 1, &shaderStringUFT8, &shaderStringLength);\n    glCompileShader(shaderHandle);\n    \n    GLint compileSuccess;\n    glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &compileSuccess);\n    if (compileSuccess == GL_FALSE) {\n        GLchar messages[256];\n        glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &messages[0]);\n        NSString *messageString = [NSString stringWithUTF8String:messages];\n        NSLog(@\"glGetShaderiv ShaderIngoLog: %@\", messageString);\n        exit(1);\n    }\n    \n    return shaderHandle;\n}\n```\n\n\n\n获取 **shaderStringUFT8** 的方式就不说明了，下面主要分析 OpenGL ES 相关 API 的调用情况：\n\n我们首先要做的是创建一个着色器对象，还是用 ID 来引用。所以我们储存这个顶点着色器为 `GLuint`，然后用 `glCreateShader` 创建这个着色器，它的原型如下：\n\n```c\nGLuint GL_APIENTRY glCreateShader (GLenum type);\n```\n\n- type：着色器类型，可选值有 **GL_VERTEX_SHADER** 和 **GL_FRAGMENT_SHADER**。\n\n下一步我们需要通过 `glShaderSource` 把着色器源码附加到着色器对象上，它的原型如下：\n\n```c\nvoid GL_APIENTRY glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint* length);\n```\n\n- shader：要编译的着色器对象。\n- count：传递的源码字符串数量，这里只有一个。\n- string：着色器真正的源码。\n- length：着色器源码的长度。\n\n最后，通过 `glCompileShader` 来编译着色器，它的原型如下：\n\n```c\nvoid GL_APIENTRY glCompileShader (GLuint shader);\n```\n\n- shader：待编译的着色器对象。\n\n至此，着色器的编译就完成了。\n\n但是，你可能希望知道在调用 `glCompileShader` 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修正它们。剩余的一部分代码，则是检测编译时是否发生了错误。\n\n首先定义一个变量 **compileSuccess** 来表示是否成功编译。然后用 `glGetShaderiv` 检查是否编译成功。如果编译失败，会用 `glGetShaderInfoLog` 获取错误消息，然后打印它。\n\n\n\n最后，在使用上，我们只需调用 `compileShader`，即可获得对应的着色器对象。\n\n```objc\nGLuint vertexShader = [self compileShader:@\"OpenGLESDemo.vsh\" withType:GL_VERTEX_SHADER];\nGLuint fragmentShader = [self compileShader:@\"OpenGLESDemo.fsh\" withType:GL_FRAGMENT_SHADER];\n```\n\n\n\n## 5. 着色器程序\n\n着色器程序对象（Shader Program Object）是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器，我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序（已激活着色器程序的着色器将在我们发送渲染调用的时候被使用）。\n\n> PS：\n>\n> 当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会得到一个链接错误。\n\n对应的具体代码如下：\n\n```objc\nGLuint programHandle = glCreateProgram();\nglAttachShader(programHandle, vertexShader);\nglAttachShader(programHandle, fragmentShader);\nglLinkProgram(programHandle);\n\nGLint linkSuccess;\nglGetProgramiv(programHandle, GL_LINK_STATUS, &linkSuccess);\nif (linkSuccess == GL_FALSE) {\n    GLchar messages[256];\n    glGetShaderInfoLog(programHandle, sizeof(messages), 0, &messages[0]);\n    NSString *messageString = [NSString stringWithUTF8String:messages];\n    NSLog(@\"glGetProgramiv ShaderIngoLog: %@\", messageString);\n    exit(1);\n}\n\nglUseProgram(programHandle);\n```\n\n创建一个着色器程序对象很简单，直接通过调用 `glCreateProgram` 函数即可，它会返回新创建着色器程序对象的 ID 引用。然后需要通过 `glAttachShader`，把之前编译好的着色器附加到着色器程序对象上。它的原型如下：\n\n```c\nvoid glAttachShader (GLuint program, GLuint shader);\n```\n\n- program：着色器程序对象。\n- shader：需要附加的着色器。\n\n然后用 `glLinkProgram` 链接它们，它的原型如下：\n\n```c\nvoid glLinkProgram (GLuint program);\n```\n\n- program：着色器程序对象。\n\n就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与之前不同，我们不会调用 `glGetShaderiv` 和 `glGetShaderInfoLog`，现在使用 `glGetProgramiv` 和 `glGetProgramInfoLog`，不再赘述。\n\n得到着色器程序对象后，我们可以调用 `glUseProgram` 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象。\n\n\n\n另外，在把着色器对象链接到着色器程序对象以后，不再需要它们，记得删除着色器对象，如下：\n\n```objc\nglDeleteShader(vertexShader);\nglDeleteShader(fragmentShader);\n```\n\n> PS：\n>\n> glDeleteShader 删除不再使用的着色器。如果当前着色器链接到一个程序对象上，那么这个着色器将不会被真正的删除，直到此着色器不再链接到任何程序对象。\n\n\n\n\n\n## 6. 链接顶点属性\n\n现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。但是，OpenGL ES 还不知道它该如何解析内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL ES 怎么做。\n\n我们传入的顶点数据 **vertices**，是这样排布的：\n\n![2017020171966DA004F9B-C0A7-44FE-B747-AA5BEC0ABCF5.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_3.png)\n\n\n\n从这个图上，我们可以很清晰知道我们的顶点数据是如何排布，每个字节对应哪些内容，但是 OpenGL ES 本身并不知道，我们应该告诉它如何解析这些顶点数据。\n\n首先，我们需要定义与着色器脚本相对应的变量，为了方便，可以直接使用枚举。\n\n```objc\nenum\n{\n    ATTRIBUTE_POSITION = 0,\n    ATTRIBUTE_COLOR,\n    NUM_ATTRIBUTES\n};\nGLint glViewAttributes[NUM_ATTRIBUTES];\n\n...\n  \nglViewAttributes[ATTRIBUTE_POSITION] = glGetAttribLocation(programHandle, \"position\");\nglViewAttributes[ATTRIBUTE_COLOR]  = glGetAttribLocation(programHandle, \"color\");\n\nglEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_POSITION]);\nglEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_COLOR]);\n```\n\n\n\n> PS：\n>\n> 通过 NUM_ATTRIBUTES，可以很方便拿到变量的个数。\n\n\n\n然后使用 `glGetAttribLocation`，来获得着色器变量的入口，使之绑定起来。它的原型如下：\n\n```c\nint GL_APIENTRY glGetAttribLocation (GLuint program, const GLchar* name);\n```\n\n- program：着色器程序对象\n- name：着色器中对应的变量名\n\n然后，使用 `glEnableVertexAttribArray` ，以顶点属性值作为参数，启用顶点属性（顶点属性默认是禁用的）。\n\n\n\n至此，顶点属性的绑定已经完成了，之后只需要在渲染的时候，为对应的顶点属性赋值即可。\n\n下面是对应的渲染代码，其中 **/////////** 包围的是本节新增的：\n\n```objc\n- (void)render {\n    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);\n    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);\n    glClearColor(0, 1, 1, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    //////////////////\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_POSITION], 4, GL_FLOAT, GL_FALSE, sizeof(CustomVertex), 0);\n    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_COLOR], 4, GL_FLOAT, GL_FALSE, sizeof(CustomVertex), (GLvoid *)(sizeof(float) * 4));\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n    //////////////////\n  \n    [_context presentRenderbuffer:GL_RENDERBUFFER];\n}\n```\n\n\n\n为了渲染图形，我们需要给定渲染区域（视见区域），即告诉 OpenGL ES 应把渲染之后的图形绘制在窗体的哪个部位。当视见区域是整个窗体时，OpenGL ES 将把渲染结果绘制到整个窗口。\n\n调用 `glViewPort` 函数来决定视见区域，它的原型如下：\n\n```c\nvoid glViewport (GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n- x，y：指定了视见区域的左下角在窗口中的位置。\n- width，height：指定了视见区域的宽度和高度。\n\n这里我们直接设置成窗口的大小即可。\n\n准备工作都完成后，有了这些信息我们就可以使用 glVertexAttribPointer 函数告诉 OpenGL ES 该如何解析顶点数据（应用到逐个顶点属性上）了，它的原型如下：\n\n```c\nvoid GL_APIENTRY glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr);\n```\n\n- indx：指定要配置的顶点属性。\n- size：指定顶点属性的大小（这里不管是位置还是色值，都是四元向量，所以是4）。\n- type：指定属性的类型，这里是 **GL_FLOAT** （GLSL中 `vec*` 都是由浮点数值组成的）。\n- normalized：指定是否希望数据被标准化（Normalize）。如果设置为 GL_TRUE，所有数据都会被映射到0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为GL_FALSE。\n- stride：步长（Stride），它告诉 OpenGL ES 连续的顶点数据组之间的间隔。如上图所示，每个顶点数据大小都是 32 字节（`sizeof(CustomVertex)`），即下组顶点数据数据在一个 `CustomVertex` 之后，所以我们把步长设置为 `sizeof(CustomVertex)`。\n- ptr：表示该属性在缓存中起始位置的偏移量（Offset）。如图，位置属性的偏移量是 0，而对于色值属性，它是紧挨着位置属性之后，所以它相对起始位置的偏移量，应该是一个位置属性的大小，即 16（sizeof(float) * 4）。另外，参数类型是 `GLvoid*`，所以需要进行这个奇怪的强制类型转换。\n\n至此，所有东西都已经设置好了：我们使用一个顶点缓存对象将顶点数据初始化至缓存中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL ES 如何把顶点数据链接到顶点着色器的顶点属性上。\n\n\n\n最后，要想渲染我们想要的图形，OpenGL ES 提供了 `glDrawArrays` 函数，它使用当前激活的着色器，之前定义的顶点属性配置，以及VBO的顶点数据来渲染图元。它的原型如下：\n\n```c\nvoid GL_APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);\n```\n\n- mode：指定渲染的 OpenGL ES 图元的类型。这里渲染的是一个三角形，所以传递 GL_TRIANGLES 给它。\n- first：指定了顶点数据的起始索引，这里为 0。\n- count：指定顶点个数，这里为 3。\n\n> PS：\n>\n> mode 的类型还有其他几种，应用于不同的场景，感兴趣的可以了解下～\n\n\n\n## 7. 测试，运行\n\n最后，在 setup 中添加如下代码：\n\n```objc\n[self compileShaders];\n[self setupVBOs];\n```\n\n\n\n运行，不出意外的话，你将会看到之前的三角形。\n\n\n\n最终的工程可以从[这里](https://github.com/colin1994/OpenGLES/blob/master/Lesson03/OpenGLESDemo.zip)下载。下一节，将详细介绍 GLSL，一起期待吧～","slug":"OpenGLES-Lesson03","published":1,"updated":"2019-12-23T01:02:31.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1n4001zzwlnwmrtz0ri","content":"<p>在<a href=\"http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/\" target=\"_blank\" rel=\"external\">上篇文章</a>中，已经介绍了 OpenGL ES 的基础环境搭建，并且实现了设置背景色功能。</p>\n<p>在本文中，我们将会在上文的基础上，渲染基本图元，三角形。在这个过程中，将会详细介绍可编程图形渲染管线是如何工作的。</p>\n<p>最终的效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_1.png\" alt=\"2017013028167QQ20170130-174258@2x.png\"></p>\n<a id=\"more\"></a>\n<h2 id=\"0-_初始工程\">0. 初始工程</h2><p>你可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip\" target=\"_blank\" rel=\"external\">这里</a>下载到初始工程，避免重复实现一些和本节内容不相干的事情。</p>\n<p>这是上一节的最终工程，包含了 OpenGL ES 的基础环境搭建。</p>\n<blockquote>\n<p>PS：</p>\n<p>在之后的步骤里，如果你细心观察对比，你会发现其实它就是围绕图形渲染管线展开的，把之前介绍的内容，用代码的方式实现出来，具体流程可以参照下图回顾：<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_2.jpg\" alt=\"20170112148420103614414.jpg\"></p>\n</blockquote>\n<h2 id=\"1-_顶点数据\">1. 顶点数据</h2><p>开始渲染图形之前，我们必须先给 OpenGL ES 输入一些顶点数据。</p>\n<p>为了渲染一个如图所示的三角形，我们需要以数组的形式传递3个 3D 坐标（之前提到过，在 OpenGL 中，任何事物都在 <strong>3D</strong> 空间中）作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data），<strong>顶点数据是一系列顶点的集合</strong>。</p>\n<p>在这个简单的例子里，我们一共要指定三个顶点，每个顶点只由一个 3D 位置和一个颜色值组成。</p>\n<p>自定义顶点结构体如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> position[<span class=\"number\">4</span>]; <span class=\"comment\">// 3D 位置</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> color[<span class=\"number\">4</span>];    <span class=\"comment\">// 颜色值</span></span><br><span class=\"line\">&#125; CustomVertex;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p><strong>Q：</strong>这里的颜色值，用四维向量表示可以理解（RGBA），那么 3D 位置为什么也是四维向量（XYZW）呢（包含4个元素的数组表示的向量）？</p>\n<p><strong>A：</strong> 3D 图形渲染过程中用到了 4x4 的矩阵（4行4列），矩阵乘法要求 nxm <em> mxp（n行m列 乘 m行p列）才能相乘，注意 m 是相同的，所以 1x4 </em> 4x4 才能相乘。</p>\n<p>The w in vec4(x, y, z, w) is used for clipping, and plays its part while linear algebra transformations are applied to the position.</p>\n<p>By default, this should be set to 1.0.</p>\n<p><strong>See here for some more info：</strong></p>\n<p><a href=\"http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html\" target=\"_blank\" rel=\"external\">http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html</a></p>\n</blockquote>\n<p>针对此三角形，我们可以填充对应的数据如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> CustomVertex vertices[] =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123; .position = &#123; <span class=\"number\">-1.0</span>,  <span class=\"number\">1.0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;, .color = &#123; <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; .position = &#123; <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;, .color = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; .position = &#123;  <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;, .color = &#123; <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span> &#125; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>虽然 OpenGL 是在 3D 空间中工作的，但是我们渲染的是一个 2D 三角形，所以我们可以将它顶点的 z 坐标设置为 0.0。这样子的话三角形每一点的<strong>深度</strong>都是一样的，从而使它看上去像是 2D 的。</p>\n<blockquote>\n<p>PS：</p>\n<p>深度通常可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</p>\n</blockquote>\n<p>另外，没有特殊操作的情况下，W 轴默认都设置为 1.0。</p>\n<h2 id=\"2-_顶点缓存对象（VBO）\">2. 顶点缓存对象（VBO）</h2><p>定义了上述顶点数据后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：<strong>顶点着色器</strong>。它会在 GPU 上创建内存用于储存我们的顶点数据。</p>\n<p>我们通过顶点缓存对象（Vertex Buffer Objects，<strong>VBO</strong>）管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓存对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>\n<p>创建 VBO 的过程如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vertexBuffer;</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;vertexBuffer);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>\n<p>和之前的其它对象一样，OpenGL ES 对象的创建离不开 Gen，Bin 操作。这里记住 VBO 的缓存类型是 <strong>GL_ARRAY_BUFFER</strong> 即可。</p>\n<p>这里着重介绍下 <code>glBufferData</code> 函数，它会把之前定义的顶点数据复制到缓存的内存中：</p>\n<p>它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glBufferData</span> <span class=\"params\">(GLenum target, GLsizeiptr size, <span class=\"keyword\">const</span> GLvoid* data, GLenum usage)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>target：缓存类型，这里指定 GL_ARRAY_BUFFER。</p>\n</li>\n<li><p>size：传输数据的大小（以字节为单位）。直接通过 <code>sizeof(vertices)</code> 计算出顶点数据大小即可。</p>\n</li>\n<li><p>data：指向实际传输数据。</p>\n</li>\n<li><p>usage：指定我们希望显卡如何管理给定的数据。它有三种形式：</p>\n<ul>\n<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>\n<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>\n<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>\n</ul>\n<p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓存中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW 或 GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>\n</li>\n</ul>\n<h2 id=\"3-_着色器编写\">3. 着色器编写</h2><p>准备好顶点数据后，接下去需要做的就是着色器的编写。关于着色器相关的内容，这节不做过多的解释，下节会针对着色器做详细的介绍。</p>\n<p>顶点着色器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>片段着色器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    gl_FragColor = colorVarying;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>着色器是用着色器语言 GLSL（OpenGL Shading Language）编写的，它看起来很像C语言。</p>\n<p>在本节中，我们需要简单的知道这几个概念就好了：</p>\n<ul>\n<li>顶点着色器每个顶点执行一次，片段着色器每个片段执行一次。</li>\n<li>color，position 是变量，和我们自定义的顶点数据对应。</li>\n<li>colorVarying，顶点着色器和片段着色器中相同的变量，它们是相对应的。</li>\n<li>vec4 是参数类型，GLSL 内置的向量数据类型，这里我们用到的都是四元向量。</li>\n<li>attribute，存储类型限定符，表示链接，链接 OpenGL ES 的每一个顶点数据到顶点着色器（一个一个地）。可以简单理解成输入顶点属性。这里我们将 color，position 传入顶点着色器。</li>\n<li>varying，存储类型限定符，表示链接顶点着色器和片元着色器的内部数据。</li>\n<li>着色器由 main 函数开始执行，也可以自定义函数，和 C 都是一样的。</li>\n<li>lowp，精度限定符。</li>\n<li>gl_Position，内建变量，顶点着色器的输出值，而且是<strong>必须要赋值</strong>的变量。对 gl_Position 设置的值会成为该顶点着色器的输出。</li>\n<li>gl_FragColor，和 gl_Position 一样，也是内建变量，对应片段的色值。</li>\n</ul>\n<p>理解完这几个概念，再看这两个着色器，就是设置对应顶点的位置和色值，再简单不过了。</p>\n<p>至此，你可能会有一些疑惑：</p>\n<p><strong>Q：着色器代码以什么形式存在？</strong></p>\n<p><strong>A：</strong>创建的时候，是通过传入字符串来实现的。所以着色器代码可以通过任何形式存在，最后加载成 NSString 来使用。这里我们在 Xcode 里头，一般是 <strong>New File —&gt; Empty —&gt; xx.vsh / xx.fsh</strong>。然后在对应的文件里面添加代码。这样有个好处就是编辑起来有高亮，更直观。</p>\n<p><strong>Q：为什么传入的三个顶点色值是固定的，但是最终的效果却是渐变色？</strong></p>\n<p><strong>A：</strong>这是因为 <strong>varying</strong> 变量存在<strong>内插（interpolate）</strong>的过程。</p>\n<p>之前提到过，varying 变量的作用是从顶点着色器向片段着色器传值，<strong>但是值不是直接传递，会先进行内插</strong>。</p>\n<p>所谓内插，就像补间动画一样。比如想要把一系列散点连成平滑曲线，相邻已知点之间缺少很多点，此时就需要通过内插填补缺少的数据，最终平滑曲线上除已知点之外的所有点都是插值得到的。</p>\n<p>同样的，三角形的三个角色值给定后，其它的片段则根据插值计算出来，也就呈现来渐变的效果。</p>\n<h2 id=\"4-_编译着色器\">4. 编译着色器</h2><p>我们已经有了着色器源码，但是为了能够让 OpenGL ES 使用它，我们必须在运行时动态编译它的源码。具体代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (GLuint)compileShader:(<span class=\"built_in\">NSString</span> *)shaderName withType:(GLenum)shaderType &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderPath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:shaderName ofType:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderString = [<span class=\"built_in\">NSString</span> stringWithContentsOfFile:shaderPath encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shaderString) &#123;</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* shaderStringUFT8 = [shaderString UTF8String];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> shaderStringLength = (<span class=\"keyword\">int</span>)[shaderString length];</span><br><span class=\"line\">  </span><br><span class=\"line\">    GLuint shaderHandle = glCreateShader(shaderType);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glShaderSource(shaderHandle, <span class=\"number\">1</span>, &amp;shaderStringUFT8, &amp;shaderStringLength);</span><br><span class=\"line\">    glCompileShader(shaderHandle);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLint compileSuccess;</span><br><span class=\"line\">    glGetShaderiv(shaderHandle, GL_CO<span class=\"built_in\">MPILE_STATUS</span>, &amp;compileSuccess);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compileSuccess == GL_FALSE) &#123;</span><br><span class=\"line\">        GLchar messages[<span class=\"number\">256</span>];</span><br><span class=\"line\">        glGetShaderInfoLog(shaderHandle, <span class=\"keyword\">sizeof</span>(messages), <span class=\"number\">0</span>, &amp;messages[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *messageString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:messages];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"glGetShaderiv ShaderIngoLog: %@\"</span>, messageString);</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> shaderHandle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取 <strong>shaderStringUFT8</strong> 的方式就不说明了，下面主要分析 OpenGL ES 相关 API 的调用情况：</p>\n<p>我们首先要做的是创建一个着色器对象，还是用 ID 来引用。所以我们储存这个顶点着色器为 <code>GLuint</code>，然后用 <code>glCreateShader</code> 创建这个着色器，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">GLuint GL_APIENTRY <span class=\"title\">glCreateShader</span> <span class=\"params\">(GLenum type)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>type：着色器类型，可选值有 <strong>GL_VERTEX_SHADER</strong> 和 <strong>GL_FRAGMENT_SHADER</strong>。</li>\n</ul>\n<p>下一步我们需要通过 <code>glShaderSource</code> 把着色器源码附加到着色器对象上，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glShaderSource</span> <span class=\"params\">(GLuint shader, GLsizei count, <span class=\"keyword\">const</span> GLchar* <span class=\"keyword\">const</span> *<span class=\"built_in\">string</span>, <span class=\"keyword\">const</span> GLint* length)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>shader：要编译的着色器对象。</li>\n<li>count：传递的源码字符串数量，这里只有一个。</li>\n<li>string：着色器真正的源码。</li>\n<li>length：着色器源码的长度。</li>\n</ul>\n<p>最后，通过 <code>glCompileShader</code> 来编译着色器，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glCompileShader</span> <span class=\"params\">(GLuint shader)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>shader：待编译的着色器对象。</li>\n</ul>\n<p>至此，着色器的编译就完成了。</p>\n<p>但是，你可能希望知道在调用 <code>glCompileShader</code> 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修正它们。剩余的一部分代码，则是检测编译时是否发生了错误。</p>\n<p>首先定义一个变量 <strong>compileSuccess</strong> 来表示是否成功编译。然后用 <code>glGetShaderiv</code> 检查是否编译成功。如果编译失败，会用 <code>glGetShaderInfoLog</code> 获取错误消息，然后打印它。</p>\n<p>最后，在使用上，我们只需调用 <code>compileShader</code>，即可获得对应的着色器对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vertexShader = [<span class=\"keyword\">self</span> compileShader:<span class=\"string\">@\"OpenGLESDemo.vsh\"</span> withType:GL_VERTEX_SHADER];</span><br><span class=\"line\">GLuint fragmentShader = [<span class=\"keyword\">self</span> compileShader:<span class=\"string\">@\"OpenGLESDemo.fsh\"</span> withType:GL_FRAGMENT_SHADER];</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-_着色器程序\">5. 着色器程序</h2><p>着色器程序对象（Shader Program Object）是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器，我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序（已激活着色器程序的着色器将在我们发送渲染调用的时候被使用）。</p>\n<blockquote>\n<p>PS：</p>\n<p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会得到一个链接错误。</p>\n</blockquote>\n<p>对应的具体代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint programHandle = glCreateProgram();</span><br><span class=\"line\">glAttachShader(programHandle, vertexShader);</span><br><span class=\"line\">glAttachShader(programHandle, fragmentShader);</span><br><span class=\"line\">glLinkProgram(programHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">GLint linkSuccess;</span><br><span class=\"line\">glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkSuccess);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (linkSuccess == GL_FALSE) &#123;</span><br><span class=\"line\">    GLchar messages[<span class=\"number\">256</span>];</span><br><span class=\"line\">    glGetShaderInfoLog(programHandle, <span class=\"keyword\">sizeof</span>(messages), <span class=\"number\">0</span>, &amp;messages[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *messageString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:messages];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"glGetProgramiv ShaderIngoLog: %@\"</span>, messageString);</span><br><span class=\"line\">    exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">glUseProgram(programHandle);</span><br></pre></td></tr></table></figure>\n<p>创建一个着色器程序对象很简单，直接通过调用 <code>glCreateProgram</code> 函数即可，它会返回新创建着色器程序对象的 ID 引用。然后需要通过 <code>glAttachShader</code>，把之前编译好的着色器附加到着色器程序对象上。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glAttachShader</span> <span class=\"params\">(GLuint program, GLuint shader)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>program：着色器程序对象。</li>\n<li>shader：需要附加的着色器。</li>\n</ul>\n<p>然后用 <code>glLinkProgram</code> 链接它们，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glLinkProgram</span> <span class=\"params\">(GLuint program)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>program：着色器程序对象。</li>\n</ul>\n<p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与之前不同，我们不会调用 <code>glGetShaderiv</code> 和 <code>glGetShaderInfoLog</code>，现在使用 <code>glGetProgramiv</code> 和 <code>glGetProgramInfoLog</code>，不再赘述。</p>\n<p>得到着色器程序对象后，我们可以调用 <code>glUseProgram</code> 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象。</p>\n<p>另外，在把着色器对象链接到着色器程序对象以后，不再需要它们，记得删除着色器对象，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDeleteShader(vertexShader);</span><br><span class=\"line\">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>glDeleteShader 删除不再使用的着色器。如果当前着色器链接到一个程序对象上，那么这个着色器将不会被真正的删除，直到此着色器不再链接到任何程序对象。</p>\n</blockquote>\n<h2 id=\"6-_链接顶点属性\">6. 链接顶点属性</h2><p>现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。但是，OpenGL ES 还不知道它该如何解析内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL ES 怎么做。</p>\n<p>我们传入的顶点数据 <strong>vertices</strong>，是这样排布的：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_3.png\" alt=\"2017020171966DA004F9B-C0A7-44FE-B747-AA5BEC0ABCF5.png\"></p>\n<p>从这个图上，我们可以很清晰知道我们的顶点数据是如何排布，每个字节对应哪些内容，但是 OpenGL ES 本身并不知道，我们应该告诉它如何解析这些顶点数据。</p>\n<p>首先，我们需要定义与着色器脚本相对应的变量，为了方便，可以直接使用枚举。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ATTRIBUTE_POSITION = <span class=\"number\">0</span>,</span><br><span class=\"line\">    ATTRIBUTE_COLOR,</span><br><span class=\"line\">    NUM_ATTRIBUTES</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLint glViewAttributes[NUM_ATTRIBUTES];</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">  </span><br><span class=\"line\">glViewAttributes[ATTRIBUTE_POSITION] = glGetAttribLocation(programHandle, <span class=\"string\">\"position\"</span>);</span><br><span class=\"line\">glViewAttributes[ATTRIBUTE_COLOR]  = glGetAttribLocation(programHandle, <span class=\"string\">\"color\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_POSITION]);</span><br><span class=\"line\">glEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_COLOR]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>通过 NUM_ATTRIBUTES，可以很方便拿到变量的个数。</p>\n</blockquote>\n<p>然后使用 <code>glGetAttribLocation</code>，来获得着色器变量的入口，使之绑定起来。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> GL_APIENTRY <span class=\"title\">glGetAttribLocation</span> <span class=\"params\">(GLuint program, <span class=\"keyword\">const</span> GLchar* name)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>program：着色器程序对象</li>\n<li>name：着色器中对应的变量名</li>\n</ul>\n<p>然后，使用 <code>glEnableVertexAttribArray</code> ，以顶点属性值作为参数，启用顶点属性（顶点属性默认是禁用的）。</p>\n<p>至此，顶点属性的绑定已经完成了，之后只需要在渲染的时候，为对应的顶点属性赋值即可。</p>\n<p>下面是对应的渲染代码，其中 <strong>/////////</strong> 包围的是本节新增的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)render &#123;</span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//////////////////</span></span><br><span class=\"line\">    glViewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.frame.size.width, <span class=\"keyword\">self</span>.frame.size.height);</span><br><span class=\"line\">    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_POSITION], <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(CustomVertex), <span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_COLOR], <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(CustomVertex), (GLvoid *)(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>) * <span class=\"number\">4</span>));</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"comment\">//////////////////</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了渲染图形，我们需要给定渲染区域（视见区域），即告诉 OpenGL ES 应把渲染之后的图形绘制在窗体的哪个部位。当视见区域是整个窗体时，OpenGL ES 将把渲染结果绘制到整个窗口。</p>\n<p>调用 <code>glViewPort</code> 函数来决定视见区域，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glViewport</span> <span class=\"params\">(GLint x, GLint y, GLsizei width, GLsizei height)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>x，y：指定了视见区域的左下角在窗口中的位置。</li>\n<li>width，height：指定了视见区域的宽度和高度。</li>\n</ul>\n<p>这里我们直接设置成窗口的大小即可。</p>\n<p>准备工作都完成后，有了这些信息我们就可以使用 glVertexAttribPointer 函数告诉 OpenGL ES 该如何解析顶点数据（应用到逐个顶点属性上）了，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glVertexAttribPointer</span> <span class=\"params\">(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, <span class=\"keyword\">const</span> GLvoid* ptr)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>indx：指定要配置的顶点属性。</li>\n<li>size：指定顶点属性的大小（这里不管是位置还是色值，都是四元向量，所以是4）。</li>\n<li>type：指定属性的类型，这里是 <strong>GL_FLOAT</strong> （GLSL中 <code>vec*</code> 都是由浮点数值组成的）。</li>\n<li>normalized：指定是否希望数据被标准化（Normalize）。如果设置为 GL_TRUE，所有数据都会被映射到0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为GL_FALSE。</li>\n<li>stride：步长（Stride），它告诉 OpenGL ES 连续的顶点数据组之间的间隔。如上图所示，每个顶点数据大小都是 32 字节（<code>sizeof(CustomVertex)</code>），即下组顶点数据数据在一个 <code>CustomVertex</code> 之后，所以我们把步长设置为 <code>sizeof(CustomVertex)</code>。</li>\n<li>ptr：表示该属性在缓存中起始位置的偏移量（Offset）。如图，位置属性的偏移量是 0，而对于色值属性，它是紧挨着位置属性之后，所以它相对起始位置的偏移量，应该是一个位置属性的大小，即 16（sizeof(float) <em> 4）。另外，参数类型是 `GLvoid</em>`，所以需要进行这个奇怪的强制类型转换。</li>\n</ul>\n<p>至此，所有东西都已经设置好了：我们使用一个顶点缓存对象将顶点数据初始化至缓存中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL ES 如何把顶点数据链接到顶点着色器的顶点属性上。</p>\n<p>最后，要想渲染我们想要的图形，OpenGL ES 提供了 <code>glDrawArrays</code> 函数，它使用当前激活的着色器，之前定义的顶点属性配置，以及VBO的顶点数据来渲染图元。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glDrawArrays</span> <span class=\"params\">(GLenum mode, GLint first, GLsizei count)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>mode：指定渲染的 OpenGL ES 图元的类型。这里渲染的是一个三角形，所以传递 GL_TRIANGLES 给它。</li>\n<li>first：指定了顶点数据的起始索引，这里为 0。</li>\n<li>count：指定顶点个数，这里为 3。</li>\n</ul>\n<blockquote>\n<p>PS：</p>\n<p>mode 的类型还有其他几种，应用于不同的场景，感兴趣的可以了解下～</p>\n</blockquote>\n<h2 id=\"7-_测试，运行\">7. 测试，运行</h2><p>最后，在 setup 中添加如下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> compileShaders];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setupVBOs];</span><br></pre></td></tr></table></figure>\n<p>运行，不出意外的话，你将会看到之前的三角形。</p>\n<p>最终的工程可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson03/OpenGLESDemo.zip\" target=\"_blank\" rel=\"external\">这里</a>下载。下一节，将详细介绍 GLSL，一起期待吧～</p>\n","excerpt":"<p>在<a href=\"http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/\">上篇文章</a>中，已经介绍了 OpenGL ES 的基础环境搭建，并且实现了设置背景色功能。</p>\n<p>在本文中，我们将会在上文的基础上，渲染基本图元，三角形。在这个过程中，将会详细介绍可编程图形渲染管线是如何工作的。</p>\n<p>最终的效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_1.png\" alt=\"2017013028167QQ20170130-174258@2x.png\"></p>","more":"<h2 id=\"0-_初始工程\">0. 初始工程</h2><p>你可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip\">这里</a>下载到初始工程，避免重复实现一些和本节内容不相干的事情。</p>\n<p>这是上一节的最终工程，包含了 OpenGL ES 的基础环境搭建。</p>\n<blockquote>\n<p>PS：</p>\n<p>在之后的步骤里，如果你细心观察对比，你会发现其实它就是围绕图形渲染管线展开的，把之前介绍的内容，用代码的方式实现出来，具体流程可以参照下图回顾：<img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_2.jpg\" alt=\"20170112148420103614414.jpg\"></p>\n</blockquote>\n<h2 id=\"1-_顶点数据\">1. 顶点数据</h2><p>开始渲染图形之前，我们必须先给 OpenGL ES 输入一些顶点数据。</p>\n<p>为了渲染一个如图所示的三角形，我们需要以数组的形式传递3个 3D 坐标（之前提到过，在 OpenGL 中，任何事物都在 <strong>3D</strong> 空间中）作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data），<strong>顶点数据是一系列顶点的集合</strong>。</p>\n<p>在这个简单的例子里，我们一共要指定三个顶点，每个顶点只由一个 3D 位置和一个颜色值组成。</p>\n<p>自定义顶点结构体如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> position[<span class=\"number\">4</span>]; <span class=\"comment\">// 3D 位置</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> color[<span class=\"number\">4</span>];    <span class=\"comment\">// 颜色值</span></span><br><span class=\"line\">&#125; CustomVertex;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p><strong>Q：</strong>这里的颜色值，用四维向量表示可以理解（RGBA），那么 3D 位置为什么也是四维向量（XYZW）呢（包含4个元素的数组表示的向量）？</p>\n<p><strong>A：</strong> 3D 图形渲染过程中用到了 4x4 的矩阵（4行4列），矩阵乘法要求 nxm <em> mxp（n行m列 乘 m行p列）才能相乘，注意 m 是相同的，所以 1x4 </em> 4x4 才能相乘。</p>\n<p>The w in vec4(x, y, z, w) is used for clipping, and plays its part while linear algebra transformations are applied to the position.</p>\n<p>By default, this should be set to 1.0.</p>\n<p><strong>See here for some more info：</strong></p>\n<p><a href=\"http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html\">http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html</a></p>\n</blockquote>\n<p>针对此三角形，我们可以填充对应的数据如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> CustomVertex vertices[] =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123; .position = &#123; <span class=\"number\">-1.0</span>,  <span class=\"number\">1.0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;, .color = &#123; <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; .position = &#123; <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;, .color = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; .position = &#123;  <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;, .color = &#123; <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span> &#125; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>虽然 OpenGL 是在 3D 空间中工作的，但是我们渲染的是一个 2D 三角形，所以我们可以将它顶点的 z 坐标设置为 0.0。这样子的话三角形每一点的<strong>深度</strong>都是一样的，从而使它看上去像是 2D 的。</p>\n<blockquote>\n<p>PS：</p>\n<p>深度通常可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</p>\n</blockquote>\n<p>另外，没有特殊操作的情况下，W 轴默认都设置为 1.0。</p>\n<h2 id=\"2-_顶点缓存对象（VBO）\">2. 顶点缓存对象（VBO）</h2><p>定义了上述顶点数据后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：<strong>顶点着色器</strong>。它会在 GPU 上创建内存用于储存我们的顶点数据。</p>\n<p>我们通过顶点缓存对象（Vertex Buffer Objects，<strong>VBO</strong>）管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓存对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>\n<p>创建 VBO 的过程如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vertexBuffer;</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;vertexBuffer);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>\n<p>和之前的其它对象一样，OpenGL ES 对象的创建离不开 Gen，Bin 操作。这里记住 VBO 的缓存类型是 <strong>GL_ARRAY_BUFFER</strong> 即可。</p>\n<p>这里着重介绍下 <code>glBufferData</code> 函数，它会把之前定义的顶点数据复制到缓存的内存中：</p>\n<p>它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glBufferData</span> <span class=\"params\">(GLenum target, GLsizeiptr size, <span class=\"keyword\">const</span> GLvoid* data, GLenum usage)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>target：缓存类型，这里指定 GL_ARRAY_BUFFER。</p>\n</li>\n<li><p>size：传输数据的大小（以字节为单位）。直接通过 <code>sizeof(vertices)</code> 计算出顶点数据大小即可。</p>\n</li>\n<li><p>data：指向实际传输数据。</p>\n</li>\n<li><p>usage：指定我们希望显卡如何管理给定的数据。它有三种形式：</p>\n<ul>\n<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>\n<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>\n<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>\n</ul>\n<p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓存中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW 或 GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>\n</li>\n</ul>\n<h2 id=\"3-_着色器编写\">3. 着色器编写</h2><p>准备好顶点数据后，接下去需要做的就是着色器的编写。关于着色器相关的内容，这节不做过多的解释，下节会针对着色器做详细的介绍。</p>\n<p>顶点着色器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>片段着色器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    gl_FragColor = colorVarying;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>着色器是用着色器语言 GLSL（OpenGL Shading Language）编写的，它看起来很像C语言。</p>\n<p>在本节中，我们需要简单的知道这几个概念就好了：</p>\n<ul>\n<li>顶点着色器每个顶点执行一次，片段着色器每个片段执行一次。</li>\n<li>color，position 是变量，和我们自定义的顶点数据对应。</li>\n<li>colorVarying，顶点着色器和片段着色器中相同的变量，它们是相对应的。</li>\n<li>vec4 是参数类型，GLSL 内置的向量数据类型，这里我们用到的都是四元向量。</li>\n<li>attribute，存储类型限定符，表示链接，链接 OpenGL ES 的每一个顶点数据到顶点着色器（一个一个地）。可以简单理解成输入顶点属性。这里我们将 color，position 传入顶点着色器。</li>\n<li>varying，存储类型限定符，表示链接顶点着色器和片元着色器的内部数据。</li>\n<li>着色器由 main 函数开始执行，也可以自定义函数，和 C 都是一样的。</li>\n<li>lowp，精度限定符。</li>\n<li>gl_Position，内建变量，顶点着色器的输出值，而且是<strong>必须要赋值</strong>的变量。对 gl_Position 设置的值会成为该顶点着色器的输出。</li>\n<li>gl_FragColor，和 gl_Position 一样，也是内建变量，对应片段的色值。</li>\n</ul>\n<p>理解完这几个概念，再看这两个着色器，就是设置对应顶点的位置和色值，再简单不过了。</p>\n<p>至此，你可能会有一些疑惑：</p>\n<p><strong>Q：着色器代码以什么形式存在？</strong></p>\n<p><strong>A：</strong>创建的时候，是通过传入字符串来实现的。所以着色器代码可以通过任何形式存在，最后加载成 NSString 来使用。这里我们在 Xcode 里头，一般是 <strong>New File —&gt; Empty —&gt; xx.vsh / xx.fsh</strong>。然后在对应的文件里面添加代码。这样有个好处就是编辑起来有高亮，更直观。</p>\n<p><strong>Q：为什么传入的三个顶点色值是固定的，但是最终的效果却是渐变色？</strong></p>\n<p><strong>A：</strong>这是因为 <strong>varying</strong> 变量存在<strong>内插（interpolate）</strong>的过程。</p>\n<p>之前提到过，varying 变量的作用是从顶点着色器向片段着色器传值，<strong>但是值不是直接传递，会先进行内插</strong>。</p>\n<p>所谓内插，就像补间动画一样。比如想要把一系列散点连成平滑曲线，相邻已知点之间缺少很多点，此时就需要通过内插填补缺少的数据，最终平滑曲线上除已知点之外的所有点都是插值得到的。</p>\n<p>同样的，三角形的三个角色值给定后，其它的片段则根据插值计算出来，也就呈现来渐变的效果。</p>\n<h2 id=\"4-_编译着色器\">4. 编译着色器</h2><p>我们已经有了着色器源码，但是为了能够让 OpenGL ES 使用它，我们必须在运行时动态编译它的源码。具体代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (GLuint)compileShader:(<span class=\"built_in\">NSString</span> *)shaderName withType:(GLenum)shaderType &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderPath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:shaderName ofType:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderString = [<span class=\"built_in\">NSString</span> stringWithContentsOfFile:shaderPath encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shaderString) &#123;</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* shaderStringUFT8 = [shaderString UTF8String];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> shaderStringLength = (<span class=\"keyword\">int</span>)[shaderString length];</span><br><span class=\"line\">  </span><br><span class=\"line\">    GLuint shaderHandle = glCreateShader(shaderType);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glShaderSource(shaderHandle, <span class=\"number\">1</span>, &amp;shaderStringUFT8, &amp;shaderStringLength);</span><br><span class=\"line\">    glCompileShader(shaderHandle);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLint compileSuccess;</span><br><span class=\"line\">    glGetShaderiv(shaderHandle, GL_CO<span class=\"built_in\">MPILE_STATUS</span>, &amp;compileSuccess);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compileSuccess == GL_FALSE) &#123;</span><br><span class=\"line\">        GLchar messages[<span class=\"number\">256</span>];</span><br><span class=\"line\">        glGetShaderInfoLog(shaderHandle, <span class=\"keyword\">sizeof</span>(messages), <span class=\"number\">0</span>, &amp;messages[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *messageString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:messages];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"glGetShaderiv ShaderIngoLog: %@\"</span>, messageString);</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> shaderHandle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取 <strong>shaderStringUFT8</strong> 的方式就不说明了，下面主要分析 OpenGL ES 相关 API 的调用情况：</p>\n<p>我们首先要做的是创建一个着色器对象，还是用 ID 来引用。所以我们储存这个顶点着色器为 <code>GLuint</code>，然后用 <code>glCreateShader</code> 创建这个着色器，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">GLuint GL_APIENTRY <span class=\"title\">glCreateShader</span> <span class=\"params\">(GLenum type)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>type：着色器类型，可选值有 <strong>GL_VERTEX_SHADER</strong> 和 <strong>GL_FRAGMENT_SHADER</strong>。</li>\n</ul>\n<p>下一步我们需要通过 <code>glShaderSource</code> 把着色器源码附加到着色器对象上，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glShaderSource</span> <span class=\"params\">(GLuint shader, GLsizei count, <span class=\"keyword\">const</span> GLchar* <span class=\"keyword\">const</span> *<span class=\"built_in\">string</span>, <span class=\"keyword\">const</span> GLint* length)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>shader：要编译的着色器对象。</li>\n<li>count：传递的源码字符串数量，这里只有一个。</li>\n<li>string：着色器真正的源码。</li>\n<li>length：着色器源码的长度。</li>\n</ul>\n<p>最后，通过 <code>glCompileShader</code> 来编译着色器，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glCompileShader</span> <span class=\"params\">(GLuint shader)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>shader：待编译的着色器对象。</li>\n</ul>\n<p>至此，着色器的编译就完成了。</p>\n<p>但是，你可能希望知道在调用 <code>glCompileShader</code> 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修正它们。剩余的一部分代码，则是检测编译时是否发生了错误。</p>\n<p>首先定义一个变量 <strong>compileSuccess</strong> 来表示是否成功编译。然后用 <code>glGetShaderiv</code> 检查是否编译成功。如果编译失败，会用 <code>glGetShaderInfoLog</code> 获取错误消息，然后打印它。</p>\n<p>最后，在使用上，我们只需调用 <code>compileShader</code>，即可获得对应的着色器对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vertexShader = [<span class=\"keyword\">self</span> compileShader:<span class=\"string\">@\"OpenGLESDemo.vsh\"</span> withType:GL_VERTEX_SHADER];</span><br><span class=\"line\">GLuint fragmentShader = [<span class=\"keyword\">self</span> compileShader:<span class=\"string\">@\"OpenGLESDemo.fsh\"</span> withType:GL_FRAGMENT_SHADER];</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-_着色器程序\">5. 着色器程序</h2><p>着色器程序对象（Shader Program Object）是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器，我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序（已激活着色器程序的着色器将在我们发送渲染调用的时候被使用）。</p>\n<blockquote>\n<p>PS：</p>\n<p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会得到一个链接错误。</p>\n</blockquote>\n<p>对应的具体代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint programHandle = glCreateProgram();</span><br><span class=\"line\">glAttachShader(programHandle, vertexShader);</span><br><span class=\"line\">glAttachShader(programHandle, fragmentShader);</span><br><span class=\"line\">glLinkProgram(programHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">GLint linkSuccess;</span><br><span class=\"line\">glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkSuccess);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (linkSuccess == GL_FALSE) &#123;</span><br><span class=\"line\">    GLchar messages[<span class=\"number\">256</span>];</span><br><span class=\"line\">    glGetShaderInfoLog(programHandle, <span class=\"keyword\">sizeof</span>(messages), <span class=\"number\">0</span>, &amp;messages[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *messageString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:messages];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"glGetProgramiv ShaderIngoLog: %@\"</span>, messageString);</span><br><span class=\"line\">    exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">glUseProgram(programHandle);</span><br></pre></td></tr></table></figure>\n<p>创建一个着色器程序对象很简单，直接通过调用 <code>glCreateProgram</code> 函数即可，它会返回新创建着色器程序对象的 ID 引用。然后需要通过 <code>glAttachShader</code>，把之前编译好的着色器附加到着色器程序对象上。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glAttachShader</span> <span class=\"params\">(GLuint program, GLuint shader)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>program：着色器程序对象。</li>\n<li>shader：需要附加的着色器。</li>\n</ul>\n<p>然后用 <code>glLinkProgram</code> 链接它们，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glLinkProgram</span> <span class=\"params\">(GLuint program)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>program：着色器程序对象。</li>\n</ul>\n<p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与之前不同，我们不会调用 <code>glGetShaderiv</code> 和 <code>glGetShaderInfoLog</code>，现在使用 <code>glGetProgramiv</code> 和 <code>glGetProgramInfoLog</code>，不再赘述。</p>\n<p>得到着色器程序对象后，我们可以调用 <code>glUseProgram</code> 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象。</p>\n<p>另外，在把着色器对象链接到着色器程序对象以后，不再需要它们，记得删除着色器对象，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDeleteShader(vertexShader);</span><br><span class=\"line\">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>glDeleteShader 删除不再使用的着色器。如果当前着色器链接到一个程序对象上，那么这个着色器将不会被真正的删除，直到此着色器不再链接到任何程序对象。</p>\n</blockquote>\n<h2 id=\"6-_链接顶点属性\">6. 链接顶点属性</h2><p>现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。但是，OpenGL ES 还不知道它该如何解析内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL ES 怎么做。</p>\n<p>我们传入的顶点数据 <strong>vertices</strong>，是这样排布的：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/OpenGLES/image_4_3.png\" alt=\"2017020171966DA004F9B-C0A7-44FE-B747-AA5BEC0ABCF5.png\"></p>\n<p>从这个图上，我们可以很清晰知道我们的顶点数据是如何排布，每个字节对应哪些内容，但是 OpenGL ES 本身并不知道，我们应该告诉它如何解析这些顶点数据。</p>\n<p>首先，我们需要定义与着色器脚本相对应的变量，为了方便，可以直接使用枚举。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ATTRIBUTE_POSITION = <span class=\"number\">0</span>,</span><br><span class=\"line\">    ATTRIBUTE_COLOR,</span><br><span class=\"line\">    NUM_ATTRIBUTES</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLint glViewAttributes[NUM_ATTRIBUTES];</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">  </span><br><span class=\"line\">glViewAttributes[ATTRIBUTE_POSITION] = glGetAttribLocation(programHandle, <span class=\"string\">\"position\"</span>);</span><br><span class=\"line\">glViewAttributes[ATTRIBUTE_COLOR]  = glGetAttribLocation(programHandle, <span class=\"string\">\"color\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_POSITION]);</span><br><span class=\"line\">glEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_COLOR]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>通过 NUM_ATTRIBUTES，可以很方便拿到变量的个数。</p>\n</blockquote>\n<p>然后使用 <code>glGetAttribLocation</code>，来获得着色器变量的入口，使之绑定起来。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> GL_APIENTRY <span class=\"title\">glGetAttribLocation</span> <span class=\"params\">(GLuint program, <span class=\"keyword\">const</span> GLchar* name)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>program：着色器程序对象</li>\n<li>name：着色器中对应的变量名</li>\n</ul>\n<p>然后，使用 <code>glEnableVertexAttribArray</code> ，以顶点属性值作为参数，启用顶点属性（顶点属性默认是禁用的）。</p>\n<p>至此，顶点属性的绑定已经完成了，之后只需要在渲染的时候，为对应的顶点属性赋值即可。</p>\n<p>下面是对应的渲染代码，其中 <strong>/////////</strong> 包围的是本节新增的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)render &#123;</span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//////////////////</span></span><br><span class=\"line\">    glViewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.frame.size.width, <span class=\"keyword\">self</span>.frame.size.height);</span><br><span class=\"line\">    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_POSITION], <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(CustomVertex), <span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_COLOR], <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(CustomVertex), (GLvoid *)(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>) * <span class=\"number\">4</span>));</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"comment\">//////////////////</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了渲染图形，我们需要给定渲染区域（视见区域），即告诉 OpenGL ES 应把渲染之后的图形绘制在窗体的哪个部位。当视见区域是整个窗体时，OpenGL ES 将把渲染结果绘制到整个窗口。</p>\n<p>调用 <code>glViewPort</code> 函数来决定视见区域，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glViewport</span> <span class=\"params\">(GLint x, GLint y, GLsizei width, GLsizei height)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>x，y：指定了视见区域的左下角在窗口中的位置。</li>\n<li>width，height：指定了视见区域的宽度和高度。</li>\n</ul>\n<p>这里我们直接设置成窗口的大小即可。</p>\n<p>准备工作都完成后，有了这些信息我们就可以使用 glVertexAttribPointer 函数告诉 OpenGL ES 该如何解析顶点数据（应用到逐个顶点属性上）了，它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glVertexAttribPointer</span> <span class=\"params\">(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, <span class=\"keyword\">const</span> GLvoid* ptr)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>indx：指定要配置的顶点属性。</li>\n<li>size：指定顶点属性的大小（这里不管是位置还是色值，都是四元向量，所以是4）。</li>\n<li>type：指定属性的类型，这里是 <strong>GL_FLOAT</strong> （GLSL中 <code>vec*</code> 都是由浮点数值组成的）。</li>\n<li>normalized：指定是否希望数据被标准化（Normalize）。如果设置为 GL_TRUE，所有数据都会被映射到0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为GL_FALSE。</li>\n<li>stride：步长（Stride），它告诉 OpenGL ES 连续的顶点数据组之间的间隔。如上图所示，每个顶点数据大小都是 32 字节（<code>sizeof(CustomVertex)</code>），即下组顶点数据数据在一个 <code>CustomVertex</code> 之后，所以我们把步长设置为 <code>sizeof(CustomVertex)</code>。</li>\n<li>ptr：表示该属性在缓存中起始位置的偏移量（Offset）。如图，位置属性的偏移量是 0，而对于色值属性，它是紧挨着位置属性之后，所以它相对起始位置的偏移量，应该是一个位置属性的大小，即 16（sizeof(float) <em> 4）。另外，参数类型是 `GLvoid</em>`，所以需要进行这个奇怪的强制类型转换。</li>\n</ul>\n<p>至此，所有东西都已经设置好了：我们使用一个顶点缓存对象将顶点数据初始化至缓存中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL ES 如何把顶点数据链接到顶点着色器的顶点属性上。</p>\n<p>最后，要想渲染我们想要的图形，OpenGL ES 提供了 <code>glDrawArrays</code> 函数，它使用当前激活的着色器，之前定义的顶点属性配置，以及VBO的顶点数据来渲染图元。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> GL_APIENTRY <span class=\"title\">glDrawArrays</span> <span class=\"params\">(GLenum mode, GLint first, GLsizei count)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>mode：指定渲染的 OpenGL ES 图元的类型。这里渲染的是一个三角形，所以传递 GL_TRIANGLES 给它。</li>\n<li>first：指定了顶点数据的起始索引，这里为 0。</li>\n<li>count：指定顶点个数，这里为 3。</li>\n</ul>\n<blockquote>\n<p>PS：</p>\n<p>mode 的类型还有其他几种，应用于不同的场景，感兴趣的可以了解下～</p>\n</blockquote>\n<h2 id=\"7-_测试，运行\">7. 测试，运行</h2><p>最后，在 setup 中添加如下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> compileShaders];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setupVBOs];</span><br></pre></td></tr></table></figure>\n<p>运行，不出意外的话，你将会看到之前的三角形。</p>\n<p>最终的工程可以从<a href=\"https://github.com/colin1994/OpenGLES/blob/master/Lesson03/OpenGLESDemo.zip\">这里</a>下载。下一节，将详细介绍 GLSL，一起期待吧～</p>"},{"title":"GLSL 详解（高级篇）","date":"2017-11-12T10:25:12.000Z","_content":"\n\n\n> PS：\n> 无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。\n\n<!--more-->\n\n### 7. 预处理\n\nGLSL 中预处理指令的使用也跟 C 语言的预处理指令相似。以下代码是宏及宏的条件判断：\n\n```c\n#define\n#undef\n#if\n#ifdef\n#ifndef\n#else\n#elif\n#endif\n```\n\n注意与 C 语言中不同，**宏不能带参数定义**。使用 `#if`，`#else` 和 `#elif` 可以用来判断宏是否被定义过。以下是一些预先定义好的宏及它们的描述：\n\n```c\n__LINE__ \t// 当前源码中的行号.\n__FILE__ \t// OpenGL ES 2.0 中始终为 0.\n__VERSION__ // 一个整数,指示当前的 glsl版本. 比如 100 ps: 100 = v1.00\nGL_ES \t\t// 如果当前是在 OPGL ES 环境中运行则 GL_ES 被设置成1,一般用来检查当前环境是不是 OPENGL ES.\n```\n\n在着色器编译过程中，**`#error` 指令会触发编译错误并向日志中写入内容。使用 `#pragma` 指令可以向编译器明确与实现相关的指令**。还有一种与 C 语言中不同的预处理指令是 **`#version`**，**它指定了编译着色器的 GLSL 对应版本**，可以在未来更新的版本中据此判断着色器的语言版本，以使用对应的版本来完成编译。这一标记需要写在代码的最开始位置，对于OpenGL ES 2.0 的着色器应将此值设置为 100。如下：\n\n```c\n#version 100 // OpenGL ES Shading Language v1.00\n```\n\n**实例:**\n\n**Q：1，如何通过判断系统环境，来选择合适的精度：**\n\n```c\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n```\n\n**Q：2，如何自定义宏：**\n\n```c\n#define NUM 100\n#if NUM==100\n#endif\n```\n\n预处理指令中另一个非常重要的是 `#extension`，**用来控制是否启用某些扩展的功能。**当供应商扩展 GLSL 时，会增加新的语言扩展明细，如 `GL_OES_texture_3D` 等。着色器必须告知编译器是否允许使用扩展或以怎样的行为方式出现，这就需要使用 `#extension` 指令来完成，如下：\n\n```c\n// Set behavior for an extension\n#extension extension_name : behavior\n// Set behavior for ALL extensions\n#extension all : behavior\n```\n\n第一个参数应为扩展的名称或者 “all”，“all” 表示该行为方式适用于所有的扩展。\n\n| 扩展的行为方式 | 描述                                       |\n| ------- | ---------------------------------------- |\n| require | 指明扩展是必须的，如果该扩展不被支持，预处理器会抛出错误。如果扩展参数为 “all” 则一定会抛出错误。 |\n| enable  | 指明扩展是启用的，如果该扩展不被支持，预处理器会发出警告。代码会按照扩展被启用的状态执行，如果扩展参数为“all”则一定会抛出错误。 |\n| warn    | 除非是因为该扩展被其它处于启用状态的扩展所需要，否则在使用该扩展时会发出警告。如果扩展参数为 “all” 则无论何时使用扩展都会抛出警告。除此之外，如果扩展不被支持，也会发出警告。 |\n| disable | 指明扩展被禁用，如果使用该扩展会抛出错误。如果扩展参数为 “all”（即默认设置），则不允许使用任何扩展。 |\n\n例如，实现不支持 3D 纹理扩展，如果你希望处理器发出警告（此时着色器也会同样被执行，如同实现支持 3D 纹理扩展一样），应当在着色器顶部加入以下代码：\n\n```c\n#extension GL_OES_texture_3D : enable\n```\n\n\n\n### 8. 内置变量\n\n#### 顶点着色器内置变量\n\n顶点着色器中有变量 `gl_Position`，此变量用于写入齐次顶点位置坐标。一个完整的顶点着色器的所有执行命令都应该向此变量写入值。写入的时机可以是着色器执行过程中的任意时间。当被写入之后也同样可以读取此变量的值。在处理顶点之后的图元装配、剪切（clipping）、剔除（culling）等对于图元的固定功能操作中将会使用此值。如果编译器发现 `gl_Position` 未写入或在写入之前有读取行为将会产生一条诊断信息，但并非所有的情况都能发现。如果执行顶点着色器而未写入 `gl_Position`，则 `gl_Position` 的值将是未定义。\n顶点着色器中有变量 `gl_PointSize`，此变量用于为顶点着色器写入将要栅格化的点的大小，以像素为单位。\n顶点着色器中的这些内置变量固有的声明类型如下：\n\n```c\nhighp vec4 gl_Position; // should be written to\nmediump float gl_PointSize; // may be written to\n```\n\n- 这些变量如果未写入或在在写入之前读取，则取到的值是未定义值。\n- 如果被写入多次，则在后续步骤中使用的是最后一次写入的值。\n- 这些内置变量拥有全局作用域。\n- OpenGL ES 中没有内置的 attribute 名称。\n\n\n\n#### 片段着色器内置变量\n\nOpenGL ES 渲染管线最后的步骤会对片段着色器的输出进行处理。\n如果没有使用过 `discard` 关键字，则片段着色器使用内置变量 `gl_FragColor` 和 `gl_FragData` 来向渲染管线输出数据。\n\n同样，\n\n- 在片段着色器中，并非必须要对 `gl_FragColor` 和 `gl_FragData` 的值进行写入。\n- 这些变量可以多次写入值，这样管线中后续步骤使用的是最后一次赋的值。\n- 写入的值可以再次读取出，如果在写入之前读取则会得到未定义值。\n- 写入的 `gl_FragColor` 值定义了后续固定功能管线中使用的片段的颜色。而变量 `gl_FragData` 是一个数组，写入的数值 `gl_FragData[n]` 指定了后续固定功能管线中对应于数据 `n` 的片段数据。\n- 如果着色器为 `gl_FragColor` 静态赋值，则可不必为 `gl_FragData` 赋值，同样如果着色器为 `gl_FragData` 中任意元素静态赋值，则可不必为 `gl_FragColor` 赋值。每个着色器应为二者之一赋值，而非二者同时。（在着色器中，如果某个变量在该着色器完成预处理之后，不受运行时的流程控制语句影响，一定会被写入值，则称之为对该变量的静态赋值）。\n- 如果着色器执行了`discard` 关键字，则该片段被丢弃，且 `gl_FragColor` 和 `gl_FragData` 不再相关。\n- 片段着色器中有一个只读变量 `gl_FragCoord`，存储了片段的窗口相对坐标 `x`、`y`、`z` 及 `1/w`。该值是在顶点处理阶段之后对图元插值生成片段计算所得。`z` 分量是深度值用来表示片段的深度。\n- 片段着色器可以访问内置的只读变量 `gl_FrontFacing` ，如果片段属于正面向前（front-facing）的图元，则该变量的值为 `true`。该变量可以选取顶点着色器计算出的两个颜色之一以模拟两面光照。\n- 片段着色器有只读变量 `gl_PointCoord`。`gl_PointCoord` 存储的是当前片段所在点图元的二维坐标。点的范围是 0.0 到 1.0。如果当前的图元不是一个点，那么从 `gl_PointCoord` 读出的值是未定义的。\n\n片段着色器中这些内置变量固有声明类型如下：\n\n```c\nmediump vec4 gl_FragCoord;\nbool gl_FrontFacing;\nmediump vec4 gl_FragColor;\nmediump vec4 gl_FragData[gl_MaxDrawBuffers];\nmediump vec2 gl_PointCoord;\n```\n\n但是它们实际的行为并不像是无存储限定符，而是像上边描述的样子。\n这些内置变量拥有全局作用域。\n\n\n\n#### uniform 状态变量\n\nGLSL 中还有一种内置的 uniform 状态变量,  `gl_DepthRange` 它用来表明全局深度范围。\n\n结构如下:\n\n```c\nstruct gl_DepthRangeParameters {\n highp float near; // n\n highp float far; // f\n highp float diff; // f - n\n };\n uniform gl_DepthRangeParameters gl_DepthRange;\n```\n\n除了  gl_DepthRange 外的所有 uniform 状态常量都已在 GLSL 1.30 中废弃。\n\n\n\n### 9. 内置常量\n\n以下是提供给顶点着色器或片段着色器的内置常量：\n\n```c\n//\n// Implementation dependent constants. The example values below\n// are the minimum values allowed for these maximums.\n//\n\n// gl_MaxVertexAttribs 表示在vertex shader(顶点着色器)中可用的最大attributes数.这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxVertexAttribs = 8;\n\n// gl_MaxVertexUniformVectors 表示在vertex shader(顶点着色器)中可用的最大uniform vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 128 个.\nconst mediump int gl_MaxVertexUniformVectors = 128;\n\n// gl_MaxVaryingVectors 表示在vertex shader(顶点着色器)中可用的最大varying vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxVaryingVectors = 8;\n\n// gl_MaxCombinedTextureImageUnits 表示在vertex shader(顶点着色器)中可用的最大纹理单元数(贴图). 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 甚至可以一个都没有(无法获取顶点纹理)\nconst mediump int gl_MaxVertexTextureImageUnits = 0;\n\n// gl_MaxCombinedTextureImageUnits 表示在 vertex Shader和fragment Shader总共最多支持多少个纹理单元. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxCombinedTextureImageUnits = 8;\n\n// gl_MaxTextureImageUnits 表示在 fragment Shader(片元着色器)中能访问的最大纹理单元数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxTextureImageUnits = 8;\n\n// gl_MaxFragmentUniformVectors 表示在 fragment Shader(片元着色器)中可用的最大uniform vectors数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 16 个.\nconst mediump int gl_MaxFragmentUniformVectors = 16;\n\n// gl_MaxDrawBuffers 表示可用的drawBuffers数,在OpenGL ES 2.0中这个值为1, 在将来的版本可能会有所变化.\nconst mediump int gl_MaxDrawBuffers = 1;\n```\n\n\n\n### 10. 内置函数\n\n在 GLSL 中还有很多内置的函数，如下边的例子是片段着色器中用来计算镜面光的代码。\n\n```c\nfloat nDotL = dot(normal , light);\nfloat rDotV = dot(viewDir, (2.0 * normal) * nDotL – light);\nfloat specular = specularColor * pow(rDotV, specularPower);\n```\n\n在上边的代码中，使用内置函数 `dot` 来计算两个矢量的点乘积，使用内置函数 `pow` 来完成标量的幂计算。\n在编写着色程序时，GLSL 中有大量的内置函数供使用。绝大多数的内置函数可用于多种着色器，也有一些只适用于一种特定的着色器。这些内置函数大致可分为以下三类：\n\n- 将一些必要的硬件功能显露成方便调用的函数，如访问纹理图。着色器无法用语言模拟这些函数。\n\n- 代表一系列琐碎的操作，虽然这些操作可以由用户直接编写完成，但是这些操作都很常用并且可能会有一些硬件支持。编译器处理表达式于汇编指令的映射是非常困难的事情。\n\n- 代表可获得图形硬件加速的操作，如三角函数属于这一分类。\n\n  ​\n\n很多函数与一些常见的 C 语言库里的同名函数相似，但这些内置函数不仅支持标量输入，还可以支持矢量输入。应用程序中应当尽量使用这些内置函数而不是有相同计算的自定义代码，因为内置函数很可能是最优化的（如可能是硬件直接支持的）。用户函数可以重载内置函数，但不能将其重定义。\n\n在下边的内置函数中，函数的输入参数（及相对应的输出）可以是 float、vec2、vec3 或 vec4，则使用 genType 来作为参数。在实际使用一个函数时，所有的参数类型及返回类型必须是一致的。对于 mat 也相似，其具体类型可以是 mat2、mat3 或 mat4。\n\n参数和返回值的精度限定符不显示。对于纹理函数，返回类型的精度与采样器的类型相匹配。\n\n```c\nuniform lowp sampler2D sampler;\nhighp vec2 coord;\n...\nlowp vec4 col = texture2D (sampler, coord); // texture2D returns lowp\n```\n\n其它内置函数的形式参数的精度限定符则无关。调用这些内置函数将会返回一个匹配输入参数的最高精度级的精度限定符。\n\n按功能大致可以分成 7 类：\n\n#### 角度和三角函数\n\n函数参数是以弧度为单位的角度值。以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                              | Description                              |\n| ----------------------------------- | ---------------------------------------- |\n| genType radians (genType degrees)   | Converts degrees to radians              |\n| genType degrees (genType radians)   | Converts radians to degrees              |\n| genType sin (genType angle)         | The standard trigonometric sine function. |\n| genType cos (genType angle)         | The standard trigonometric cosine function. |\n| genType tan (genType angle)         | The standard trigonometric tangent.      |\n| genType asin (genType x)            | Arc sine. Returns an angle whose sine is x. The range of values returned by this function is[-π/2,π/2] .Results are undefined if ∣x∣ > 1. |\n| genType acos (genType x)            | Arc cosine. Returns an angle whose cosine is x. The range of values returned by this function is [0, π]. Results are undefined if ∣x∣ > 1. |\n| genType atan (genType y, genType x) | Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in . The range of values returned by this function is [−π,π]. Results are undefined if x and y are both 0. |\n| genType atan (genType y_over_x)     | Arc tangent. Returns an angle whose tangent is y_over_x. The range of values returned by this function is [−π/2,π/2] |\n\n\n\n#### 指数函数\n\n以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                             | Description                              |\n| ---------------------------------- | ---------------------------------------- |\n| genType pow (genType x, genType y) | Returns x raised to the y power. Results are undefined if x < 0 .Results are undefined if x = 0 and y <= 0. |\n| genType exp (genType x)            | Returns the natural exponentiation of x. |\n| genType log (genType x)            | Returns the natural logarithm of x. Results are undefined if x <= 0. |\n| genType exp2 (genType x)           | Returns 2 raised to the x power.         |\n| genType log2 (genType x)           | Returns the base 2 logarithm of x. Results are undefined if x <= 0. |\n| genType sqrt (genType x)           | Returns square root of x. Results are undefined if x < 0. |\n| genType inversesqrt (genType x)    | Returns 1/sqrt(x) . Results are undefined if x <= 0. |\n\n\n\n#### 通用函数\n\n以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                                   | Description                              |\n| ---------------------------------------- | ---------------------------------------- |\n| genType abs (genType x)                  | Returns x if x >= 0, otherwise it returns –x. |\n| genType sign (genType x)                 | Returns 1.0 if x > 0, 0.0 if x = 0, or –1.0 if x < 0 |\n| genType floor (genType x)                | Returns a value equal to the nearest integer that is less than or equal to x |\n| genType ceil (genType x)                 | Returns a value equal to the nearest integer that is greater than or equal to x |\n| genType fract (genType x)                | Returns x – floor (x)                    |\n| genType mod (genType x, float y)         | Modulus (modulo). Returns x – y ∗ floor (x/y) |\n| genType mod (genType x, genType y)       | Modulus. Returns x – y ∗ floor (x/y)     |\n| genType min (genType x, genType y)genType min (genType x, float y) | Returns y if y < x, otherwise it returns x |\n| genType max (genType x, genType y) genType max (genType x, float y) | Returns y if x < y, otherwise it returns x. |\n| genType clamp (genType x,genType minVal, genType maxVal)genType clamp (genType x, float minVal,float maxVal) | Returns min (max (x, minVal), maxVal) Results are undefined if minVal > maxVal. |\n| genType mix (genType x,genType y,genType a)genType mix (genType x,genType y, float a) | Returns the linear blend of x and y: x*(1-a)+y*a |\n| genType step (genType edge, genType x)genType step (float edge, genType x) | Returns 0.0 if x < edge, otherwise it returns 1.0 |\n| genType smoothstep (genType edge0,genType edge1,genType x)genType smoothstep (float edge0,float edge1,genType x) | Returns 0.0 if x <= edge0 and 1.0 if x >= edge1 and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: `genType t; t = clamp ((x – edge0) / (edge1 – edge0), 0, 1); return t * t * (3 – 2 * t);` Results are undefined if edge0 >= edge1. |\n\n\n\n#### 几何函数\n\n以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                                   | Description                              |\n| ---------------------------------------- | ---------------------------------------- |\n| float length (genType x)                 | Returns the length of vector x.          |\n| float distance (genType p0, genType p1)  | Returns the distance between p0 and p1.  |\n| float dot (genType x, genType y)         | Returns the dot product of x and y.      |\n| vec3 cross (vec3 x, vec3 y)              | Returns the cross product of x and y.    |\n| genType normalize (genType x)            | Returns a vector in the same direction as x but with a length of 1. |\n| genType faceforward(genType N,genType I,genType Nref) | If dot(Nref, I) < 0 return N, otherwise return –N. |\n| genType reflect (genType I, genType N)   | For the incident vector I and surface orientation N,returns the reflection direction: I – 2 ∗ dot(N, I) ∗ N. N must already be normalized in order to achieve the desired result. |\n| genType refract(genType I, genType N,float eta) | For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector. The result is computed by `k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I)); if (k < 0.0) return genType(0.0) else return eta * I - (eta * dot(N, I) + sqrt(k)) * N`. The input parameters for the incident vector I and thesurface normal N must already be normalized to get the desired results. |\n\n\n\n#### 矩阵函数\n\n| Syntax                            | Description                              |\n| --------------------------------- | ---------------------------------------- |\n| mat matrixCompMult (mat x, mat y) | Multiply matrix x by matrix y component-wise, i.e.,result[i][j] is the scalar product of x[i][j] and y[i][j]. Note: to get linear algebraic matrix multiplication, usethe multiply operator (*). |\n\n\n\n#### 矢量关系函数\n\n矢量之间的比较关系符号（<, <=, >, >=, ==, !=）被定义（或保留）比较产生一个标量的布尔型结果。使用下边的函数可以得到矢量结果。\n\n以下的 ”bvec” 指代 ”bvec2”、”bvec3” 或 ”bvec4” 之一，”ivec” 指代 ”ivec2”、”ivec3” 或 ”ivec4” 之一，”vec” 指代 ”vec2”、”vec3” 或 ”vec4”之一。输入参数和返回值各矢量的大小必须一致。\n\n| Syntax                                   | Description                              |\n| ---------------------------------------- | ---------------------------------------- |\n| bvec lessThan(vec x, vec y)bvec lessThan(ivec x, ivec y) | Returns the component-wise compare of x < y. |\n| bvec lessThanEqual(vec x, vec y)bvec lessThanEqual(ivec x, ivec y) | Returns the component-wise compare of x <= y. |\n| bvec greaterThan(vec x, vec y)bvec greaterThan(ivec x, ivec y) | Returns the component-wise compare of x > y. |\n| bvec greaterThanEqual(vec x, vec y)bvec greaterThanEqual(ivec x, ivec y) | Returns the component-wise compare of x >= y. |\n| bvec equal(vec x, vec y)bvec equal(ivec x, ivec y)bvec equal(bvec x, bvec y)bvec notEqual(vec x, vec y)bvec notEqual(ivec x, ivec y)bvec notEqual(bvec x, bvec y) | Returns the component-wise compare of x == y; Returns the component-wise compare of x != y. |\n| bool any(bvec x)                         | Returns true if any component of x is true. |\n| bool all(bvec x)                         | Returns true only if all components of x are true. |\n| bvec not(bvec x)                         | Returns the component-wise logical complement of x. |\n\n#### 纹理查找函数\n\n纹理查询的最终目的是从 sampler 中提取指定坐标的颜色信息。\n\n顶点着色器和片段着色器中都可以使用纹理查找函数。但是在顶点着色器中不会计算细节层次（level of detail），所以二者的纹理查找函数略有不同。\n\n图像纹理有两种：一种是平面2d纹理，另一种是盒纹理。针对不同的纹理类型有不同访问方法。\n\n- 函数中带有 Cube 字样的是指需要传入盒状纹理。\n- 带有 Proj 字样的是指带投影的版本。\n\n以下函数只在顶点着色器中可用：\n\n```c\nvec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\nvec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\nvec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\nvec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\n```\n\n以下函数只在片段着色器中可用:\n\n```c\nvec4 texture2D(sampler2D sampler, vec2 coord, float bias);\nvec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\nvec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\nvec4 textureCube(samplerCube sampler, vec3 coord, float bias);\n```\n\n在定点着色器和片段着色器中都可用:\n\n```c\nvec4 texture2D(sampler2D sampler, vec2 coord);\nvec4 texture2DProj(sampler2D sampler, vec3 coord);\nvec4 texture2DProj(sampler2D sampler, vec4 coord);\nvec4 textureCube(samplerCube sampler, vec3 coord);\n```\n\n\n\n### 11. 自测\n\n下面是官方的一段实例着色器。如果你可以一眼看懂，说明你已经对 GLSL 语言基本掌握了，那么这篇文章就没有白写了~\n\n\n\n**Vertex Shader:**\n\n```c\nuniform mat4 mvp_matrix; \t// 透视矩阵 * 视图矩阵 * 模型变换矩阵\nuniform mat3 normal_matrix; // 法线变换矩阵(用于物体变换后法线跟着变换)\nuniform vec3 ec_light_dir; \t// 光照方向\nattribute vec4 a_vertex; \t// 顶点坐标\nattribute vec3 a_normal; \t// 顶点法线\nattribute vec2 a_texcoord; \t// 纹理坐标\nvarying float v_diffuse; \t// 法线与入射光的夹角\nvarying vec2 v_texcoord; \t// 2d纹理坐标\n\nvoid main(void) {\n  // 归一化法线\n  vec3 ec_normal = normalize(normal_matrix * a_normal);\n  // v_diffuse 是法线与光照的夹角.根据向量点乘法则,当两向量长度为1是 乘积即cosθ值\n  v_diffuse = max(dot(ec_light_dir, ec_normal), 0.0);\n  v_texcoord = a_texcoord;\n  gl_Position = mvp_matrix * a_vertex;\n}\n```\n\n**Fragment Shader:**\n\n```c\nprecision mediump float;\nuniform sampler2D t_reflectance;\nuniform vec4 i_ambient;\nvarying float v_diffuse;\nvarying vec2 v_texcoord;\n\nvoid main (void) {\n  vec4 color = texture2D(t_reflectance, v_texcoord);\n  // 这里分解开来是 color*vec3(1,1,1)*v_diffuse + color*i_ambient\n  // 色*光*夹角cos + 色*环境光\n  gl_FragColor = color*(vec4(v_diffuse) + i_ambient);\n}\n```","source":"_posts/OpenGLES-Lesson05.md","raw":"title: GLSL 详解（高级篇）\n\ndate: 2017-11-12 18:25:12\n\ntags:\n\n- iOS开发\n- OpenGLES\n- 图像处理\n\n------\n\n\n\n> PS：\n> 无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。\n\n<!--more-->\n\n### 7. 预处理\n\nGLSL 中预处理指令的使用也跟 C 语言的预处理指令相似。以下代码是宏及宏的条件判断：\n\n```c\n#define\n#undef\n#if\n#ifdef\n#ifndef\n#else\n#elif\n#endif\n```\n\n注意与 C 语言中不同，**宏不能带参数定义**。使用 `#if`，`#else` 和 `#elif` 可以用来判断宏是否被定义过。以下是一些预先定义好的宏及它们的描述：\n\n```c\n__LINE__ \t// 当前源码中的行号.\n__FILE__ \t// OpenGL ES 2.0 中始终为 0.\n__VERSION__ // 一个整数,指示当前的 glsl版本. 比如 100 ps: 100 = v1.00\nGL_ES \t\t// 如果当前是在 OPGL ES 环境中运行则 GL_ES 被设置成1,一般用来检查当前环境是不是 OPENGL ES.\n```\n\n在着色器编译过程中，**`#error` 指令会触发编译错误并向日志中写入内容。使用 `#pragma` 指令可以向编译器明确与实现相关的指令**。还有一种与 C 语言中不同的预处理指令是 **`#version`**，**它指定了编译着色器的 GLSL 对应版本**，可以在未来更新的版本中据此判断着色器的语言版本，以使用对应的版本来完成编译。这一标记需要写在代码的最开始位置，对于OpenGL ES 2.0 的着色器应将此值设置为 100。如下：\n\n```c\n#version 100 // OpenGL ES Shading Language v1.00\n```\n\n**实例:**\n\n**Q：1，如何通过判断系统环境，来选择合适的精度：**\n\n```c\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n```\n\n**Q：2，如何自定义宏：**\n\n```c\n#define NUM 100\n#if NUM==100\n#endif\n```\n\n预处理指令中另一个非常重要的是 `#extension`，**用来控制是否启用某些扩展的功能。**当供应商扩展 GLSL 时，会增加新的语言扩展明细，如 `GL_OES_texture_3D` 等。着色器必须告知编译器是否允许使用扩展或以怎样的行为方式出现，这就需要使用 `#extension` 指令来完成，如下：\n\n```c\n// Set behavior for an extension\n#extension extension_name : behavior\n// Set behavior for ALL extensions\n#extension all : behavior\n```\n\n第一个参数应为扩展的名称或者 “all”，“all” 表示该行为方式适用于所有的扩展。\n\n| 扩展的行为方式 | 描述                                       |\n| ------- | ---------------------------------------- |\n| require | 指明扩展是必须的，如果该扩展不被支持，预处理器会抛出错误。如果扩展参数为 “all” 则一定会抛出错误。 |\n| enable  | 指明扩展是启用的，如果该扩展不被支持，预处理器会发出警告。代码会按照扩展被启用的状态执行，如果扩展参数为“all”则一定会抛出错误。 |\n| warn    | 除非是因为该扩展被其它处于启用状态的扩展所需要，否则在使用该扩展时会发出警告。如果扩展参数为 “all” 则无论何时使用扩展都会抛出警告。除此之外，如果扩展不被支持，也会发出警告。 |\n| disable | 指明扩展被禁用，如果使用该扩展会抛出错误。如果扩展参数为 “all”（即默认设置），则不允许使用任何扩展。 |\n\n例如，实现不支持 3D 纹理扩展，如果你希望处理器发出警告（此时着色器也会同样被执行，如同实现支持 3D 纹理扩展一样），应当在着色器顶部加入以下代码：\n\n```c\n#extension GL_OES_texture_3D : enable\n```\n\n\n\n### 8. 内置变量\n\n#### 顶点着色器内置变量\n\n顶点着色器中有变量 `gl_Position`，此变量用于写入齐次顶点位置坐标。一个完整的顶点着色器的所有执行命令都应该向此变量写入值。写入的时机可以是着色器执行过程中的任意时间。当被写入之后也同样可以读取此变量的值。在处理顶点之后的图元装配、剪切（clipping）、剔除（culling）等对于图元的固定功能操作中将会使用此值。如果编译器发现 `gl_Position` 未写入或在写入之前有读取行为将会产生一条诊断信息，但并非所有的情况都能发现。如果执行顶点着色器而未写入 `gl_Position`，则 `gl_Position` 的值将是未定义。\n顶点着色器中有变量 `gl_PointSize`，此变量用于为顶点着色器写入将要栅格化的点的大小，以像素为单位。\n顶点着色器中的这些内置变量固有的声明类型如下：\n\n```c\nhighp vec4 gl_Position; // should be written to\nmediump float gl_PointSize; // may be written to\n```\n\n- 这些变量如果未写入或在在写入之前读取，则取到的值是未定义值。\n- 如果被写入多次，则在后续步骤中使用的是最后一次写入的值。\n- 这些内置变量拥有全局作用域。\n- OpenGL ES 中没有内置的 attribute 名称。\n\n\n\n#### 片段着色器内置变量\n\nOpenGL ES 渲染管线最后的步骤会对片段着色器的输出进行处理。\n如果没有使用过 `discard` 关键字，则片段着色器使用内置变量 `gl_FragColor` 和 `gl_FragData` 来向渲染管线输出数据。\n\n同样，\n\n- 在片段着色器中，并非必须要对 `gl_FragColor` 和 `gl_FragData` 的值进行写入。\n- 这些变量可以多次写入值，这样管线中后续步骤使用的是最后一次赋的值。\n- 写入的值可以再次读取出，如果在写入之前读取则会得到未定义值。\n- 写入的 `gl_FragColor` 值定义了后续固定功能管线中使用的片段的颜色。而变量 `gl_FragData` 是一个数组，写入的数值 `gl_FragData[n]` 指定了后续固定功能管线中对应于数据 `n` 的片段数据。\n- 如果着色器为 `gl_FragColor` 静态赋值，则可不必为 `gl_FragData` 赋值，同样如果着色器为 `gl_FragData` 中任意元素静态赋值，则可不必为 `gl_FragColor` 赋值。每个着色器应为二者之一赋值，而非二者同时。（在着色器中，如果某个变量在该着色器完成预处理之后，不受运行时的流程控制语句影响，一定会被写入值，则称之为对该变量的静态赋值）。\n- 如果着色器执行了`discard` 关键字，则该片段被丢弃，且 `gl_FragColor` 和 `gl_FragData` 不再相关。\n- 片段着色器中有一个只读变量 `gl_FragCoord`，存储了片段的窗口相对坐标 `x`、`y`、`z` 及 `1/w`。该值是在顶点处理阶段之后对图元插值生成片段计算所得。`z` 分量是深度值用来表示片段的深度。\n- 片段着色器可以访问内置的只读变量 `gl_FrontFacing` ，如果片段属于正面向前（front-facing）的图元，则该变量的值为 `true`。该变量可以选取顶点着色器计算出的两个颜色之一以模拟两面光照。\n- 片段着色器有只读变量 `gl_PointCoord`。`gl_PointCoord` 存储的是当前片段所在点图元的二维坐标。点的范围是 0.0 到 1.0。如果当前的图元不是一个点，那么从 `gl_PointCoord` 读出的值是未定义的。\n\n片段着色器中这些内置变量固有声明类型如下：\n\n```c\nmediump vec4 gl_FragCoord;\nbool gl_FrontFacing;\nmediump vec4 gl_FragColor;\nmediump vec4 gl_FragData[gl_MaxDrawBuffers];\nmediump vec2 gl_PointCoord;\n```\n\n但是它们实际的行为并不像是无存储限定符，而是像上边描述的样子。\n这些内置变量拥有全局作用域。\n\n\n\n#### uniform 状态变量\n\nGLSL 中还有一种内置的 uniform 状态变量,  `gl_DepthRange` 它用来表明全局深度范围。\n\n结构如下:\n\n```c\nstruct gl_DepthRangeParameters {\n highp float near; // n\n highp float far; // f\n highp float diff; // f - n\n };\n uniform gl_DepthRangeParameters gl_DepthRange;\n```\n\n除了  gl_DepthRange 外的所有 uniform 状态常量都已在 GLSL 1.30 中废弃。\n\n\n\n### 9. 内置常量\n\n以下是提供给顶点着色器或片段着色器的内置常量：\n\n```c\n//\n// Implementation dependent constants. The example values below\n// are the minimum values allowed for these maximums.\n//\n\n// gl_MaxVertexAttribs 表示在vertex shader(顶点着色器)中可用的最大attributes数.这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxVertexAttribs = 8;\n\n// gl_MaxVertexUniformVectors 表示在vertex shader(顶点着色器)中可用的最大uniform vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 128 个.\nconst mediump int gl_MaxVertexUniformVectors = 128;\n\n// gl_MaxVaryingVectors 表示在vertex shader(顶点着色器)中可用的最大varying vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxVaryingVectors = 8;\n\n// gl_MaxCombinedTextureImageUnits 表示在vertex shader(顶点着色器)中可用的最大纹理单元数(贴图). 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 甚至可以一个都没有(无法获取顶点纹理)\nconst mediump int gl_MaxVertexTextureImageUnits = 0;\n\n// gl_MaxCombinedTextureImageUnits 表示在 vertex Shader和fragment Shader总共最多支持多少个纹理单元. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxCombinedTextureImageUnits = 8;\n\n// gl_MaxTextureImageUnits 表示在 fragment Shader(片元着色器)中能访问的最大纹理单元数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.\nconst mediump int gl_MaxTextureImageUnits = 8;\n\n// gl_MaxFragmentUniformVectors 表示在 fragment Shader(片元着色器)中可用的最大uniform vectors数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 16 个.\nconst mediump int gl_MaxFragmentUniformVectors = 16;\n\n// gl_MaxDrawBuffers 表示可用的drawBuffers数,在OpenGL ES 2.0中这个值为1, 在将来的版本可能会有所变化.\nconst mediump int gl_MaxDrawBuffers = 1;\n```\n\n\n\n### 10. 内置函数\n\n在 GLSL 中还有很多内置的函数，如下边的例子是片段着色器中用来计算镜面光的代码。\n\n```c\nfloat nDotL = dot(normal , light);\nfloat rDotV = dot(viewDir, (2.0 * normal) * nDotL – light);\nfloat specular = specularColor * pow(rDotV, specularPower);\n```\n\n在上边的代码中，使用内置函数 `dot` 来计算两个矢量的点乘积，使用内置函数 `pow` 来完成标量的幂计算。\n在编写着色程序时，GLSL 中有大量的内置函数供使用。绝大多数的内置函数可用于多种着色器，也有一些只适用于一种特定的着色器。这些内置函数大致可分为以下三类：\n\n- 将一些必要的硬件功能显露成方便调用的函数，如访问纹理图。着色器无法用语言模拟这些函数。\n\n- 代表一系列琐碎的操作，虽然这些操作可以由用户直接编写完成，但是这些操作都很常用并且可能会有一些硬件支持。编译器处理表达式于汇编指令的映射是非常困难的事情。\n\n- 代表可获得图形硬件加速的操作，如三角函数属于这一分类。\n\n  ​\n\n很多函数与一些常见的 C 语言库里的同名函数相似，但这些内置函数不仅支持标量输入，还可以支持矢量输入。应用程序中应当尽量使用这些内置函数而不是有相同计算的自定义代码，因为内置函数很可能是最优化的（如可能是硬件直接支持的）。用户函数可以重载内置函数，但不能将其重定义。\n\n在下边的内置函数中，函数的输入参数（及相对应的输出）可以是 float、vec2、vec3 或 vec4，则使用 genType 来作为参数。在实际使用一个函数时，所有的参数类型及返回类型必须是一致的。对于 mat 也相似，其具体类型可以是 mat2、mat3 或 mat4。\n\n参数和返回值的精度限定符不显示。对于纹理函数，返回类型的精度与采样器的类型相匹配。\n\n```c\nuniform lowp sampler2D sampler;\nhighp vec2 coord;\n...\nlowp vec4 col = texture2D (sampler, coord); // texture2D returns lowp\n```\n\n其它内置函数的形式参数的精度限定符则无关。调用这些内置函数将会返回一个匹配输入参数的最高精度级的精度限定符。\n\n按功能大致可以分成 7 类：\n\n#### 角度和三角函数\n\n函数参数是以弧度为单位的角度值。以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                              | Description                              |\n| ----------------------------------- | ---------------------------------------- |\n| genType radians (genType degrees)   | Converts degrees to radians              |\n| genType degrees (genType radians)   | Converts radians to degrees              |\n| genType sin (genType angle)         | The standard trigonometric sine function. |\n| genType cos (genType angle)         | The standard trigonometric cosine function. |\n| genType tan (genType angle)         | The standard trigonometric tangent.      |\n| genType asin (genType x)            | Arc sine. Returns an angle whose sine is x. The range of values returned by this function is[-π/2,π/2] .Results are undefined if ∣x∣ > 1. |\n| genType acos (genType x)            | Arc cosine. Returns an angle whose cosine is x. The range of values returned by this function is [0, π]. Results are undefined if ∣x∣ > 1. |\n| genType atan (genType y, genType x) | Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in . The range of values returned by this function is [−π,π]. Results are undefined if x and y are both 0. |\n| genType atan (genType y_over_x)     | Arc tangent. Returns an angle whose tangent is y_over_x. The range of values returned by this function is [−π/2,π/2] |\n\n\n\n#### 指数函数\n\n以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                             | Description                              |\n| ---------------------------------- | ---------------------------------------- |\n| genType pow (genType x, genType y) | Returns x raised to the y power. Results are undefined if x < 0 .Results are undefined if x = 0 and y <= 0. |\n| genType exp (genType x)            | Returns the natural exponentiation of x. |\n| genType log (genType x)            | Returns the natural logarithm of x. Results are undefined if x <= 0. |\n| genType exp2 (genType x)           | Returns 2 raised to the x power.         |\n| genType log2 (genType x)           | Returns the base 2 logarithm of x. Results are undefined if x <= 0. |\n| genType sqrt (genType x)           | Returns square root of x. Results are undefined if x < 0. |\n| genType inversesqrt (genType x)    | Returns 1/sqrt(x) . Results are undefined if x <= 0. |\n\n\n\n#### 通用函数\n\n以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                                   | Description                              |\n| ---------------------------------------- | ---------------------------------------- |\n| genType abs (genType x)                  | Returns x if x >= 0, otherwise it returns –x. |\n| genType sign (genType x)                 | Returns 1.0 if x > 0, 0.0 if x = 0, or –1.0 if x < 0 |\n| genType floor (genType x)                | Returns a value equal to the nearest integer that is less than or equal to x |\n| genType ceil (genType x)                 | Returns a value equal to the nearest integer that is greater than or equal to x |\n| genType fract (genType x)                | Returns x – floor (x)                    |\n| genType mod (genType x, float y)         | Modulus (modulo). Returns x – y ∗ floor (x/y) |\n| genType mod (genType x, genType y)       | Modulus. Returns x – y ∗ floor (x/y)     |\n| genType min (genType x, genType y)genType min (genType x, float y) | Returns y if y < x, otherwise it returns x |\n| genType max (genType x, genType y) genType max (genType x, float y) | Returns y if x < y, otherwise it returns x. |\n| genType clamp (genType x,genType minVal, genType maxVal)genType clamp (genType x, float minVal,float maxVal) | Returns min (max (x, minVal), maxVal) Results are undefined if minVal > maxVal. |\n| genType mix (genType x,genType y,genType a)genType mix (genType x,genType y, float a) | Returns the linear blend of x and y: x*(1-a)+y*a |\n| genType step (genType edge, genType x)genType step (float edge, genType x) | Returns 0.0 if x < edge, otherwise it returns 1.0 |\n| genType smoothstep (genType edge0,genType edge1,genType x)genType smoothstep (float edge0,float edge1,genType x) | Returns 0.0 if x <= edge0 and 1.0 if x >= edge1 and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: `genType t; t = clamp ((x – edge0) / (edge1 – edge0), 0, 1); return t * t * (3 – 2 * t);` Results are undefined if edge0 >= edge1. |\n\n\n\n#### 几何函数\n\n以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。\n\n| Syntax                                   | Description                              |\n| ---------------------------------------- | ---------------------------------------- |\n| float length (genType x)                 | Returns the length of vector x.          |\n| float distance (genType p0, genType p1)  | Returns the distance between p0 and p1.  |\n| float dot (genType x, genType y)         | Returns the dot product of x and y.      |\n| vec3 cross (vec3 x, vec3 y)              | Returns the cross product of x and y.    |\n| genType normalize (genType x)            | Returns a vector in the same direction as x but with a length of 1. |\n| genType faceforward(genType N,genType I,genType Nref) | If dot(Nref, I) < 0 return N, otherwise return –N. |\n| genType reflect (genType I, genType N)   | For the incident vector I and surface orientation N,returns the reflection direction: I – 2 ∗ dot(N, I) ∗ N. N must already be normalized in order to achieve the desired result. |\n| genType refract(genType I, genType N,float eta) | For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector. The result is computed by `k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I)); if (k < 0.0) return genType(0.0) else return eta * I - (eta * dot(N, I) + sqrt(k)) * N`. The input parameters for the incident vector I and thesurface normal N must already be normalized to get the desired results. |\n\n\n\n#### 矩阵函数\n\n| Syntax                            | Description                              |\n| --------------------------------- | ---------------------------------------- |\n| mat matrixCompMult (mat x, mat y) | Multiply matrix x by matrix y component-wise, i.e.,result[i][j] is the scalar product of x[i][j] and y[i][j]. Note: to get linear algebraic matrix multiplication, usethe multiply operator (*). |\n\n\n\n#### 矢量关系函数\n\n矢量之间的比较关系符号（<, <=, >, >=, ==, !=）被定义（或保留）比较产生一个标量的布尔型结果。使用下边的函数可以得到矢量结果。\n\n以下的 ”bvec” 指代 ”bvec2”、”bvec3” 或 ”bvec4” 之一，”ivec” 指代 ”ivec2”、”ivec3” 或 ”ivec4” 之一，”vec” 指代 ”vec2”、”vec3” 或 ”vec4”之一。输入参数和返回值各矢量的大小必须一致。\n\n| Syntax                                   | Description                              |\n| ---------------------------------------- | ---------------------------------------- |\n| bvec lessThan(vec x, vec y)bvec lessThan(ivec x, ivec y) | Returns the component-wise compare of x < y. |\n| bvec lessThanEqual(vec x, vec y)bvec lessThanEqual(ivec x, ivec y) | Returns the component-wise compare of x <= y. |\n| bvec greaterThan(vec x, vec y)bvec greaterThan(ivec x, ivec y) | Returns the component-wise compare of x > y. |\n| bvec greaterThanEqual(vec x, vec y)bvec greaterThanEqual(ivec x, ivec y) | Returns the component-wise compare of x >= y. |\n| bvec equal(vec x, vec y)bvec equal(ivec x, ivec y)bvec equal(bvec x, bvec y)bvec notEqual(vec x, vec y)bvec notEqual(ivec x, ivec y)bvec notEqual(bvec x, bvec y) | Returns the component-wise compare of x == y; Returns the component-wise compare of x != y. |\n| bool any(bvec x)                         | Returns true if any component of x is true. |\n| bool all(bvec x)                         | Returns true only if all components of x are true. |\n| bvec not(bvec x)                         | Returns the component-wise logical complement of x. |\n\n#### 纹理查找函数\n\n纹理查询的最终目的是从 sampler 中提取指定坐标的颜色信息。\n\n顶点着色器和片段着色器中都可以使用纹理查找函数。但是在顶点着色器中不会计算细节层次（level of detail），所以二者的纹理查找函数略有不同。\n\n图像纹理有两种：一种是平面2d纹理，另一种是盒纹理。针对不同的纹理类型有不同访问方法。\n\n- 函数中带有 Cube 字样的是指需要传入盒状纹理。\n- 带有 Proj 字样的是指带投影的版本。\n\n以下函数只在顶点着色器中可用：\n\n```c\nvec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\nvec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\nvec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\nvec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\n```\n\n以下函数只在片段着色器中可用:\n\n```c\nvec4 texture2D(sampler2D sampler, vec2 coord, float bias);\nvec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\nvec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\nvec4 textureCube(samplerCube sampler, vec3 coord, float bias);\n```\n\n在定点着色器和片段着色器中都可用:\n\n```c\nvec4 texture2D(sampler2D sampler, vec2 coord);\nvec4 texture2DProj(sampler2D sampler, vec3 coord);\nvec4 texture2DProj(sampler2D sampler, vec4 coord);\nvec4 textureCube(samplerCube sampler, vec3 coord);\n```\n\n\n\n### 11. 自测\n\n下面是官方的一段实例着色器。如果你可以一眼看懂，说明你已经对 GLSL 语言基本掌握了，那么这篇文章就没有白写了~\n\n\n\n**Vertex Shader:**\n\n```c\nuniform mat4 mvp_matrix; \t// 透视矩阵 * 视图矩阵 * 模型变换矩阵\nuniform mat3 normal_matrix; // 法线变换矩阵(用于物体变换后法线跟着变换)\nuniform vec3 ec_light_dir; \t// 光照方向\nattribute vec4 a_vertex; \t// 顶点坐标\nattribute vec3 a_normal; \t// 顶点法线\nattribute vec2 a_texcoord; \t// 纹理坐标\nvarying float v_diffuse; \t// 法线与入射光的夹角\nvarying vec2 v_texcoord; \t// 2d纹理坐标\n\nvoid main(void) {\n  // 归一化法线\n  vec3 ec_normal = normalize(normal_matrix * a_normal);\n  // v_diffuse 是法线与光照的夹角.根据向量点乘法则,当两向量长度为1是 乘积即cosθ值\n  v_diffuse = max(dot(ec_light_dir, ec_normal), 0.0);\n  v_texcoord = a_texcoord;\n  gl_Position = mvp_matrix * a_vertex;\n}\n```\n\n**Fragment Shader:**\n\n```c\nprecision mediump float;\nuniform sampler2D t_reflectance;\nuniform vec4 i_ambient;\nvarying float v_diffuse;\nvarying vec2 v_texcoord;\n\nvoid main (void) {\n  vec4 color = texture2D(t_reflectance, v_texcoord);\n  // 这里分解开来是 color*vec3(1,1,1)*v_diffuse + color*i_ambient\n  // 色*光*夹角cos + 色*环境光\n  gl_FragColor = color*(vec4(v_diffuse) + i_ambient);\n}\n```","slug":"OpenGLES-Lesson05","published":1,"updated":"2019-12-23T01:02:31.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1n40021zwln5cawuhwv","content":"<blockquote>\n<p>PS：<br>无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"7-_预处理\">7. 预处理</h3><p>GLSL 中预处理指令的使用也跟 C 语言的预处理指令相似。以下代码是宏及宏的条件判断：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>注意与 C 语言中不同，<strong>宏不能带参数定义</strong>。使用 <code>#if</code>，<code>#else</code> 和 <code>#elif</code> 可以用来判断宏是否被定义过。以下是一些预先定义好的宏及它们的描述：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__LINE__ \t<span class=\"comment\">// 当前源码中的行号.</span></span><br><span class=\"line\">__FILE__ \t<span class=\"comment\">// OpenGL ES 2.0 中始终为 0.</span></span><br><span class=\"line\">__VERSION__ <span class=\"comment\">// 一个整数,指示当前的 glsl版本. 比如 100 ps: 100 = v1.00</span></span><br><span class=\"line\">GL_ES \t\t<span class=\"comment\">// 如果当前是在 OPGL ES 环境中运行则 GL_ES 被设置成1,一般用来检查当前环境是不是 OPENGL ES.</span></span><br></pre></td></tr></table></figure>\n<p>在着色器编译过程中，<strong><code>#error</code> 指令会触发编译错误并向日志中写入内容。使用 <code>#pragma</code> 指令可以向编译器明确与实现相关的指令</strong>。还有一种与 C 语言中不同的预处理指令是 <strong><code>#version</code></strong>，<strong>它指定了编译着色器的 GLSL 对应版本</strong>，可以在未来更新的版本中据此判断着色器的语言版本，以使用对应的版本来完成编译。这一标记需要写在代码的最开始位置，对于OpenGL ES 2.0 的着色器应将此值设置为 100。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 100 <span class=\"comment\">// OpenGL ES Shading Language v1.00</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>实例:</strong></p>\n<p><strong>Q：1，如何通过判断系统环境，来选择合适的精度：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_ES</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_FRAGMENT_PRECISION_HIGH</span></span><br><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>Q：2，如何自定义宏：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUM 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> NUM==100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>预处理指令中另一个非常重要的是 <code>#extension</code>，<strong>用来控制是否启用某些扩展的功能。</strong>当供应商扩展 GLSL 时，会增加新的语言扩展明细，如 <code>GL_OES_texture_3D</code> 等。着色器必须告知编译器是否允许使用扩展或以怎样的行为方式出现，这就需要使用 <code>#extension</code> 指令来完成，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Set behavior for an extension</span></span><br><span class=\"line\"><span class=\"meta\">#extension extension_name : behavior</span></span><br><span class=\"line\"><span class=\"comment\">// Set behavior for ALL extensions</span></span><br><span class=\"line\"><span class=\"meta\">#extension all : behavior</span></span><br></pre></td></tr></table></figure>\n<p>第一个参数应为扩展的名称或者 “all”，“all” 表示该行为方式适用于所有的扩展。</p>\n<table>\n<thead>\n<tr>\n<th>扩展的行为方式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>require</td>\n<td>指明扩展是必须的，如果该扩展不被支持，预处理器会抛出错误。如果扩展参数为 “all” 则一定会抛出错误。</td>\n</tr>\n<tr>\n<td>enable</td>\n<td>指明扩展是启用的，如果该扩展不被支持，预处理器会发出警告。代码会按照扩展被启用的状态执行，如果扩展参数为“all”则一定会抛出错误。</td>\n</tr>\n<tr>\n<td>warn</td>\n<td>除非是因为该扩展被其它处于启用状态的扩展所需要，否则在使用该扩展时会发出警告。如果扩展参数为 “all” 则无论何时使用扩展都会抛出警告。除此之外，如果扩展不被支持，也会发出警告。</td>\n</tr>\n<tr>\n<td>disable</td>\n<td>指明扩展被禁用，如果使用该扩展会抛出错误。如果扩展参数为 “all”（即默认设置），则不允许使用任何扩展。</td>\n</tr>\n</tbody>\n</table>\n<p>例如，实现不支持 3D 纹理扩展，如果你希望处理器发出警告（此时着色器也会同样被执行，如同实现支持 3D 纹理扩展一样），应当在着色器顶部加入以下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#extension GL_OES_texture_3D : enable</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-_内置变量\">8. 内置变量</h3><h4 id=\"顶点着色器内置变量\">顶点着色器内置变量</h4><p>顶点着色器中有变量 <code>gl_Position</code>，此变量用于写入齐次顶点位置坐标。一个完整的顶点着色器的所有执行命令都应该向此变量写入值。写入的时机可以是着色器执行过程中的任意时间。当被写入之后也同样可以读取此变量的值。在处理顶点之后的图元装配、剪切（clipping）、剔除（culling）等对于图元的固定功能操作中将会使用此值。如果编译器发现 <code>gl_Position</code> 未写入或在写入之前有读取行为将会产生一条诊断信息，但并非所有的情况都能发现。如果执行顶点着色器而未写入 <code>gl_Position</code>，则 <code>gl_Position</code> 的值将是未定义。<br>顶点着色器中有变量 <code>gl_PointSize</code>，此变量用于为顶点着色器写入将要栅格化的点的大小，以像素为单位。<br>顶点着色器中的这些内置变量固有的声明类型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">highp vec4 gl_Position; <span class=\"comment\">// should be written to</span></span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> gl_PointSize; <span class=\"comment\">// may be written to</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>这些变量如果未写入或在在写入之前读取，则取到的值是未定义值。</li>\n<li>如果被写入多次，则在后续步骤中使用的是最后一次写入的值。</li>\n<li>这些内置变量拥有全局作用域。</li>\n<li>OpenGL ES 中没有内置的 attribute 名称。</li>\n</ul>\n<h4 id=\"片段着色器内置变量\">片段着色器内置变量</h4><p>OpenGL ES 渲染管线最后的步骤会对片段着色器的输出进行处理。<br>如果没有使用过 <code>discard</code> 关键字，则片段着色器使用内置变量 <code>gl_FragColor</code> 和 <code>gl_FragData</code> 来向渲染管线输出数据。</p>\n<p>同样，</p>\n<ul>\n<li>在片段着色器中，并非必须要对 <code>gl_FragColor</code> 和 <code>gl_FragData</code> 的值进行写入。</li>\n<li>这些变量可以多次写入值，这样管线中后续步骤使用的是最后一次赋的值。</li>\n<li>写入的值可以再次读取出，如果在写入之前读取则会得到未定义值。</li>\n<li>写入的 <code>gl_FragColor</code> 值定义了后续固定功能管线中使用的片段的颜色。而变量 <code>gl_FragData</code> 是一个数组，写入的数值 <code>gl_FragData[n]</code> 指定了后续固定功能管线中对应于数据 <code>n</code> 的片段数据。</li>\n<li>如果着色器为 <code>gl_FragColor</code> 静态赋值，则可不必为 <code>gl_FragData</code> 赋值，同样如果着色器为 <code>gl_FragData</code> 中任意元素静态赋值，则可不必为 <code>gl_FragColor</code> 赋值。每个着色器应为二者之一赋值，而非二者同时。（在着色器中，如果某个变量在该着色器完成预处理之后，不受运行时的流程控制语句影响，一定会被写入值，则称之为对该变量的静态赋值）。</li>\n<li>如果着色器执行了<code>discard</code> 关键字，则该片段被丢弃，且 <code>gl_FragColor</code> 和 <code>gl_FragData</code> 不再相关。</li>\n<li>片段着色器中有一个只读变量 <code>gl_FragCoord</code>，存储了片段的窗口相对坐标 <code>x</code>、<code>y</code>、<code>z</code> 及 <code>1/w</code>。该值是在顶点处理阶段之后对图元插值生成片段计算所得。<code>z</code> 分量是深度值用来表示片段的深度。</li>\n<li>片段着色器可以访问内置的只读变量 <code>gl_FrontFacing</code> ，如果片段属于正面向前（front-facing）的图元，则该变量的值为 <code>true</code>。该变量可以选取顶点着色器计算出的两个颜色之一以模拟两面光照。</li>\n<li>片段着色器有只读变量 <code>gl_PointCoord</code>。<code>gl_PointCoord</code> 存储的是当前片段所在点图元的二维坐标。点的范围是 0.0 到 1.0。如果当前的图元不是一个点，那么从 <code>gl_PointCoord</code> 读出的值是未定义的。</li>\n</ul>\n<p>片段着色器中这些内置变量固有声明类型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mediump vec4 gl_FragCoord;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> gl_FrontFacing;</span><br><span class=\"line\">mediump vec4 gl_FragColor;</span><br><span class=\"line\">mediump vec4 gl_FragData[gl_MaxDrawBuffers];</span><br><span class=\"line\">mediump vec2 gl_PointCoord;</span><br></pre></td></tr></table></figure>\n<p>但是它们实际的行为并不像是无存储限定符，而是像上边描述的样子。<br>这些内置变量拥有全局作用域。</p>\n<h4 id=\"uniform_状态变量\">uniform 状态变量</h4><p>GLSL 中还有一种内置的 uniform 状态变量,  <code>gl_DepthRange</code> 它用来表明全局深度范围。</p>\n<p>结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> gl_DepthRangeParameters &#123;</span><br><span class=\"line\"> highp <span class=\"keyword\">float</span> near; <span class=\"comment\">// n</span></span><br><span class=\"line\"> highp <span class=\"keyword\">float</span> far; <span class=\"comment\">// f</span></span><br><span class=\"line\"> highp <span class=\"keyword\">float</span> diff; <span class=\"comment\">// f - n</span></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> uniform gl_DepthRangeParameters gl_DepthRange;</span><br></pre></td></tr></table></figure>\n<p>除了  gl_DepthRange 外的所有 uniform 状态常量都已在 GLSL 1.30 中废弃。</p>\n<h3 id=\"9-_内置常量\">9. 内置常量</h3><p>以下是提供给顶点着色器或片段着色器的内置常量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Implementation dependent constants. The example values below</span></span><br><span class=\"line\"><span class=\"comment\">// are the minimum values allowed for these maximums.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxVertexAttribs 表示在vertex shader(顶点着色器)中可用的最大attributes数.这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexAttribs = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxVertexUniformVectors 表示在vertex shader(顶点着色器)中可用的最大uniform vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 128 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexUniformVectors = <span class=\"number\">128</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxVaryingVectors 表示在vertex shader(顶点着色器)中可用的最大varying vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVaryingVectors = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxCombinedTextureImageUnits 表示在vertex shader(顶点着色器)中可用的最大纹理单元数(贴图). 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 甚至可以一个都没有(无法获取顶点纹理)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexTextureImageUnits = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxCombinedTextureImageUnits 表示在 vertex Shader和fragment Shader总共最多支持多少个纹理单元. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxCombinedTextureImageUnits = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxTextureImageUnits 表示在 fragment Shader(片元着色器)中能访问的最大纹理单元数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxTextureImageUnits = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxFragmentUniformVectors 表示在 fragment Shader(片元着色器)中可用的最大uniform vectors数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 16 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxFragmentUniformVectors = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxDrawBuffers 表示可用的drawBuffers数,在OpenGL ES 2.0中这个值为1, 在将来的版本可能会有所变化.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxDrawBuffers = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-_内置函数\">10. 内置函数</h3><p>在 GLSL 中还有很多内置的函数，如下边的例子是片段着色器中用来计算镜面光的代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> nDotL = dot(normal , light);</span><br><span class=\"line\"><span class=\"keyword\">float</span> rDotV = dot(viewDir, (<span class=\"number\">2.0</span> * normal) * nDotL – light);</span><br><span class=\"line\"><span class=\"keyword\">float</span> specular = <span class=\"function\">specularColor * <span class=\"title\">pow</span><span class=\"params\">(rDotV, specularPower)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在上边的代码中，使用内置函数 <code>dot</code> 来计算两个矢量的点乘积，使用内置函数 <code>pow</code> 来完成标量的幂计算。<br>在编写着色程序时，GLSL 中有大量的内置函数供使用。绝大多数的内置函数可用于多种着色器，也有一些只适用于一种特定的着色器。这些内置函数大致可分为以下三类：</p>\n<ul>\n<li><p>将一些必要的硬件功能显露成方便调用的函数，如访问纹理图。着色器无法用语言模拟这些函数。</p>\n</li>\n<li><p>代表一系列琐碎的操作，虽然这些操作可以由用户直接编写完成，但是这些操作都很常用并且可能会有一些硬件支持。编译器处理表达式于汇编指令的映射是非常困难的事情。</p>\n</li>\n<li><p>代表可获得图形硬件加速的操作，如三角函数属于这一分类。</p>\n<p>​</p>\n</li>\n</ul>\n<p>很多函数与一些常见的 C 语言库里的同名函数相似，但这些内置函数不仅支持标量输入，还可以支持矢量输入。应用程序中应当尽量使用这些内置函数而不是有相同计算的自定义代码，因为内置函数很可能是最优化的（如可能是硬件直接支持的）。用户函数可以重载内置函数，但不能将其重定义。</p>\n<p>在下边的内置函数中，函数的输入参数（及相对应的输出）可以是 float、vec2、vec3 或 vec4，则使用 genType 来作为参数。在实际使用一个函数时，所有的参数类型及返回类型必须是一致的。对于 mat 也相似，其具体类型可以是 mat2、mat3 或 mat4。</p>\n<p>参数和返回值的精度限定符不显示。对于纹理函数，返回类型的精度与采样器的类型相匹配。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform lowp sampler2D sampler;</span><br><span class=\"line\">highp vec2 coord;</span><br><span class=\"line\">...</span><br><span class=\"line\">lowp vec4 col = texture2D (sampler, coord); <span class=\"comment\">// texture2D returns lowp</span></span><br></pre></td></tr></table></figure>\n<p>其它内置函数的形式参数的精度限定符则无关。调用这些内置函数将会返回一个匹配输入参数的最高精度级的精度限定符。</p>\n<p>按功能大致可以分成 7 类：</p>\n<h4 id=\"角度和三角函数\">角度和三角函数</h4><p>函数参数是以弧度为单位的角度值。以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>genType radians (genType degrees)</td>\n<td>Converts degrees to radians</td>\n</tr>\n<tr>\n<td>genType degrees (genType radians)</td>\n<td>Converts radians to degrees</td>\n</tr>\n<tr>\n<td>genType sin (genType angle)</td>\n<td>The standard trigonometric sine function.</td>\n</tr>\n<tr>\n<td>genType cos (genType angle)</td>\n<td>The standard trigonometric cosine function.</td>\n</tr>\n<tr>\n<td>genType tan (genType angle)</td>\n<td>The standard trigonometric tangent.</td>\n</tr>\n<tr>\n<td>genType asin (genType x)</td>\n<td>Arc sine. Returns an angle whose sine is x. The range of values returned by this function is[-π/2,π/2] .Results are undefined if ∣x∣ &gt; 1.</td>\n</tr>\n<tr>\n<td>genType acos (genType x)</td>\n<td>Arc cosine. Returns an angle whose cosine is x. The range of values returned by this function is [0, π]. Results are undefined if ∣x∣ &gt; 1.</td>\n</tr>\n<tr>\n<td>genType atan (genType y, genType x)</td>\n<td>Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in . The range of values returned by this function is [−π,π]. Results are undefined if x and y are both 0.</td>\n</tr>\n<tr>\n<td>genType atan (genType y_over_x)</td>\n<td>Arc tangent. Returns an angle whose tangent is y_over_x. The range of values returned by this function is [−π/2,π/2]</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"指数函数\">指数函数</h4><p>以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>genType pow (genType x, genType y)</td>\n<td>Returns x raised to the y power. Results are undefined if x &lt; 0 .Results are undefined if x = 0 and y &lt;= 0.</td>\n</tr>\n<tr>\n<td>genType exp (genType x)</td>\n<td>Returns the natural exponentiation of x.</td>\n</tr>\n<tr>\n<td>genType log (genType x)</td>\n<td>Returns the natural logarithm of x. Results are undefined if x &lt;= 0.</td>\n</tr>\n<tr>\n<td>genType exp2 (genType x)</td>\n<td>Returns 2 raised to the x power.</td>\n</tr>\n<tr>\n<td>genType log2 (genType x)</td>\n<td>Returns the base 2 logarithm of x. Results are undefined if x &lt;= 0.</td>\n</tr>\n<tr>\n<td>genType sqrt (genType x)</td>\n<td>Returns square root of x. Results are undefined if x &lt; 0.</td>\n</tr>\n<tr>\n<td>genType inversesqrt (genType x)</td>\n<td>Returns 1/sqrt(x) . Results are undefined if x &lt;= 0.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"通用函数\">通用函数</h4><p>以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>genType abs (genType x)</td>\n<td>Returns x if x &gt;= 0, otherwise it returns –x.</td>\n</tr>\n<tr>\n<td>genType sign (genType x)</td>\n<td>Returns 1.0 if x &gt; 0, 0.0 if x = 0, or –1.0 if x &lt; 0</td>\n</tr>\n<tr>\n<td>genType floor (genType x)</td>\n<td>Returns a value equal to the nearest integer that is less than or equal to x</td>\n</tr>\n<tr>\n<td>genType ceil (genType x)</td>\n<td>Returns a value equal to the nearest integer that is greater than or equal to x</td>\n</tr>\n<tr>\n<td>genType fract (genType x)</td>\n<td>Returns x – floor (x)</td>\n</tr>\n<tr>\n<td>genType mod (genType x, float y)</td>\n<td>Modulus (modulo). Returns x – y ∗ floor (x/y)</td>\n</tr>\n<tr>\n<td>genType mod (genType x, genType y)</td>\n<td>Modulus. Returns x – y ∗ floor (x/y)</td>\n</tr>\n<tr>\n<td>genType min (genType x, genType y)genType min (genType x, float y)</td>\n<td>Returns y if y &lt; x, otherwise it returns x</td>\n</tr>\n<tr>\n<td>genType max (genType x, genType y) genType max (genType x, float y)</td>\n<td>Returns y if x &lt; y, otherwise it returns x.</td>\n</tr>\n<tr>\n<td>genType clamp (genType x,genType minVal, genType maxVal)genType clamp (genType x, float minVal,float maxVal)</td>\n<td>Returns min (max (x, minVal), maxVal) Results are undefined if minVal &gt; maxVal.</td>\n</tr>\n<tr>\n<td>genType mix (genType x,genType y,genType a)genType mix (genType x,genType y, float a)</td>\n<td>Returns the linear blend of x and y: x<em>(1-a)+y</em>a</td>\n</tr>\n<tr>\n<td>genType step (genType edge, genType x)genType step (float edge, genType x)</td>\n<td>Returns 0.0 if x &lt; edge, otherwise it returns 1.0</td>\n</tr>\n<tr>\n<td>genType smoothstep (genType edge0,genType edge1,genType x)genType smoothstep (float edge0,float edge1,genType x)</td>\n<td>Returns 0.0 if x &lt;= edge0 and 1.0 if x &gt;= edge1 and performs smooth Hermite interpolation between 0 and 1 when edge0 &lt; x &lt; edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: <code>genType t; t = clamp ((x – edge0) / (edge1 – edge0), 0, 1); return t * t * (3 – 2 * t);</code> Results are undefined if edge0 &gt;= edge1.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"几何函数\">几何函数</h4><p>以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float length (genType x)</td>\n<td>Returns the length of vector x.</td>\n</tr>\n<tr>\n<td>float distance (genType p0, genType p1)</td>\n<td>Returns the distance between p0 and p1.</td>\n</tr>\n<tr>\n<td>float dot (genType x, genType y)</td>\n<td>Returns the dot product of x and y.</td>\n</tr>\n<tr>\n<td>vec3 cross (vec3 x, vec3 y)</td>\n<td>Returns the cross product of x and y.</td>\n</tr>\n<tr>\n<td>genType normalize (genType x)</td>\n<td>Returns a vector in the same direction as x but with a length of 1.</td>\n</tr>\n<tr>\n<td>genType faceforward(genType N,genType I,genType Nref)</td>\n<td>If dot(Nref, I) &lt; 0 return N, otherwise return –N.</td>\n</tr>\n<tr>\n<td>genType reflect (genType I, genType N)</td>\n<td>For the incident vector I and surface orientation N,returns the reflection direction: I – 2 ∗ dot(N, I) ∗ N. N must already be normalized in order to achieve the desired result.</td>\n</tr>\n<tr>\n<td>genType refract(genType I, genType N,float eta)</td>\n<td>For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector. The result is computed by <code>k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I)); if (k &lt; 0.0) return genType(0.0) else return eta * I - (eta * dot(N, I) + sqrt(k)) * N</code>. The input parameters for the incident vector I and thesurface normal N must already be normalized to get the desired results.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"矩阵函数\">矩阵函数</h4><table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mat matrixCompMult (mat x, mat y)</td>\n<td>Multiply matrix x by matrix y component-wise, i.e.,result[i][j] is the scalar product of x[i][j] and y[i][j]. Note: to get linear algebraic matrix multiplication, usethe multiply operator (*).</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"矢量关系函数\">矢量关系函数</h4><p>矢量之间的比较关系符号（&lt;, &lt;=, &gt;, &gt;=, ==, !=）被定义（或保留）比较产生一个标量的布尔型结果。使用下边的函数可以得到矢量结果。</p>\n<p>以下的 ”bvec” 指代 ”bvec2”、”bvec3” 或 ”bvec4” 之一，”ivec” 指代 ”ivec2”、”ivec3” 或 ”ivec4” 之一，”vec” 指代 ”vec2”、”vec3” 或 ”vec4”之一。输入参数和返回值各矢量的大小必须一致。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bvec lessThan(vec x, vec y)bvec lessThan(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &lt; y.</td>\n</tr>\n<tr>\n<td>bvec lessThanEqual(vec x, vec y)bvec lessThanEqual(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &lt;= y.</td>\n</tr>\n<tr>\n<td>bvec greaterThan(vec x, vec y)bvec greaterThan(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &gt; y.</td>\n</tr>\n<tr>\n<td>bvec greaterThanEqual(vec x, vec y)bvec greaterThanEqual(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &gt;= y.</td>\n</tr>\n<tr>\n<td>bvec equal(vec x, vec y)bvec equal(ivec x, ivec y)bvec equal(bvec x, bvec y)bvec notEqual(vec x, vec y)bvec notEqual(ivec x, ivec y)bvec notEqual(bvec x, bvec y)</td>\n<td>Returns the component-wise compare of x == y; Returns the component-wise compare of x != y.</td>\n</tr>\n<tr>\n<td>bool any(bvec x)</td>\n<td>Returns true if any component of x is true.</td>\n</tr>\n<tr>\n<td>bool all(bvec x)</td>\n<td>Returns true only if all components of x are true.</td>\n</tr>\n<tr>\n<td>bvec not(bvec x)</td>\n<td>Returns the component-wise logical complement of x.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"纹理查找函数\">纹理查找函数</h4><p>纹理查询的最终目的是从 sampler 中提取指定坐标的颜色信息。</p>\n<p>顶点着色器和片段着色器中都可以使用纹理查找函数。但是在顶点着色器中不会计算细节层次（level of detail），所以二者的纹理查找函数略有不同。</p>\n<p>图像纹理有两种：一种是平面2d纹理，另一种是盒纹理。针对不同的纹理类型有不同访问方法。</p>\n<ul>\n<li>函数中带有 Cube 字样的是指需要传入盒状纹理。</li>\n<li>带有 Proj 字样的是指带投影的版本。</li>\n</ul>\n<p>以下函数只在顶点着色器中可用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DLod</span><span class=\"params\">(sampler2D sampler, vec2 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProjLod</span><span class=\"params\">(sampler2D sampler, vec3 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProjLod</span><span class=\"params\">(sampler2D sampler, vec4 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">textureCubeLod</span><span class=\"params\">(samplerCube sampler, vec3 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>以下函数只在片段着色器中可用:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2D</span><span class=\"params\">(sampler2D sampler, vec2 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec3 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec4 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">textureCube</span><span class=\"params\">(samplerCube sampler, vec3 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在定点着色器和片段着色器中都可用:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2D</span><span class=\"params\">(sampler2D sampler, vec2 coord)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec3 coord)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec4 coord)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">textureCube</span><span class=\"params\">(samplerCube sampler, vec3 coord)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-_自测\">11. 自测</h3><p>下面是官方的一段实例着色器。如果你可以一眼看懂，说明你已经对 GLSL 语言基本掌握了，那么这篇文章就没有白写了~</p>\n<p><strong>Vertex Shader:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 mvp_matrix; \t<span class=\"comment\">// 透视矩阵 * 视图矩阵 * 模型变换矩阵</span></span><br><span class=\"line\">uniform mat3 normal_matrix; <span class=\"comment\">// 法线变换矩阵(用于物体变换后法线跟着变换)</span></span><br><span class=\"line\">uniform vec3 ec_light_dir; \t<span class=\"comment\">// 光照方向</span></span><br><span class=\"line\">attribute vec4 a_vertex; \t<span class=\"comment\">// 顶点坐标</span></span><br><span class=\"line\">attribute vec3 a_normal; \t<span class=\"comment\">// 顶点法线</span></span><br><span class=\"line\">attribute vec2 a_texcoord; \t<span class=\"comment\">// 纹理坐标</span></span><br><span class=\"line\">varying <span class=\"keyword\">float</span> v_diffuse; \t<span class=\"comment\">// 法线与入射光的夹角</span></span><br><span class=\"line\">varying vec2 v_texcoord; \t<span class=\"comment\">// 2d纹理坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 归一化法线</span></span><br><span class=\"line\">  vec3 ec_normal = normalize(normal_matrix * a_normal);</span><br><span class=\"line\">  <span class=\"comment\">// v_diffuse 是法线与光照的夹角.根据向量点乘法则,当两向量长度为1是 乘积即cosθ值</span></span><br><span class=\"line\">  v_diffuse = max(dot(ec_light_dir, ec_normal), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">  v_texcoord = a_texcoord;</span><br><span class=\"line\">  gl_Position = mvp_matrix * a_vertex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Fragment Shader:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\">uniform sampler2D t_reflectance;</span><br><span class=\"line\">uniform vec4 i_ambient;</span><br><span class=\"line\">varying <span class=\"keyword\">float</span> v_diffuse;</span><br><span class=\"line\">varying vec2 v_texcoord;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  vec4 color = texture2D(t_reflectance, v_texcoord);</span><br><span class=\"line\">  <span class=\"comment\">// 这里分解开来是 color*vec3(1,1,1)*v_diffuse + color*i_ambient</span></span><br><span class=\"line\">  <span class=\"comment\">// 色*光*夹角cos + 色*环境光</span></span><br><span class=\"line\">  gl_FragColor = color*(vec4(v_diffuse) + i_ambient);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<blockquote>\n<p>PS：<br>无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。</p>\n</blockquote>","more":"<h3 id=\"7-_预处理\">7. 预处理</h3><p>GLSL 中预处理指令的使用也跟 C 语言的预处理指令相似。以下代码是宏及宏的条件判断：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>注意与 C 语言中不同，<strong>宏不能带参数定义</strong>。使用 <code>#if</code>，<code>#else</code> 和 <code>#elif</code> 可以用来判断宏是否被定义过。以下是一些预先定义好的宏及它们的描述：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__LINE__ \t<span class=\"comment\">// 当前源码中的行号.</span></span><br><span class=\"line\">__FILE__ \t<span class=\"comment\">// OpenGL ES 2.0 中始终为 0.</span></span><br><span class=\"line\">__VERSION__ <span class=\"comment\">// 一个整数,指示当前的 glsl版本. 比如 100 ps: 100 = v1.00</span></span><br><span class=\"line\">GL_ES \t\t<span class=\"comment\">// 如果当前是在 OPGL ES 环境中运行则 GL_ES 被设置成1,一般用来检查当前环境是不是 OPENGL ES.</span></span><br></pre></td></tr></table></figure>\n<p>在着色器编译过程中，<strong><code>#error</code> 指令会触发编译错误并向日志中写入内容。使用 <code>#pragma</code> 指令可以向编译器明确与实现相关的指令</strong>。还有一种与 C 语言中不同的预处理指令是 <strong><code>#version</code></strong>，<strong>它指定了编译着色器的 GLSL 对应版本</strong>，可以在未来更新的版本中据此判断着色器的语言版本，以使用对应的版本来完成编译。这一标记需要写在代码的最开始位置，对于OpenGL ES 2.0 的着色器应将此值设置为 100。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 100 <span class=\"comment\">// OpenGL ES Shading Language v1.00</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>实例:</strong></p>\n<p><strong>Q：1，如何通过判断系统环境，来选择合适的精度：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_ES</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_FRAGMENT_PRECISION_HIGH</span></span><br><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>Q：2，如何自定义宏：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUM 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> NUM==100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>预处理指令中另一个非常重要的是 <code>#extension</code>，<strong>用来控制是否启用某些扩展的功能。</strong>当供应商扩展 GLSL 时，会增加新的语言扩展明细，如 <code>GL_OES_texture_3D</code> 等。着色器必须告知编译器是否允许使用扩展或以怎样的行为方式出现，这就需要使用 <code>#extension</code> 指令来完成，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Set behavior for an extension</span></span><br><span class=\"line\"><span class=\"meta\">#extension extension_name : behavior</span></span><br><span class=\"line\"><span class=\"comment\">// Set behavior for ALL extensions</span></span><br><span class=\"line\"><span class=\"meta\">#extension all : behavior</span></span><br></pre></td></tr></table></figure>\n<p>第一个参数应为扩展的名称或者 “all”，“all” 表示该行为方式适用于所有的扩展。</p>\n<table>\n<thead>\n<tr>\n<th>扩展的行为方式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>require</td>\n<td>指明扩展是必须的，如果该扩展不被支持，预处理器会抛出错误。如果扩展参数为 “all” 则一定会抛出错误。</td>\n</tr>\n<tr>\n<td>enable</td>\n<td>指明扩展是启用的，如果该扩展不被支持，预处理器会发出警告。代码会按照扩展被启用的状态执行，如果扩展参数为“all”则一定会抛出错误。</td>\n</tr>\n<tr>\n<td>warn</td>\n<td>除非是因为该扩展被其它处于启用状态的扩展所需要，否则在使用该扩展时会发出警告。如果扩展参数为 “all” 则无论何时使用扩展都会抛出警告。除此之外，如果扩展不被支持，也会发出警告。</td>\n</tr>\n<tr>\n<td>disable</td>\n<td>指明扩展被禁用，如果使用该扩展会抛出错误。如果扩展参数为 “all”（即默认设置），则不允许使用任何扩展。</td>\n</tr>\n</tbody>\n</table>\n<p>例如，实现不支持 3D 纹理扩展，如果你希望处理器发出警告（此时着色器也会同样被执行，如同实现支持 3D 纹理扩展一样），应当在着色器顶部加入以下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#extension GL_OES_texture_3D : enable</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-_内置变量\">8. 内置变量</h3><h4 id=\"顶点着色器内置变量\">顶点着色器内置变量</h4><p>顶点着色器中有变量 <code>gl_Position</code>，此变量用于写入齐次顶点位置坐标。一个完整的顶点着色器的所有执行命令都应该向此变量写入值。写入的时机可以是着色器执行过程中的任意时间。当被写入之后也同样可以读取此变量的值。在处理顶点之后的图元装配、剪切（clipping）、剔除（culling）等对于图元的固定功能操作中将会使用此值。如果编译器发现 <code>gl_Position</code> 未写入或在写入之前有读取行为将会产生一条诊断信息，但并非所有的情况都能发现。如果执行顶点着色器而未写入 <code>gl_Position</code>，则 <code>gl_Position</code> 的值将是未定义。<br>顶点着色器中有变量 <code>gl_PointSize</code>，此变量用于为顶点着色器写入将要栅格化的点的大小，以像素为单位。<br>顶点着色器中的这些内置变量固有的声明类型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">highp vec4 gl_Position; <span class=\"comment\">// should be written to</span></span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> gl_PointSize; <span class=\"comment\">// may be written to</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>这些变量如果未写入或在在写入之前读取，则取到的值是未定义值。</li>\n<li>如果被写入多次，则在后续步骤中使用的是最后一次写入的值。</li>\n<li>这些内置变量拥有全局作用域。</li>\n<li>OpenGL ES 中没有内置的 attribute 名称。</li>\n</ul>\n<h4 id=\"片段着色器内置变量\">片段着色器内置变量</h4><p>OpenGL ES 渲染管线最后的步骤会对片段着色器的输出进行处理。<br>如果没有使用过 <code>discard</code> 关键字，则片段着色器使用内置变量 <code>gl_FragColor</code> 和 <code>gl_FragData</code> 来向渲染管线输出数据。</p>\n<p>同样，</p>\n<ul>\n<li>在片段着色器中，并非必须要对 <code>gl_FragColor</code> 和 <code>gl_FragData</code> 的值进行写入。</li>\n<li>这些变量可以多次写入值，这样管线中后续步骤使用的是最后一次赋的值。</li>\n<li>写入的值可以再次读取出，如果在写入之前读取则会得到未定义值。</li>\n<li>写入的 <code>gl_FragColor</code> 值定义了后续固定功能管线中使用的片段的颜色。而变量 <code>gl_FragData</code> 是一个数组，写入的数值 <code>gl_FragData[n]</code> 指定了后续固定功能管线中对应于数据 <code>n</code> 的片段数据。</li>\n<li>如果着色器为 <code>gl_FragColor</code> 静态赋值，则可不必为 <code>gl_FragData</code> 赋值，同样如果着色器为 <code>gl_FragData</code> 中任意元素静态赋值，则可不必为 <code>gl_FragColor</code> 赋值。每个着色器应为二者之一赋值，而非二者同时。（在着色器中，如果某个变量在该着色器完成预处理之后，不受运行时的流程控制语句影响，一定会被写入值，则称之为对该变量的静态赋值）。</li>\n<li>如果着色器执行了<code>discard</code> 关键字，则该片段被丢弃，且 <code>gl_FragColor</code> 和 <code>gl_FragData</code> 不再相关。</li>\n<li>片段着色器中有一个只读变量 <code>gl_FragCoord</code>，存储了片段的窗口相对坐标 <code>x</code>、<code>y</code>、<code>z</code> 及 <code>1/w</code>。该值是在顶点处理阶段之后对图元插值生成片段计算所得。<code>z</code> 分量是深度值用来表示片段的深度。</li>\n<li>片段着色器可以访问内置的只读变量 <code>gl_FrontFacing</code> ，如果片段属于正面向前（front-facing）的图元，则该变量的值为 <code>true</code>。该变量可以选取顶点着色器计算出的两个颜色之一以模拟两面光照。</li>\n<li>片段着色器有只读变量 <code>gl_PointCoord</code>。<code>gl_PointCoord</code> 存储的是当前片段所在点图元的二维坐标。点的范围是 0.0 到 1.0。如果当前的图元不是一个点，那么从 <code>gl_PointCoord</code> 读出的值是未定义的。</li>\n</ul>\n<p>片段着色器中这些内置变量固有声明类型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mediump vec4 gl_FragCoord;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> gl_FrontFacing;</span><br><span class=\"line\">mediump vec4 gl_FragColor;</span><br><span class=\"line\">mediump vec4 gl_FragData[gl_MaxDrawBuffers];</span><br><span class=\"line\">mediump vec2 gl_PointCoord;</span><br></pre></td></tr></table></figure>\n<p>但是它们实际的行为并不像是无存储限定符，而是像上边描述的样子。<br>这些内置变量拥有全局作用域。</p>\n<h4 id=\"uniform_状态变量\">uniform 状态变量</h4><p>GLSL 中还有一种内置的 uniform 状态变量,  <code>gl_DepthRange</code> 它用来表明全局深度范围。</p>\n<p>结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> gl_DepthRangeParameters &#123;</span><br><span class=\"line\"> highp <span class=\"keyword\">float</span> near; <span class=\"comment\">// n</span></span><br><span class=\"line\"> highp <span class=\"keyword\">float</span> far; <span class=\"comment\">// f</span></span><br><span class=\"line\"> highp <span class=\"keyword\">float</span> diff; <span class=\"comment\">// f - n</span></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> uniform gl_DepthRangeParameters gl_DepthRange;</span><br></pre></td></tr></table></figure>\n<p>除了  gl_DepthRange 外的所有 uniform 状态常量都已在 GLSL 1.30 中废弃。</p>\n<h3 id=\"9-_内置常量\">9. 内置常量</h3><p>以下是提供给顶点着色器或片段着色器的内置常量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Implementation dependent constants. The example values below</span></span><br><span class=\"line\"><span class=\"comment\">// are the minimum values allowed for these maximums.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxVertexAttribs 表示在vertex shader(顶点着色器)中可用的最大attributes数.这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexAttribs = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxVertexUniformVectors 表示在vertex shader(顶点着色器)中可用的最大uniform vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 128 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexUniformVectors = <span class=\"number\">128</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxVaryingVectors 表示在vertex shader(顶点着色器)中可用的最大varying vectors数. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVaryingVectors = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxCombinedTextureImageUnits 表示在vertex shader(顶点着色器)中可用的最大纹理单元数(贴图). 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 甚至可以一个都没有(无法获取顶点纹理)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexTextureImageUnits = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxCombinedTextureImageUnits 表示在 vertex Shader和fragment Shader总共最多支持多少个纹理单元. 这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxCombinedTextureImageUnits = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxTextureImageUnits 表示在 fragment Shader(片元着色器)中能访问的最大纹理单元数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 8 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxTextureImageUnits = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxFragmentUniformVectors 表示在 fragment Shader(片元着色器)中可用的最大uniform vectors数,这个值的大小取决于 OpenGL ES 在某设备上的具体实现, 不过最低不能小于 16 个.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxFragmentUniformVectors = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gl_MaxDrawBuffers 表示可用的drawBuffers数,在OpenGL ES 2.0中这个值为1, 在将来的版本可能会有所变化.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxDrawBuffers = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-_内置函数\">10. 内置函数</h3><p>在 GLSL 中还有很多内置的函数，如下边的例子是片段着色器中用来计算镜面光的代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> nDotL = dot(normal , light);</span><br><span class=\"line\"><span class=\"keyword\">float</span> rDotV = dot(viewDir, (<span class=\"number\">2.0</span> * normal) * nDotL – light);</span><br><span class=\"line\"><span class=\"keyword\">float</span> specular = <span class=\"function\">specularColor * <span class=\"title\">pow</span><span class=\"params\">(rDotV, specularPower)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在上边的代码中，使用内置函数 <code>dot</code> 来计算两个矢量的点乘积，使用内置函数 <code>pow</code> 来完成标量的幂计算。<br>在编写着色程序时，GLSL 中有大量的内置函数供使用。绝大多数的内置函数可用于多种着色器，也有一些只适用于一种特定的着色器。这些内置函数大致可分为以下三类：</p>\n<ul>\n<li><p>将一些必要的硬件功能显露成方便调用的函数，如访问纹理图。着色器无法用语言模拟这些函数。</p>\n</li>\n<li><p>代表一系列琐碎的操作，虽然这些操作可以由用户直接编写完成，但是这些操作都很常用并且可能会有一些硬件支持。编译器处理表达式于汇编指令的映射是非常困难的事情。</p>\n</li>\n<li><p>代表可获得图形硬件加速的操作，如三角函数属于这一分类。</p>\n<p>​</p>\n</li>\n</ul>\n<p>很多函数与一些常见的 C 语言库里的同名函数相似，但这些内置函数不仅支持标量输入，还可以支持矢量输入。应用程序中应当尽量使用这些内置函数而不是有相同计算的自定义代码，因为内置函数很可能是最优化的（如可能是硬件直接支持的）。用户函数可以重载内置函数，但不能将其重定义。</p>\n<p>在下边的内置函数中，函数的输入参数（及相对应的输出）可以是 float、vec2、vec3 或 vec4，则使用 genType 来作为参数。在实际使用一个函数时，所有的参数类型及返回类型必须是一致的。对于 mat 也相似，其具体类型可以是 mat2、mat3 或 mat4。</p>\n<p>参数和返回值的精度限定符不显示。对于纹理函数，返回类型的精度与采样器的类型相匹配。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform lowp sampler2D sampler;</span><br><span class=\"line\">highp vec2 coord;</span><br><span class=\"line\">...</span><br><span class=\"line\">lowp vec4 col = texture2D (sampler, coord); <span class=\"comment\">// texture2D returns lowp</span></span><br></pre></td></tr></table></figure>\n<p>其它内置函数的形式参数的精度限定符则无关。调用这些内置函数将会返回一个匹配输入参数的最高精度级的精度限定符。</p>\n<p>按功能大致可以分成 7 类：</p>\n<h4 id=\"角度和三角函数\">角度和三角函数</h4><p>函数参数是以弧度为单位的角度值。以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>genType radians (genType degrees)</td>\n<td>Converts degrees to radians</td>\n</tr>\n<tr>\n<td>genType degrees (genType radians)</td>\n<td>Converts radians to degrees</td>\n</tr>\n<tr>\n<td>genType sin (genType angle)</td>\n<td>The standard trigonometric sine function.</td>\n</tr>\n<tr>\n<td>genType cos (genType angle)</td>\n<td>The standard trigonometric cosine function.</td>\n</tr>\n<tr>\n<td>genType tan (genType angle)</td>\n<td>The standard trigonometric tangent.</td>\n</tr>\n<tr>\n<td>genType asin (genType x)</td>\n<td>Arc sine. Returns an angle whose sine is x. The range of values returned by this function is[-π/2,π/2] .Results are undefined if ∣x∣ &gt; 1.</td>\n</tr>\n<tr>\n<td>genType acos (genType x)</td>\n<td>Arc cosine. Returns an angle whose cosine is x. The range of values returned by this function is [0, π]. Results are undefined if ∣x∣ &gt; 1.</td>\n</tr>\n<tr>\n<td>genType atan (genType y, genType x)</td>\n<td>Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in . The range of values returned by this function is [−π,π]. Results are undefined if x and y are both 0.</td>\n</tr>\n<tr>\n<td>genType atan (genType y_over_x)</td>\n<td>Arc tangent. Returns an angle whose tangent is y_over_x. The range of values returned by this function is [−π/2,π/2]</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"指数函数\">指数函数</h4><p>以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>genType pow (genType x, genType y)</td>\n<td>Returns x raised to the y power. Results are undefined if x &lt; 0 .Results are undefined if x = 0 and y &lt;= 0.</td>\n</tr>\n<tr>\n<td>genType exp (genType x)</td>\n<td>Returns the natural exponentiation of x.</td>\n</tr>\n<tr>\n<td>genType log (genType x)</td>\n<td>Returns the natural logarithm of x. Results are undefined if x &lt;= 0.</td>\n</tr>\n<tr>\n<td>genType exp2 (genType x)</td>\n<td>Returns 2 raised to the x power.</td>\n</tr>\n<tr>\n<td>genType log2 (genType x)</td>\n<td>Returns the base 2 logarithm of x. Results are undefined if x &lt;= 0.</td>\n</tr>\n<tr>\n<td>genType sqrt (genType x)</td>\n<td>Returns square root of x. Results are undefined if x &lt; 0.</td>\n</tr>\n<tr>\n<td>genType inversesqrt (genType x)</td>\n<td>Returns 1/sqrt(x) . Results are undefined if x &lt;= 0.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"通用函数\">通用函数</h4><p>以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>genType abs (genType x)</td>\n<td>Returns x if x &gt;= 0, otherwise it returns –x.</td>\n</tr>\n<tr>\n<td>genType sign (genType x)</td>\n<td>Returns 1.0 if x &gt; 0, 0.0 if x = 0, or –1.0 if x &lt; 0</td>\n</tr>\n<tr>\n<td>genType floor (genType x)</td>\n<td>Returns a value equal to the nearest integer that is less than or equal to x</td>\n</tr>\n<tr>\n<td>genType ceil (genType x)</td>\n<td>Returns a value equal to the nearest integer that is greater than or equal to x</td>\n</tr>\n<tr>\n<td>genType fract (genType x)</td>\n<td>Returns x – floor (x)</td>\n</tr>\n<tr>\n<td>genType mod (genType x, float y)</td>\n<td>Modulus (modulo). Returns x – y ∗ floor (x/y)</td>\n</tr>\n<tr>\n<td>genType mod (genType x, genType y)</td>\n<td>Modulus. Returns x – y ∗ floor (x/y)</td>\n</tr>\n<tr>\n<td>genType min (genType x, genType y)genType min (genType x, float y)</td>\n<td>Returns y if y &lt; x, otherwise it returns x</td>\n</tr>\n<tr>\n<td>genType max (genType x, genType y) genType max (genType x, float y)</td>\n<td>Returns y if x &lt; y, otherwise it returns x.</td>\n</tr>\n<tr>\n<td>genType clamp (genType x,genType minVal, genType maxVal)genType clamp (genType x, float minVal,float maxVal)</td>\n<td>Returns min (max (x, minVal), maxVal) Results are undefined if minVal &gt; maxVal.</td>\n</tr>\n<tr>\n<td>genType mix (genType x,genType y,genType a)genType mix (genType x,genType y, float a)</td>\n<td>Returns the linear blend of x and y: x<em>(1-a)+y</em>a</td>\n</tr>\n<tr>\n<td>genType step (genType edge, genType x)genType step (float edge, genType x)</td>\n<td>Returns 0.0 if x &lt; edge, otherwise it returns 1.0</td>\n</tr>\n<tr>\n<td>genType smoothstep (genType edge0,genType edge1,genType x)genType smoothstep (float edge0,float edge1,genType x)</td>\n<td>Returns 0.0 if x &lt;= edge0 and 1.0 if x &gt;= edge1 and performs smooth Hermite interpolation between 0 and 1 when edge0 &lt; x &lt; edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: <code>genType t; t = clamp ((x – edge0) / (edge1 – edge0), 0, 1); return t * t * (3 – 2 * t);</code> Results are undefined if edge0 &gt;= edge1.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"几何函数\">几何函数</h4><p>以下内置函数是按逐个分量进行操作，但按单个分量操作进行描述。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float length (genType x)</td>\n<td>Returns the length of vector x.</td>\n</tr>\n<tr>\n<td>float distance (genType p0, genType p1)</td>\n<td>Returns the distance between p0 and p1.</td>\n</tr>\n<tr>\n<td>float dot (genType x, genType y)</td>\n<td>Returns the dot product of x and y.</td>\n</tr>\n<tr>\n<td>vec3 cross (vec3 x, vec3 y)</td>\n<td>Returns the cross product of x and y.</td>\n</tr>\n<tr>\n<td>genType normalize (genType x)</td>\n<td>Returns a vector in the same direction as x but with a length of 1.</td>\n</tr>\n<tr>\n<td>genType faceforward(genType N,genType I,genType Nref)</td>\n<td>If dot(Nref, I) &lt; 0 return N, otherwise return –N.</td>\n</tr>\n<tr>\n<td>genType reflect (genType I, genType N)</td>\n<td>For the incident vector I and surface orientation N,returns the reflection direction: I – 2 ∗ dot(N, I) ∗ N. N must already be normalized in order to achieve the desired result.</td>\n</tr>\n<tr>\n<td>genType refract(genType I, genType N,float eta)</td>\n<td>For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector. The result is computed by <code>k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I)); if (k &lt; 0.0) return genType(0.0) else return eta * I - (eta * dot(N, I) + sqrt(k)) * N</code>. The input parameters for the incident vector I and thesurface normal N must already be normalized to get the desired results.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"矩阵函数\">矩阵函数</h4><table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mat matrixCompMult (mat x, mat y)</td>\n<td>Multiply matrix x by matrix y component-wise, i.e.,result[i][j] is the scalar product of x[i][j] and y[i][j]. Note: to get linear algebraic matrix multiplication, usethe multiply operator (*).</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"矢量关系函数\">矢量关系函数</h4><p>矢量之间的比较关系符号（&lt;, &lt;=, &gt;, &gt;=, ==, !=）被定义（或保留）比较产生一个标量的布尔型结果。使用下边的函数可以得到矢量结果。</p>\n<p>以下的 ”bvec” 指代 ”bvec2”、”bvec3” 或 ”bvec4” 之一，”ivec” 指代 ”ivec2”、”ivec3” 或 ”ivec4” 之一，”vec” 指代 ”vec2”、”vec3” 或 ”vec4”之一。输入参数和返回值各矢量的大小必须一致。</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bvec lessThan(vec x, vec y)bvec lessThan(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &lt; y.</td>\n</tr>\n<tr>\n<td>bvec lessThanEqual(vec x, vec y)bvec lessThanEqual(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &lt;= y.</td>\n</tr>\n<tr>\n<td>bvec greaterThan(vec x, vec y)bvec greaterThan(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &gt; y.</td>\n</tr>\n<tr>\n<td>bvec greaterThanEqual(vec x, vec y)bvec greaterThanEqual(ivec x, ivec y)</td>\n<td>Returns the component-wise compare of x &gt;= y.</td>\n</tr>\n<tr>\n<td>bvec equal(vec x, vec y)bvec equal(ivec x, ivec y)bvec equal(bvec x, bvec y)bvec notEqual(vec x, vec y)bvec notEqual(ivec x, ivec y)bvec notEqual(bvec x, bvec y)</td>\n<td>Returns the component-wise compare of x == y; Returns the component-wise compare of x != y.</td>\n</tr>\n<tr>\n<td>bool any(bvec x)</td>\n<td>Returns true if any component of x is true.</td>\n</tr>\n<tr>\n<td>bool all(bvec x)</td>\n<td>Returns true only if all components of x are true.</td>\n</tr>\n<tr>\n<td>bvec not(bvec x)</td>\n<td>Returns the component-wise logical complement of x.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"纹理查找函数\">纹理查找函数</h4><p>纹理查询的最终目的是从 sampler 中提取指定坐标的颜色信息。</p>\n<p>顶点着色器和片段着色器中都可以使用纹理查找函数。但是在顶点着色器中不会计算细节层次（level of detail），所以二者的纹理查找函数略有不同。</p>\n<p>图像纹理有两种：一种是平面2d纹理，另一种是盒纹理。针对不同的纹理类型有不同访问方法。</p>\n<ul>\n<li>函数中带有 Cube 字样的是指需要传入盒状纹理。</li>\n<li>带有 Proj 字样的是指带投影的版本。</li>\n</ul>\n<p>以下函数只在顶点着色器中可用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DLod</span><span class=\"params\">(sampler2D sampler, vec2 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProjLod</span><span class=\"params\">(sampler2D sampler, vec3 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProjLod</span><span class=\"params\">(sampler2D sampler, vec4 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">textureCubeLod</span><span class=\"params\">(samplerCube sampler, vec3 coord, <span class=\"keyword\">float</span> lod)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>以下函数只在片段着色器中可用:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2D</span><span class=\"params\">(sampler2D sampler, vec2 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec3 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec4 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">textureCube</span><span class=\"params\">(samplerCube sampler, vec3 coord, <span class=\"keyword\">float</span> bias)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在定点着色器和片段着色器中都可用:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2D</span><span class=\"params\">(sampler2D sampler, vec2 coord)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec3 coord)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">texture2DProj</span><span class=\"params\">(sampler2D sampler, vec4 coord)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">textureCube</span><span class=\"params\">(samplerCube sampler, vec3 coord)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-_自测\">11. 自测</h3><p>下面是官方的一段实例着色器。如果你可以一眼看懂，说明你已经对 GLSL 语言基本掌握了，那么这篇文章就没有白写了~</p>\n<p><strong>Vertex Shader:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 mvp_matrix; \t<span class=\"comment\">// 透视矩阵 * 视图矩阵 * 模型变换矩阵</span></span><br><span class=\"line\">uniform mat3 normal_matrix; <span class=\"comment\">// 法线变换矩阵(用于物体变换后法线跟着变换)</span></span><br><span class=\"line\">uniform vec3 ec_light_dir; \t<span class=\"comment\">// 光照方向</span></span><br><span class=\"line\">attribute vec4 a_vertex; \t<span class=\"comment\">// 顶点坐标</span></span><br><span class=\"line\">attribute vec3 a_normal; \t<span class=\"comment\">// 顶点法线</span></span><br><span class=\"line\">attribute vec2 a_texcoord; \t<span class=\"comment\">// 纹理坐标</span></span><br><span class=\"line\">varying <span class=\"keyword\">float</span> v_diffuse; \t<span class=\"comment\">// 法线与入射光的夹角</span></span><br><span class=\"line\">varying vec2 v_texcoord; \t<span class=\"comment\">// 2d纹理坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 归一化法线</span></span><br><span class=\"line\">  vec3 ec_normal = normalize(normal_matrix * a_normal);</span><br><span class=\"line\">  <span class=\"comment\">// v_diffuse 是法线与光照的夹角.根据向量点乘法则,当两向量长度为1是 乘积即cosθ值</span></span><br><span class=\"line\">  v_diffuse = max(dot(ec_light_dir, ec_normal), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">  v_texcoord = a_texcoord;</span><br><span class=\"line\">  gl_Position = mvp_matrix * a_vertex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Fragment Shader:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\">uniform sampler2D t_reflectance;</span><br><span class=\"line\">uniform vec4 i_ambient;</span><br><span class=\"line\">varying <span class=\"keyword\">float</span> v_diffuse;</span><br><span class=\"line\">varying vec2 v_texcoord;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  vec4 color = texture2D(t_reflectance, v_texcoord);</span><br><span class=\"line\">  <span class=\"comment\">// 这里分解开来是 color*vec3(1,1,1)*v_diffuse + color*i_ambient</span></span><br><span class=\"line\">  <span class=\"comment\">// 色*光*夹角cos + 色*环境光</span></span><br><span class=\"line\">  gl_FragColor = color*(vec4(v_diffuse) + i_ambient);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"iOS开发小记","title":"Photo Editing Extension 详解 (附带应用滤镜Demo)","date":"2016-03-12T13:34:35.000Z","_content":"\n> extension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。允许应用帮助系统扩展自定义功能，去实现一个特定作用域的任务，如照片编辑、自定义键盘、通知中心、Action动作、Share分享等。 这对于一向封闭的iOS来说, 无疑是一大福音。\n\n<!--more-->\n\n虽然iOS8离现在比较远了, 分享 **\"Extension \"** 相关的文章也很多了, 不过对于**\"Photo Editing\"**, 我觉得还是有必要来讲一讲的, 一来多数教程介绍Extension 的时候都是拿**Widgets**举例, 再有**Photo Editing**是可自定义内容最丰富的一个, 你完全可以把它当作App里额外的一个界面来完成。\n\n正好前一阵在实习的时候, 实现过相关功能, 总结一番也是极好。\n\n\n\n# 1. 相关概念\n\n## 1.1 Extension Point\n\n系统中支持Extension 的区域，Extension 的类别也是据此区分的，iOS上共有Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard几种，其中Today中的extension又被称为Widget。\n\n- **今日(Today，又称为Widget)**：可以快速获取更新或者在通知中心的今日视图中执行一项快速任务。\n- **共享(Share)**：发布到一个共享网站或者与其它应用程序共享内容。\n- **动作(Action)**：在另一个应用程序的上下文中操作或查看内容。\n- **照片编辑(Photo Editing)**（仅限于iOS）：在照片应用程序中编辑照片或视频。\n- **查找器**（仅限于iOS）：在查找器中直接显示文件同步的状态信息。\n- **文档提供程序(Storage Provider)**（仅限于iOS）：提供对文件库的访问和管理。\n- **自定义键盘(Custom keyboard)**（仅限于iOS）：用自定义键盘替代iOS系统键盘，并用于所有的应用程序中。\n\n由于每个扩展点都有与之相关的使用策略和专门的API，开发人员必须为他们想要提供的那种功能选择恰当的扩展点, 每种Extension Point的使用方式和适合干的活都不一样，因此不存在通用的Extension 。\n\n例如，在默认情况下，键盘Extension“[不能访问网络，而且不能与其包含应用程序共享同一容器](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/Keyboard.html)”。通过对Extension进行恰当的配置，这样的限制可以移除，但开发人员仍然需要遵守苹果应用商店审查指南和iOS开发者计划许可协议中的具体的网络键盘指南。\n\n\n\n![Extension Point](http://img.my.csdn.net/uploads/201512/13/1449993990_7598.png)\n\n## 1.2 App Extension\n\n即为本文所说的Extension。Extension并不是一个独立的app，它有一个包含在App Bundle中的独立Bundle，Extension的Bundle后缀名是.appex。其生命周期也和普通App不同，这些后文将会详述。\n\nExtension不能单独存在，必须有一个包含它的Containing App。\n\n另外，Extension需要用户手动激活，不同的Extension激活方式也不同。\n\n比如：\n\n- Today中的widget需要在Today中激活和关闭；\n- Custom keyboard需要在设置中进行相关设置；\n- Photo Editing需要在使用照片时在照片管理器中激活或关闭；\n- Storage Provider可以在选择文件时出现；\n- Share和Action可以在任何应用里被激活，但前提是开发者需要设置Activation Rules，以确定extension需要在合适出现。\n\n## 1.3 Containing App\n\n尽管苹果开放了Extension，但是在iOS中Extension并不能单独存在，要想提交到AppStore，必须将Extension包含在一个app中提交，并且App的实现部分不能为空, 这个包含Extension的App就叫Containing App。\n\nExtension会随着Containing App的安装而安装，同时随着Containing App的卸载而卸载。\n\n## 1.4 Host App\n\n能够调起Extension的App被称为Host App。\n\n比如:\n\n- widget的Host App就是Today。\n- Photo Editing 的 Host App 就是 Photos\n\n\n\n# 2. Extension和Containing App、Host App通信\n\n## 2.1 Extension和Host App\n\nExtension和Host App之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别：\n\n``` objc\n@interface UIViewController(NSExtensionAdditions) <NSExtensionRequestHandling> \n\n// Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request. \n@property (nonatomic,readonly,retain) NSExtensionContext *extensionContext NS_AVAILABLE_IOS(8_0); \n\n@end \n```\n\n实际上extension和Host App之间是通过IPC（interprocess communication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。\n\n\n\n## 2.2 Containing App和Host App\n\n他们之间没有任何直接关系，也从来不需要通信。\n\n## 2.3 Extension和Containing App\n\n这二者之间的关系最复杂，纠纠缠缠扯不清关系。\n\n众所周知，[每个iOS应用程序都有自己的沙箱](https://developer.apple.com/library/ios/documentation/iphone/conceptual/iphoneosprogrammingguide/TheiOSEnvironment/TheiOSEnvironment.html)。[通过Mac苹果应用商店分发的OS X应用程序](https://developer.apple.com/library/mac/documentation/security/conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html)也有类似的要求，不过许多OS X应用程序是在Mac苹果应用商店之外分发的，并不需要遵守这一沙箱要求。\n\n沙箱是苹果iOS安全策略的基石之一。沙箱是为了限制应用程序对文件、首选项、网络资源、硬件等的访问，具体来讲，其目的是为了限制受损的应用程序可能对系统造成的损害。\n\n考虑到并不是所有可以用在应用程序中的API都可以用在Extension中，所以与通常的应用程序相比，App Extension运行在有更多限制的沙箱中。不能在Extension中使用的API标记为不可用宏，如NS_EXTENSIONS_UNAVAILABLE，它会在链接时导致失败。\n\n此外，对于Extension与其它应用程序之间的通信，苹果有几项强制规定：\n\n1. 调用Extension的应用程序即主应用程序不能启动Extension；只有系统可以启动Extension。\n2. 当Extension启动后，主应用程序就和它直接通信。\n3. 主应用程序永远不和包含应用程序直接通信。\n4. Extension不是一个应用程序，但它由系统生成，并有它自己单独的进程。\n5. 为了在包含应用程序和它的Extension之间共享数据，包含应用程序及其Extension都必须是应用程序组的一部分。对于应用程序组的其中两个成员，部分数据可以在两者沙箱之外的第三个容器中共享。\n\n正如Ars Technica的Andrew Cunningham总结的那样，这些规则的最终结果主要是一个应用程序不能进入另一个应用程序的沙箱。这与Android相反，在Android上，[内容提供程序](http://developer.android.com/guide/topics/providers/content-providers.html)和[解析程序](http://developer.android.com/reference/android/content/ContentResolver.html)仍然可以一起工作来为应用程序提供对其它应用程序中数据的访问。\n\n\n\n**不能直接通信:**\n\n首先，尽管Extension的bundle是放在Containing App的bundle中，但是他们是两个完全独立的进程，之间不能直接通信。不过Extension可以通过openURL的方式启动Containing App（当然也能启动其它App），不过必须通过extensionContext借助host app来实现：\n\n``` objc\n//通过openURL的方式启动Containing APP \n- (void)openURLContainingAPP \n{ \n    [self.extensionContext openURL:[NSURL URLWithString:@\"appextension://123\"] \n                 completionHandler:^(BOOL success) { \n                     NSLog(@\"open url result:%d\",success); \n                 }]; \n} \n```\n\n**Extension中是无法直接使用openURL的。**\n\n**可以共享Shared Resources:**\n\nExtension和Containing App可以共同读写一个被称为Shared Resources的存储区域，这是通过App Groups实现的，后文将会详述。\n\n三者间的关系可以通过官网给的两张图片形象地说明：\n\n ![Extension_Containing_App_1](http://img.my.csdn.net/uploads/201512/13/1449995608_4851.png)\n\n![Extension_Containing_App_2](http://img.my.csdn.net/uploads/201512/13/1449995608_8648.png)\n\n\n\n\n\n# 3. 数据共享\n\n**App Groups**这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一Group下的App共享同一份读写空间，以实现数据共享。\n\n\n\n## 3.1 功能开启\n\n为了便于后续操作，请先确保你的开发者账号在Xcode上处于登录状态。\n\n### 3.1.1 在App中开启\n\nApp Groups位于：\n\nTARGETS-->AppExtensionDemo-->Capabilities-->App Groups`\n\n找到以后，将App Groups右上角的开关打开，然后选择添加Groups，正规的命名规则应该是：group.com.company.app。\n\n添加成功以后如下图所示：\n\n![App_Groups](http://img.my.csdn.net/uploads/201512/13/1449996631_7873.jpeg)\n\n\n\n### 3.1.2 在Extension中开启\n\n开启方式和App中一样，需要注意的是必须保证这里地App Groups名称和App中的相同。\n\n\n\n## 3.2 extension和containing app数据共享\n\nApp Groups给我们提供了同一Group内App可以共同读写的区域，可以通过以下方式实现数据共享：\n\n### 3.2.1 通过NSUserDefaults共享数据\n\n**存数据**\n\n通过以下方式向NSUserDefaults中保存数据：\n\n``` objc\n- (void)saveTextByNSUserDefaults\n{\n    NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@\"group.com.xx.test\"];\n    [shared setObject:_textField.text forKey:@\"test\"];\n    [shared synchronize];\n}\n```\n\n需要注意的是：\n\n1. 保存数据的时候必须指明group id；\n2. 而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见[Property List Programming Guide](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PropertyLists/AboutPropertyLists/AboutPropertyLists.html)。\n3. 为了防止出现数据同步问题，不要忘记调用`[shared synchronize];`\n\n**读数据**\n\n对应的读取数据方式：\n\n``` objc\n- (NSString *)readDataFromNSUserDefaults\n{\n    NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@\"group.com.xx.test\"];\n    NSString *value = [shared valueForKey:@\"test\"];\n\n    return value;\n}\n```\n\n### 3.2.1 通过NSFileManager共享数据\n\nNSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。\n\n**存数据**\n\n``` objc\n- (BOOL)saveTextByNSFileManager\n{\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    containerURL = [containerURL URLByAppendingPathComponent:@\"Library/Caches/good\"];\n\n    NSString *value = _textField.text;\n    BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&err];\n    if (!result) {\n        NSLog(@\"%@\",err);\n    } else {\n        NSLog(@\"save value:%@ success.\",value);\n    }\n\n    return result;\n}\n```\n\n**读数据**\n\n``` objc\n- (NSString *)readTextByNSFileManager\n{\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    containerURL = [containerURL URLByAppendingPathComponent:@\"Library/Caches/good\"];\n    NSString *value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&err];\n\n    return value;\n}\n```\n\nPS:\n\n两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步。\n\n\n\n## 3.3 动态加载, 资源共享\n\n这个感兴趣的可以看下, 无关紧要~\n\n和数据共享类似，Extension和Containing App很自然地会有一些业务逻辑上可以共用的代码，这时可以通过iOS8中刚开放使用的framework实现。苹果在[App Extension Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1)中是这样描述的：\n\n> In iOS 8.0 and later, you can use an embedded framework to share code between your extension and its containing app. For example, if you develop image-processing code that you want both your Photo Editing extension and its containing app to share, you can put the code into a framework and embed it in both targets.\n\n即将framework分别嵌入到extension和containing app的target中实现代码共享。但这样岂不是需要分别要将framework分别copy到extension和containing app的main bundle中？\n\n参考extension和containing app数据共享，我试想能不能将framework只保存一份放在App Groups区域？\n\n### 3.3.1 copy framework到App Groups\n\n在app首次启动的时候将framework放到App Groups区域：\n\n``` objc\n- (BOOL)copyFrameworkFromMainBundleToAppGroup\n{\n    NSFileManager *manager = [NSFileManager defaultManager];\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    NSString *sorPath = [NSString stringWithFormat:@\"%@/Dylib.framework\",[[NSBundle mainBundle] bundlePath]];\n    NSString *desPath = [NSString stringWithFormat:@\"%@/Library/Caches/Dylib.framework\",containerURL.path];\n\n    BOOL removeResult = [manager removeItemAtPath:desPath error:&err];\n    if (!removeResult) {\n        NSLog(@\"%@\",err);\n    } else {\n        NSLog(@\"remove success.\");\n    }\n\n    BOOL copyResult = [[NSFileManager defaultManager] copyItemAtPath:sorPath toPath:desPath error:&err];\n    if (!copyResult) {\n        NSLog(@\"%@\",err);\n    } else {\n        NSLog(@\"copy success.\");\n    }\n\n    return copyResult;\n}\n```\n\n\n\n### 3.3.2 使用framework\n\n``` objc\n- (BOOL)loadFrameworkInAppGroup\n{\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    NSString *desPath = [NSString stringWithFormat:@\"%@/Library/Caches/Dylib.framework\",containerURL.path];\n    NSBundle *bundle = [NSBundle bundleWithPath:desPath];\n    BOOL result = [bundle loadAndReturnError:&err];\n    if (result) {\n        Class root = NSClassFromString(@\"Person\");\n        if (root) {\n            Person *person = [[root alloc] init];\n            if (person) {\n                [person run];\n            }\n        }\n    } else {\n        NSLog(@\"%@\",err);\n    }\n\n    return result;\n}\n```\n\n经过测试，竟然能够加载成功。\n\n对比一下, 有如下总结: \n\n\n\n主要验证了两种方式:\n\n1. 导入公用framework到项目中, 只有**containing app** 的 **Link Binary With Libraries**添加对应framework, extension运行时动态加载framework。\n2. **containing app** 和 **extension**的**Link Binary With Libraries**分别链接公用framework, (Compile Sources 只包含在framework这个target中)\n\n以上两种方式都可以做到公用资源。 区别如下:\n\n1. 方式一需要App Groups, 共享资源。 方式二不需要。\n   \n2. 方式一需要**containing app**先启动把, 把数据copy到App Groups中, **entension**才能加载到。 方式二不需要。\n   \n3. 方式一不能直接初始化类, 比如:\n   \n   ``` objc\n   #import <TestFrameWork/FilterImage.h>\n   \n   FilterImage *filter = [[FilterImage alloc] init];\n   \n   将会报错:\n   \n   Undefined symbols for architecture x86_64:\n     \"_OBJC_CLASS_$_FilterImage\", referenced from:\n         objc-class-ref in PhotoEditingViewController.o\n   ld: symbol(s) not found for architecture x86_64\n   clang: error: linker command failed with exit code 1 (use -v to see invocation)\n   ```\n   \n   需要用这样的方式:\n   \n   ``` objc\n       Class root = NSClassFromString(@\"FilterImage\");\n       if (root) {\n           FilterImage *filter = [[root alloc] init];\n           NSString *nameLUT = [NSString stringWithFormat:@\"%@/TestFrameWork.bundle/images/filter_lut_%d\", desPath, 2];\n   \n           self.imageView.image = [filter filterImage:self.input.displaySizeImage imageName:nameLUT];\n       }\n   ```\n   \n   方式二可以直接使用。 (#import \"FilterImage.h\")\n   \n   ​\n   \n   对比了一下导出包的大小。\n   \n   写了3个Demo, \n   \n   1. 方式一, 动态加载          12.1M\n   2. 方式二，静态链接         23.7M\n   3. 方式三，只包含framework，没有extension   11.2M\n\n\n\n# 4. 生命周期\n\n下图来自官方文档，它详细描述了Extension App的生命周期 ![Life_Cycle](http://img.my.csdn.net/uploads/201512/13/1449996016_4664.png)\n\n**开始**\n\n在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。\n\n**执行任务**\n\n在extension启动以后，开始执行它的使命。\n\n**终止**\n\n在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。\n\n由此可见，extension就是为了任务而生！\n\n\n\n# 5. Photo Editing使用滤镜实战\n\n这里因为时间关系, 就直接采用 **Apple** 官方例子, 不再重新写了。如果实践过程中, 有遇到任何问题, 欢迎留言或者其他方式与我交流~\n\n\n\nDemo下载地址: ![](http://download.csdn.net/images/minetype/zip.gif)Photo Editing Extension Demo  \n\n\n\n这里有几点需要注意的。\n\n1. 因为Host App是Photos, 所以我们的Extension必须适配横竖屏, 因为它的状态是跟着Host App变的, 而不是Containing App。 至于横竖屏的适配, 建议采用Size Class, 然后监听缩放模式, 来适配屏幕\n   \n   ​\n   \n   ``` objc\n   #pragma mark - UIContentContainer\n   - (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection\n                 withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator\n   {\n       [super willTransitionToTraitCollection:newCollection\n                    withTransitionCoordinator:coordinator];\n       [coordinator animateAlongsideTransition:^(id <UIViewControllerTransitionCoordinatorContext> context) {\n          // 横屏处理\n           }\n           else {\n            // 竖屏处理\n           }\n           [self.view setNeedsLayout];\n       } completion:nil];\n   }\n   ```\n   \n   同样, 需要获取初始状态来处理。\n   \n   ​\n   \n   ``` objc\n       if (self.traitCollection.verticalSizeClass == UIUserInterfaceSizeClassCompact) {\n           //To Do: modify something for compact vertical size\n       }\n       else {\n           //To Do: modify something for other vertical size\n       }\n   ```\n   \n2. 如果第三方库用Pod来管理的话, 需要修改pod的target, 以及添加链接。\n   \n   `Build Settings — > Other Linker Flags    **-l\"Pods-MBProgressHUD\"**`\n\n\n\n# 6. 相关资料\n\n[App Extension Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1)\n\n[App Extensions for iOS 8 in Depth](http://www.infoq.com/news/2014/07/apple-ios8-app-extensions)\n\n[WWDC2014之App Extensions学习笔记](http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/)\n\n[Sample Photo Editing Extension](https://developer.apple.com/library/ios/samplecode/SamplePhotoEditingExtension/Introduction/Intro.html#//apple_ref/doc/uid/TP40014576)","source":"_posts/Photo-Editing-Extension.md","raw":"layout: \"iOS开发小记\"\n\ntitle: Photo Editing Extension 详解 (附带应用滤镜Demo)\n\ndate: 2016-03-12 21:34:35\n\ntags:\n\n- iOS开发\n- 教程\n\n------\n\n> extension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。允许应用帮助系统扩展自定义功能，去实现一个特定作用域的任务，如照片编辑、自定义键盘、通知中心、Action动作、Share分享等。 这对于一向封闭的iOS来说, 无疑是一大福音。\n\n<!--more-->\n\n虽然iOS8离现在比较远了, 分享 **\"Extension \"** 相关的文章也很多了, 不过对于**\"Photo Editing\"**, 我觉得还是有必要来讲一讲的, 一来多数教程介绍Extension 的时候都是拿**Widgets**举例, 再有**Photo Editing**是可自定义内容最丰富的一个, 你完全可以把它当作App里额外的一个界面来完成。\n\n正好前一阵在实习的时候, 实现过相关功能, 总结一番也是极好。\n\n\n\n# 1. 相关概念\n\n## 1.1 Extension Point\n\n系统中支持Extension 的区域，Extension 的类别也是据此区分的，iOS上共有Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard几种，其中Today中的extension又被称为Widget。\n\n- **今日(Today，又称为Widget)**：可以快速获取更新或者在通知中心的今日视图中执行一项快速任务。\n- **共享(Share)**：发布到一个共享网站或者与其它应用程序共享内容。\n- **动作(Action)**：在另一个应用程序的上下文中操作或查看内容。\n- **照片编辑(Photo Editing)**（仅限于iOS）：在照片应用程序中编辑照片或视频。\n- **查找器**（仅限于iOS）：在查找器中直接显示文件同步的状态信息。\n- **文档提供程序(Storage Provider)**（仅限于iOS）：提供对文件库的访问和管理。\n- **自定义键盘(Custom keyboard)**（仅限于iOS）：用自定义键盘替代iOS系统键盘，并用于所有的应用程序中。\n\n由于每个扩展点都有与之相关的使用策略和专门的API，开发人员必须为他们想要提供的那种功能选择恰当的扩展点, 每种Extension Point的使用方式和适合干的活都不一样，因此不存在通用的Extension 。\n\n例如，在默认情况下，键盘Extension“[不能访问网络，而且不能与其包含应用程序共享同一容器](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/Keyboard.html)”。通过对Extension进行恰当的配置，这样的限制可以移除，但开发人员仍然需要遵守苹果应用商店审查指南和iOS开发者计划许可协议中的具体的网络键盘指南。\n\n\n\n![Extension Point](http://img.my.csdn.net/uploads/201512/13/1449993990_7598.png)\n\n## 1.2 App Extension\n\n即为本文所说的Extension。Extension并不是一个独立的app，它有一个包含在App Bundle中的独立Bundle，Extension的Bundle后缀名是.appex。其生命周期也和普通App不同，这些后文将会详述。\n\nExtension不能单独存在，必须有一个包含它的Containing App。\n\n另外，Extension需要用户手动激活，不同的Extension激活方式也不同。\n\n比如：\n\n- Today中的widget需要在Today中激活和关闭；\n- Custom keyboard需要在设置中进行相关设置；\n- Photo Editing需要在使用照片时在照片管理器中激活或关闭；\n- Storage Provider可以在选择文件时出现；\n- Share和Action可以在任何应用里被激活，但前提是开发者需要设置Activation Rules，以确定extension需要在合适出现。\n\n## 1.3 Containing App\n\n尽管苹果开放了Extension，但是在iOS中Extension并不能单独存在，要想提交到AppStore，必须将Extension包含在一个app中提交，并且App的实现部分不能为空, 这个包含Extension的App就叫Containing App。\n\nExtension会随着Containing App的安装而安装，同时随着Containing App的卸载而卸载。\n\n## 1.4 Host App\n\n能够调起Extension的App被称为Host App。\n\n比如:\n\n- widget的Host App就是Today。\n- Photo Editing 的 Host App 就是 Photos\n\n\n\n# 2. Extension和Containing App、Host App通信\n\n## 2.1 Extension和Host App\n\nExtension和Host App之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别：\n\n``` objc\n@interface UIViewController(NSExtensionAdditions) <NSExtensionRequestHandling> \n\n// Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request. \n@property (nonatomic,readonly,retain) NSExtensionContext *extensionContext NS_AVAILABLE_IOS(8_0); \n\n@end \n```\n\n实际上extension和Host App之间是通过IPC（interprocess communication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。\n\n\n\n## 2.2 Containing App和Host App\n\n他们之间没有任何直接关系，也从来不需要通信。\n\n## 2.3 Extension和Containing App\n\n这二者之间的关系最复杂，纠纠缠缠扯不清关系。\n\n众所周知，[每个iOS应用程序都有自己的沙箱](https://developer.apple.com/library/ios/documentation/iphone/conceptual/iphoneosprogrammingguide/TheiOSEnvironment/TheiOSEnvironment.html)。[通过Mac苹果应用商店分发的OS X应用程序](https://developer.apple.com/library/mac/documentation/security/conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html)也有类似的要求，不过许多OS X应用程序是在Mac苹果应用商店之外分发的，并不需要遵守这一沙箱要求。\n\n沙箱是苹果iOS安全策略的基石之一。沙箱是为了限制应用程序对文件、首选项、网络资源、硬件等的访问，具体来讲，其目的是为了限制受损的应用程序可能对系统造成的损害。\n\n考虑到并不是所有可以用在应用程序中的API都可以用在Extension中，所以与通常的应用程序相比，App Extension运行在有更多限制的沙箱中。不能在Extension中使用的API标记为不可用宏，如NS_EXTENSIONS_UNAVAILABLE，它会在链接时导致失败。\n\n此外，对于Extension与其它应用程序之间的通信，苹果有几项强制规定：\n\n1. 调用Extension的应用程序即主应用程序不能启动Extension；只有系统可以启动Extension。\n2. 当Extension启动后，主应用程序就和它直接通信。\n3. 主应用程序永远不和包含应用程序直接通信。\n4. Extension不是一个应用程序，但它由系统生成，并有它自己单独的进程。\n5. 为了在包含应用程序和它的Extension之间共享数据，包含应用程序及其Extension都必须是应用程序组的一部分。对于应用程序组的其中两个成员，部分数据可以在两者沙箱之外的第三个容器中共享。\n\n正如Ars Technica的Andrew Cunningham总结的那样，这些规则的最终结果主要是一个应用程序不能进入另一个应用程序的沙箱。这与Android相反，在Android上，[内容提供程序](http://developer.android.com/guide/topics/providers/content-providers.html)和[解析程序](http://developer.android.com/reference/android/content/ContentResolver.html)仍然可以一起工作来为应用程序提供对其它应用程序中数据的访问。\n\n\n\n**不能直接通信:**\n\n首先，尽管Extension的bundle是放在Containing App的bundle中，但是他们是两个完全独立的进程，之间不能直接通信。不过Extension可以通过openURL的方式启动Containing App（当然也能启动其它App），不过必须通过extensionContext借助host app来实现：\n\n``` objc\n//通过openURL的方式启动Containing APP \n- (void)openURLContainingAPP \n{ \n    [self.extensionContext openURL:[NSURL URLWithString:@\"appextension://123\"] \n                 completionHandler:^(BOOL success) { \n                     NSLog(@\"open url result:%d\",success); \n                 }]; \n} \n```\n\n**Extension中是无法直接使用openURL的。**\n\n**可以共享Shared Resources:**\n\nExtension和Containing App可以共同读写一个被称为Shared Resources的存储区域，这是通过App Groups实现的，后文将会详述。\n\n三者间的关系可以通过官网给的两张图片形象地说明：\n\n ![Extension_Containing_App_1](http://img.my.csdn.net/uploads/201512/13/1449995608_4851.png)\n\n![Extension_Containing_App_2](http://img.my.csdn.net/uploads/201512/13/1449995608_8648.png)\n\n\n\n\n\n# 3. 数据共享\n\n**App Groups**这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一Group下的App共享同一份读写空间，以实现数据共享。\n\n\n\n## 3.1 功能开启\n\n为了便于后续操作，请先确保你的开发者账号在Xcode上处于登录状态。\n\n### 3.1.1 在App中开启\n\nApp Groups位于：\n\nTARGETS-->AppExtensionDemo-->Capabilities-->App Groups`\n\n找到以后，将App Groups右上角的开关打开，然后选择添加Groups，正规的命名规则应该是：group.com.company.app。\n\n添加成功以后如下图所示：\n\n![App_Groups](http://img.my.csdn.net/uploads/201512/13/1449996631_7873.jpeg)\n\n\n\n### 3.1.2 在Extension中开启\n\n开启方式和App中一样，需要注意的是必须保证这里地App Groups名称和App中的相同。\n\n\n\n## 3.2 extension和containing app数据共享\n\nApp Groups给我们提供了同一Group内App可以共同读写的区域，可以通过以下方式实现数据共享：\n\n### 3.2.1 通过NSUserDefaults共享数据\n\n**存数据**\n\n通过以下方式向NSUserDefaults中保存数据：\n\n``` objc\n- (void)saveTextByNSUserDefaults\n{\n    NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@\"group.com.xx.test\"];\n    [shared setObject:_textField.text forKey:@\"test\"];\n    [shared synchronize];\n}\n```\n\n需要注意的是：\n\n1. 保存数据的时候必须指明group id；\n2. 而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见[Property List Programming Guide](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PropertyLists/AboutPropertyLists/AboutPropertyLists.html)。\n3. 为了防止出现数据同步问题，不要忘记调用`[shared synchronize];`\n\n**读数据**\n\n对应的读取数据方式：\n\n``` objc\n- (NSString *)readDataFromNSUserDefaults\n{\n    NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@\"group.com.xx.test\"];\n    NSString *value = [shared valueForKey:@\"test\"];\n\n    return value;\n}\n```\n\n### 3.2.1 通过NSFileManager共享数据\n\nNSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。\n\n**存数据**\n\n``` objc\n- (BOOL)saveTextByNSFileManager\n{\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    containerURL = [containerURL URLByAppendingPathComponent:@\"Library/Caches/good\"];\n\n    NSString *value = _textField.text;\n    BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&err];\n    if (!result) {\n        NSLog(@\"%@\",err);\n    } else {\n        NSLog(@\"save value:%@ success.\",value);\n    }\n\n    return result;\n}\n```\n\n**读数据**\n\n``` objc\n- (NSString *)readTextByNSFileManager\n{\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    containerURL = [containerURL URLByAppendingPathComponent:@\"Library/Caches/good\"];\n    NSString *value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&err];\n\n    return value;\n}\n```\n\nPS:\n\n两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步。\n\n\n\n## 3.3 动态加载, 资源共享\n\n这个感兴趣的可以看下, 无关紧要~\n\n和数据共享类似，Extension和Containing App很自然地会有一些业务逻辑上可以共用的代码，这时可以通过iOS8中刚开放使用的framework实现。苹果在[App Extension Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1)中是这样描述的：\n\n> In iOS 8.0 and later, you can use an embedded framework to share code between your extension and its containing app. For example, if you develop image-processing code that you want both your Photo Editing extension and its containing app to share, you can put the code into a framework and embed it in both targets.\n\n即将framework分别嵌入到extension和containing app的target中实现代码共享。但这样岂不是需要分别要将framework分别copy到extension和containing app的main bundle中？\n\n参考extension和containing app数据共享，我试想能不能将framework只保存一份放在App Groups区域？\n\n### 3.3.1 copy framework到App Groups\n\n在app首次启动的时候将framework放到App Groups区域：\n\n``` objc\n- (BOOL)copyFrameworkFromMainBundleToAppGroup\n{\n    NSFileManager *manager = [NSFileManager defaultManager];\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    NSString *sorPath = [NSString stringWithFormat:@\"%@/Dylib.framework\",[[NSBundle mainBundle] bundlePath]];\n    NSString *desPath = [NSString stringWithFormat:@\"%@/Library/Caches/Dylib.framework\",containerURL.path];\n\n    BOOL removeResult = [manager removeItemAtPath:desPath error:&err];\n    if (!removeResult) {\n        NSLog(@\"%@\",err);\n    } else {\n        NSLog(@\"remove success.\");\n    }\n\n    BOOL copyResult = [[NSFileManager defaultManager] copyItemAtPath:sorPath toPath:desPath error:&err];\n    if (!copyResult) {\n        NSLog(@\"%@\",err);\n    } else {\n        NSLog(@\"copy success.\");\n    }\n\n    return copyResult;\n}\n```\n\n\n\n### 3.3.2 使用framework\n\n``` objc\n- (BOOL)loadFrameworkInAppGroup\n{\n    NSError *err = nil;\n    NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@\"group.com.xx.test\"];\n    NSString *desPath = [NSString stringWithFormat:@\"%@/Library/Caches/Dylib.framework\",containerURL.path];\n    NSBundle *bundle = [NSBundle bundleWithPath:desPath];\n    BOOL result = [bundle loadAndReturnError:&err];\n    if (result) {\n        Class root = NSClassFromString(@\"Person\");\n        if (root) {\n            Person *person = [[root alloc] init];\n            if (person) {\n                [person run];\n            }\n        }\n    } else {\n        NSLog(@\"%@\",err);\n    }\n\n    return result;\n}\n```\n\n经过测试，竟然能够加载成功。\n\n对比一下, 有如下总结: \n\n\n\n主要验证了两种方式:\n\n1. 导入公用framework到项目中, 只有**containing app** 的 **Link Binary With Libraries**添加对应framework, extension运行时动态加载framework。\n2. **containing app** 和 **extension**的**Link Binary With Libraries**分别链接公用framework, (Compile Sources 只包含在framework这个target中)\n\n以上两种方式都可以做到公用资源。 区别如下:\n\n1. 方式一需要App Groups, 共享资源。 方式二不需要。\n   \n2. 方式一需要**containing app**先启动把, 把数据copy到App Groups中, **entension**才能加载到。 方式二不需要。\n   \n3. 方式一不能直接初始化类, 比如:\n   \n   ``` objc\n   #import <TestFrameWork/FilterImage.h>\n   \n   FilterImage *filter = [[FilterImage alloc] init];\n   \n   将会报错:\n   \n   Undefined symbols for architecture x86_64:\n     \"_OBJC_CLASS_$_FilterImage\", referenced from:\n         objc-class-ref in PhotoEditingViewController.o\n   ld: symbol(s) not found for architecture x86_64\n   clang: error: linker command failed with exit code 1 (use -v to see invocation)\n   ```\n   \n   需要用这样的方式:\n   \n   ``` objc\n       Class root = NSClassFromString(@\"FilterImage\");\n       if (root) {\n           FilterImage *filter = [[root alloc] init];\n           NSString *nameLUT = [NSString stringWithFormat:@\"%@/TestFrameWork.bundle/images/filter_lut_%d\", desPath, 2];\n   \n           self.imageView.image = [filter filterImage:self.input.displaySizeImage imageName:nameLUT];\n       }\n   ```\n   \n   方式二可以直接使用。 (#import \"FilterImage.h\")\n   \n   ​\n   \n   对比了一下导出包的大小。\n   \n   写了3个Demo, \n   \n   1. 方式一, 动态加载          12.1M\n   2. 方式二，静态链接         23.7M\n   3. 方式三，只包含framework，没有extension   11.2M\n\n\n\n# 4. 生命周期\n\n下图来自官方文档，它详细描述了Extension App的生命周期 ![Life_Cycle](http://img.my.csdn.net/uploads/201512/13/1449996016_4664.png)\n\n**开始**\n\n在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。\n\n**执行任务**\n\n在extension启动以后，开始执行它的使命。\n\n**终止**\n\n在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。\n\n由此可见，extension就是为了任务而生！\n\n\n\n# 5. Photo Editing使用滤镜实战\n\n这里因为时间关系, 就直接采用 **Apple** 官方例子, 不再重新写了。如果实践过程中, 有遇到任何问题, 欢迎留言或者其他方式与我交流~\n\n\n\nDemo下载地址: ![](http://download.csdn.net/images/minetype/zip.gif)Photo Editing Extension Demo  \n\n\n\n这里有几点需要注意的。\n\n1. 因为Host App是Photos, 所以我们的Extension必须适配横竖屏, 因为它的状态是跟着Host App变的, 而不是Containing App。 至于横竖屏的适配, 建议采用Size Class, 然后监听缩放模式, 来适配屏幕\n   \n   ​\n   \n   ``` objc\n   #pragma mark - UIContentContainer\n   - (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection\n                 withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator\n   {\n       [super willTransitionToTraitCollection:newCollection\n                    withTransitionCoordinator:coordinator];\n       [coordinator animateAlongsideTransition:^(id <UIViewControllerTransitionCoordinatorContext> context) {\n          // 横屏处理\n           }\n           else {\n            // 竖屏处理\n           }\n           [self.view setNeedsLayout];\n       } completion:nil];\n   }\n   ```\n   \n   同样, 需要获取初始状态来处理。\n   \n   ​\n   \n   ``` objc\n       if (self.traitCollection.verticalSizeClass == UIUserInterfaceSizeClassCompact) {\n           //To Do: modify something for compact vertical size\n       }\n       else {\n           //To Do: modify something for other vertical size\n       }\n   ```\n   \n2. 如果第三方库用Pod来管理的话, 需要修改pod的target, 以及添加链接。\n   \n   `Build Settings — > Other Linker Flags    **-l\"Pods-MBProgressHUD\"**`\n\n\n\n# 6. 相关资料\n\n[App Extension Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1)\n\n[App Extensions for iOS 8 in Depth](http://www.infoq.com/news/2014/07/apple-ios8-app-extensions)\n\n[WWDC2014之App Extensions学习笔记](http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/)\n\n[Sample Photo Editing Extension](https://developer.apple.com/library/ios/samplecode/SamplePhotoEditingExtension/Introduction/Intro.html#//apple_ref/doc/uid/TP40014576)","slug":"Photo-Editing-Extension","published":1,"updated":"2019-12-23T01:02:31.289Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1n50023zwlnspfekhdo","content":"<blockquote>\n<p>extension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。允许应用帮助系统扩展自定义功能，去实现一个特定作用域的任务，如照片编辑、自定义键盘、通知中心、Action动作、Share分享等。 这对于一向封闭的iOS来说, 无疑是一大福音。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>虽然iOS8离现在比较远了, 分享 <strong>“Extension “</strong> 相关的文章也很多了, 不过对于<strong>“Photo Editing”</strong>, 我觉得还是有必要来讲一讲的, 一来多数教程介绍Extension 的时候都是拿<strong>Widgets</strong>举例, 再有<strong>Photo Editing</strong>是可自定义内容最丰富的一个, 你完全可以把它当作App里额外的一个界面来完成。</p>\n<p>正好前一阵在实习的时候, 实现过相关功能, 总结一番也是极好。</p>\n<h1 id=\"1-_相关概念\">1. 相关概念</h1><h2 id=\"1-1_Extension_Point\">1.1 Extension Point</h2><p>系统中支持Extension 的区域，Extension 的类别也是据此区分的，iOS上共有Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard几种，其中Today中的extension又被称为Widget。</p>\n<ul>\n<li><strong>今日(Today，又称为Widget)</strong>：可以快速获取更新或者在通知中心的今日视图中执行一项快速任务。</li>\n<li><strong>共享(Share)</strong>：发布到一个共享网站或者与其它应用程序共享内容。</li>\n<li><strong>动作(Action)</strong>：在另一个应用程序的上下文中操作或查看内容。</li>\n<li><strong>照片编辑(Photo Editing)</strong>（仅限于iOS）：在照片应用程序中编辑照片或视频。</li>\n<li><strong>查找器</strong>（仅限于iOS）：在查找器中直接显示文件同步的状态信息。</li>\n<li><strong>文档提供程序(Storage Provider)</strong>（仅限于iOS）：提供对文件库的访问和管理。</li>\n<li><strong>自定义键盘(Custom keyboard)</strong>（仅限于iOS）：用自定义键盘替代iOS系统键盘，并用于所有的应用程序中。</li>\n</ul>\n<p>由于每个扩展点都有与之相关的使用策略和专门的API，开发人员必须为他们想要提供的那种功能选择恰当的扩展点, 每种Extension Point的使用方式和适合干的活都不一样，因此不存在通用的Extension 。</p>\n<p>例如，在默认情况下，键盘Extension“<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/Keyboard.html\" target=\"_blank\" rel=\"external\">不能访问网络，而且不能与其包含应用程序共享同一容器</a>”。通过对Extension进行恰当的配置，这样的限制可以移除，但开发人员仍然需要遵守苹果应用商店审查指南和iOS开发者计划许可协议中的具体的网络键盘指南。</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201512/13/1449993990_7598.png\" alt=\"Extension Point\"></p>\n<h2 id=\"1-2_App_Extension\">1.2 App Extension</h2><p>即为本文所说的Extension。Extension并不是一个独立的app，它有一个包含在App Bundle中的独立Bundle，Extension的Bundle后缀名是.appex。其生命周期也和普通App不同，这些后文将会详述。</p>\n<p>Extension不能单独存在，必须有一个包含它的Containing App。</p>\n<p>另外，Extension需要用户手动激活，不同的Extension激活方式也不同。</p>\n<p>比如：</p>\n<ul>\n<li>Today中的widget需要在Today中激活和关闭；</li>\n<li>Custom keyboard需要在设置中进行相关设置；</li>\n<li>Photo Editing需要在使用照片时在照片管理器中激活或关闭；</li>\n<li>Storage Provider可以在选择文件时出现；</li>\n<li>Share和Action可以在任何应用里被激活，但前提是开发者需要设置Activation Rules，以确定extension需要在合适出现。</li>\n</ul>\n<h2 id=\"1-3_Containing_App\">1.3 Containing App</h2><p>尽管苹果开放了Extension，但是在iOS中Extension并不能单独存在，要想提交到AppStore，必须将Extension包含在一个app中提交，并且App的实现部分不能为空, 这个包含Extension的App就叫Containing App。</p>\n<p>Extension会随着Containing App的安装而安装，同时随着Containing App的卸载而卸载。</p>\n<h2 id=\"1-4_Host_App\">1.4 Host App</h2><p>能够调起Extension的App被称为Host App。</p>\n<p>比如:</p>\n<ul>\n<li>widget的Host App就是Today。</li>\n<li>Photo Editing 的 Host App 就是 Photos</li>\n</ul>\n<h1 id=\"2-_Extension和Containing_App、Host_App通信\">2. Extension和Containing App、Host App通信</h1><h2 id=\"2-1_Extension和Host_App\">2.1 Extension和Host App</h2><p>Extension和Host App之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIViewController</span>(<span class=\"title\">NSExtensionAdditions</span>) &lt;<span class=\"title\">NSExtensionRequestHandling</span>&gt; </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request. </span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,retain) <span class=\"built_in\">NSExtensionContext</span> *extensionContext <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实际上extension和Host App之间是通过IPC（interprocess communication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。</p>\n<h2 id=\"2-2_Containing_App和Host_App\">2.2 Containing App和Host App</h2><p>他们之间没有任何直接关系，也从来不需要通信。</p>\n<h2 id=\"2-3_Extension和Containing_App\">2.3 Extension和Containing App</h2><p>这二者之间的关系最复杂，纠纠缠缠扯不清关系。</p>\n<p>众所周知，<a href=\"https://developer.apple.com/library/ios/documentation/iphone/conceptual/iphoneosprogrammingguide/TheiOSEnvironment/TheiOSEnvironment.html\" target=\"_blank\" rel=\"external\">每个iOS应用程序都有自己的沙箱</a>。<a href=\"https://developer.apple.com/library/mac/documentation/security/conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html\" target=\"_blank\" rel=\"external\">通过Mac苹果应用商店分发的OS X应用程序</a>也有类似的要求，不过许多OS X应用程序是在Mac苹果应用商店之外分发的，并不需要遵守这一沙箱要求。</p>\n<p>沙箱是苹果iOS安全策略的基石之一。沙箱是为了限制应用程序对文件、首选项、网络资源、硬件等的访问，具体来讲，其目的是为了限制受损的应用程序可能对系统造成的损害。</p>\n<p>考虑到并不是所有可以用在应用程序中的API都可以用在Extension中，所以与通常的应用程序相比，App Extension运行在有更多限制的沙箱中。不能在Extension中使用的API标记为不可用宏，如NS_EXTENSIONS_UNAVAILABLE，它会在链接时导致失败。</p>\n<p>此外，对于Extension与其它应用程序之间的通信，苹果有几项强制规定：</p>\n<ol>\n<li>调用Extension的应用程序即主应用程序不能启动Extension；只有系统可以启动Extension。</li>\n<li>当Extension启动后，主应用程序就和它直接通信。</li>\n<li>主应用程序永远不和包含应用程序直接通信。</li>\n<li>Extension不是一个应用程序，但它由系统生成，并有它自己单独的进程。</li>\n<li>为了在包含应用程序和它的Extension之间共享数据，包含应用程序及其Extension都必须是应用程序组的一部分。对于应用程序组的其中两个成员，部分数据可以在两者沙箱之外的第三个容器中共享。</li>\n</ol>\n<p>正如Ars Technica的Andrew Cunningham总结的那样，这些规则的最终结果主要是一个应用程序不能进入另一个应用程序的沙箱。这与Android相反，在Android上，<a href=\"http://developer.android.com/guide/topics/providers/content-providers.html\" target=\"_blank\" rel=\"external\">内容提供程序</a>和<a href=\"http://developer.android.com/reference/android/content/ContentResolver.html\" target=\"_blank\" rel=\"external\">解析程序</a>仍然可以一起工作来为应用程序提供对其它应用程序中数据的访问。</p>\n<p><strong>不能直接通信:</strong></p>\n<p>首先，尽管Extension的bundle是放在Containing App的bundle中，但是他们是两个完全独立的进程，之间不能直接通信。不过Extension可以通过openURL的方式启动Containing App（当然也能启动其它App），不过必须通过extensionContext借助host app来实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过openURL的方式启动Containing APP </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)openURLContainingAPP </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.extensionContext openURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"appextension://123\"</span>] </span><br><span class=\"line\">                 completionHandler:^(<span class=\"built_in\">BOOL</span> success) &#123; </span><br><span class=\"line\">                     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"open url result:%d\"</span>,success); </span><br><span class=\"line\">                 &#125;]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Extension中是无法直接使用openURL的。</strong></p>\n<p><strong>可以共享Shared Resources:</strong></p>\n<p>Extension和Containing App可以共同读写一个被称为Shared Resources的存储区域，这是通过App Groups实现的，后文将会详述。</p>\n<p>三者间的关系可以通过官网给的两张图片形象地说明：</p>\n<p> <img src=\"http://img.my.csdn.net/uploads/201512/13/1449995608_4851.png\" alt=\"Extension_Containing_App_1\"></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201512/13/1449995608_8648.png\" alt=\"Extension_Containing_App_2\"></p>\n<h1 id=\"3-_数据共享\">3. 数据共享</h1><p><strong>App Groups</strong>这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一Group下的App共享同一份读写空间，以实现数据共享。</p>\n<h2 id=\"3-1_功能开启\">3.1 功能开启</h2><p>为了便于后续操作，请先确保你的开发者账号在Xcode上处于登录状态。</p>\n<h3 id=\"3-1-1_在App中开启\">3.1.1 在App中开启</h3><p>App Groups位于：</p>\n<p>TARGETS—&gt;AppExtensionDemo—&gt;Capabilities—&gt;App Groups`</p>\n<p>找到以后，将App Groups右上角的开关打开，然后选择添加Groups，正规的命名规则应该是：group.com.company.app。</p>\n<p>添加成功以后如下图所示：</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201512/13/1449996631_7873.jpeg\" alt=\"App_Groups\"></p>\n<h3 id=\"3-1-2_在Extension中开启\">3.1.2 在Extension中开启</h3><p>开启方式和App中一样，需要注意的是必须保证这里地App Groups名称和App中的相同。</p>\n<h2 id=\"3-2_extension和containing_app数据共享\">3.2 extension和containing app数据共享</h2><p>App Groups给我们提供了同一Group内App可以共同读写的区域，可以通过以下方式实现数据共享：</p>\n<h3 id=\"3-2-1_通过NSUserDefaults共享数据\">3.2.1 通过NSUserDefaults共享数据</h3><p><strong>存数据</strong></p>\n<p>通过以下方式向NSUserDefaults中保存数据：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)saveTextBy<span class=\"built_in\">NSUserDefaults</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUserDefaults</span> *shared = [[<span class=\"built_in\">NSUserDefaults</span> alloc] initWithSuiteName:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    [shared setObject:_textField.text forKey:<span class=\"string\">@\"test\"</span>];</span><br><span class=\"line\">    [shared synchronize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：</p>\n<ol>\n<li>保存数据的时候必须指明group id；</li>\n<li>而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PropertyLists/AboutPropertyLists/AboutPropertyLists.html\" target=\"_blank\" rel=\"external\">Property List Programming Guide</a>。</li>\n<li>为了防止出现数据同步问题，不要忘记调用<code>[shared synchronize];</code></li>\n</ol>\n<p><strong>读数据</strong></p>\n<p>对应的读取数据方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)readDataFrom<span class=\"built_in\">NSUserDefaults</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUserDefaults</span> *shared = [[<span class=\"built_in\">NSUserDefaults</span> alloc] initWithSuiteName:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *value = [shared valueForKey:<span class=\"string\">@\"test\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-1_通过NSFileManager共享数据\">3.2.1 通过NSFileManager共享数据</h3><p>NSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。</p>\n<p><strong>存数据</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveTextBy<span class=\"built_in\">NSFileManager</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    containerURL = [containerURL URLByAppendingPathComponent:<span class=\"string\">@\"Library/Caches/good\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *value = _textField.text;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> result = [value writeToURL:containerURL atomically:<span class=\"literal\">YES</span> encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"save value:%@ success.\"</span>,value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>读数据</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)readTextBy<span class=\"built_in\">NSFileManager</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    containerURL = [containerURL URLByAppendingPathComponent:<span class=\"string\">@\"Library/Caches/good\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *value = [<span class=\"built_in\">NSString</span> stringWithContentsOfURL:containerURL encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;err];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS:</p>\n<p>两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步。</p>\n<h2 id=\"3-3_动态加载,_资源共享\">3.3 动态加载, 资源共享</h2><p>这个感兴趣的可以看下, 无关紧要~</p>\n<p>和数据共享类似，Extension和Containing App很自然地会有一些业务逻辑上可以共用的代码，这时可以通过iOS8中刚开放使用的framework实现。苹果在<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1\" target=\"_blank\" rel=\"external\">App Extension Programming Guide</a>中是这样描述的：</p>\n<blockquote>\n<p>In iOS 8.0 and later, you can use an embedded framework to share code between your extension and its containing app. For example, if you develop image-processing code that you want both your Photo Editing extension and its containing app to share, you can put the code into a framework and embed it in both targets.</p>\n</blockquote>\n<p>即将framework分别嵌入到extension和containing app的target中实现代码共享。但这样岂不是需要分别要将framework分别copy到extension和containing app的main bundle中？</p>\n<p>参考extension和containing app数据共享，我试想能不能将framework只保存一份放在App Groups区域？</p>\n<h3 id=\"3-3-1_copy_framework到App_Groups\">3.3.1 copy framework到App Groups</h3><p>在app首次启动的时候将framework放到App Groups区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)copyFrameworkFromMainBundleToAppGroup</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSFileManager</span> *manager = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *sorPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/Dylib.framework\"</span>,[[<span class=\"built_in\">NSBundle</span> mainBundle] bundlePath]];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *desPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/Library/Caches/Dylib.framework\"</span>,containerURL.path];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> removeResult = [manager removeItemAtPath:desPath error:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!removeResult) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"remove success.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> copyResult = [[<span class=\"built_in\">NSFileManager</span> defaultManager] copyItemAtPath:sorPath toPath:desPath error:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!copyResult) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copy success.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyResult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-2_使用framework\">3.3.2 使用framework</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)loadFrameworkInAppGroup</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *desPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/Library/Caches/Dylib.framework\"</span>,containerURL.path];</span><br><span class=\"line\">    <span class=\"built_in\">NSBundle</span> *bundle = [<span class=\"built_in\">NSBundle</span> bundleWithPath:desPath];</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> result = [bundle loadAndReturnError:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        Class root = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Person\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            Person *person = [[root alloc] init];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (person) &#123;</span><br><span class=\"line\">                [person run];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过测试，竟然能够加载成功。</p>\n<p>对比一下, 有如下总结: </p>\n<p>主要验证了两种方式:</p>\n<ol>\n<li>导入公用framework到项目中, 只有<strong>containing app</strong> 的 <strong>Link Binary With Libraries</strong>添加对应framework, extension运行时动态加载framework。</li>\n<li><strong>containing app</strong> 和 <strong>extension</strong>的<strong>Link Binary With Libraries</strong>分别链接公用framework, (Compile Sources 只包含在framework这个target中)</li>\n</ol>\n<p>以上两种方式都可以做到公用资源。 区别如下:</p>\n<ol>\n<li><p>方式一需要App Groups, 共享资源。 方式二不需要。</p>\n</li>\n<li><p>方式一需要<strong>containing app</strong>先启动把, 把数据copy到App Groups中, <strong>entension</strong>才能加载到。 方式二不需要。</p>\n</li>\n<li><p>方式一不能直接初始化类, 比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;TestFrameWork/FilterImage.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">FilterImage *filter = [[FilterImage alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">将会报错:</span><br><span class=\"line\"></span><br><span class=\"line\">Undefined symbols <span class=\"keyword\">for</span> architecture x86_64:</span><br><span class=\"line\">  <span class=\"string\">\"_OBJC_CLASS_$_FilterImage\"</span>, referenced from:</span><br><span class=\"line\">      objc-class-ref <span class=\"keyword\">in</span> PhotoEditingViewController.o</span><br><span class=\"line\">ld: symbol(s) not found <span class=\"keyword\">for</span> architecture x86_64</span><br><span class=\"line\">clang: error: linker command failed with exit code <span class=\"number\">1</span> (use -v to see invocation)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   需要用这样的方式:</p>\n   <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class root = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"FilterImage\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">    FilterImage *filter = [[root alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *nameLUT = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/TestFrameWork.bundle/images/filter_lut_%d\"</span>, desPath, <span class=\"number\">2</span>];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.imageView.image = [filter filterImage:<span class=\"keyword\">self</span>.input.displaySizeImage imageName:nameLUT];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   方式二可以直接使用。 (#import “FilterImage.h”)</p>\n<p>   ​</p>\n<p>   对比了一下导出包的大小。</p>\n<p>   写了3个Demo, </p>\n<ol>\n<li>方式一, 动态加载          12.1M</li>\n<li>方式二，静态链接         23.7M</li>\n<li>方式三，只包含framework，没有extension   11.2M</li>\n</ol>\n<h1 id=\"4-_生命周期\">4. 生命周期</h1><p>下图来自官方文档，它详细描述了Extension App的生命周期 <img src=\"http://img.my.csdn.net/uploads/201512/13/1449996016_4664.png\" alt=\"Life_Cycle\"></p>\n<p><strong>开始</strong></p>\n<p>在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。</p>\n<p><strong>执行任务</strong></p>\n<p>在extension启动以后，开始执行它的使命。</p>\n<p><strong>终止</strong></p>\n<p>在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。</p>\n<p>由此可见，extension就是为了任务而生！</p>\n<h1 id=\"5-_Photo_Editing使用滤镜实战\">5. Photo Editing使用滤镜实战</h1><p>这里因为时间关系, 就直接采用 <strong>Apple</strong> 官方例子, 不再重新写了。如果实践过程中, 有遇到任何问题, 欢迎留言或者其他方式与我交流~</p>\n<p>Demo下载地址: <img src=\"http://download.csdn.net/images/minetype/zip.gif\" alt=\"\">Photo Editing Extension Demo  </p>\n<p>这里有几点需要注意的。</p>\n<ol>\n<li><p>因为Host App是Photos, 所以我们的Extension必须适配横竖屏, 因为它的状态是跟着Host App变的, 而不是Containing App。 至于横竖屏的适配, 建议采用Size Class, 然后监听缩放模式, 来适配屏幕</p>\n<p>​</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark - UIContentContainer</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)willTransitionToTraitCollection:(<span class=\"built_in\">UITraitCollection</span> *)newCollection</span><br><span class=\"line\">              withTransitionCoordinator:(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIViewControllerTransitionCoordinator</span>&gt;)coordinator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> willTransitionToTraitCollection:newCollection</span><br><span class=\"line\">                 withTransitionCoordinator:coordinator];</span><br><span class=\"line\">    [coordinator animateAlongsideTransition:^(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIViewControllerTransitionCoordinatorContext</span>&gt; context) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 横屏处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 竖屏处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.view setNeedsLayout];</span><br><span class=\"line\">    &#125; completion:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   同样, 需要获取初始状态来处理。</p>\n<p>   ​</p>\n   <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.traitCollection.verticalSizeClass == <span class=\"built_in\">UIUserInterfaceSizeClassCompact</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//To Do: modify something for compact vertical size</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//To Do: modify something for other vertical size</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果第三方库用Pod来管理的话, 需要修改pod的target, 以及添加链接。</p>\n<p><code>Build Settings — &gt; Other Linker Flags    **-l&quot;Pods-MBProgressHUD&quot;**</code></p>\n</li>\n</ol>\n<h1 id=\"6-_相关资料\">6. 相关资料</h1><p><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1\" target=\"_blank\" rel=\"external\">App Extension Programming Guide</a></p>\n<p><a href=\"http://www.infoq.com/news/2014/07/apple-ios8-app-extensions\" target=\"_blank\" rel=\"external\">App Extensions for iOS 8 in Depth</a></p>\n<p><a href=\"http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/\" target=\"_blank\" rel=\"external\">WWDC2014之App Extensions学习笔记</a></p>\n<p><a href=\"https://developer.apple.com/library/ios/samplecode/SamplePhotoEditingExtension/Introduction/Intro.html#//apple_ref/doc/uid/TP40014576\" target=\"_blank\" rel=\"external\">Sample Photo Editing Extension</a></p>\n","excerpt":"<blockquote>\n<p>extension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。允许应用帮助系统扩展自定义功能，去实现一个特定作用域的任务，如照片编辑、自定义键盘、通知中心、Action动作、Share分享等。 这对于一向封闭的iOS来说, 无疑是一大福音。</p>\n</blockquote>","more":"<p>虽然iOS8离现在比较远了, 分享 <strong>“Extension “</strong> 相关的文章也很多了, 不过对于<strong>“Photo Editing”</strong>, 我觉得还是有必要来讲一讲的, 一来多数教程介绍Extension 的时候都是拿<strong>Widgets</strong>举例, 再有<strong>Photo Editing</strong>是可自定义内容最丰富的一个, 你完全可以把它当作App里额外的一个界面来完成。</p>\n<p>正好前一阵在实习的时候, 实现过相关功能, 总结一番也是极好。</p>\n<h1 id=\"1-_相关概念\">1. 相关概念</h1><h2 id=\"1-1_Extension_Point\">1.1 Extension Point</h2><p>系统中支持Extension 的区域，Extension 的类别也是据此区分的，iOS上共有Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard几种，其中Today中的extension又被称为Widget。</p>\n<ul>\n<li><strong>今日(Today，又称为Widget)</strong>：可以快速获取更新或者在通知中心的今日视图中执行一项快速任务。</li>\n<li><strong>共享(Share)</strong>：发布到一个共享网站或者与其它应用程序共享内容。</li>\n<li><strong>动作(Action)</strong>：在另一个应用程序的上下文中操作或查看内容。</li>\n<li><strong>照片编辑(Photo Editing)</strong>（仅限于iOS）：在照片应用程序中编辑照片或视频。</li>\n<li><strong>查找器</strong>（仅限于iOS）：在查找器中直接显示文件同步的状态信息。</li>\n<li><strong>文档提供程序(Storage Provider)</strong>（仅限于iOS）：提供对文件库的访问和管理。</li>\n<li><strong>自定义键盘(Custom keyboard)</strong>（仅限于iOS）：用自定义键盘替代iOS系统键盘，并用于所有的应用程序中。</li>\n</ul>\n<p>由于每个扩展点都有与之相关的使用策略和专门的API，开发人员必须为他们想要提供的那种功能选择恰当的扩展点, 每种Extension Point的使用方式和适合干的活都不一样，因此不存在通用的Extension 。</p>\n<p>例如，在默认情况下，键盘Extension“<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/Keyboard.html\">不能访问网络，而且不能与其包含应用程序共享同一容器</a>”。通过对Extension进行恰当的配置，这样的限制可以移除，但开发人员仍然需要遵守苹果应用商店审查指南和iOS开发者计划许可协议中的具体的网络键盘指南。</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201512/13/1449993990_7598.png\" alt=\"Extension Point\"></p>\n<h2 id=\"1-2_App_Extension\">1.2 App Extension</h2><p>即为本文所说的Extension。Extension并不是一个独立的app，它有一个包含在App Bundle中的独立Bundle，Extension的Bundle后缀名是.appex。其生命周期也和普通App不同，这些后文将会详述。</p>\n<p>Extension不能单独存在，必须有一个包含它的Containing App。</p>\n<p>另外，Extension需要用户手动激活，不同的Extension激活方式也不同。</p>\n<p>比如：</p>\n<ul>\n<li>Today中的widget需要在Today中激活和关闭；</li>\n<li>Custom keyboard需要在设置中进行相关设置；</li>\n<li>Photo Editing需要在使用照片时在照片管理器中激活或关闭；</li>\n<li>Storage Provider可以在选择文件时出现；</li>\n<li>Share和Action可以在任何应用里被激活，但前提是开发者需要设置Activation Rules，以确定extension需要在合适出现。</li>\n</ul>\n<h2 id=\"1-3_Containing_App\">1.3 Containing App</h2><p>尽管苹果开放了Extension，但是在iOS中Extension并不能单独存在，要想提交到AppStore，必须将Extension包含在一个app中提交，并且App的实现部分不能为空, 这个包含Extension的App就叫Containing App。</p>\n<p>Extension会随着Containing App的安装而安装，同时随着Containing App的卸载而卸载。</p>\n<h2 id=\"1-4_Host_App\">1.4 Host App</h2><p>能够调起Extension的App被称为Host App。</p>\n<p>比如:</p>\n<ul>\n<li>widget的Host App就是Today。</li>\n<li>Photo Editing 的 Host App 就是 Photos</li>\n</ul>\n<h1 id=\"2-_Extension和Containing_App、Host_App通信\">2. Extension和Containing App、Host App通信</h1><h2 id=\"2-1_Extension和Host_App\">2.1 Extension和Host App</h2><p>Extension和Host App之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIViewController</span>(<span class=\"title\">NSExtensionAdditions</span>) &lt;<span class=\"title\">NSExtensionRequestHandling</span>&gt; </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request. </span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,retain) <span class=\"built_in\">NSExtensionContext</span> *extensionContext <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>实际上extension和Host App之间是通过IPC（interprocess communication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。</p>\n<h2 id=\"2-2_Containing_App和Host_App\">2.2 Containing App和Host App</h2><p>他们之间没有任何直接关系，也从来不需要通信。</p>\n<h2 id=\"2-3_Extension和Containing_App\">2.3 Extension和Containing App</h2><p>这二者之间的关系最复杂，纠纠缠缠扯不清关系。</p>\n<p>众所周知，<a href=\"https://developer.apple.com/library/ios/documentation/iphone/conceptual/iphoneosprogrammingguide/TheiOSEnvironment/TheiOSEnvironment.html\">每个iOS应用程序都有自己的沙箱</a>。<a href=\"https://developer.apple.com/library/mac/documentation/security/conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html\">通过Mac苹果应用商店分发的OS X应用程序</a>也有类似的要求，不过许多OS X应用程序是在Mac苹果应用商店之外分发的，并不需要遵守这一沙箱要求。</p>\n<p>沙箱是苹果iOS安全策略的基石之一。沙箱是为了限制应用程序对文件、首选项、网络资源、硬件等的访问，具体来讲，其目的是为了限制受损的应用程序可能对系统造成的损害。</p>\n<p>考虑到并不是所有可以用在应用程序中的API都可以用在Extension中，所以与通常的应用程序相比，App Extension运行在有更多限制的沙箱中。不能在Extension中使用的API标记为不可用宏，如NS_EXTENSIONS_UNAVAILABLE，它会在链接时导致失败。</p>\n<p>此外，对于Extension与其它应用程序之间的通信，苹果有几项强制规定：</p>\n<ol>\n<li>调用Extension的应用程序即主应用程序不能启动Extension；只有系统可以启动Extension。</li>\n<li>当Extension启动后，主应用程序就和它直接通信。</li>\n<li>主应用程序永远不和包含应用程序直接通信。</li>\n<li>Extension不是一个应用程序，但它由系统生成，并有它自己单独的进程。</li>\n<li>为了在包含应用程序和它的Extension之间共享数据，包含应用程序及其Extension都必须是应用程序组的一部分。对于应用程序组的其中两个成员，部分数据可以在两者沙箱之外的第三个容器中共享。</li>\n</ol>\n<p>正如Ars Technica的Andrew Cunningham总结的那样，这些规则的最终结果主要是一个应用程序不能进入另一个应用程序的沙箱。这与Android相反，在Android上，<a href=\"http://developer.android.com/guide/topics/providers/content-providers.html\">内容提供程序</a>和<a href=\"http://developer.android.com/reference/android/content/ContentResolver.html\">解析程序</a>仍然可以一起工作来为应用程序提供对其它应用程序中数据的访问。</p>\n<p><strong>不能直接通信:</strong></p>\n<p>首先，尽管Extension的bundle是放在Containing App的bundle中，但是他们是两个完全独立的进程，之间不能直接通信。不过Extension可以通过openURL的方式启动Containing App（当然也能启动其它App），不过必须通过extensionContext借助host app来实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过openURL的方式启动Containing APP </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)openURLContainingAPP </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.extensionContext openURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"appextension://123\"</span>] </span><br><span class=\"line\">                 completionHandler:^(<span class=\"built_in\">BOOL</span> success) &#123; </span><br><span class=\"line\">                     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"open url result:%d\"</span>,success); </span><br><span class=\"line\">                 &#125;]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Extension中是无法直接使用openURL的。</strong></p>\n<p><strong>可以共享Shared Resources:</strong></p>\n<p>Extension和Containing App可以共同读写一个被称为Shared Resources的存储区域，这是通过App Groups实现的，后文将会详述。</p>\n<p>三者间的关系可以通过官网给的两张图片形象地说明：</p>\n<p> <img src=\"http://img.my.csdn.net/uploads/201512/13/1449995608_4851.png\" alt=\"Extension_Containing_App_1\"></p>\n<p><img src=\"http://img.my.csdn.net/uploads/201512/13/1449995608_8648.png\" alt=\"Extension_Containing_App_2\"></p>\n<h1 id=\"3-_数据共享\">3. 数据共享</h1><p><strong>App Groups</strong>这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一Group下的App共享同一份读写空间，以实现数据共享。</p>\n<h2 id=\"3-1_功能开启\">3.1 功能开启</h2><p>为了便于后续操作，请先确保你的开发者账号在Xcode上处于登录状态。</p>\n<h3 id=\"3-1-1_在App中开启\">3.1.1 在App中开启</h3><p>App Groups位于：</p>\n<p>TARGETS—&gt;AppExtensionDemo—&gt;Capabilities—&gt;App Groups`</p>\n<p>找到以后，将App Groups右上角的开关打开，然后选择添加Groups，正规的命名规则应该是：group.com.company.app。</p>\n<p>添加成功以后如下图所示：</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201512/13/1449996631_7873.jpeg\" alt=\"App_Groups\"></p>\n<h3 id=\"3-1-2_在Extension中开启\">3.1.2 在Extension中开启</h3><p>开启方式和App中一样，需要注意的是必须保证这里地App Groups名称和App中的相同。</p>\n<h2 id=\"3-2_extension和containing_app数据共享\">3.2 extension和containing app数据共享</h2><p>App Groups给我们提供了同一Group内App可以共同读写的区域，可以通过以下方式实现数据共享：</p>\n<h3 id=\"3-2-1_通过NSUserDefaults共享数据\">3.2.1 通过NSUserDefaults共享数据</h3><p><strong>存数据</strong></p>\n<p>通过以下方式向NSUserDefaults中保存数据：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)saveTextBy<span class=\"built_in\">NSUserDefaults</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUserDefaults</span> *shared = [[<span class=\"built_in\">NSUserDefaults</span> alloc] initWithSuiteName:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    [shared setObject:_textField.text forKey:<span class=\"string\">@\"test\"</span>];</span><br><span class=\"line\">    [shared synchronize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：</p>\n<ol>\n<li>保存数据的时候必须指明group id；</li>\n<li>而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PropertyLists/AboutPropertyLists/AboutPropertyLists.html\">Property List Programming Guide</a>。</li>\n<li>为了防止出现数据同步问题，不要忘记调用<code>[shared synchronize];</code></li>\n</ol>\n<p><strong>读数据</strong></p>\n<p>对应的读取数据方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)readDataFrom<span class=\"built_in\">NSUserDefaults</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUserDefaults</span> *shared = [[<span class=\"built_in\">NSUserDefaults</span> alloc] initWithSuiteName:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *value = [shared valueForKey:<span class=\"string\">@\"test\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-1_通过NSFileManager共享数据\">3.2.1 通过NSFileManager共享数据</h3><p>NSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。</p>\n<p><strong>存数据</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveTextBy<span class=\"built_in\">NSFileManager</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    containerURL = [containerURL URLByAppendingPathComponent:<span class=\"string\">@\"Library/Caches/good\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *value = _textField.text;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> result = [value writeToURL:containerURL atomically:<span class=\"literal\">YES</span> encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"save value:%@ success.\"</span>,value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>读数据</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)readTextBy<span class=\"built_in\">NSFileManager</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    containerURL = [containerURL URLByAppendingPathComponent:<span class=\"string\">@\"Library/Caches/good\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *value = [<span class=\"built_in\">NSString</span> stringWithContentsOfURL:containerURL encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;err];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS:</p>\n<p>两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步。</p>\n<h2 id=\"3-3_动态加载,_资源共享\">3.3 动态加载, 资源共享</h2><p>这个感兴趣的可以看下, 无关紧要~</p>\n<p>和数据共享类似，Extension和Containing App很自然地会有一些业务逻辑上可以共用的代码，这时可以通过iOS8中刚开放使用的framework实现。苹果在<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1\">App Extension Programming Guide</a>中是这样描述的：</p>\n<blockquote>\n<p>In iOS 8.0 and later, you can use an embedded framework to share code between your extension and its containing app. For example, if you develop image-processing code that you want both your Photo Editing extension and its containing app to share, you can put the code into a framework and embed it in both targets.</p>\n</blockquote>\n<p>即将framework分别嵌入到extension和containing app的target中实现代码共享。但这样岂不是需要分别要将framework分别copy到extension和containing app的main bundle中？</p>\n<p>参考extension和containing app数据共享，我试想能不能将framework只保存一份放在App Groups区域？</p>\n<h3 id=\"3-3-1_copy_framework到App_Groups\">3.3.1 copy framework到App Groups</h3><p>在app首次启动的时候将framework放到App Groups区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)copyFrameworkFromMainBundleToAppGroup</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSFileManager</span> *manager = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *sorPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/Dylib.framework\"</span>,[[<span class=\"built_in\">NSBundle</span> mainBundle] bundlePath]];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *desPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/Library/Caches/Dylib.framework\"</span>,containerURL.path];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> removeResult = [manager removeItemAtPath:desPath error:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!removeResult) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"remove success.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> copyResult = [[<span class=\"built_in\">NSFileManager</span> defaultManager] copyItemAtPath:sorPath toPath:desPath error:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!copyResult) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copy success.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyResult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-2_使用framework\">3.3.2 使用framework</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)loadFrameworkInAppGroup</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *err = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *containerURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class=\"string\">@\"group.com.xx.test\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *desPath = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/Library/Caches/Dylib.framework\"</span>,containerURL.path];</span><br><span class=\"line\">    <span class=\"built_in\">NSBundle</span> *bundle = [<span class=\"built_in\">NSBundle</span> bundleWithPath:desPath];</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> result = [bundle loadAndReturnError:&amp;err];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        Class root = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"Person\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            Person *person = [[root alloc] init];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (person) &#123;</span><br><span class=\"line\">                [person run];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过测试，竟然能够加载成功。</p>\n<p>对比一下, 有如下总结: </p>\n<p>主要验证了两种方式:</p>\n<ol>\n<li>导入公用framework到项目中, 只有<strong>containing app</strong> 的 <strong>Link Binary With Libraries</strong>添加对应framework, extension运行时动态加载framework。</li>\n<li><strong>containing app</strong> 和 <strong>extension</strong>的<strong>Link Binary With Libraries</strong>分别链接公用framework, (Compile Sources 只包含在framework这个target中)</li>\n</ol>\n<p>以上两种方式都可以做到公用资源。 区别如下:</p>\n<ol>\n<li><p>方式一需要App Groups, 共享资源。 方式二不需要。</p>\n</li>\n<li><p>方式一需要<strong>containing app</strong>先启动把, 把数据copy到App Groups中, <strong>entension</strong>才能加载到。 方式二不需要。</p>\n</li>\n<li><p>方式一不能直接初始化类, 比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;TestFrameWork/FilterImage.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">FilterImage *filter = [[FilterImage alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">将会报错:</span><br><span class=\"line\"></span><br><span class=\"line\">Undefined symbols <span class=\"keyword\">for</span> architecture x86_64:</span><br><span class=\"line\">  <span class=\"string\">\"_OBJC_CLASS_$_FilterImage\"</span>, referenced from:</span><br><span class=\"line\">      objc-class-ref <span class=\"keyword\">in</span> PhotoEditingViewController.o</span><br><span class=\"line\">ld: symbol(s) not found <span class=\"keyword\">for</span> architecture x86_64</span><br><span class=\"line\">clang: error: linker command failed with exit code <span class=\"number\">1</span> (use -v to see invocation)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   需要用这样的方式:</p>\n   <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class root = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"FilterImage\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">    FilterImage *filter = [[root alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *nameLUT = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/TestFrameWork.bundle/images/filter_lut_%d\"</span>, desPath, <span class=\"number\">2</span>];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.imageView.image = [filter filterImage:<span class=\"keyword\">self</span>.input.displaySizeImage imageName:nameLUT];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   方式二可以直接使用。 (#import “FilterImage.h”)</p>\n<p>   ​</p>\n<p>   对比了一下导出包的大小。</p>\n<p>   写了3个Demo, </p>\n<ol>\n<li>方式一, 动态加载          12.1M</li>\n<li>方式二，静态链接         23.7M</li>\n<li>方式三，只包含framework，没有extension   11.2M</li>\n</ol>\n<h1 id=\"4-_生命周期\">4. 生命周期</h1><p>下图来自官方文档，它详细描述了Extension App的生命周期 <img src=\"http://img.my.csdn.net/uploads/201512/13/1449996016_4664.png\" alt=\"Life_Cycle\"></p>\n<p><strong>开始</strong></p>\n<p>在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。</p>\n<p><strong>执行任务</strong></p>\n<p>在extension启动以后，开始执行它的使命。</p>\n<p><strong>终止</strong></p>\n<p>在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。</p>\n<p>由此可见，extension就是为了任务而生！</p>\n<h1 id=\"5-_Photo_Editing使用滤镜实战\">5. Photo Editing使用滤镜实战</h1><p>这里因为时间关系, 就直接采用 <strong>Apple</strong> 官方例子, 不再重新写了。如果实践过程中, 有遇到任何问题, 欢迎留言或者其他方式与我交流~</p>\n<p>Demo下载地址: <img src=\"http://download.csdn.net/images/minetype/zip.gif\" alt=\"\">Photo Editing Extension Demo  </p>\n<p>这里有几点需要注意的。</p>\n<ol>\n<li><p>因为Host App是Photos, 所以我们的Extension必须适配横竖屏, 因为它的状态是跟着Host App变的, 而不是Containing App。 至于横竖屏的适配, 建议采用Size Class, 然后监听缩放模式, 来适配屏幕</p>\n<p>​</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark - UIContentContainer</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)willTransitionToTraitCollection:(<span class=\"built_in\">UITraitCollection</span> *)newCollection</span><br><span class=\"line\">              withTransitionCoordinator:(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIViewControllerTransitionCoordinator</span>&gt;)coordinator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> willTransitionToTraitCollection:newCollection</span><br><span class=\"line\">                 withTransitionCoordinator:coordinator];</span><br><span class=\"line\">    [coordinator animateAlongsideTransition:^(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIViewControllerTransitionCoordinatorContext</span>&gt; context) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 横屏处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 竖屏处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.view setNeedsLayout];</span><br><span class=\"line\">    &#125; completion:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   同样, 需要获取初始状态来处理。</p>\n<p>   ​</p>\n   <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.traitCollection.verticalSizeClass == <span class=\"built_in\">UIUserInterfaceSizeClassCompact</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//To Do: modify something for compact vertical size</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//To Do: modify something for other vertical size</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果第三方库用Pod来管理的话, 需要修改pod的target, 以及添加链接。</p>\n<p><code>Build Settings — &gt; Other Linker Flags    **-l&quot;Pods-MBProgressHUD&quot;**</code></p>\n</li>\n</ol>\n<h1 id=\"6-_相关资料\">6. 相关资料</h1><p><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1\">App Extension Programming Guide</a></p>\n<p><a href=\"http://www.infoq.com/news/2014/07/apple-ios8-app-extensions\">App Extensions for iOS 8 in Depth</a></p>\n<p><a href=\"http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/\">WWDC2014之App Extensions学习笔记</a></p>\n<p><a href=\"https://developer.apple.com/library/ios/samplecode/SamplePhotoEditingExtension/Introduction/Intro.html#//apple_ref/doc/uid/TP40014576\">Sample Photo Editing Extension</a></p>"},{"title":"TDD 学习总结（Swift 实践）","date":"2016-06-03T11:33:40.000Z","_content":"\n> 花了几天时间，看完了 [《Test-Driven iOS Development with Swift》](https://www.packtpub.com/application-development/test-driven-ios-development-swift) 这本书，虽然只有短短 500页的 epub，但是讲解的很生动透彻，全书围绕一个 `ToDo` 应用展开，讲解了 `Test-Driven Development （TDD，即测试驱动开发）` 的实际应用，让我对 TDD 有了更全面的认识。故此，开坑记录之~\n\n![TDD](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDTDDFigure.png)\n\n<!--more-->\n\n\n\n## 什么是 TDD\n\n测试驱动开发(TDD)是极限编程的重要特点，它以不断的测试推动代码的开发，既简化了代码，又保证了软件质量。\n\n测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。\n\nOK，概括来说，TDD 的开发过程可以用上图来描述：Red，Green，Refactor。\n\n翻译过来就是：\n\n1. 编写测试用例，测试不通过。（红色 Error）\n2. 编写代码实现功能，测试通过。（绿色 Success）\n3. 重构优化代码。（Refactor）\n\n再详细点，测试驱动开发的基本过程如下：\n\n1. 明确当前要完成的功能。记录成一个 TODO 列表。\n2. 快速完成针对此功能的测试用例编写。\n3. 测试代码编译不通过。\n4. 编写对应的功能代码。\n5. 测试通过。\n6. 对代码进行重构，并保证测试通过。\n7. 循环完成所有功能的开发。\n\n怎么样，简单吧~\n\n\n\n## 是否该用 TDD\n\n简单是简单，但是很明显的，开发前期，工作量绝对不是 1+1 那么简单，那么是否该用 TDD 呢？对此，我不做过多的阐述。世上并没有放之四海皆准的法则，TDD 好坏在于你的判断，方法论的主体在于使用的人，本文并不会给你一个完美的答案，这需要你自己在实践中取舍。接下去，我将列举 TDD 目前公认的一些优缺点，以及使用原则，加深大家对 TDD 的理解。\n\n**TDD 开发的优点：**\n\n- 可以保证代码的质量。可以对自己的所需要的业务功能的每一步设计进行验证，并得到正确的结果，减少bug的出现的，特别对于复杂业务逻辑的项目，以小步慢走的方式，避免后期繁重的测试和维护工作。\n- 找到了重构的信心，必要时候你还可以痛痛快快的并且满怀信心的对代码做一场大的变革。这样我们的代码变得干净了，扩展性、可以维护性以及易理解性纷至沓来。\n- 在团队建设中能够进行分工，以可执行的形式文档化你的需求，迫使你分清职责隔离依赖以驱动你的设计，编织安全网以便将Bug扼杀在在摇篮状态，防止其逃逸。不同于传统开发（传统的开发人员开发的软件的测试是为了找出已经逃逸得bug，可能这个bug已经长成了毒瘤）。注：这两种活动都是必要的，而且毫不冲突，互为补充。\n- 帮助你养成一个新的思维习惯，不光在你编程的道路上，在你的工作和生活中，你慢慢的会把自己的需求进行分析设计并不断地验证，最终更好去实现自己的人生目标。\n\n**TDD 开发的缺点：**\n\n- 对于测试驱动不熟练或者喜欢偷懒的的人员，加大了代码的编写量，测试代码是系统代码的两倍或更多。\n- 可能不适合时间很紧的软件开发，更适合于产品和平台的开发。\n\n**TDD 原则：**\n\n- **独立测试：**不同代码的测试应该相互独立，一个类对应一个测试类，一个函数对应一个测试函数。用例也应各自独立，每个用例不能使用其他用例的结果数据，结果也不能依赖于用例执行顺序。 一个角色：开发过程包含多种工作，如：编写测试代码、编写产品代码、代码重构等。做不同的工作时，应专注于当前的角色，不要过多考虑其他方面的细节。\n\n- **测试列表：**代码的功能点可能很多，并且需求可能是陆续出现的，任何阶段想添加功能时，应把相关功能点加到测试列表中，然后才能继续手头工作，避免疏漏。\n\n- **测试驱动：**即利用测试来驱动开发，是TDD的核心。要实现某个功能，要编写某个类或某个函数，应首先编写测试代码，明确这个类、这个函数如何使用，如何测试，然后在对其进行设计、编码。\n\n- **先写断言：**编写测试代码时，应该首先编写判断代码功能的断言语句，然后编写必要的辅助语句。\n\n- **可测试性：**产品代码设计、开发时的应尽可能提高可测试性。每个代码单元的功能应该比较单纯，“各家自扫门前雪”，每个类、每个函数应该只做它该做的事，不要弄成大杂烩。尤其是增加新功能时，不要为了图一时之便，随便在原有代码中添加功能。\n\n- **及时重构：**对结构不合理，重复等“味道”不好的代码，在测试通过后，应及时进行重构。\n\n- **小步前进：**软件开发是复杂性非常高的工作，小步前进是降低复杂性的好办法。\n\n  ​\n\n看到这里，如果你还觉得，有必要体验一把 TDD，那么接着往下看，我将通过一个简单的例子，走一遍 TDD 开发的流程，加深大家对 TDD 的了解，也为 iOS 中应用 TDD 做个入门介绍。\n\n\n\n## iOS 中如何使用 TDD\n\n> Apple一直致力于在iOS开发中集成更加方便和可用的测试，在Xcode 5中，新的IDE和SDK引入了XCTest来替代原来的SenTestingKit，并且取消了新建工程时的“包括单元测试”的可选项（同样待遇的还有使用ARC的可选项）。新工程将自动包含测试的target，并且相关框架也搭建完毕，可以说测试终于摆脱了iOS开发中“二等公民”的地位，现在已经变得和产品代码一样重要了。  —————— 喵神\n\n简单 Mark 下 TDD 在 Xcode 中的历程：\n\n- In 1998, the Swiss company Sen:te developed OCUnit, a testing framework for Objective-C (hence, the OC prefix). OCUnit was a port of SUnit, a testing framework that Kent Beck had written for Smalltalk in 1994.\n- With Xcode 2.1, Apple added OCUnit to Xcode.\n- In 2008, OCUnit was integrated into the iPhone SDK 2.2 to allow unit testing of iPhone apps.\n- Four years later, OCUnit was renamed XCUnit (XC stands for Xcode).\n\n既然 Xcode 为我们内置了这么方便的 XCTest，我们没理由不好好使用阿~\n\n接下去通过实现一个简单的功能：把句子中每个单词的首字母转成大写字母，来走一遍 TDD 的流程。话不多说，开车了~\n\n\n\n### 1. 创建工程\n\n这里创建一个常规的 iOS 工程，记得 `“ Include Unit Tests” ` 即可，语言我们选择 `Swift`。\n\n![demo_0](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_0.jpeg)\n\n\n\n创建完毕后的工程目录如下：\n\n![demo_1](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_3.jpeg)\n\n默认为我们创建了 `TDDDemoTests.swift` 文件，这里就是我们编写测试用例的地方。打开该文件，如下所示：\n\n```swift\n//\n//  TDDDemoTests.swift\n//  TDDDemoTests\n//\n//  Created by Colin on 16/6/3.\n//  Copyright © 2016年 Colin. All rights reserved.\n//\n\nimport XCTest\n@testable import TDDDemo\n\nclass TDDDemoTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        // Put setup code here. This method is called before the invocation of each test method in the class.\n    }\n    \n    override func tearDown() {\n        // Put teardown code here. This method is called after the invocation of each test method in the class.\n        super.tearDown()\n    }\n    \n    func testExample() {\n        // This is an example of a functional test case.\n        // Use XCTAssert and related functions to verify your tests produce the correct results.\n    }\n    \n    func testPerformanceExample() {\n        // This is an example of a performance test case.\n        self.measureBlock {\n            // Put the code you want to measure the time of here.\n        }\n    }\n}\n```\n\n其中，有几个地方需要说明一下：\n\n```swift\nimport XCTest\n@testable import TDDDemo\n```\n\n每一个测试用例都需要引入 `XCTest` 框架，它定义了我们需要的 `XCTestCase` 类，以及之后会用到的一些断言，比如 `XCTAssertEqual` 等。另外，还需要手动导入 `TDDDemo` 模块，我们之后的相关代码都会在 `TDDDemo` 中编写，但是默认情况下，类，结构体，枚举以及它们的方法，都是内联的（`internal`），这意味着它们所处模块外无法直接访问到它们。所以在此之外的测试代码无法访问到它们，故而需要使用 `@testable` 关键字来让测试代码能访问它们。\n\n再看 `setUp` 方法和 `tearDown` 。在每个测试用例调用前，都会先调用 `setUp` 方法，在每个测试用例执行结束后，都会调用 `tearDown` 方法，大体流程就是：setUp — test case — tearDown — setUp — test case — tearDown …. 所以我们一般在 `setUp` 中做一些初始化操作，在 `tearDown`  做一些清除释放操作。\n\n另外，每一个测试方法都需要以 `test` 开头，这样 Xcode 才能自动识别出它。比如默认提供的 `testExample` 和 `testPerformanceExample` 。\n\n\n\n再有，这里建议在 Bulid 开始的时候，新建一个导航栏，并且打印 Build Log，这样我们能更直观知道发生了什么，哪里出错了。具体设置如下： **Xcode | Preference | Behaviors** \n\n如图所示：\n\n![demo_2](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_1.jpeg)\n\n现在 **Command + U**，执行测试。毋庸置疑，测试通过（毕竟啥都还没开始写…）。你会看到如下界面：\n\n![demo_3](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_4.jpeg)\n\n左边的  **Test Navigation** 列举了所有的测试用例以及对应的测试结果。中间的编辑区展示了 **Bulid** 过程中具体做了什么，以及 **Build** 结果。\n\n\n\n哦，对了。还有一处设置也很有用。\n\n**Edit Scheme | Test** ，可以看到右边列举了所有参与测试的用例。当然我们知道，每个用例的测试都是需要时间的，如果想对某个用例单独测试，或者不想测试某个用例，相应的勾选和去选就可以了。\n\n![demo_4](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_5.jpeg)\n\n\n\n### 2. 编写测试用例\n\n好了，万事俱备，是时候展示真正的技术了！\n\n删除默认的 `TDDDemoTests.swift` 文件，重新创建一个 `CapitalTest.swift` 文件。在 `TDDDemoTests` 分组中，**File | New | File | iOS | Source | Unit Test Case Class** ，创建一个名为 **CapitalTest** 并 继承自 **XCTestCase** 的类。如图所示：\n\n![demo_5](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_6.jpeg)\n\n\n\n删掉无用的 **testExample，testPerformanceExample** 方法。\n\n引用 **TDDDemo** 类。\n\n```swift\n@testable import TDDDemo\n```\n\n编写测试用例：\n\n这里我们要做的是实现句子中单词首字母的大写转换，所以只要写个测试用例验证首字母是否都是大写即可。\n\n```swift\n    func testMakeHeadline_ReturnsStringWithEachWordStartCapital() {\n        \n        let viewController = ViewController()\n        \n        let string = \"this is A test headline\"\n        let headline = viewController.makeHeadline(string)\n        \n        XCTAssertEqual(headline, \"This Is A Test Headline\")\n    }\n```\n\n很简单，我们希望有这样一个函数 `makeHeadline`，它接受一个 **String** 类型的参数，并返回转换成功的  **String** 类型的结果。然后利用 `XCTAssertEqual` 判断一下，当左右值相同时，它才会通过。\n\n很显然，这个时候会保持，且测试不通过，因为我们的 `makeHeadline` 函数根本就不存在，现在就去实现它。\n\n回到 **ViewController.swift** 中，添加如下方法。\n\n```swift\n    func makeHeadline(string: String) -> String {\n        \n        return \"This Is A Test Headline\"\n    }\n```\n\n**Command + U** 走一遍，恭喜你，测试走通了。全部显示绿色的 Build succeeded。（眼尖的朋友可能发现问题了，不过不急，至少目前为止，我们的测试用例已经通过了~）\n\n然后接下去，做的就是重构了。虽然只写了几行代码，但是还是有优化空间的。\n\n我们之前提到过，**setUp** 方法将在每个 **test case** 调用前都自动被调用，所以这里可以放一些初始化相关操作。我们这里初始化了一个 **ViewController** 类型的对象，不出意外的话，在每个测试用例中中需要初始化一个，这无疑是很麻烦的。所以我们可以把 **viewController** 提出来，当做 **CapitalTest** 类的一个属性，然后在 **setUp** 方法中去初始化它。具体如下：\n\n```swift\nclass CapitalTest: XCTestCase {\n    \n    var viewController: ViewController!\n\n    override func setUp() {\n        super.setUp()\n        \n        viewController = ViewController()\n    }\n    \n\t/////////\n}\n```\n\n接下去，我们需要在编写另外一个测试用例，以保证第一个测试用例并不是偶然的。这也是我们在实际开发中需要做的，列举多个测试用例，来保证某个功能确实通过了。\n\n```swift\n    func testMakeHeadline_ReturnsStringWithEachWordStartCapital2() {\n        \n        let string = \"Here is another Example\"\n        let headline = viewController.makeHeadline(string)\n        \n        XCTAssertEqual(headline, \"Here Is Another Example\")\n    }\n```\n\n再次 **Command + U**，不出意外，第一个还是通过，第二个则显示失败。原因大家都懂~\n\n接下去修改 `makeHeadline` 的具体实现：\n\n```swift\n    func makeHeadline(string: String) -> String {\n        \n        // 1. 通过“ ”分割字符串, 存入数组\n        let words = string.componentsSeparatedByString(\" \")\n        \n        // 2. 遍历数组, 移除首字母, 并插入对应的大写字母\n        var headline = \"\"\n        for var word in words {\n            let firstCharacter = word.removeAtIndex(word.startIndex)\n            headline += \"\\(String(firstCharacter).uppercaseString)\\(word) \"\n        }\n        \n        // 3. 移除最后的“ ”\n        headline.removeAtIndex(headline.endIndex.predecessor())\n        return headline\n    }\n```\n\n代码很简单，注释也写的很清楚，这里就不累述了。再次 **Command + U**，bingo~ 通过了。\n\n接下去再看看，是否有优化的空间。\n\n1. 我们的测试用例描述的其实不太清楚，几个变量之间的关系比较凌乱。\n2. **makeHeadline** 函数的实现太 Objc 化了，没有用上 Swift 里的高级功能。\n\nOK，既然不好，那就优化一下呗~\n\n```swift\nfunc testMakeHeadline_ReturnsStringWithEachWordStartCapital() {\n\n        let inputString =       \"this is A test headline\"\n        let expectedHeadline =  \"This Is A Test Headline\"\n        \n        let result = viewController.makeHeadline(inputString)\n        XCTAssertEqual(result, expectedHeadline)\n    }\n    \nfunc makeHeadline(string: String) -> String {\n\n        let words = string.componentsSeparatedByString(\" \")\n        \n        let headline = words.map { (var word) -> String in\n          let firstCharacter = word.removeAtIndex(word.startIndex)\n          return \"\\(String(firstCharacter).uppercaseString)\\(word)\"\n          }.joinWithSeparator(\" \")\n        \n        return headline\n    }\n```\n\n\n\n再次  **Command + U**，确保测试通过。至此，这个简单的例子算是介绍完了。\n\n虽然例子简单，只实现了一个功能，但是 TDD 相关的东西，具体流程也都涉及了，剩下的，只是重复这些操作直至完成所有需求。\n\n\n\n如果觉得这个例子太简单了，没学够，建议看下 [《Test-Driven iOS Development with Swift》](https://www.packtpub.com/application-development/test-driven-ios-development-swift)  一书中的 [ToDo 源码](http://www.packtpub.com/code_download/23832)，大篇幅介绍 TDD 的实际应用。\n\n\n\nHave Fun~\n\n## 参考链接\n\n\n\n由衷感谢以下作者的贡献，文中出现的一些理论阐述，有从相关文章中摘取。\n\n[TDD的iOS开发初步以及Kiwi使用入门](https://onevcat.com/2014/02/ios-test-with-kiwi/)\n\n[浅谈测试驱动开发（TDD）](http://www.ibm.com/developerworks/cn/linux/l-tdd/index.html)\n\n[TDD(测试驱动开发)培训录](http://www.cnblogs.com/whitewolf/p/4205761.html)\n\n[《Test-Driven iOS Development with Swift》](https://www.packtpub.com/application-development/test-driven-ios-development-swift) \n\n","source":"_posts/TDD-With-Swift.md","raw":"title: TDD 学习总结（Swift 实践）\ndate: 2016-06-03 19:33:40\n\ntags:\n\n- iOS开发\n- TDD\n- Swift\n\n------\n\n> 花了几天时间，看完了 [《Test-Driven iOS Development with Swift》](https://www.packtpub.com/application-development/test-driven-ios-development-swift) 这本书，虽然只有短短 500页的 epub，但是讲解的很生动透彻，全书围绕一个 `ToDo` 应用展开，讲解了 `Test-Driven Development （TDD，即测试驱动开发）` 的实际应用，让我对 TDD 有了更全面的认识。故此，开坑记录之~\n\n![TDD](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDTDDFigure.png)\n\n<!--more-->\n\n\n\n## 什么是 TDD\n\n测试驱动开发(TDD)是极限编程的重要特点，它以不断的测试推动代码的开发，既简化了代码，又保证了软件质量。\n\n测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。\n\nOK，概括来说，TDD 的开发过程可以用上图来描述：Red，Green，Refactor。\n\n翻译过来就是：\n\n1. 编写测试用例，测试不通过。（红色 Error）\n2. 编写代码实现功能，测试通过。（绿色 Success）\n3. 重构优化代码。（Refactor）\n\n再详细点，测试驱动开发的基本过程如下：\n\n1. 明确当前要完成的功能。记录成一个 TODO 列表。\n2. 快速完成针对此功能的测试用例编写。\n3. 测试代码编译不通过。\n4. 编写对应的功能代码。\n5. 测试通过。\n6. 对代码进行重构，并保证测试通过。\n7. 循环完成所有功能的开发。\n\n怎么样，简单吧~\n\n\n\n## 是否该用 TDD\n\n简单是简单，但是很明显的，开发前期，工作量绝对不是 1+1 那么简单，那么是否该用 TDD 呢？对此，我不做过多的阐述。世上并没有放之四海皆准的法则，TDD 好坏在于你的判断，方法论的主体在于使用的人，本文并不会给你一个完美的答案，这需要你自己在实践中取舍。接下去，我将列举 TDD 目前公认的一些优缺点，以及使用原则，加深大家对 TDD 的理解。\n\n**TDD 开发的优点：**\n\n- 可以保证代码的质量。可以对自己的所需要的业务功能的每一步设计进行验证，并得到正确的结果，减少bug的出现的，特别对于复杂业务逻辑的项目，以小步慢走的方式，避免后期繁重的测试和维护工作。\n- 找到了重构的信心，必要时候你还可以痛痛快快的并且满怀信心的对代码做一场大的变革。这样我们的代码变得干净了，扩展性、可以维护性以及易理解性纷至沓来。\n- 在团队建设中能够进行分工，以可执行的形式文档化你的需求，迫使你分清职责隔离依赖以驱动你的设计，编织安全网以便将Bug扼杀在在摇篮状态，防止其逃逸。不同于传统开发（传统的开发人员开发的软件的测试是为了找出已经逃逸得bug，可能这个bug已经长成了毒瘤）。注：这两种活动都是必要的，而且毫不冲突，互为补充。\n- 帮助你养成一个新的思维习惯，不光在你编程的道路上，在你的工作和生活中，你慢慢的会把自己的需求进行分析设计并不断地验证，最终更好去实现自己的人生目标。\n\n**TDD 开发的缺点：**\n\n- 对于测试驱动不熟练或者喜欢偷懒的的人员，加大了代码的编写量，测试代码是系统代码的两倍或更多。\n- 可能不适合时间很紧的软件开发，更适合于产品和平台的开发。\n\n**TDD 原则：**\n\n- **独立测试：**不同代码的测试应该相互独立，一个类对应一个测试类，一个函数对应一个测试函数。用例也应各自独立，每个用例不能使用其他用例的结果数据，结果也不能依赖于用例执行顺序。 一个角色：开发过程包含多种工作，如：编写测试代码、编写产品代码、代码重构等。做不同的工作时，应专注于当前的角色，不要过多考虑其他方面的细节。\n\n- **测试列表：**代码的功能点可能很多，并且需求可能是陆续出现的，任何阶段想添加功能时，应把相关功能点加到测试列表中，然后才能继续手头工作，避免疏漏。\n\n- **测试驱动：**即利用测试来驱动开发，是TDD的核心。要实现某个功能，要编写某个类或某个函数，应首先编写测试代码，明确这个类、这个函数如何使用，如何测试，然后在对其进行设计、编码。\n\n- **先写断言：**编写测试代码时，应该首先编写判断代码功能的断言语句，然后编写必要的辅助语句。\n\n- **可测试性：**产品代码设计、开发时的应尽可能提高可测试性。每个代码单元的功能应该比较单纯，“各家自扫门前雪”，每个类、每个函数应该只做它该做的事，不要弄成大杂烩。尤其是增加新功能时，不要为了图一时之便，随便在原有代码中添加功能。\n\n- **及时重构：**对结构不合理，重复等“味道”不好的代码，在测试通过后，应及时进行重构。\n\n- **小步前进：**软件开发是复杂性非常高的工作，小步前进是降低复杂性的好办法。\n\n  ​\n\n看到这里，如果你还觉得，有必要体验一把 TDD，那么接着往下看，我将通过一个简单的例子，走一遍 TDD 开发的流程，加深大家对 TDD 的了解，也为 iOS 中应用 TDD 做个入门介绍。\n\n\n\n## iOS 中如何使用 TDD\n\n> Apple一直致力于在iOS开发中集成更加方便和可用的测试，在Xcode 5中，新的IDE和SDK引入了XCTest来替代原来的SenTestingKit，并且取消了新建工程时的“包括单元测试”的可选项（同样待遇的还有使用ARC的可选项）。新工程将自动包含测试的target，并且相关框架也搭建完毕，可以说测试终于摆脱了iOS开发中“二等公民”的地位，现在已经变得和产品代码一样重要了。  —————— 喵神\n\n简单 Mark 下 TDD 在 Xcode 中的历程：\n\n- In 1998, the Swiss company Sen:te developed OCUnit, a testing framework for Objective-C (hence, the OC prefix). OCUnit was a port of SUnit, a testing framework that Kent Beck had written for Smalltalk in 1994.\n- With Xcode 2.1, Apple added OCUnit to Xcode.\n- In 2008, OCUnit was integrated into the iPhone SDK 2.2 to allow unit testing of iPhone apps.\n- Four years later, OCUnit was renamed XCUnit (XC stands for Xcode).\n\n既然 Xcode 为我们内置了这么方便的 XCTest，我们没理由不好好使用阿~\n\n接下去通过实现一个简单的功能：把句子中每个单词的首字母转成大写字母，来走一遍 TDD 的流程。话不多说，开车了~\n\n\n\n### 1. 创建工程\n\n这里创建一个常规的 iOS 工程，记得 `“ Include Unit Tests” ` 即可，语言我们选择 `Swift`。\n\n![demo_0](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_0.jpeg)\n\n\n\n创建完毕后的工程目录如下：\n\n![demo_1](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_3.jpeg)\n\n默认为我们创建了 `TDDDemoTests.swift` 文件，这里就是我们编写测试用例的地方。打开该文件，如下所示：\n\n```swift\n//\n//  TDDDemoTests.swift\n//  TDDDemoTests\n//\n//  Created by Colin on 16/6/3.\n//  Copyright © 2016年 Colin. All rights reserved.\n//\n\nimport XCTest\n@testable import TDDDemo\n\nclass TDDDemoTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        // Put setup code here. This method is called before the invocation of each test method in the class.\n    }\n    \n    override func tearDown() {\n        // Put teardown code here. This method is called after the invocation of each test method in the class.\n        super.tearDown()\n    }\n    \n    func testExample() {\n        // This is an example of a functional test case.\n        // Use XCTAssert and related functions to verify your tests produce the correct results.\n    }\n    \n    func testPerformanceExample() {\n        // This is an example of a performance test case.\n        self.measureBlock {\n            // Put the code you want to measure the time of here.\n        }\n    }\n}\n```\n\n其中，有几个地方需要说明一下：\n\n```swift\nimport XCTest\n@testable import TDDDemo\n```\n\n每一个测试用例都需要引入 `XCTest` 框架，它定义了我们需要的 `XCTestCase` 类，以及之后会用到的一些断言，比如 `XCTAssertEqual` 等。另外，还需要手动导入 `TDDDemo` 模块，我们之后的相关代码都会在 `TDDDemo` 中编写，但是默认情况下，类，结构体，枚举以及它们的方法，都是内联的（`internal`），这意味着它们所处模块外无法直接访问到它们。所以在此之外的测试代码无法访问到它们，故而需要使用 `@testable` 关键字来让测试代码能访问它们。\n\n再看 `setUp` 方法和 `tearDown` 。在每个测试用例调用前，都会先调用 `setUp` 方法，在每个测试用例执行结束后，都会调用 `tearDown` 方法，大体流程就是：setUp — test case — tearDown — setUp — test case — tearDown …. 所以我们一般在 `setUp` 中做一些初始化操作，在 `tearDown`  做一些清除释放操作。\n\n另外，每一个测试方法都需要以 `test` 开头，这样 Xcode 才能自动识别出它。比如默认提供的 `testExample` 和 `testPerformanceExample` 。\n\n\n\n再有，这里建议在 Bulid 开始的时候，新建一个导航栏，并且打印 Build Log，这样我们能更直观知道发生了什么，哪里出错了。具体设置如下： **Xcode | Preference | Behaviors** \n\n如图所示：\n\n![demo_2](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_1.jpeg)\n\n现在 **Command + U**，执行测试。毋庸置疑，测试通过（毕竟啥都还没开始写…）。你会看到如下界面：\n\n![demo_3](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_4.jpeg)\n\n左边的  **Test Navigation** 列举了所有的测试用例以及对应的测试结果。中间的编辑区展示了 **Bulid** 过程中具体做了什么，以及 **Build** 结果。\n\n\n\n哦，对了。还有一处设置也很有用。\n\n**Edit Scheme | Test** ，可以看到右边列举了所有参与测试的用例。当然我们知道，每个用例的测试都是需要时间的，如果想对某个用例单独测试，或者不想测试某个用例，相应的勾选和去选就可以了。\n\n![demo_4](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_5.jpeg)\n\n\n\n### 2. 编写测试用例\n\n好了，万事俱备，是时候展示真正的技术了！\n\n删除默认的 `TDDDemoTests.swift` 文件，重新创建一个 `CapitalTest.swift` 文件。在 `TDDDemoTests` 分组中，**File | New | File | iOS | Source | Unit Test Case Class** ，创建一个名为 **CapitalTest** 并 继承自 **XCTestCase** 的类。如图所示：\n\n![demo_5](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_6.jpeg)\n\n\n\n删掉无用的 **testExample，testPerformanceExample** 方法。\n\n引用 **TDDDemo** 类。\n\n```swift\n@testable import TDDDemo\n```\n\n编写测试用例：\n\n这里我们要做的是实现句子中单词首字母的大写转换，所以只要写个测试用例验证首字母是否都是大写即可。\n\n```swift\n    func testMakeHeadline_ReturnsStringWithEachWordStartCapital() {\n        \n        let viewController = ViewController()\n        \n        let string = \"this is A test headline\"\n        let headline = viewController.makeHeadline(string)\n        \n        XCTAssertEqual(headline, \"This Is A Test Headline\")\n    }\n```\n\n很简单，我们希望有这样一个函数 `makeHeadline`，它接受一个 **String** 类型的参数，并返回转换成功的  **String** 类型的结果。然后利用 `XCTAssertEqual` 判断一下，当左右值相同时，它才会通过。\n\n很显然，这个时候会保持，且测试不通过，因为我们的 `makeHeadline` 函数根本就不存在，现在就去实现它。\n\n回到 **ViewController.swift** 中，添加如下方法。\n\n```swift\n    func makeHeadline(string: String) -> String {\n        \n        return \"This Is A Test Headline\"\n    }\n```\n\n**Command + U** 走一遍，恭喜你，测试走通了。全部显示绿色的 Build succeeded。（眼尖的朋友可能发现问题了，不过不急，至少目前为止，我们的测试用例已经通过了~）\n\n然后接下去，做的就是重构了。虽然只写了几行代码，但是还是有优化空间的。\n\n我们之前提到过，**setUp** 方法将在每个 **test case** 调用前都自动被调用，所以这里可以放一些初始化相关操作。我们这里初始化了一个 **ViewController** 类型的对象，不出意外的话，在每个测试用例中中需要初始化一个，这无疑是很麻烦的。所以我们可以把 **viewController** 提出来，当做 **CapitalTest** 类的一个属性，然后在 **setUp** 方法中去初始化它。具体如下：\n\n```swift\nclass CapitalTest: XCTestCase {\n    \n    var viewController: ViewController!\n\n    override func setUp() {\n        super.setUp()\n        \n        viewController = ViewController()\n    }\n    \n\t/////////\n}\n```\n\n接下去，我们需要在编写另外一个测试用例，以保证第一个测试用例并不是偶然的。这也是我们在实际开发中需要做的，列举多个测试用例，来保证某个功能确实通过了。\n\n```swift\n    func testMakeHeadline_ReturnsStringWithEachWordStartCapital2() {\n        \n        let string = \"Here is another Example\"\n        let headline = viewController.makeHeadline(string)\n        \n        XCTAssertEqual(headline, \"Here Is Another Example\")\n    }\n```\n\n再次 **Command + U**，不出意外，第一个还是通过，第二个则显示失败。原因大家都懂~\n\n接下去修改 `makeHeadline` 的具体实现：\n\n```swift\n    func makeHeadline(string: String) -> String {\n        \n        // 1. 通过“ ”分割字符串, 存入数组\n        let words = string.componentsSeparatedByString(\" \")\n        \n        // 2. 遍历数组, 移除首字母, 并插入对应的大写字母\n        var headline = \"\"\n        for var word in words {\n            let firstCharacter = word.removeAtIndex(word.startIndex)\n            headline += \"\\(String(firstCharacter).uppercaseString)\\(word) \"\n        }\n        \n        // 3. 移除最后的“ ”\n        headline.removeAtIndex(headline.endIndex.predecessor())\n        return headline\n    }\n```\n\n代码很简单，注释也写的很清楚，这里就不累述了。再次 **Command + U**，bingo~ 通过了。\n\n接下去再看看，是否有优化的空间。\n\n1. 我们的测试用例描述的其实不太清楚，几个变量之间的关系比较凌乱。\n2. **makeHeadline** 函数的实现太 Objc 化了，没有用上 Swift 里的高级功能。\n\nOK，既然不好，那就优化一下呗~\n\n```swift\nfunc testMakeHeadline_ReturnsStringWithEachWordStartCapital() {\n\n        let inputString =       \"this is A test headline\"\n        let expectedHeadline =  \"This Is A Test Headline\"\n        \n        let result = viewController.makeHeadline(inputString)\n        XCTAssertEqual(result, expectedHeadline)\n    }\n    \nfunc makeHeadline(string: String) -> String {\n\n        let words = string.componentsSeparatedByString(\" \")\n        \n        let headline = words.map { (var word) -> String in\n          let firstCharacter = word.removeAtIndex(word.startIndex)\n          return \"\\(String(firstCharacter).uppercaseString)\\(word)\"\n          }.joinWithSeparator(\" \")\n        \n        return headline\n    }\n```\n\n\n\n再次  **Command + U**，确保测试通过。至此，这个简单的例子算是介绍完了。\n\n虽然例子简单，只实现了一个功能，但是 TDD 相关的东西，具体流程也都涉及了，剩下的，只是重复这些操作直至完成所有需求。\n\n\n\n如果觉得这个例子太简单了，没学够，建议看下 [《Test-Driven iOS Development with Swift》](https://www.packtpub.com/application-development/test-driven-ios-development-swift)  一书中的 [ToDo 源码](http://www.packtpub.com/code_download/23832)，大篇幅介绍 TDD 的实际应用。\n\n\n\nHave Fun~\n\n## 参考链接\n\n\n\n由衷感谢以下作者的贡献，文中出现的一些理论阐述，有从相关文章中摘取。\n\n[TDD的iOS开发初步以及Kiwi使用入门](https://onevcat.com/2014/02/ios-test-with-kiwi/)\n\n[浅谈测试驱动开发（TDD）](http://www.ibm.com/developerworks/cn/linux/l-tdd/index.html)\n\n[TDD(测试驱动开发)培训录](http://www.cnblogs.com/whitewolf/p/4205761.html)\n\n[《Test-Driven iOS Development with Swift》](https://www.packtpub.com/application-development/test-driven-ios-development-swift) \n\n","slug":"TDD-With-Swift","published":1,"updated":"2019-12-23T01:02:31.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1n60025zwlnh2yf11cl","content":"<blockquote>\n<p>花了几天时间，看完了 <a href=\"https://www.packtpub.com/application-development/test-driven-ios-development-swift\" target=\"_blank\" rel=\"external\">《Test-Driven iOS Development with Swift》</a> 这本书，虽然只有短短 500页的 epub，但是讲解的很生动透彻，全书围绕一个 <code>ToDo</code> 应用展开，讲解了 <code>Test-Driven Development （TDD，即测试驱动开发）</code> 的实际应用，让我对 TDD 有了更全面的认识。故此，开坑记录之~</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDTDDFigure.png\" alt=\"TDD\"></p>\n<a id=\"more\"></a>\n<h2 id=\"什么是_TDD\">什么是 TDD</h2><p>测试驱动开发(TDD)是极限编程的重要特点，它以不断的测试推动代码的开发，既简化了代码，又保证了软件质量。</p>\n<p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。</p>\n<p>OK，概括来说，TDD 的开发过程可以用上图来描述：Red，Green，Refactor。</p>\n<p>翻译过来就是：</p>\n<ol>\n<li>编写测试用例，测试不通过。（红色 Error）</li>\n<li>编写代码实现功能，测试通过。（绿色 Success）</li>\n<li>重构优化代码。（Refactor）</li>\n</ol>\n<p>再详细点，测试驱动开发的基本过程如下：</p>\n<ol>\n<li>明确当前要完成的功能。记录成一个 TODO 列表。</li>\n<li>快速完成针对此功能的测试用例编写。</li>\n<li>测试代码编译不通过。</li>\n<li>编写对应的功能代码。</li>\n<li>测试通过。</li>\n<li>对代码进行重构，并保证测试通过。</li>\n<li>循环完成所有功能的开发。</li>\n</ol>\n<p>怎么样，简单吧~</p>\n<h2 id=\"是否该用_TDD\">是否该用 TDD</h2><p>简单是简单，但是很明显的，开发前期，工作量绝对不是 1+1 那么简单，那么是否该用 TDD 呢？对此，我不做过多的阐述。世上并没有放之四海皆准的法则，TDD 好坏在于你的判断，方法论的主体在于使用的人，本文并不会给你一个完美的答案，这需要你自己在实践中取舍。接下去，我将列举 TDD 目前公认的一些优缺点，以及使用原则，加深大家对 TDD 的理解。</p>\n<p><strong>TDD 开发的优点：</strong></p>\n<ul>\n<li>可以保证代码的质量。可以对自己的所需要的业务功能的每一步设计进行验证，并得到正确的结果，减少bug的出现的，特别对于复杂业务逻辑的项目，以小步慢走的方式，避免后期繁重的测试和维护工作。</li>\n<li>找到了重构的信心，必要时候你还可以痛痛快快的并且满怀信心的对代码做一场大的变革。这样我们的代码变得干净了，扩展性、可以维护性以及易理解性纷至沓来。</li>\n<li>在团队建设中能够进行分工，以可执行的形式文档化你的需求，迫使你分清职责隔离依赖以驱动你的设计，编织安全网以便将Bug扼杀在在摇篮状态，防止其逃逸。不同于传统开发（传统的开发人员开发的软件的测试是为了找出已经逃逸得bug，可能这个bug已经长成了毒瘤）。注：这两种活动都是必要的，而且毫不冲突，互为补充。</li>\n<li>帮助你养成一个新的思维习惯，不光在你编程的道路上，在你的工作和生活中，你慢慢的会把自己的需求进行分析设计并不断地验证，最终更好去实现自己的人生目标。</li>\n</ul>\n<p><strong>TDD 开发的缺点：</strong></p>\n<ul>\n<li>对于测试驱动不熟练或者喜欢偷懒的的人员，加大了代码的编写量，测试代码是系统代码的两倍或更多。</li>\n<li>可能不适合时间很紧的软件开发，更适合于产品和平台的开发。</li>\n</ul>\n<p><strong>TDD 原则：</strong></p>\n<ul>\n<li><p><strong>独立测试：</strong>不同代码的测试应该相互独立，一个类对应一个测试类，一个函数对应一个测试函数。用例也应各自独立，每个用例不能使用其他用例的结果数据，结果也不能依赖于用例执行顺序。 一个角色：开发过程包含多种工作，如：编写测试代码、编写产品代码、代码重构等。做不同的工作时，应专注于当前的角色，不要过多考虑其他方面的细节。</p>\n</li>\n<li><p><strong>测试列表：</strong>代码的功能点可能很多，并且需求可能是陆续出现的，任何阶段想添加功能时，应把相关功能点加到测试列表中，然后才能继续手头工作，避免疏漏。</p>\n</li>\n<li><p><strong>测试驱动：</strong>即利用测试来驱动开发，是TDD的核心。要实现某个功能，要编写某个类或某个函数，应首先编写测试代码，明确这个类、这个函数如何使用，如何测试，然后在对其进行设计、编码。</p>\n</li>\n<li><p><strong>先写断言：</strong>编写测试代码时，应该首先编写判断代码功能的断言语句，然后编写必要的辅助语句。</p>\n</li>\n<li><p><strong>可测试性：</strong>产品代码设计、开发时的应尽可能提高可测试性。每个代码单元的功能应该比较单纯，“各家自扫门前雪”，每个类、每个函数应该只做它该做的事，不要弄成大杂烩。尤其是增加新功能时，不要为了图一时之便，随便在原有代码中添加功能。</p>\n</li>\n<li><p><strong>及时重构：</strong>对结构不合理，重复等“味道”不好的代码，在测试通过后，应及时进行重构。</p>\n</li>\n<li><p><strong>小步前进：</strong>软件开发是复杂性非常高的工作，小步前进是降低复杂性的好办法。</p>\n<p>​</p>\n</li>\n</ul>\n<p>看到这里，如果你还觉得，有必要体验一把 TDD，那么接着往下看，我将通过一个简单的例子，走一遍 TDD 开发的流程，加深大家对 TDD 的了解，也为 iOS 中应用 TDD 做个入门介绍。</p>\n<h2 id=\"iOS_中如何使用_TDD\">iOS 中如何使用 TDD</h2><blockquote>\n<p>Apple一直致力于在iOS开发中集成更加方便和可用的测试，在Xcode 5中，新的IDE和SDK引入了XCTest来替代原来的SenTestingKit，并且取消了新建工程时的“包括单元测试”的可选项（同样待遇的还有使用ARC的可选项）。新工程将自动包含测试的target，并且相关框架也搭建完毕，可以说测试终于摆脱了iOS开发中“二等公民”的地位，现在已经变得和产品代码一样重要了。  —————— 喵神</p>\n</blockquote>\n<p>简单 Mark 下 TDD 在 Xcode 中的历程：</p>\n<ul>\n<li>In 1998, the Swiss company Sen:te developed OCUnit, a testing framework for Objective-C (hence, the OC prefix). OCUnit was a port of SUnit, a testing framework that Kent Beck had written for Smalltalk in 1994.</li>\n<li>With Xcode 2.1, Apple added OCUnit to Xcode.</li>\n<li>In 2008, OCUnit was integrated into the iPhone SDK 2.2 to allow unit testing of iPhone apps.</li>\n<li>Four years later, OCUnit was renamed XCUnit (XC stands for Xcode).</li>\n</ul>\n<p>既然 Xcode 为我们内置了这么方便的 XCTest，我们没理由不好好使用阿~</p>\n<p>接下去通过实现一个简单的功能：把句子中每个单词的首字母转成大写字母，来走一遍 TDD 的流程。话不多说，开车了~</p>\n<h3 id=\"1-_创建工程\">1. 创建工程</h3><p>这里创建一个常规的 iOS 工程，记得 <code>“ Include Unit Tests”</code> 即可，语言我们选择 <code>Swift</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_0.jpeg\" alt=\"demo_0\"></p>\n<p>创建完毕后的工程目录如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_3.jpeg\" alt=\"demo_1\"></p>\n<p>默认为我们创建了 <code>TDDDemoTests.swift</code> 文件，这里就是我们编写测试用例的地方。打开该文件，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  TDDDemoTests.swift</span></span><br><span class=\"line\"><span class=\"comment\">//  TDDDemoTests</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Created by Colin on 16/6/3.</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright © 2016年 Colin. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> XCTest</span><br><span class=\"line\"><span class=\"meta\">@testable</span> <span class=\"keyword\">import</span> TDDDemo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TDDDemoTests</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setUp()</span><br><span class=\"line\">        <span class=\"comment\">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.tearDown()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testExample</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This is an example of a functional test case.</span></span><br><span class=\"line\">        <span class=\"comment\">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testPerformanceExample</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This is an example of a performance test case.</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.measureBlock &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Put the code you want to measure the time of here.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，有几个地方需要说明一下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> XCTest</span><br><span class=\"line\"><span class=\"meta\">@testable</span> <span class=\"keyword\">import</span> TDDDemo</span><br></pre></td></tr></table></figure>\n<p>每一个测试用例都需要引入 <code>XCTest</code> 框架，它定义了我们需要的 <code>XCTestCase</code> 类，以及之后会用到的一些断言，比如 <code>XCTAssertEqual</code> 等。另外，还需要手动导入 <code>TDDDemo</code> 模块，我们之后的相关代码都会在 <code>TDDDemo</code> 中编写，但是默认情况下，类，结构体，枚举以及它们的方法，都是内联的（<code>internal</code>），这意味着它们所处模块外无法直接访问到它们。所以在此之外的测试代码无法访问到它们，故而需要使用 <code>@testable</code> 关键字来让测试代码能访问它们。</p>\n<p>再看 <code>setUp</code> 方法和 <code>tearDown</code> 。在每个测试用例调用前，都会先调用 <code>setUp</code> 方法，在每个测试用例执行结束后，都会调用 <code>tearDown</code> 方法，大体流程就是：setUp — test case — tearDown — setUp — test case — tearDown …. 所以我们一般在 <code>setUp</code> 中做一些初始化操作，在 <code>tearDown</code>  做一些清除释放操作。</p>\n<p>另外，每一个测试方法都需要以 <code>test</code> 开头，这样 Xcode 才能自动识别出它。比如默认提供的 <code>testExample</code> 和 <code>testPerformanceExample</code> 。</p>\n<p>再有，这里建议在 Bulid 开始的时候，新建一个导航栏，并且打印 Build Log，这样我们能更直观知道发生了什么，哪里出错了。具体设置如下： <strong>Xcode | Preference | Behaviors</strong> </p>\n<p>如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_1.jpeg\" alt=\"demo_2\"></p>\n<p>现在 <strong>Command + U</strong>，执行测试。毋庸置疑，测试通过（毕竟啥都还没开始写…）。你会看到如下界面：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_4.jpeg\" alt=\"demo_3\"></p>\n<p>左边的  <strong>Test Navigation</strong> 列举了所有的测试用例以及对应的测试结果。中间的编辑区展示了 <strong>Bulid</strong> 过程中具体做了什么，以及 <strong>Build</strong> 结果。</p>\n<p>哦，对了。还有一处设置也很有用。</p>\n<p><strong>Edit Scheme | Test</strong> ，可以看到右边列举了所有参与测试的用例。当然我们知道，每个用例的测试都是需要时间的，如果想对某个用例单独测试，或者不想测试某个用例，相应的勾选和去选就可以了。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_5.jpeg\" alt=\"demo_4\"></p>\n<h3 id=\"2-_编写测试用例\">2. 编写测试用例</h3><p>好了，万事俱备，是时候展示真正的技术了！</p>\n<p>删除默认的 <code>TDDDemoTests.swift</code> 文件，重新创建一个 <code>CapitalTest.swift</code> 文件。在 <code>TDDDemoTests</code> 分组中，<strong>File | New | File | iOS | Source | Unit Test Case Class</strong> ，创建一个名为 <strong>CapitalTest</strong> 并 继承自 <strong>XCTestCase</strong> 的类。如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_6.jpeg\" alt=\"demo_5\"></p>\n<p>删掉无用的 <strong>testExample，testPerformanceExample</strong> 方法。</p>\n<p>引用 <strong>TDDDemo</strong> 类。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@testable</span> <span class=\"keyword\">import</span> TDDDemo</span><br></pre></td></tr></table></figure>\n<p>编写测试用例：</p>\n<p>这里我们要做的是实现句子中单词首字母的大写转换，所以只要写个测试用例验证首字母是否都是大写即可。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testMakeHeadline_ReturnsStringWithEachWordStartCapital</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">ViewController</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> string = <span class=\"string\">\"this is A test headline\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> headline = viewController.makeHeadline(string)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(headline, <span class=\"string\">\"This Is A Test Headline\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单，我们希望有这样一个函数 <code>makeHeadline</code>，它接受一个 <strong>String</strong> 类型的参数，并返回转换成功的  <strong>String</strong> 类型的结果。然后利用 <code>XCTAssertEqual</code> 判断一下，当左右值相同时，它才会通过。</p>\n<p>很显然，这个时候会保持，且测试不通过，因为我们的 <code>makeHeadline</code> 函数根本就不存在，现在就去实现它。</p>\n<p>回到 <strong>ViewController.swift</strong> 中，添加如下方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeHeadline</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"This Is A Test Headline\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Command + U</strong> 走一遍，恭喜你，测试走通了。全部显示绿色的 Build succeeded。（眼尖的朋友可能发现问题了，不过不急，至少目前为止，我们的测试用例已经通过了~）</p>\n<p>然后接下去，做的就是重构了。虽然只写了几行代码，但是还是有优化空间的。</p>\n<p>我们之前提到过，<strong>setUp</strong> 方法将在每个 <strong>test case</strong> 调用前都自动被调用，所以这里可以放一些初始化相关操作。我们这里初始化了一个 <strong>ViewController</strong> 类型的对象，不出意外的话，在每个测试用例中中需要初始化一个，这无疑是很麻烦的。所以我们可以把 <strong>viewController</strong> 提出来，当做 <strong>CapitalTest</strong> 类的一个属性，然后在 <strong>setUp</strong> 方法中去初始化它。具体如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CapitalTest</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> viewController: <span class=\"type\">ViewController</span>!</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setUp()</span><br><span class=\"line\">        </span><br><span class=\"line\">        viewController = <span class=\"type\">ViewController</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">/////////</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下去，我们需要在编写另外一个测试用例，以保证第一个测试用例并不是偶然的。这也是我们在实际开发中需要做的，列举多个测试用例，来保证某个功能确实通过了。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testMakeHeadline_ReturnsStringWithEachWordStartCapital2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> string = <span class=\"string\">\"Here is another Example\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> headline = viewController.makeHeadline(string)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(headline, <span class=\"string\">\"Here Is Another Example\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次 <strong>Command + U</strong>，不出意外，第一个还是通过，第二个则显示失败。原因大家都懂~</p>\n<p>接下去修改 <code>makeHeadline</code> 的具体实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeHeadline</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1. 通过“ ”分割字符串, 存入数组</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> words = string.componentsSeparatedByString(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 遍历数组, 移除首字母, 并插入对应的大写字母</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> headline = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">var</span> word <span class=\"keyword\">in</span> words &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> firstCharacter = word.removeAtIndex(word.startIndex)</span><br><span class=\"line\">        headline += <span class=\"string\">\"\\(String(firstCharacter).uppercaseString)\\(word) \"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 3. 移除最后的“ ”</span></span><br><span class=\"line\">    headline.removeAtIndex(headline.endIndex.predecessor())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> headline</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，注释也写的很清楚，这里就不累述了。再次 <strong>Command + U</strong>，bingo~ 通过了。</p>\n<p>接下去再看看，是否有优化的空间。</p>\n<ol>\n<li>我们的测试用例描述的其实不太清楚，几个变量之间的关系比较凌乱。</li>\n<li><strong>makeHeadline</strong> 函数的实现太 Objc 化了，没有用上 Swift 里的高级功能。</li>\n</ol>\n<p>OK，既然不好，那就优化一下呗~</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testMakeHeadline_ReturnsStringWithEachWordStartCapital</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> inputString =       <span class=\"string\">\"this is A test headline\"</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> expectedHeadline =  <span class=\"string\">\"This Is A Test Headline\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = viewController.makeHeadline(inputString)</span><br><span class=\"line\">        <span class=\"type\">XCTAssertEqual</span>(result, expectedHeadline)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeHeadline</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> words = string.componentsSeparatedByString(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> headline = words.<span class=\"built_in\">map</span> &#123; (<span class=\"keyword\">var</span> word) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> firstCharacter = word.removeAtIndex(word.startIndex)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">\"\\(String(firstCharacter).uppercaseString)\\(word)\"</span></span><br><span class=\"line\">          &#125;.joinWithSeparator(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> headline</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>再次  <strong>Command + U</strong>，确保测试通过。至此，这个简单的例子算是介绍完了。</p>\n<p>虽然例子简单，只实现了一个功能，但是 TDD 相关的东西，具体流程也都涉及了，剩下的，只是重复这些操作直至完成所有需求。</p>\n<p>如果觉得这个例子太简单了，没学够，建议看下 <a href=\"https://www.packtpub.com/application-development/test-driven-ios-development-swift\" target=\"_blank\" rel=\"external\">《Test-Driven iOS Development with Swift》</a>  一书中的 <a href=\"http://www.packtpub.com/code_download/23832\" target=\"_blank\" rel=\"external\">ToDo 源码</a>，大篇幅介绍 TDD 的实际应用。</p>\n<p>Have Fun~</p>\n<h2 id=\"参考链接\">参考链接</h2><p>由衷感谢以下作者的贡献，文中出现的一些理论阐述，有从相关文章中摘取。</p>\n<p><a href=\"https://onevcat.com/2014/02/ios-test-with-kiwi/\" target=\"_blank\" rel=\"external\">TDD的iOS开发初步以及Kiwi使用入门</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/linux/l-tdd/index.html\" target=\"_blank\" rel=\"external\">浅谈测试驱动开发（TDD）</a></p>\n<p><a href=\"http://www.cnblogs.com/whitewolf/p/4205761.html\" target=\"_blank\" rel=\"external\">TDD(测试驱动开发)培训录</a></p>\n<p><a href=\"https://www.packtpub.com/application-development/test-driven-ios-development-swift\" target=\"_blank\" rel=\"external\">《Test-Driven iOS Development with Swift》</a> </p>\n","excerpt":"<blockquote>\n<p>花了几天时间，看完了 <a href=\"https://www.packtpub.com/application-development/test-driven-ios-development-swift\">《Test-Driven iOS Development with Swift》</a> 这本书，虽然只有短短 500页的 epub，但是讲解的很生动透彻，全书围绕一个 <code>ToDo</code> 应用展开，讲解了 <code>Test-Driven Development （TDD，即测试驱动开发）</code> 的实际应用，让我对 TDD 有了更全面的认识。故此，开坑记录之~</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDTDDFigure.png\" alt=\"TDD\"></p>","more":"<h2 id=\"什么是_TDD\">什么是 TDD</h2><p>测试驱动开发(TDD)是极限编程的重要特点，它以不断的测试推动代码的开发，既简化了代码，又保证了软件质量。</p>\n<p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。</p>\n<p>OK，概括来说，TDD 的开发过程可以用上图来描述：Red，Green，Refactor。</p>\n<p>翻译过来就是：</p>\n<ol>\n<li>编写测试用例，测试不通过。（红色 Error）</li>\n<li>编写代码实现功能，测试通过。（绿色 Success）</li>\n<li>重构优化代码。（Refactor）</li>\n</ol>\n<p>再详细点，测试驱动开发的基本过程如下：</p>\n<ol>\n<li>明确当前要完成的功能。记录成一个 TODO 列表。</li>\n<li>快速完成针对此功能的测试用例编写。</li>\n<li>测试代码编译不通过。</li>\n<li>编写对应的功能代码。</li>\n<li>测试通过。</li>\n<li>对代码进行重构，并保证测试通过。</li>\n<li>循环完成所有功能的开发。</li>\n</ol>\n<p>怎么样，简单吧~</p>\n<h2 id=\"是否该用_TDD\">是否该用 TDD</h2><p>简单是简单，但是很明显的，开发前期，工作量绝对不是 1+1 那么简单，那么是否该用 TDD 呢？对此，我不做过多的阐述。世上并没有放之四海皆准的法则，TDD 好坏在于你的判断，方法论的主体在于使用的人，本文并不会给你一个完美的答案，这需要你自己在实践中取舍。接下去，我将列举 TDD 目前公认的一些优缺点，以及使用原则，加深大家对 TDD 的理解。</p>\n<p><strong>TDD 开发的优点：</strong></p>\n<ul>\n<li>可以保证代码的质量。可以对自己的所需要的业务功能的每一步设计进行验证，并得到正确的结果，减少bug的出现的，特别对于复杂业务逻辑的项目，以小步慢走的方式，避免后期繁重的测试和维护工作。</li>\n<li>找到了重构的信心，必要时候你还可以痛痛快快的并且满怀信心的对代码做一场大的变革。这样我们的代码变得干净了，扩展性、可以维护性以及易理解性纷至沓来。</li>\n<li>在团队建设中能够进行分工，以可执行的形式文档化你的需求，迫使你分清职责隔离依赖以驱动你的设计，编织安全网以便将Bug扼杀在在摇篮状态，防止其逃逸。不同于传统开发（传统的开发人员开发的软件的测试是为了找出已经逃逸得bug，可能这个bug已经长成了毒瘤）。注：这两种活动都是必要的，而且毫不冲突，互为补充。</li>\n<li>帮助你养成一个新的思维习惯，不光在你编程的道路上，在你的工作和生活中，你慢慢的会把自己的需求进行分析设计并不断地验证，最终更好去实现自己的人生目标。</li>\n</ul>\n<p><strong>TDD 开发的缺点：</strong></p>\n<ul>\n<li>对于测试驱动不熟练或者喜欢偷懒的的人员，加大了代码的编写量，测试代码是系统代码的两倍或更多。</li>\n<li>可能不适合时间很紧的软件开发，更适合于产品和平台的开发。</li>\n</ul>\n<p><strong>TDD 原则：</strong></p>\n<ul>\n<li><p><strong>独立测试：</strong>不同代码的测试应该相互独立，一个类对应一个测试类，一个函数对应一个测试函数。用例也应各自独立，每个用例不能使用其他用例的结果数据，结果也不能依赖于用例执行顺序。 一个角色：开发过程包含多种工作，如：编写测试代码、编写产品代码、代码重构等。做不同的工作时，应专注于当前的角色，不要过多考虑其他方面的细节。</p>\n</li>\n<li><p><strong>测试列表：</strong>代码的功能点可能很多，并且需求可能是陆续出现的，任何阶段想添加功能时，应把相关功能点加到测试列表中，然后才能继续手头工作，避免疏漏。</p>\n</li>\n<li><p><strong>测试驱动：</strong>即利用测试来驱动开发，是TDD的核心。要实现某个功能，要编写某个类或某个函数，应首先编写测试代码，明确这个类、这个函数如何使用，如何测试，然后在对其进行设计、编码。</p>\n</li>\n<li><p><strong>先写断言：</strong>编写测试代码时，应该首先编写判断代码功能的断言语句，然后编写必要的辅助语句。</p>\n</li>\n<li><p><strong>可测试性：</strong>产品代码设计、开发时的应尽可能提高可测试性。每个代码单元的功能应该比较单纯，“各家自扫门前雪”，每个类、每个函数应该只做它该做的事，不要弄成大杂烩。尤其是增加新功能时，不要为了图一时之便，随便在原有代码中添加功能。</p>\n</li>\n<li><p><strong>及时重构：</strong>对结构不合理，重复等“味道”不好的代码，在测试通过后，应及时进行重构。</p>\n</li>\n<li><p><strong>小步前进：</strong>软件开发是复杂性非常高的工作，小步前进是降低复杂性的好办法。</p>\n<p>​</p>\n</li>\n</ul>\n<p>看到这里，如果你还觉得，有必要体验一把 TDD，那么接着往下看，我将通过一个简单的例子，走一遍 TDD 开发的流程，加深大家对 TDD 的了解，也为 iOS 中应用 TDD 做个入门介绍。</p>\n<h2 id=\"iOS_中如何使用_TDD\">iOS 中如何使用 TDD</h2><blockquote>\n<p>Apple一直致力于在iOS开发中集成更加方便和可用的测试，在Xcode 5中，新的IDE和SDK引入了XCTest来替代原来的SenTestingKit，并且取消了新建工程时的“包括单元测试”的可选项（同样待遇的还有使用ARC的可选项）。新工程将自动包含测试的target，并且相关框架也搭建完毕，可以说测试终于摆脱了iOS开发中“二等公民”的地位，现在已经变得和产品代码一样重要了。  —————— 喵神</p>\n</blockquote>\n<p>简单 Mark 下 TDD 在 Xcode 中的历程：</p>\n<ul>\n<li>In 1998, the Swiss company Sen:te developed OCUnit, a testing framework for Objective-C (hence, the OC prefix). OCUnit was a port of SUnit, a testing framework that Kent Beck had written for Smalltalk in 1994.</li>\n<li>With Xcode 2.1, Apple added OCUnit to Xcode.</li>\n<li>In 2008, OCUnit was integrated into the iPhone SDK 2.2 to allow unit testing of iPhone apps.</li>\n<li>Four years later, OCUnit was renamed XCUnit (XC stands for Xcode).</li>\n</ul>\n<p>既然 Xcode 为我们内置了这么方便的 XCTest，我们没理由不好好使用阿~</p>\n<p>接下去通过实现一个简单的功能：把句子中每个单词的首字母转成大写字母，来走一遍 TDD 的流程。话不多说，开车了~</p>\n<h3 id=\"1-_创建工程\">1. 创建工程</h3><p>这里创建一个常规的 iOS 工程，记得 <code>“ Include Unit Tests”</code> 即可，语言我们选择 <code>Swift</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_0.jpeg\" alt=\"demo_0\"></p>\n<p>创建完毕后的工程目录如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_3.jpeg\" alt=\"demo_1\"></p>\n<p>默认为我们创建了 <code>TDDDemoTests.swift</code> 文件，这里就是我们编写测试用例的地方。打开该文件，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  TDDDemoTests.swift</span></span><br><span class=\"line\"><span class=\"comment\">//  TDDDemoTests</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Created by Colin on 16/6/3.</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright © 2016年 Colin. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> XCTest</span><br><span class=\"line\"><span class=\"meta\">@testable</span> <span class=\"keyword\">import</span> TDDDemo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TDDDemoTests</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setUp()</span><br><span class=\"line\">        <span class=\"comment\">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.tearDown()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testExample</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This is an example of a functional test case.</span></span><br><span class=\"line\">        <span class=\"comment\">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testPerformanceExample</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This is an example of a performance test case.</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.measureBlock &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Put the code you want to measure the time of here.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，有几个地方需要说明一下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> XCTest</span><br><span class=\"line\"><span class=\"meta\">@testable</span> <span class=\"keyword\">import</span> TDDDemo</span><br></pre></td></tr></table></figure>\n<p>每一个测试用例都需要引入 <code>XCTest</code> 框架，它定义了我们需要的 <code>XCTestCase</code> 类，以及之后会用到的一些断言，比如 <code>XCTAssertEqual</code> 等。另外，还需要手动导入 <code>TDDDemo</code> 模块，我们之后的相关代码都会在 <code>TDDDemo</code> 中编写，但是默认情况下，类，结构体，枚举以及它们的方法，都是内联的（<code>internal</code>），这意味着它们所处模块外无法直接访问到它们。所以在此之外的测试代码无法访问到它们，故而需要使用 <code>@testable</code> 关键字来让测试代码能访问它们。</p>\n<p>再看 <code>setUp</code> 方法和 <code>tearDown</code> 。在每个测试用例调用前，都会先调用 <code>setUp</code> 方法，在每个测试用例执行结束后，都会调用 <code>tearDown</code> 方法，大体流程就是：setUp — test case — tearDown — setUp — test case — tearDown …. 所以我们一般在 <code>setUp</code> 中做一些初始化操作，在 <code>tearDown</code>  做一些清除释放操作。</p>\n<p>另外，每一个测试方法都需要以 <code>test</code> 开头，这样 Xcode 才能自动识别出它。比如默认提供的 <code>testExample</code> 和 <code>testPerformanceExample</code> 。</p>\n<p>再有，这里建议在 Bulid 开始的时候，新建一个导航栏，并且打印 Build Log，这样我们能更直观知道发生了什么，哪里出错了。具体设置如下： <strong>Xcode | Preference | Behaviors</strong> </p>\n<p>如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_1.jpeg\" alt=\"demo_2\"></p>\n<p>现在 <strong>Command + U</strong>，执行测试。毋庸置疑，测试通过（毕竟啥都还没开始写…）。你会看到如下界面：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_4.jpeg\" alt=\"demo_3\"></p>\n<p>左边的  <strong>Test Navigation</strong> 列举了所有的测试用例以及对应的测试结果。中间的编辑区展示了 <strong>Bulid</strong> 过程中具体做了什么，以及 <strong>Build</strong> 结果。</p>\n<p>哦，对了。还有一处设置也很有用。</p>\n<p><strong>Edit Scheme | Test</strong> ，可以看到右边列举了所有参与测试的用例。当然我们知道，每个用例的测试都是需要时间的，如果想对某个用例单独测试，或者不想测试某个用例，相应的勾选和去选就可以了。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_5.jpeg\" alt=\"demo_4\"></p>\n<h3 id=\"2-_编写测试用例\">2. 编写测试用例</h3><p>好了，万事俱备，是时候展示真正的技术了！</p>\n<p>删除默认的 <code>TDDDemoTests.swift</code> 文件，重新创建一个 <code>CapitalTest.swift</code> 文件。在 <code>TDDDemoTests</code> 分组中，<strong>File | New | File | iOS | Source | Unit Test Case Class</strong> ，创建一个名为 <strong>CapitalTest</strong> 并 继承自 <strong>XCTestCase</strong> 的类。如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/iOS/TDD/TDDdemo_6.jpeg\" alt=\"demo_5\"></p>\n<p>删掉无用的 <strong>testExample，testPerformanceExample</strong> 方法。</p>\n<p>引用 <strong>TDDDemo</strong> 类。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@testable</span> <span class=\"keyword\">import</span> TDDDemo</span><br></pre></td></tr></table></figure>\n<p>编写测试用例：</p>\n<p>这里我们要做的是实现句子中单词首字母的大写转换，所以只要写个测试用例验证首字母是否都是大写即可。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testMakeHeadline_ReturnsStringWithEachWordStartCapital</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">ViewController</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> string = <span class=\"string\">\"this is A test headline\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> headline = viewController.makeHeadline(string)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(headline, <span class=\"string\">\"This Is A Test Headline\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单，我们希望有这样一个函数 <code>makeHeadline</code>，它接受一个 <strong>String</strong> 类型的参数，并返回转换成功的  <strong>String</strong> 类型的结果。然后利用 <code>XCTAssertEqual</code> 判断一下，当左右值相同时，它才会通过。</p>\n<p>很显然，这个时候会保持，且测试不通过，因为我们的 <code>makeHeadline</code> 函数根本就不存在，现在就去实现它。</p>\n<p>回到 <strong>ViewController.swift</strong> 中，添加如下方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeHeadline</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"This Is A Test Headline\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Command + U</strong> 走一遍，恭喜你，测试走通了。全部显示绿色的 Build succeeded。（眼尖的朋友可能发现问题了，不过不急，至少目前为止，我们的测试用例已经通过了~）</p>\n<p>然后接下去，做的就是重构了。虽然只写了几行代码，但是还是有优化空间的。</p>\n<p>我们之前提到过，<strong>setUp</strong> 方法将在每个 <strong>test case</strong> 调用前都自动被调用，所以这里可以放一些初始化相关操作。我们这里初始化了一个 <strong>ViewController</strong> 类型的对象，不出意外的话，在每个测试用例中中需要初始化一个，这无疑是很麻烦的。所以我们可以把 <strong>viewController</strong> 提出来，当做 <strong>CapitalTest</strong> 类的一个属性，然后在 <strong>setUp</strong> 方法中去初始化它。具体如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CapitalTest</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> viewController: <span class=\"type\">ViewController</span>!</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setUp()</span><br><span class=\"line\">        </span><br><span class=\"line\">        viewController = <span class=\"type\">ViewController</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">/////////</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下去，我们需要在编写另外一个测试用例，以保证第一个测试用例并不是偶然的。这也是我们在实际开发中需要做的，列举多个测试用例，来保证某个功能确实通过了。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testMakeHeadline_ReturnsStringWithEachWordStartCapital2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> string = <span class=\"string\">\"Here is another Example\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> headline = viewController.makeHeadline(string)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(headline, <span class=\"string\">\"Here Is Another Example\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次 <strong>Command + U</strong>，不出意外，第一个还是通过，第二个则显示失败。原因大家都懂~</p>\n<p>接下去修改 <code>makeHeadline</code> 的具体实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeHeadline</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1. 通过“ ”分割字符串, 存入数组</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> words = string.componentsSeparatedByString(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 遍历数组, 移除首字母, 并插入对应的大写字母</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> headline = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">var</span> word <span class=\"keyword\">in</span> words &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> firstCharacter = word.removeAtIndex(word.startIndex)</span><br><span class=\"line\">        headline += <span class=\"string\">\"\\(String(firstCharacter).uppercaseString)\\(word) \"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 3. 移除最后的“ ”</span></span><br><span class=\"line\">    headline.removeAtIndex(headline.endIndex.predecessor())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> headline</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，注释也写的很清楚，这里就不累述了。再次 <strong>Command + U</strong>，bingo~ 通过了。</p>\n<p>接下去再看看，是否有优化的空间。</p>\n<ol>\n<li>我们的测试用例描述的其实不太清楚，几个变量之间的关系比较凌乱。</li>\n<li><strong>makeHeadline</strong> 函数的实现太 Objc 化了，没有用上 Swift 里的高级功能。</li>\n</ol>\n<p>OK，既然不好，那就优化一下呗~</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testMakeHeadline_ReturnsStringWithEachWordStartCapital</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> inputString =       <span class=\"string\">\"this is A test headline\"</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> expectedHeadline =  <span class=\"string\">\"This Is A Test Headline\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = viewController.makeHeadline(inputString)</span><br><span class=\"line\">        <span class=\"type\">XCTAssertEqual</span>(result, expectedHeadline)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeHeadline</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> words = string.componentsSeparatedByString(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> headline = words.<span class=\"built_in\">map</span> &#123; (<span class=\"keyword\">var</span> word) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> firstCharacter = word.removeAtIndex(word.startIndex)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">\"\\(String(firstCharacter).uppercaseString)\\(word)\"</span></span><br><span class=\"line\">          &#125;.joinWithSeparator(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> headline</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>再次  <strong>Command + U</strong>，确保测试通过。至此，这个简单的例子算是介绍完了。</p>\n<p>虽然例子简单，只实现了一个功能，但是 TDD 相关的东西，具体流程也都涉及了，剩下的，只是重复这些操作直至完成所有需求。</p>\n<p>如果觉得这个例子太简单了，没学够，建议看下 <a href=\"https://www.packtpub.com/application-development/test-driven-ios-development-swift\">《Test-Driven iOS Development with Swift》</a>  一书中的 <a href=\"http://www.packtpub.com/code_download/23832\">ToDo 源码</a>，大篇幅介绍 TDD 的实际应用。</p>\n<p>Have Fun~</p>\n<h2 id=\"参考链接\">参考链接</h2><p>由衷感谢以下作者的贡献，文中出现的一些理论阐述，有从相关文章中摘取。</p>\n<p><a href=\"https://onevcat.com/2014/02/ios-test-with-kiwi/\">TDD的iOS开发初步以及Kiwi使用入门</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/linux/l-tdd/index.html\">浅谈测试驱动开发（TDD）</a></p>\n<p><a href=\"http://www.cnblogs.com/whitewolf/p/4205761.html\">TDD(测试驱动开发)培训录</a></p>\n<p><a href=\"https://www.packtpub.com/application-development/test-driven-ios-development-swift\">《Test-Driven iOS Development with Swift》</a> </p>"},{"title":"Core Image 你需要了解的那些事~","date":"2016-10-21T14:31:29.000Z","_content":"\nCore Image 系列，目前的文章如下：\n\n- [Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)\n- [Core Image 之自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)\n- [Core Image【3】—— 2017 新特性](https://xiaozhuanlan.com/topic/3095648721)\n- [Core Image【4】—— 2018 新特性](https://xiaozhuanlan.com/topic/5094762183)\n\n\n\n---\n\n\n\n## 前言\n\n最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~\n\n本文将会介绍逐一介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比。也算是下一篇文章： [Core Image 自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/) 的预备知识，毕竟只有了解了 Core Image 的作用以及它的优势，才有学习自定义 Filter 的动力。\n\n现在，开始吧～![](http://wanzao2.b0.upaiyun.com/system/pictures/24/original/6.png)\n\n<!--more-->\n\n## Core Image 概述\n\n![2016100195437core_image.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/core_image.png)\n\n\n\nCore Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 `滤镜链` 将各种效果的 `Filter叠加` 起来形成强大的自定义效果。\n\n一个 **滤镜** 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。\n\n一个 **滤镜链** 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。\n\n iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。\n\n> Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.\n\n这是苹果官方文档对于 Core Image 的介绍，大致意思是：Core Image 是一种为静态图像和 Video 提供处理和分析的技术，它可以使用 GPU/CPU 的方式对图像进行处理。Core Image 提供了简洁的 API 给用户，隐藏了图像处理中复杂的底层内容。你可以在不了解 OpenGL、OpenGL ES 甚至是 GCD 的基础上对其进行使用，他已经帮你对这些复杂的内容进行处理了。\n\n废话这么多，苹果就想告诉我们一件事：**所有的底层细节他都帮你做好了，你只需要放心调用API就行了。**\n\n这就是 Core Image 的基础概念，比较简短，正如它的使用方式一样简洁。\n\n然而在我个人学习过程中，我有一种强烈的感觉：**Apple 很重视 Core Image，Core Image 一定会越来越棒。**\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/149/original/%E5%91%86%E8%90%8C_%E5%89%AF%E6%9C%AC.png)\n\n- 每年的 WWDC Session 中，都有提及 Core Image 的相关优化。\n- 从最初的几十种内置滤镜到如今的180多种。\n- 从最初只支持 macOS，到如今也支持 iOS。\n- iOS8 之后支持自定义 Filter。\n- iOS8 增强 GPU 渲染，在后台也能继续使用 GPU 进行处理。\n- 引入 CIDetector，提供一些常用的图片识别功能。包括人脸识别、条形码识别、文本识别等。\n- 与越来越多的框架相结合：OpenGLES，PhotoExtension，SceneKit，SpriteKit，Metal。\n- iOS 10之后，支持对原生 RAW 格式图片的处理。\n- ...\n\nSo，它真的值得学习！\n\n\n\n## 使用方式\n\n![2016100259378process.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/process.png)\n\n这里我们从它的基础 API 介绍起。\n\nCore Image 的 API 主要就是三类：\n\n- CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。\n- CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。\n- CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。\n\n至于使用，相当的方便。\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/22/original/16.png)\n\n下面以 “动态模糊” 举例，我们使用系统提供的 **CIMotionBlur** 来实现。\n\n```objc\n// 传入滤镜名称(e.g. @\"CIMotionBlur\"), 输出处理后的图片\n- (UIImage *)outputImageWithFilterName:(NSString *)filterName {\n    // 1. 将UIImage转换成CIImage\n    CIImage *ciImage = [[CIImage alloc] initWithImage:self.imageView.image];\n    \n    // 2. 创建滤镜\n    self.filter = [CIFilter filterWithName:filterName keysAndValues:kCIInputImageKey, ciImage, nil];\n    // 设置相关参数\n    [self.filter setValue:@(10.f) forKey:@\"inputRadius\"];\n    \n    // 3. 渲染并输出CIImage\n    CIImage *outputImage = [self.filter outputImage];\n    \n    // 4. 获取绘制上下文\n    self.context = [CIContext contextWithOptions:nil];\n    \n    // 5. 创建输出CGImage\n    CGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]];\n    UIImage *image = [UIImage imageWithCGImage:cgImage];\n    // 6. 释放CGImage\n    CGImageRelease(cgImage);\n    \n    return image;\n}\n```\n\n效果如下：\n\n![2016100243119blurCompre.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/blurCompre.png)\n\n\n\n至于滤镜链，则是和普通滤镜的使用没什么差别。只要把前一个滤镜的输出，当作后一个滤镜的输入，即可实现，就不累述了。\n\n另外，如果想查阅 Filter 的属性，可以通过 **attributes** 属性来获取。比如这个例子中的 **CIMotionBlur**：\n\n```objc\n{\n    \"CIAttributeFilterAvailable_Mac\" = \"10.4\";\n    \"CIAttributeFilterAvailable_iOS\" = \"8.3\";\n    CIAttributeFilterCategories =     (\n        CICategoryBlur,\n        CICategoryStillImage,\n        CICategoryVideo,\n        CICategoryBuiltIn\n    );\n    CIAttributeFilterDisplayName = \"Motion Blur\";\n    CIAttributeFilterName = CIMotionBlur;\n    CIAttributeReferenceDocumentation = \"http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIMotionBlur\";\n    inputAngle =     {\n        CIAttributeClass = NSNumber;\n        CIAttributeDefault = 0;\n        CIAttributeDescription = \"The angle of the motion determines which direction the blur smears.\";\n        CIAttributeDisplayName = Angle;\n        CIAttributeIdentity = 0;\n        CIAttributeSliderMax = \"3.141592653589793\";\n        CIAttributeSliderMin = \"-3.141592653589793\";\n        CIAttributeType = CIAttributeTypeAngle;\n    };\n    inputImage =     {\n        CIAttributeClass = CIImage;\n        CIAttributeDescription = \"The image to use as an input image. For filters that also use a background image, this is the foreground image.\";\n        CIAttributeDisplayName = Image;\n        CIAttributeType = CIAttributeTypeImage;\n    };\n    inputRadius =     {\n        CIAttributeClass = NSNumber;\n        CIAttributeDefault = 20;\n        CIAttributeDescription = \"The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result.\";\n        CIAttributeDisplayName = Radius;\n        CIAttributeIdentity = 0;\n        CIAttributeMin = 0;\n        CIAttributeSliderMax = 100;\n        CIAttributeSliderMin = 0;\n        CIAttributeType = CIAttributeTypeDistance;\n    };\n}\n```\n\n以上的介绍，可能偏显苍白，但是我想说的是，使用内置的滤镜，就是这么简单。如果你还想了解更多，可以继续阅读以下这几篇文章，它们对 Core Image 的基础概念介绍的更加详细。\n\n- [Core Image 介绍](https://objccn.io/issue-21-6/) ： ObjC 的文章，值得看看。\n- [iOS8 Core Image In Swift](http://blog.csdn.net/zhangao0086/article/details/39012231) ：这个系列是对官方文档的一个完整实战，讲的比较全面。\n- [Core Image Filter Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html)：内置的所有滤镜及其用法示例。\n- [Filterpedia](https://github.com/FlexMonkey/Filterpedia) ：演示了内置滤镜及一些自定义滤镜的效果，基于 Swift 实现的。\n\n\n\n下面，才是本文着重想要介绍的，算是 Core Image 的一些高级应用。让我们继续往下看～\n\n![goon](http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png)\n\n\n\n## 注意点\n\n### 1. image.CIImage == nil\n\n为了获取 CIImage，可能有的同学会直接通 UIImage.CIImage 的方式去获取，但是这样的方式是无法保证获取到 CIImage 对象的。定义如下：\n\n```objc\n@property(nullable,nonatomic,readonly) CIImage *CIImage NS_AVAILABLE_IOS(5_0); \n// returns underlying CIImage or nil if CGImageRef based\n```\n\n这里已经很明确说明了，UIImage 对象可能不是基于 CIImage 创建的（比如它是由 `imageWithCIImage:` 生成的），这样就无法获取到 CIImage 对象。\n\n正确的姿势应该是：\n\n```objc\nCIImage *ciImage = [[CIImage alloc] initWithImage:self.originalImage];\n```\n\n\n\n### 2. CIContext\n\n在创建结果 UIImage 的时候，最简单的方式就是通过 **imageWithCIImage** 来实现。这种情况下，不需要显示的声明 **CIContext**，因为 **imageWithCIImage** 内部自动完成了这个步骤。这使得使用 Core Image 更加的方便。当然，它也引起了另外一个问题，每次都会重新创建一个 **CIContext**，然而 **CIContext** 的代价是非常高的。\n\n并且，CIContext 和 CIImage 对象是不可变的，在线程之间共享这些对象是安全的。所以多个线程可以使用同一个 GPU 或者 CPU CIContext 对象来渲染 CIImage 对象。\n\n所以重用 CIContext 是很有必要的。这意味着，我们不应该使用 **imageWithCIImage** 来生成 UIImage，而应该自己创建维护 CIContext。\n\n比如：\n\n```objc\nself.context = [CIContext contextWithOptions:nil];\n\n...\n \nCGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]];\nUIImage *image = [UIImage imageWithCGImage:cgImage];\n```\n\n\n\n### 3. CPU / GPU\n\nCore Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。\n\nContext 创建的时候，我们可以给它设置为是基于 GPU 还是 CPU。\n\n基于 GPU 的话，处理速度更快，因为利用了 GPU 硬件的并行优势。可以使用 OpenGLES 或者 Metal 来渲染图像，这种方式CPU完全没有负担，应用程序的运行循环不会受到图像渲染的影响。\n\n但是 GPU 受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用 CPU，因为当 App 切换到后台状态时 GPU 处理会被打断。使用 CPU 渲染的 iOS 会采用 GCD 来对图像进行渲染，这保证了 CPU 渲染在大部分情况下更可靠，比 GPU 渲染更容易使用，可以在后台实现渲染过程。\n\n综上，对于复杂的图像滤镜使用 GPU 更好，但是如果在处理视频并保存文件，或保存照片到照片库中时，为避免程序进入后台对图片保存造成影响，这时应该使用 CPU 进行渲染。\n\n用 Apple 官方的一句话来描述再合适不过了：\n\n> CPU is still what will give you the best fidelity where as the GPU will give you the best performance.\n\n具体的设置方式，可以参考下面的例子：\n\n```objc\n// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)\ncontext = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]];\n\n// 创建基于 GPU 的 CIContext 对象\ncontext = [CIContext contextWithOptions: nil];\n\n// 创建基于 GPU 的 CIContext 对象\nEAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\ncontext = [CIContext contextWithEAGLContext:eaglctx];\n```\n\n同样是基于  GPU 的，它们之间也是有区别的。\n\n**contextWithOptions** 创建的 context 并没有实时性能， 虽然渲染是在 GPU 上执行，但是其输出的 image 是不能显示的，只有当其被复制回 CPU 存储器上时，才会被转成一个可被显示的 image 类型，比如 UIImage。\n\n它的渲染过程大致如下：\n\n![2016100325659cpu.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/cpu.png)\n\n当使用 Core Image 在 GPU 上渲染图片的时候，先是把图像传递到 GPU 上，然后执行滤镜相关操作。但是当需要生成  CGImage 对象的时候，图像又被复制回 CPU 上。最后要在视图上显示的时候，又返回 GPU 进行渲染。这样在 GPU 和 CPU 之前来回切换，会造成很严重的性能损耗。\n\n\n\n**contextWithEAGLContext** 创建的 context 支持实时渲染，渲染图像的过程始终在 GPU 上进行，并且永远不会复制回 CPU 存储器上，这就保证了更快的渲染速度和更好的性能。\n\n当然，这个前提是利用实时渲染的特效，而不是每次操作都产生一个 UIImage，然后再设置到视图上。\n\n比如 OpenGLES：\n\n```objc\n// 设置 OpenGLES 渲染环境\nEAGLContext *eaglContext = [[EAGLContext alloc] \t  initWithAPI:kEAGLRenderingAPIOpenGLES2];\nself.glkView.context = eaglContext;\nself.context = [CIContext contextWithEAGLContext:eaglContext];\n\n...\n  \n// 实时渲染\n[self.pixellateFilter setValue:@(sender.value) forKey:@\"inputRadius\"];\n\n[self.context drawImage:_pixellateFilter.outputImage inRect:_targetBounds  fromRect:_inputImage.extent];\n[self.glkView.context presentRenderbuffer:GL_RENDERBUFFER];\n```\n\n它的渲染过程大致如下：\n\n![2016100328506gpu.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/gpu.png)\n\n\n\n并且，iOS8 后增强了 GPU 渲染，在后台也能继续使用 GPU 进行处理。这点会在下文详细说明。\n\n**所以应该尽可能的使用 GPU 去做图像处理。**\n\n另外，Apple 对 Core Image 内部进行了优化，如果通过\n\n```objc\n// 创建基于 GPU 的 CIContext 对象\ncontext = [CIContext contextWithOptions: nil];\n```\n\n创建 **context**，那么它内部的渲染器会根据设备最优选择。依次为 **Metal，OpenGLES，CoreGraphics。**\n\n> PS：Metal 需要 iOS8 + A7，且模拟器不支持 Metal。OpenGLES3 需要 iOS7 + A7\n>\n> 测试结果：\n>\n> iPhone 6s， iOS 10， 模拟器：OpenGLES3\n>\n> iPhone 6s，iOS 10，真机：Metal\n>\n> iPhone 5，iOS 8， 模拟器：OpenGLES\n\n\n\n### 4. CIFilter\n\n之前提到 CIContext 是线程安全的，然而 CIFilter 并不是线程安全的，这意味着 一个 CIFilter 对象不能在多个线程间共享。如果你的操作是多线程的，每个线程都必须创建自己的 CIFilter 对象。否则，你的 App 将产生不可预期的结果。\n\n\n\n## Core Image vs GPUImage\n\n其他图像处理方案的对比，这里比较有争议的就是 OpenGLES 和 Core Image 了。\n\n在 OpenGLES 部分，拿主流的 [GPUImage](https://github.com/BradLarson/GPUImage) 来做对比，分析一下它们各自的优缺点。只有对比了才知道，Core Image 好在哪里，是否值得使用。\n\n> PS：以下的优势阐述，撇去了两个框架都具备的，仅保留对比后各自的优势。\n>\n> 另外，GPUImage 我没有深入学习过，对于它的一些优势，主要是总结它的开发者 Brad 描述的，以及简单的 Demo 进行对比。\n\n \n\n**GPUImage 优势：**\n\n- 最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。\n- 在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的）\n- GPUImage 在视频处理上有更好的表现。\n- GPUImage 的代码完成公开，实现透明。\n- 可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。\n\n\n\n**Core Image 优势：**\n\n- 官方框架，使用放心，维护方便。\n- 支持 CPU 渲染，可以在后台继续处理和保存图片。\n- 一些滤镜的性能更强劲。例如由 Metal Performance Shaders 支持的模糊滤镜等。\n- 支持使用 Metal 渲染图像。而 Metal 在 iOS 平台上有更好的表现。\n- 与 Metal，SpriteKit，SceneKit，Core Animation 等更完美的配合。\n- 支持图像识别功能。包括人脸识别、条形码识别、文本识别等。\n- 支持自动增强图像效果，会分析图像的直方图，图像属性，脸部区域，然后通过一组滤镜来改善图像效果。\n- 支持对原生 RAW 格式图片的处理。\n- 滤镜链的性能比 GPUImage 高。(没有验证过，GPUImage 的主页上是这么说的)。\n- 支持对大图进行处理，超过 GPU 纹理限制 (4096 * 4096)的时候，会自动拆分成几个小块处理(Automatic tiling)。GPUImage 当处理超过纹理限制的图像时候，会先做判断，压缩成最大纹理限制的图像，导致图像质量损失。\n\n至此，我觉得 Core Image 的优势很明显了，尤其是与 Metal 的配合，自动增强图像效果，支持处理大图以及滤镜链的优化。\n\n\n\n下面关于这几点优化，做个简单的描述。\n\n### 1. 滤镜链\n\n> if you chain together a sequence of filters, Core Image will automatically concatenate these subroutines into a single program.The idea behind this is to improve performance and quality, by reducing the number of intermediate buffers.\n\n![2016100749763filters.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/filters.png)\n\nCore Image 会自动把多个滤镜组合成一个新的程序（program），通过减少中间缓冲区的数量，来提高性能和质量。\n\n\n\n### 2. 支持大图\n\n超过 GPU 纹理限制 （4096 * 4096）的时候，会自动拆分成几个小块处理 （Automatic tiling）。\n\n图片大小：（8374，7780），验证结果：\n\n> PS： rois 表示当前处理区域。 extent 表示图像实际大小。\n>\n> 这个输出是 Core Image 在处理过程中打印的。\n\n```objc\n(1) rois=[0 0 2092 3888] extent=[0 0 8374 7780]  \n(2) rois=[2092 0 2092 3888] extent=[0 0 8374 7780]\n(3) rois=[0 3888 2092 3892] extent=[0 0 8374 7780]\n(4) rois=[2092 3888 2092 3892] extent=[0 0 8374 7780]\n(5) rois=[4184 0 2092 3888] extent=[0 0 8374 7780]\n(6) rois=[6276 0 2098 3888] extent=[0 0 8374 7780]\n(7) rois=[4184 3888 2092 3892] extent=[0 0 8374 7780]\n(8) rois=[6276 3888 2098 3892] extent=[0 0 8374 7780]\n```\n\n如果按序讲每个区域进行拼凑，就是原图的实际区域了。\n\n![2016101313942automatic_tiling.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/automatic_tiling.png)\n\n\n\n另外，Core Image 对大图和小图的处理上，也有所不同。**小图提前解码，大图延迟解码 !**\n\n当传入的 image 是小图 (size < inputImageMaximumSize)时，在调用 **initWithCGImage** 获取输入图像 **CIImage** 的时候，这个 image 就被完全解码了。这是很有必要的。因为小图可能多次被用到，把编码的工作提前并且只做一次，一定程度上优化性能。\n\n而对于大图来说，它的解码操作是尽可能延后的（**being lazy**），直到真正需要显示， CIContext 执行 render 相关操作。因为大图的解码代价较大，并且不常用，无脑提前解码，放到内存中是没有必要的。\n\n下面是验证结果，选了两个相差不大的图片，但是介于 4096 左右。\n\n**4000 * 4000，小图：**\n\n![20161005272964000_memory.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_memory.png)\n\n![20161005205644000_decode.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_decode.png)\n\n很明显的，**Memory 占有率高**，并且调用了 **decode** 相关操作。\n\n**4100 * 4100，大图：**\n\n![20161005838734100_memory.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100_memory.png)\n\n![20161005840444100.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100.png)\n\n这里的 **Memory 占用较低**，并且没有看到 **decode** 相关操作。\n\n同样的，当通过 CIImage 获取输出 CGImage 的时候，如果输出 CGImage 是小图的话，那么当 **[CIContext createCGImage]** 调用的时候，image 就被完全渲染了。而对于大图，要等到 CGImage 真正需要渲染显示的时候，这个 image 才会被渲染。\n\n```objc\n/* Render the region 'fromRect' of image 'image' into a temporary buffer using\n * the context, then create and return a new CoreGraphics image with\n * the results. The caller is responsible for releasing the returned image.\n * The return value will be null if size is empty or too big. */\n#if !defined(SWIFT_CLASS_EXTRA) || (defined(SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH) && SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH >= 2)\n- (nullable CGImageRef)createCGImage:(CIImage *)image\n                            fromRect:(CGRect)fromRect;\n```\n\n经过这样的优化处理后，对于大图，[Session 514](https://developer.apple.com/videos/play/wwdc2014/514/) 给出了直观的数据对比：\n\n![2016100518100largeCompare.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/largeCompare.png)\n\n\n\n### 3. GPU 优化\n\n另外一个很重要的优化就是：**提高了 iOS 上 Core Image 使用 GPU 进行渲染的性能**\n\n具体体现在：\n\n**1.后台操作**\n\n- 短时间内，进入后台后会依旧使用高效的 GPU 进行渲染。\n- 后台操作的 GPU 优先级低，不会对前台的渲染造成性能影响。\n\n**2.多线程**\n\niOS 8之前，如果主线程使用 GPU 做相关操作，次要线程想使用 Core Image 的时候，通常要使用安全的 CPU 来实现，避免引起意想不到的问题。\n\n在 iOS 8之后，可以在次要线程设置 Context 的 **kCIContextPriorityRequestLow** 值为 YES，这样就标记为当前 Context 在 GPU 上渲染的时候优先级低，从而不会影响到 GPU 上高优先级的渲染。\n\n```objc\nCIContext *context = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextPriorityRequestLow]];\n```\n\n所以，应该尽可能的使用 GPU 进行渲染，来提高性能。\n\n\n\n\n\n**综上，我认为在某需求 Core Image 能实现的时候，使用 Core Image 应该是 iOS 平台上最好的选择。**\n\n\n\n至此，我所了解的 Core Image 使用上的注意点已经总结完了，希望你能有所获~\n\n当然，如果你还想了解更多，那么我的下一篇文章： [Core Image 自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)  值得你期待。\n\nHave fun~\n\n## 延伸阅读\n\n[Core Image Filter Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html)\n\n包含了 Core Image 所提供图像滤镜的完整列表以及用法示例。\n\n[Core Image 介绍](https://objccn.io/issue-21-6/) \n\n ObjC 的文章，详细介绍了 Core Image，值得看看。\n\n[Core Image Sessions](https://developer.apple.com/search/?q=Core%20Image&type=Videos)\n\n关于 Core Image 的 Session，内容很全。\n\n[Core Image Programming Guide](https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html)\n\n官方 Core Image 编程指南。","source":"_posts/Core-Image-OverView.md","raw":"title: Core Image 你需要了解的那些事~\ndate: 2016-10-21 22:31:29\n\ntags:\n\n- Core Image\n\n------\n\nCore Image 系列，目前的文章如下：\n\n- [Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)\n- [Core Image 之自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)\n- [Core Image【3】—— 2017 新特性](https://xiaozhuanlan.com/topic/3095648721)\n- [Core Image【4】—— 2018 新特性](https://xiaozhuanlan.com/topic/5094762183)\n\n\n\n---\n\n\n\n## 前言\n\n最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~\n\n本文将会介绍逐一介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比。也算是下一篇文章： [Core Image 自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/) 的预备知识，毕竟只有了解了 Core Image 的作用以及它的优势，才有学习自定义 Filter 的动力。\n\n现在，开始吧～![](http://wanzao2.b0.upaiyun.com/system/pictures/24/original/6.png)\n\n<!--more-->\n\n## Core Image 概述\n\n![2016100195437core_image.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/core_image.png)\n\n\n\nCore Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 `滤镜链` 将各种效果的 `Filter叠加` 起来形成强大的自定义效果。\n\n一个 **滤镜** 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。\n\n一个 **滤镜链** 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。\n\n iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。\n\n> Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.\n\n这是苹果官方文档对于 Core Image 的介绍，大致意思是：Core Image 是一种为静态图像和 Video 提供处理和分析的技术，它可以使用 GPU/CPU 的方式对图像进行处理。Core Image 提供了简洁的 API 给用户，隐藏了图像处理中复杂的底层内容。你可以在不了解 OpenGL、OpenGL ES 甚至是 GCD 的基础上对其进行使用，他已经帮你对这些复杂的内容进行处理了。\n\n废话这么多，苹果就想告诉我们一件事：**所有的底层细节他都帮你做好了，你只需要放心调用API就行了。**\n\n这就是 Core Image 的基础概念，比较简短，正如它的使用方式一样简洁。\n\n然而在我个人学习过程中，我有一种强烈的感觉：**Apple 很重视 Core Image，Core Image 一定会越来越棒。**\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/149/original/%E5%91%86%E8%90%8C_%E5%89%AF%E6%9C%AC.png)\n\n- 每年的 WWDC Session 中，都有提及 Core Image 的相关优化。\n- 从最初的几十种内置滤镜到如今的180多种。\n- 从最初只支持 macOS，到如今也支持 iOS。\n- iOS8 之后支持自定义 Filter。\n- iOS8 增强 GPU 渲染，在后台也能继续使用 GPU 进行处理。\n- 引入 CIDetector，提供一些常用的图片识别功能。包括人脸识别、条形码识别、文本识别等。\n- 与越来越多的框架相结合：OpenGLES，PhotoExtension，SceneKit，SpriteKit，Metal。\n- iOS 10之后，支持对原生 RAW 格式图片的处理。\n- ...\n\nSo，它真的值得学习！\n\n\n\n## 使用方式\n\n![2016100259378process.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/process.png)\n\n这里我们从它的基础 API 介绍起。\n\nCore Image 的 API 主要就是三类：\n\n- CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。\n- CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。\n- CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。\n\n至于使用，相当的方便。\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/22/original/16.png)\n\n下面以 “动态模糊” 举例，我们使用系统提供的 **CIMotionBlur** 来实现。\n\n```objc\n// 传入滤镜名称(e.g. @\"CIMotionBlur\"), 输出处理后的图片\n- (UIImage *)outputImageWithFilterName:(NSString *)filterName {\n    // 1. 将UIImage转换成CIImage\n    CIImage *ciImage = [[CIImage alloc] initWithImage:self.imageView.image];\n    \n    // 2. 创建滤镜\n    self.filter = [CIFilter filterWithName:filterName keysAndValues:kCIInputImageKey, ciImage, nil];\n    // 设置相关参数\n    [self.filter setValue:@(10.f) forKey:@\"inputRadius\"];\n    \n    // 3. 渲染并输出CIImage\n    CIImage *outputImage = [self.filter outputImage];\n    \n    // 4. 获取绘制上下文\n    self.context = [CIContext contextWithOptions:nil];\n    \n    // 5. 创建输出CGImage\n    CGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]];\n    UIImage *image = [UIImage imageWithCGImage:cgImage];\n    // 6. 释放CGImage\n    CGImageRelease(cgImage);\n    \n    return image;\n}\n```\n\n效果如下：\n\n![2016100243119blurCompre.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/blurCompre.png)\n\n\n\n至于滤镜链，则是和普通滤镜的使用没什么差别。只要把前一个滤镜的输出，当作后一个滤镜的输入，即可实现，就不累述了。\n\n另外，如果想查阅 Filter 的属性，可以通过 **attributes** 属性来获取。比如这个例子中的 **CIMotionBlur**：\n\n```objc\n{\n    \"CIAttributeFilterAvailable_Mac\" = \"10.4\";\n    \"CIAttributeFilterAvailable_iOS\" = \"8.3\";\n    CIAttributeFilterCategories =     (\n        CICategoryBlur,\n        CICategoryStillImage,\n        CICategoryVideo,\n        CICategoryBuiltIn\n    );\n    CIAttributeFilterDisplayName = \"Motion Blur\";\n    CIAttributeFilterName = CIMotionBlur;\n    CIAttributeReferenceDocumentation = \"http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIMotionBlur\";\n    inputAngle =     {\n        CIAttributeClass = NSNumber;\n        CIAttributeDefault = 0;\n        CIAttributeDescription = \"The angle of the motion determines which direction the blur smears.\";\n        CIAttributeDisplayName = Angle;\n        CIAttributeIdentity = 0;\n        CIAttributeSliderMax = \"3.141592653589793\";\n        CIAttributeSliderMin = \"-3.141592653589793\";\n        CIAttributeType = CIAttributeTypeAngle;\n    };\n    inputImage =     {\n        CIAttributeClass = CIImage;\n        CIAttributeDescription = \"The image to use as an input image. For filters that also use a background image, this is the foreground image.\";\n        CIAttributeDisplayName = Image;\n        CIAttributeType = CIAttributeTypeImage;\n    };\n    inputRadius =     {\n        CIAttributeClass = NSNumber;\n        CIAttributeDefault = 20;\n        CIAttributeDescription = \"The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result.\";\n        CIAttributeDisplayName = Radius;\n        CIAttributeIdentity = 0;\n        CIAttributeMin = 0;\n        CIAttributeSliderMax = 100;\n        CIAttributeSliderMin = 0;\n        CIAttributeType = CIAttributeTypeDistance;\n    };\n}\n```\n\n以上的介绍，可能偏显苍白，但是我想说的是，使用内置的滤镜，就是这么简单。如果你还想了解更多，可以继续阅读以下这几篇文章，它们对 Core Image 的基础概念介绍的更加详细。\n\n- [Core Image 介绍](https://objccn.io/issue-21-6/) ： ObjC 的文章，值得看看。\n- [iOS8 Core Image In Swift](http://blog.csdn.net/zhangao0086/article/details/39012231) ：这个系列是对官方文档的一个完整实战，讲的比较全面。\n- [Core Image Filter Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html)：内置的所有滤镜及其用法示例。\n- [Filterpedia](https://github.com/FlexMonkey/Filterpedia) ：演示了内置滤镜及一些自定义滤镜的效果，基于 Swift 实现的。\n\n\n\n下面，才是本文着重想要介绍的，算是 Core Image 的一些高级应用。让我们继续往下看～\n\n![goon](http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png)\n\n\n\n## 注意点\n\n### 1. image.CIImage == nil\n\n为了获取 CIImage，可能有的同学会直接通 UIImage.CIImage 的方式去获取，但是这样的方式是无法保证获取到 CIImage 对象的。定义如下：\n\n```objc\n@property(nullable,nonatomic,readonly) CIImage *CIImage NS_AVAILABLE_IOS(5_0); \n// returns underlying CIImage or nil if CGImageRef based\n```\n\n这里已经很明确说明了，UIImage 对象可能不是基于 CIImage 创建的（比如它是由 `imageWithCIImage:` 生成的），这样就无法获取到 CIImage 对象。\n\n正确的姿势应该是：\n\n```objc\nCIImage *ciImage = [[CIImage alloc] initWithImage:self.originalImage];\n```\n\n\n\n### 2. CIContext\n\n在创建结果 UIImage 的时候，最简单的方式就是通过 **imageWithCIImage** 来实现。这种情况下，不需要显示的声明 **CIContext**，因为 **imageWithCIImage** 内部自动完成了这个步骤。这使得使用 Core Image 更加的方便。当然，它也引起了另外一个问题，每次都会重新创建一个 **CIContext**，然而 **CIContext** 的代价是非常高的。\n\n并且，CIContext 和 CIImage 对象是不可变的，在线程之间共享这些对象是安全的。所以多个线程可以使用同一个 GPU 或者 CPU CIContext 对象来渲染 CIImage 对象。\n\n所以重用 CIContext 是很有必要的。这意味着，我们不应该使用 **imageWithCIImage** 来生成 UIImage，而应该自己创建维护 CIContext。\n\n比如：\n\n```objc\nself.context = [CIContext contextWithOptions:nil];\n\n...\n \nCGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]];\nUIImage *image = [UIImage imageWithCGImage:cgImage];\n```\n\n\n\n### 3. CPU / GPU\n\nCore Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。\n\nContext 创建的时候，我们可以给它设置为是基于 GPU 还是 CPU。\n\n基于 GPU 的话，处理速度更快，因为利用了 GPU 硬件的并行优势。可以使用 OpenGLES 或者 Metal 来渲染图像，这种方式CPU完全没有负担，应用程序的运行循环不会受到图像渲染的影响。\n\n但是 GPU 受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用 CPU，因为当 App 切换到后台状态时 GPU 处理会被打断。使用 CPU 渲染的 iOS 会采用 GCD 来对图像进行渲染，这保证了 CPU 渲染在大部分情况下更可靠，比 GPU 渲染更容易使用，可以在后台实现渲染过程。\n\n综上，对于复杂的图像滤镜使用 GPU 更好，但是如果在处理视频并保存文件，或保存照片到照片库中时，为避免程序进入后台对图片保存造成影响，这时应该使用 CPU 进行渲染。\n\n用 Apple 官方的一句话来描述再合适不过了：\n\n> CPU is still what will give you the best fidelity where as the GPU will give you the best performance.\n\n具体的设置方式，可以参考下面的例子：\n\n```objc\n// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)\ncontext = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]];\n\n// 创建基于 GPU 的 CIContext 对象\ncontext = [CIContext contextWithOptions: nil];\n\n// 创建基于 GPU 的 CIContext 对象\nEAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\ncontext = [CIContext contextWithEAGLContext:eaglctx];\n```\n\n同样是基于  GPU 的，它们之间也是有区别的。\n\n**contextWithOptions** 创建的 context 并没有实时性能， 虽然渲染是在 GPU 上执行，但是其输出的 image 是不能显示的，只有当其被复制回 CPU 存储器上时，才会被转成一个可被显示的 image 类型，比如 UIImage。\n\n它的渲染过程大致如下：\n\n![2016100325659cpu.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/cpu.png)\n\n当使用 Core Image 在 GPU 上渲染图片的时候，先是把图像传递到 GPU 上，然后执行滤镜相关操作。但是当需要生成  CGImage 对象的时候，图像又被复制回 CPU 上。最后要在视图上显示的时候，又返回 GPU 进行渲染。这样在 GPU 和 CPU 之前来回切换，会造成很严重的性能损耗。\n\n\n\n**contextWithEAGLContext** 创建的 context 支持实时渲染，渲染图像的过程始终在 GPU 上进行，并且永远不会复制回 CPU 存储器上，这就保证了更快的渲染速度和更好的性能。\n\n当然，这个前提是利用实时渲染的特效，而不是每次操作都产生一个 UIImage，然后再设置到视图上。\n\n比如 OpenGLES：\n\n```objc\n// 设置 OpenGLES 渲染环境\nEAGLContext *eaglContext = [[EAGLContext alloc] \t  initWithAPI:kEAGLRenderingAPIOpenGLES2];\nself.glkView.context = eaglContext;\nself.context = [CIContext contextWithEAGLContext:eaglContext];\n\n...\n  \n// 实时渲染\n[self.pixellateFilter setValue:@(sender.value) forKey:@\"inputRadius\"];\n\n[self.context drawImage:_pixellateFilter.outputImage inRect:_targetBounds  fromRect:_inputImage.extent];\n[self.glkView.context presentRenderbuffer:GL_RENDERBUFFER];\n```\n\n它的渲染过程大致如下：\n\n![2016100328506gpu.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/gpu.png)\n\n\n\n并且，iOS8 后增强了 GPU 渲染，在后台也能继续使用 GPU 进行处理。这点会在下文详细说明。\n\n**所以应该尽可能的使用 GPU 去做图像处理。**\n\n另外，Apple 对 Core Image 内部进行了优化，如果通过\n\n```objc\n// 创建基于 GPU 的 CIContext 对象\ncontext = [CIContext contextWithOptions: nil];\n```\n\n创建 **context**，那么它内部的渲染器会根据设备最优选择。依次为 **Metal，OpenGLES，CoreGraphics。**\n\n> PS：Metal 需要 iOS8 + A7，且模拟器不支持 Metal。OpenGLES3 需要 iOS7 + A7\n>\n> 测试结果：\n>\n> iPhone 6s， iOS 10， 模拟器：OpenGLES3\n>\n> iPhone 6s，iOS 10，真机：Metal\n>\n> iPhone 5，iOS 8， 模拟器：OpenGLES\n\n\n\n### 4. CIFilter\n\n之前提到 CIContext 是线程安全的，然而 CIFilter 并不是线程安全的，这意味着 一个 CIFilter 对象不能在多个线程间共享。如果你的操作是多线程的，每个线程都必须创建自己的 CIFilter 对象。否则，你的 App 将产生不可预期的结果。\n\n\n\n## Core Image vs GPUImage\n\n其他图像处理方案的对比，这里比较有争议的就是 OpenGLES 和 Core Image 了。\n\n在 OpenGLES 部分，拿主流的 [GPUImage](https://github.com/BradLarson/GPUImage) 来做对比，分析一下它们各自的优缺点。只有对比了才知道，Core Image 好在哪里，是否值得使用。\n\n> PS：以下的优势阐述，撇去了两个框架都具备的，仅保留对比后各自的优势。\n>\n> 另外，GPUImage 我没有深入学习过，对于它的一些优势，主要是总结它的开发者 Brad 描述的，以及简单的 Demo 进行对比。\n\n \n\n**GPUImage 优势：**\n\n- 最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。\n- 在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的）\n- GPUImage 在视频处理上有更好的表现。\n- GPUImage 的代码完成公开，实现透明。\n- 可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。\n\n\n\n**Core Image 优势：**\n\n- 官方框架，使用放心，维护方便。\n- 支持 CPU 渲染，可以在后台继续处理和保存图片。\n- 一些滤镜的性能更强劲。例如由 Metal Performance Shaders 支持的模糊滤镜等。\n- 支持使用 Metal 渲染图像。而 Metal 在 iOS 平台上有更好的表现。\n- 与 Metal，SpriteKit，SceneKit，Core Animation 等更完美的配合。\n- 支持图像识别功能。包括人脸识别、条形码识别、文本识别等。\n- 支持自动增强图像效果，会分析图像的直方图，图像属性，脸部区域，然后通过一组滤镜来改善图像效果。\n- 支持对原生 RAW 格式图片的处理。\n- 滤镜链的性能比 GPUImage 高。(没有验证过，GPUImage 的主页上是这么说的)。\n- 支持对大图进行处理，超过 GPU 纹理限制 (4096 * 4096)的时候，会自动拆分成几个小块处理(Automatic tiling)。GPUImage 当处理超过纹理限制的图像时候，会先做判断，压缩成最大纹理限制的图像，导致图像质量损失。\n\n至此，我觉得 Core Image 的优势很明显了，尤其是与 Metal 的配合，自动增强图像效果，支持处理大图以及滤镜链的优化。\n\n\n\n下面关于这几点优化，做个简单的描述。\n\n### 1. 滤镜链\n\n> if you chain together a sequence of filters, Core Image will automatically concatenate these subroutines into a single program.The idea behind this is to improve performance and quality, by reducing the number of intermediate buffers.\n\n![2016100749763filters.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/filters.png)\n\nCore Image 会自动把多个滤镜组合成一个新的程序（program），通过减少中间缓冲区的数量，来提高性能和质量。\n\n\n\n### 2. 支持大图\n\n超过 GPU 纹理限制 （4096 * 4096）的时候，会自动拆分成几个小块处理 （Automatic tiling）。\n\n图片大小：（8374，7780），验证结果：\n\n> PS： rois 表示当前处理区域。 extent 表示图像实际大小。\n>\n> 这个输出是 Core Image 在处理过程中打印的。\n\n```objc\n(1) rois=[0 0 2092 3888] extent=[0 0 8374 7780]  \n(2) rois=[2092 0 2092 3888] extent=[0 0 8374 7780]\n(3) rois=[0 3888 2092 3892] extent=[0 0 8374 7780]\n(4) rois=[2092 3888 2092 3892] extent=[0 0 8374 7780]\n(5) rois=[4184 0 2092 3888] extent=[0 0 8374 7780]\n(6) rois=[6276 0 2098 3888] extent=[0 0 8374 7780]\n(7) rois=[4184 3888 2092 3892] extent=[0 0 8374 7780]\n(8) rois=[6276 3888 2098 3892] extent=[0 0 8374 7780]\n```\n\n如果按序讲每个区域进行拼凑，就是原图的实际区域了。\n\n![2016101313942automatic_tiling.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/automatic_tiling.png)\n\n\n\n另外，Core Image 对大图和小图的处理上，也有所不同。**小图提前解码，大图延迟解码 !**\n\n当传入的 image 是小图 (size < inputImageMaximumSize)时，在调用 **initWithCGImage** 获取输入图像 **CIImage** 的时候，这个 image 就被完全解码了。这是很有必要的。因为小图可能多次被用到，把编码的工作提前并且只做一次，一定程度上优化性能。\n\n而对于大图来说，它的解码操作是尽可能延后的（**being lazy**），直到真正需要显示， CIContext 执行 render 相关操作。因为大图的解码代价较大，并且不常用，无脑提前解码，放到内存中是没有必要的。\n\n下面是验证结果，选了两个相差不大的图片，但是介于 4096 左右。\n\n**4000 * 4000，小图：**\n\n![20161005272964000_memory.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_memory.png)\n\n![20161005205644000_decode.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_decode.png)\n\n很明显的，**Memory 占有率高**，并且调用了 **decode** 相关操作。\n\n**4100 * 4100，大图：**\n\n![20161005838734100_memory.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100_memory.png)\n\n![20161005840444100.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100.png)\n\n这里的 **Memory 占用较低**，并且没有看到 **decode** 相关操作。\n\n同样的，当通过 CIImage 获取输出 CGImage 的时候，如果输出 CGImage 是小图的话，那么当 **[CIContext createCGImage]** 调用的时候，image 就被完全渲染了。而对于大图，要等到 CGImage 真正需要渲染显示的时候，这个 image 才会被渲染。\n\n```objc\n/* Render the region 'fromRect' of image 'image' into a temporary buffer using\n * the context, then create and return a new CoreGraphics image with\n * the results. The caller is responsible for releasing the returned image.\n * The return value will be null if size is empty or too big. */\n#if !defined(SWIFT_CLASS_EXTRA) || (defined(SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH) && SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH >= 2)\n- (nullable CGImageRef)createCGImage:(CIImage *)image\n                            fromRect:(CGRect)fromRect;\n```\n\n经过这样的优化处理后，对于大图，[Session 514](https://developer.apple.com/videos/play/wwdc2014/514/) 给出了直观的数据对比：\n\n![2016100518100largeCompare.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/largeCompare.png)\n\n\n\n### 3. GPU 优化\n\n另外一个很重要的优化就是：**提高了 iOS 上 Core Image 使用 GPU 进行渲染的性能**\n\n具体体现在：\n\n**1.后台操作**\n\n- 短时间内，进入后台后会依旧使用高效的 GPU 进行渲染。\n- 后台操作的 GPU 优先级低，不会对前台的渲染造成性能影响。\n\n**2.多线程**\n\niOS 8之前，如果主线程使用 GPU 做相关操作，次要线程想使用 Core Image 的时候，通常要使用安全的 CPU 来实现，避免引起意想不到的问题。\n\n在 iOS 8之后，可以在次要线程设置 Context 的 **kCIContextPriorityRequestLow** 值为 YES，这样就标记为当前 Context 在 GPU 上渲染的时候优先级低，从而不会影响到 GPU 上高优先级的渲染。\n\n```objc\nCIContext *context = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextPriorityRequestLow]];\n```\n\n所以，应该尽可能的使用 GPU 进行渲染，来提高性能。\n\n\n\n\n\n**综上，我认为在某需求 Core Image 能实现的时候，使用 Core Image 应该是 iOS 平台上最好的选择。**\n\n\n\n至此，我所了解的 Core Image 使用上的注意点已经总结完了，希望你能有所获~\n\n当然，如果你还想了解更多，那么我的下一篇文章： [Core Image 自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)  值得你期待。\n\nHave fun~\n\n## 延伸阅读\n\n[Core Image Filter Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html)\n\n包含了 Core Image 所提供图像滤镜的完整列表以及用法示例。\n\n[Core Image 介绍](https://objccn.io/issue-21-6/) \n\n ObjC 的文章，详细介绍了 Core Image，值得看看。\n\n[Core Image Sessions](https://developer.apple.com/search/?q=Core%20Image&type=Videos)\n\n关于 Core Image 的 Session，内容很全。\n\n[Core Image Programming Guide](https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html)\n\n官方 Core Image 编程指南。","slug":"Core-Image-OverView","published":1,"updated":"2019-12-23T01:02:31.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1nh002jzwlnejrzb6fc","content":"<p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\" target=\"_blank\" rel=\"external\">Core Image 你需要了解的那些事~</a></li>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\" target=\"_blank\" rel=\"external\">Core Image 之自定义 Filter~</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/3095648721\" target=\"_blank\" rel=\"external\">Core Image【3】—— 2017 新特性</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/5094762183\" target=\"_blank\" rel=\"external\">Core Image【4】—— 2018 新特性</a></li>\n</ul>\n<hr>\n<h2 id=\"前言\">前言</h2><p>最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~</p>\n<p>本文将会介绍逐一介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比。也算是下一篇文章： <a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\" target=\"_blank\" rel=\"external\">Core Image 自定义 Filter~</a> 的预备知识，毕竟只有了解了 Core Image 的作用以及它的优势，才有学习自定义 Filter 的动力。</p>\n<p>现在，开始吧～<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/24/original/6.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Core_Image_概述\">Core Image 概述</h2><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/core_image.png\" alt=\"2016100195437core_image.png\"></p>\n<p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 <code>滤镜链</code> 将各种效果的 <code>Filter叠加</code> 起来形成强大的自定义效果。</p>\n<p>一个 <strong>滤镜</strong> 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。</p>\n<p>一个 <strong>滤镜链</strong> 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。</p>\n<p> iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。</p>\n<blockquote>\n<p>Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.</p>\n</blockquote>\n<p>这是苹果官方文档对于 Core Image 的介绍，大致意思是：Core Image 是一种为静态图像和 Video 提供处理和分析的技术，它可以使用 GPU/CPU 的方式对图像进行处理。Core Image 提供了简洁的 API 给用户，隐藏了图像处理中复杂的底层内容。你可以在不了解 OpenGL、OpenGL ES 甚至是 GCD 的基础上对其进行使用，他已经帮你对这些复杂的内容进行处理了。</p>\n<p>废话这么多，苹果就想告诉我们一件事：<strong>所有的底层细节他都帮你做好了，你只需要放心调用API就行了。</strong></p>\n<p>这就是 Core Image 的基础概念，比较简短，正如它的使用方式一样简洁。</p>\n<p>然而在我个人学习过程中，我有一种强烈的感觉：<strong>Apple 很重视 Core Image，Core Image 一定会越来越棒。</strong></p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/149/original/%E5%91%86%E8%90%8C_%E5%89%AF%E6%9C%AC.png\" alt=\"\"></p>\n<ul>\n<li>每年的 WWDC Session 中，都有提及 Core Image 的相关优化。</li>\n<li>从最初的几十种内置滤镜到如今的180多种。</li>\n<li>从最初只支持 macOS，到如今也支持 iOS。</li>\n<li>iOS8 之后支持自定义 Filter。</li>\n<li>iOS8 增强 GPU 渲染，在后台也能继续使用 GPU 进行处理。</li>\n<li>引入 CIDetector，提供一些常用的图片识别功能。包括人脸识别、条形码识别、文本识别等。</li>\n<li>与越来越多的框架相结合：OpenGLES，PhotoExtension，SceneKit，SpriteKit，Metal。</li>\n<li>iOS 10之后，支持对原生 RAW 格式图片的处理。</li>\n<li>…</li>\n</ul>\n<p>So，它真的值得学习！</p>\n<h2 id=\"使用方式\">使用方式</h2><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/process.png\" alt=\"2016100259378process.png\"></p>\n<p>这里我们从它的基础 API 介绍起。</p>\n<p>Core Image 的 API 主要就是三类：</p>\n<ul>\n<li>CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。</li>\n<li>CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</li>\n<li>CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。</li>\n</ul>\n<p>至于使用，相当的方便。</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/22/original/16.png\" alt=\"\"></p>\n<p>下面以 “动态模糊” 举例，我们使用系统提供的 <strong>CIMotionBlur</strong> 来实现。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传入滤镜名称(e.g. @\"CIMotionBlur\"), 输出处理后的图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)outputImageWithFilterName:(<span class=\"built_in\">NSString</span> *)filterName &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 将UIImage转换成CIImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *ciImage = [[<span class=\"built_in\">CIImage</span> alloc] initWithImage:<span class=\"keyword\">self</span>.imageView.image];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 创建滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.filter = [<span class=\"built_in\">CIFilter</span> filterWithName:filterName keysAndValues:k<span class=\"built_in\">CIInputImageKey</span>, ciImage, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 设置相关参数</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.filter setValue:@(<span class=\"number\">10.</span>f) forKey:<span class=\"string\">@\"inputRadius\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 3. 渲染并输出CIImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *outputImage = [<span class=\"keyword\">self</span>.filter outputImage];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 4. 获取绘制上下文</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithOptions:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 5. 创建输出CGImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"keyword\">self</span>.context create<span class=\"built_in\">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CGImage</span>:cgImage];</span><br><span class=\"line\">    <span class=\"comment\">// 6. 释放CGImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(cgImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/blurCompre.png\" alt=\"2016100243119blurCompre.png\"></p>\n<p>至于滤镜链，则是和普通滤镜的使用没什么差别。只要把前一个滤镜的输出，当作后一个滤镜的输入，即可实现，就不累述了。</p>\n<p>另外，如果想查阅 Filter 的属性，可以通过 <strong>attributes</strong> 属性来获取。比如这个例子中的 <strong>CIMotionBlur</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"CIAttributeFilterAvailable_Mac\"</span> = <span class=\"string\">\"10.4\"</span>;</span><br><span class=\"line\">    <span class=\"string\">\"CIAttributeFilterAvailable_iOS\"</span> = <span class=\"string\">\"8.3\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeFilterCategories</span> =     (</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryBlur</span>,</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryStillImage</span>,</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryVideo</span>,</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryBuiltIn</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeFilterDisplayName</span> = <span class=\"string\">\"Motion Blur\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeFilterName</span> = <span class=\"built_in\">CIMotionBlur</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeReferenceDocumentation</span> = <span class=\"string\">\"http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIMotionBlur\"</span>;</span><br><span class=\"line\">    inputAngle =     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeClass</span> = <span class=\"built_in\">NSNumber</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDefault</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDescription</span> = <span class=\"string\">\"The angle of the motion determines which direction the blur smears.\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDisplayName</span> = Angle;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeIdentity</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMax</span> = <span class=\"string\">\"3.141592653589793\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMin</span> = <span class=\"string\">\"-3.141592653589793\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeType</span> = <span class=\"built_in\">CIAttributeTypeAngle</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    inputImage =     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeClass</span> = <span class=\"built_in\">CIImage</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDescription</span> = <span class=\"string\">\"The image to use as an input image. For filters that also use a background image, this is the foreground image.\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDisplayName</span> = Image;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeType</span> = <span class=\"built_in\">CIAttributeTypeImage</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    inputRadius =     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeClass</span> = <span class=\"built_in\">NSNumber</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDefault</span> = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDescription</span> = <span class=\"string\">\"The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result.\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDisplayName</span> = Radius;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeIdentity</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeMin</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMax</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMin</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeType</span> = <span class=\"built_in\">CIAttributeTypeDistance</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的介绍，可能偏显苍白，但是我想说的是，使用内置的滤镜，就是这么简单。如果你还想了解更多，可以继续阅读以下这几篇文章，它们对 Core Image 的基础概念介绍的更加详细。</p>\n<ul>\n<li><a href=\"https://objccn.io/issue-21-6/\" target=\"_blank\" rel=\"external\">Core Image 介绍</a> ： ObjC 的文章，值得看看。</li>\n<li><a href=\"http://blog.csdn.net/zhangao0086/article/details/39012231\" target=\"_blank\" rel=\"external\">iOS8 Core Image In Swift</a> ：这个系列是对官方文档的一个完整实战，讲的比较全面。</li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html\" target=\"_blank\" rel=\"external\">Core Image Filter Reference</a>：内置的所有滤镜及其用法示例。</li>\n<li><a href=\"https://github.com/FlexMonkey/Filterpedia\" target=\"_blank\" rel=\"external\">Filterpedia</a> ：演示了内置滤镜及一些自定义滤镜的效果，基于 Swift 实现的。</li>\n</ul>\n<p>下面，才是本文着重想要介绍的，算是 Core Image 的一些高级应用。让我们继续往下看～</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png\" alt=\"goon\"></p>\n<h2 id=\"注意点\">注意点</h2><h3 id=\"1-_image-CIImage_==_nil\">1. image.CIImage == nil</h3><p>为了获取 CIImage，可能有的同学会直接通 UIImage.CIImage 的方式去获取，但是这样的方式是无法保证获取到 CIImage 对象的。定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(nullable,<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CIImage</span> *<span class=\"built_in\">CIImage</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">5</span>_0); </span><br><span class=\"line\"><span class=\"comment\">// returns underlying CIImage or nil if CGImageRef based</span></span><br></pre></td></tr></table></figure>\n<p>这里已经很明确说明了，UIImage 对象可能不是基于 CIImage 创建的（比如它是由 <code>imageWithCIImage:</code> 生成的），这样就无法获取到 CIImage 对象。</p>\n<p>正确的姿势应该是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CIImage</span> *ciImage = [[<span class=\"built_in\">CIImage</span> alloc] initWithImage:<span class=\"keyword\">self</span>.originalImage];</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-_CIContext\">2. CIContext</h3><p>在创建结果 UIImage 的时候，最简单的方式就是通过 <strong>imageWithCIImage</strong> 来实现。这种情况下，不需要显示的声明 <strong>CIContext</strong>，因为 <strong>imageWithCIImage</strong> 内部自动完成了这个步骤。这使得使用 Core Image 更加的方便。当然，它也引起了另外一个问题，每次都会重新创建一个 <strong>CIContext</strong>，然而 <strong>CIContext</strong> 的代价是非常高的。</p>\n<p>并且，CIContext 和 CIImage 对象是不可变的，在线程之间共享这些对象是安全的。所以多个线程可以使用同一个 GPU 或者 CPU CIContext 对象来渲染 CIImage 对象。</p>\n<p>所以重用 CIContext 是很有必要的。这意味着，我们不应该使用 <strong>imageWithCIImage</strong> 来生成 UIImage，而应该自己创建维护 CIContext。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithOptions:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"keyword\">self</span>.context create<span class=\"built_in\">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CGImage</span>:cgImage];</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-_CPU_/_GPU\">3. CPU / GPU</h3><p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p>\n<p>Context 创建的时候，我们可以给它设置为是基于 GPU 还是 CPU。</p>\n<p>基于 GPU 的话，处理速度更快，因为利用了 GPU 硬件的并行优势。可以使用 OpenGLES 或者 Metal 来渲染图像，这种方式CPU完全没有负担，应用程序的运行循环不会受到图像渲染的影响。</p>\n<p>但是 GPU 受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用 CPU，因为当 App 切换到后台状态时 GPU 处理会被打断。使用 CPU 渲染的 iOS 会采用 GCD 来对图像进行渲染，这保证了 CPU 渲染在大部分情况下更可靠，比 GPU 渲染更容易使用，可以在后台实现渲染过程。</p>\n<p>综上，对于复杂的图像滤镜使用 GPU 更好，但是如果在处理视频并保存文件，或保存照片到照片库中时，为避免程序进入后台对图片保存造成影响，这时应该使用 CPU 进行渲染。</p>\n<p>用 Apple 官方的一句话来描述再合适不过了：</p>\n<blockquote>\n<p>CPU is still what will give you the best fidelity where as the GPU will give you the best performance.</p>\n</blockquote>\n<p>具体的设置方式，可以参考下面的例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)</span></span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithOptions: [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:[<span class=\"built_in\">NSNumber</span> numberWithBool:<span class=\"literal\">YES</span>] forKey:k<span class=\"built_in\">CIContextUseSoftwareRenderer</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithOptions: <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class=\"line\">EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithEAGLContext:eaglctx];</span><br></pre></td></tr></table></figure>\n<p>同样是基于  GPU 的，它们之间也是有区别的。</p>\n<p><strong>contextWithOptions</strong> 创建的 context 并没有实时性能， 虽然渲染是在 GPU 上执行，但是其输出的 image 是不能显示的，只有当其被复制回 CPU 存储器上时，才会被转成一个可被显示的 image 类型，比如 UIImage。</p>\n<p>它的渲染过程大致如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/cpu.png\" alt=\"2016100325659cpu.png\"></p>\n<p>当使用 Core Image 在 GPU 上渲染图片的时候，先是把图像传递到 GPU 上，然后执行滤镜相关操作。但是当需要生成  CGImage 对象的时候，图像又被复制回 CPU 上。最后要在视图上显示的时候，又返回 GPU 进行渲染。这样在 GPU 和 CPU 之前来回切换，会造成很严重的性能损耗。</p>\n<p><strong>contextWithEAGLContext</strong> 创建的 context 支持实时渲染，渲染图像的过程始终在 GPU 上进行，并且永远不会复制回 CPU 存储器上，这就保证了更快的渲染速度和更好的性能。</p>\n<p>当然，这个前提是利用实时渲染的特效，而不是每次操作都产生一个 UIImage，然后再设置到视图上。</p>\n<p>比如 OpenGLES：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置 OpenGLES 渲染环境</span></span><br><span class=\"line\">EAGLContext *eaglContext = [[EAGLContext alloc] \t  initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.glkView.context = eaglContext;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithEAGLContext:eaglContext];</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 实时渲染</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.pixellateFilter setValue:@(sender.value) forKey:<span class=\"string\">@\"inputRadius\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.context drawImage:_pixellateFilter.outputImage inRect:_targetBounds  fromRect:_inputImage.extent];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.glkView.context presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>它的渲染过程大致如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/gpu.png\" alt=\"2016100328506gpu.png\"></p>\n<p>并且，iOS8 后增强了 GPU 渲染，在后台也能继续使用 GPU 进行处理。这点会在下文详细说明。</p>\n<p><strong>所以应该尽可能的使用 GPU 去做图像处理。</strong></p>\n<p>另外，Apple 对 Core Image 内部进行了优化，如果通过</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithOptions: <span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>创建 <strong>context</strong>，那么它内部的渲染器会根据设备最优选择。依次为 <strong>Metal，OpenGLES，CoreGraphics。</strong></p>\n<blockquote>\n<p>PS：Metal 需要 iOS8 + A7，且模拟器不支持 Metal。OpenGLES3 需要 iOS7 + A7</p>\n<p>测试结果：</p>\n<p>iPhone 6s， iOS 10， 模拟器：OpenGLES3</p>\n<p>iPhone 6s，iOS 10，真机：Metal</p>\n<p>iPhone 5，iOS 8， 模拟器：OpenGLES</p>\n</blockquote>\n<h3 id=\"4-_CIFilter\">4. CIFilter</h3><p>之前提到 CIContext 是线程安全的，然而 CIFilter 并不是线程安全的，这意味着 一个 CIFilter 对象不能在多个线程间共享。如果你的操作是多线程的，每个线程都必须创建自己的 CIFilter 对象。否则，你的 App 将产生不可预期的结果。</p>\n<h2 id=\"Core_Image_vs_GPUImage\">Core Image vs GPUImage</h2><p>其他图像处理方案的对比，这里比较有争议的就是 OpenGLES 和 Core Image 了。</p>\n<p>在 OpenGLES 部分，拿主流的 <a href=\"https://github.com/BradLarson/GPUImage\" target=\"_blank\" rel=\"external\">GPUImage</a> 来做对比，分析一下它们各自的优缺点。只有对比了才知道，Core Image 好在哪里，是否值得使用。</p>\n<blockquote>\n<p>PS：以下的优势阐述，撇去了两个框架都具备的，仅保留对比后各自的优势。</p>\n<p>另外，GPUImage 我没有深入学习过，对于它的一些优势，主要是总结它的开发者 Brad 描述的，以及简单的 Demo 进行对比。</p>\n</blockquote>\n<p><strong>GPUImage 优势：</strong></p>\n<ul>\n<li>最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。</li>\n<li>在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的）</li>\n<li>GPUImage 在视频处理上有更好的表现。</li>\n<li>GPUImage 的代码完成公开，实现透明。</li>\n<li>可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</li>\n</ul>\n<p><strong>Core Image 优势：</strong></p>\n<ul>\n<li>官方框架，使用放心，维护方便。</li>\n<li>支持 CPU 渲染，可以在后台继续处理和保存图片。</li>\n<li>一些滤镜的性能更强劲。例如由 Metal Performance Shaders 支持的模糊滤镜等。</li>\n<li>支持使用 Metal 渲染图像。而 Metal 在 iOS 平台上有更好的表现。</li>\n<li>与 Metal，SpriteKit，SceneKit，Core Animation 等更完美的配合。</li>\n<li>支持图像识别功能。包括人脸识别、条形码识别、文本识别等。</li>\n<li>支持自动增强图像效果，会分析图像的直方图，图像属性，脸部区域，然后通过一组滤镜来改善图像效果。</li>\n<li>支持对原生 RAW 格式图片的处理。</li>\n<li>滤镜链的性能比 GPUImage 高。(没有验证过，GPUImage 的主页上是这么说的)。</li>\n<li>支持对大图进行处理，超过 GPU 纹理限制 (4096 * 4096)的时候，会自动拆分成几个小块处理(Automatic tiling)。GPUImage 当处理超过纹理限制的图像时候，会先做判断，压缩成最大纹理限制的图像，导致图像质量损失。</li>\n</ul>\n<p>至此，我觉得 Core Image 的优势很明显了，尤其是与 Metal 的配合，自动增强图像效果，支持处理大图以及滤镜链的优化。</p>\n<p>下面关于这几点优化，做个简单的描述。</p>\n<h3 id=\"1-_滤镜链\">1. 滤镜链</h3><blockquote>\n<p>if you chain together a sequence of filters, Core Image will automatically concatenate these subroutines into a single program.The idea behind this is to improve performance and quality, by reducing the number of intermediate buffers.</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/filters.png\" alt=\"2016100749763filters.png\"></p>\n<p>Core Image 会自动把多个滤镜组合成一个新的程序（program），通过减少中间缓冲区的数量，来提高性能和质量。</p>\n<h3 id=\"2-_支持大图\">2. 支持大图</h3><p>超过 GPU 纹理限制 （4096 * 4096）的时候，会自动拆分成几个小块处理 （Automatic tiling）。</p>\n<p>图片大小：（8374，7780），验证结果：</p>\n<blockquote>\n<p>PS： rois 表示当前处理区域。 extent 表示图像实际大小。</p>\n<p>这个输出是 Core Image 在处理过程中打印的。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) rois=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">2092</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]  </span><br><span class=\"line\">(<span class=\"number\">2</span>) rois=[<span class=\"number\">2092</span> <span class=\"number\">0</span> <span class=\"number\">2092</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">3</span>) rois=[<span class=\"number\">0</span> <span class=\"number\">3888</span> <span class=\"number\">2092</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">4</span>) rois=[<span class=\"number\">2092</span> <span class=\"number\">3888</span> <span class=\"number\">2092</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">5</span>) rois=[<span class=\"number\">4184</span> <span class=\"number\">0</span> <span class=\"number\">2092</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">6</span>) rois=[<span class=\"number\">6276</span> <span class=\"number\">0</span> <span class=\"number\">2098</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">7</span>) rois=[<span class=\"number\">4184</span> <span class=\"number\">3888</span> <span class=\"number\">2092</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">8</span>) rois=[<span class=\"number\">6276</span> <span class=\"number\">3888</span> <span class=\"number\">2098</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br></pre></td></tr></table></figure>\n<p>如果按序讲每个区域进行拼凑，就是原图的实际区域了。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/automatic_tiling.png\" alt=\"2016101313942automatic_tiling.png\"></p>\n<p>另外，Core Image 对大图和小图的处理上，也有所不同。<strong>小图提前解码，大图延迟解码 !</strong></p>\n<p>当传入的 image 是小图 (size &lt; inputImageMaximumSize)时，在调用 <strong>initWithCGImage</strong> 获取输入图像 <strong>CIImage</strong> 的时候，这个 image 就被完全解码了。这是很有必要的。因为小图可能多次被用到，把编码的工作提前并且只做一次，一定程度上优化性能。</p>\n<p>而对于大图来说，它的解码操作是尽可能延后的（<strong>being lazy</strong>），直到真正需要显示， CIContext 执行 render 相关操作。因为大图的解码代价较大，并且不常用，无脑提前解码，放到内存中是没有必要的。</p>\n<p>下面是验证结果，选了两个相差不大的图片，但是介于 4096 左右。</p>\n<p><strong>4000 * 4000，小图：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_memory.png\" alt=\"20161005272964000_memory.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_decode.png\" alt=\"20161005205644000_decode.png\"></p>\n<p>很明显的，<strong>Memory 占有率高</strong>，并且调用了 <strong>decode</strong> 相关操作。</p>\n<p><strong>4100 * 4100，大图：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100_memory.png\" alt=\"20161005838734100_memory.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100.png\" alt=\"20161005840444100.png\"></p>\n<p>这里的 <strong>Memory 占用较低</strong>，并且没有看到 <strong>decode</strong> 相关操作。</p>\n<p>同样的，当通过 CIImage 获取输出 CGImage 的时候，如果输出 CGImage 是小图的话，那么当 <strong>[CIContext createCGImage]</strong> 调用的时候，image 就被完全渲染了。而对于大图，要等到 CGImage 真正需要渲染显示的时候，这个 image 才会被渲染。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Render the region 'fromRect' of image 'image' into a temporary buffer using</span><br><span class=\"line\"> * the context, then create and return a new CoreGraphics image with</span><br><span class=\"line\"> * the results. The caller is responsible for releasing the returned image.</span><br><span class=\"line\"> * The return value will be null if size is empty or too big. */</span></span><br><span class=\"line\"><span class=\"meta\">#if !defined(SWIFT_CLASS_EXTRA) || (defined(SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH) &amp;&amp; SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH &gt;= 2)</span></span><br><span class=\"line\">- (nullable <span class=\"built_in\">CGImageRef</span>)create<span class=\"built_in\">CGImage</span>:(<span class=\"built_in\">CIImage</span> *)image</span><br><span class=\"line\">                            fromRect:(<span class=\"built_in\">CGRect</span>)fromRect;</span><br></pre></td></tr></table></figure>\n<p>经过这样的优化处理后，对于大图，<a href=\"https://developer.apple.com/videos/play/wwdc2014/514/\" target=\"_blank\" rel=\"external\">Session 514</a> 给出了直观的数据对比：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/largeCompare.png\" alt=\"2016100518100largeCompare.png\"></p>\n<h3 id=\"3-_GPU_优化\">3. GPU 优化</h3><p>另外一个很重要的优化就是：<strong>提高了 iOS 上 Core Image 使用 GPU 进行渲染的性能</strong></p>\n<p>具体体现在：</p>\n<p><strong>1.后台操作</strong></p>\n<ul>\n<li>短时间内，进入后台后会依旧使用高效的 GPU 进行渲染。</li>\n<li>后台操作的 GPU 优先级低，不会对前台的渲染造成性能影响。</li>\n</ul>\n<p><strong>2.多线程</strong></p>\n<p>iOS 8之前，如果主线程使用 GPU 做相关操作，次要线程想使用 Core Image 的时候，通常要使用安全的 CPU 来实现，避免引起意想不到的问题。</p>\n<p>在 iOS 8之后，可以在次要线程设置 Context 的 <strong>kCIContextPriorityRequestLow</strong> 值为 YES，这样就标记为当前 Context 在 GPU 上渲染的时候优先级低，从而不会影响到 GPU 上高优先级的渲染。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CIContext</span> *context = [<span class=\"built_in\">CIContext</span> contextWithOptions: [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:[<span class=\"built_in\">NSNumber</span> numberWithBool:<span class=\"literal\">YES</span>] forKey:k<span class=\"built_in\">CIContextPriorityRequestLow</span>]];</span><br></pre></td></tr></table></figure>\n<p>所以，应该尽可能的使用 GPU 进行渲染，来提高性能。</p>\n<p><strong>综上，我认为在某需求 Core Image 能实现的时候，使用 Core Image 应该是 iOS 平台上最好的选择。</strong></p>\n<p>至此，我所了解的 Core Image 使用上的注意点已经总结完了，希望你能有所获~</p>\n<p>当然，如果你还想了解更多，那么我的下一篇文章： <a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\" target=\"_blank\" rel=\"external\">Core Image 自定义 Filter~</a>  值得你期待。</p>\n<p>Have fun~</p>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html\" target=\"_blank\" rel=\"external\">Core Image Filter Reference</a></p>\n<p>包含了 Core Image 所提供图像滤镜的完整列表以及用法示例。</p>\n<p><a href=\"https://objccn.io/issue-21-6/\" target=\"_blank\" rel=\"external\">Core Image 介绍</a> </p>\n<p> ObjC 的文章，详细介绍了 Core Image，值得看看。</p>\n<p><a href=\"https://developer.apple.com/search/?q=Core%20Image&amp;type=Videos\" target=\"_blank\" rel=\"external\">Core Image Sessions</a></p>\n<p>关于 Core Image 的 Session，内容很全。</p>\n<p><a href=\"https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html\" target=\"_blank\" rel=\"external\">Core Image Programming Guide</a></p>\n<p>官方 Core Image 编程指南。</p>\n","excerpt":"<p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\">Core Image 你需要了解的那些事~</a></li>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\">Core Image 之自定义 Filter~</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/3095648721\">Core Image【3】—— 2017 新特性</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/5094762183\">Core Image【4】—— 2018 新特性</a></li>\n</ul>\n<hr>\n<h2 id=\"前言\">前言</h2><p>最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~</p>\n<p>本文将会介绍逐一介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比。也算是下一篇文章： <a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\">Core Image 自定义 Filter~</a> 的预备知识，毕竟只有了解了 Core Image 的作用以及它的优势，才有学习自定义 Filter 的动力。</p>\n<p>现在，开始吧～<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/24/original/6.png\" alt=\"\"></p>","more":"<h2 id=\"Core_Image_概述\">Core Image 概述</h2><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/core_image.png\" alt=\"2016100195437core_image.png\"></p>\n<p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 <code>滤镜链</code> 将各种效果的 <code>Filter叠加</code> 起来形成强大的自定义效果。</p>\n<p>一个 <strong>滤镜</strong> 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。</p>\n<p>一个 <strong>滤镜链</strong> 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。</p>\n<p> iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。</p>\n<blockquote>\n<p>Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.</p>\n</blockquote>\n<p>这是苹果官方文档对于 Core Image 的介绍，大致意思是：Core Image 是一种为静态图像和 Video 提供处理和分析的技术，它可以使用 GPU/CPU 的方式对图像进行处理。Core Image 提供了简洁的 API 给用户，隐藏了图像处理中复杂的底层内容。你可以在不了解 OpenGL、OpenGL ES 甚至是 GCD 的基础上对其进行使用，他已经帮你对这些复杂的内容进行处理了。</p>\n<p>废话这么多，苹果就想告诉我们一件事：<strong>所有的底层细节他都帮你做好了，你只需要放心调用API就行了。</strong></p>\n<p>这就是 Core Image 的基础概念，比较简短，正如它的使用方式一样简洁。</p>\n<p>然而在我个人学习过程中，我有一种强烈的感觉：<strong>Apple 很重视 Core Image，Core Image 一定会越来越棒。</strong></p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/149/original/%E5%91%86%E8%90%8C_%E5%89%AF%E6%9C%AC.png\" alt=\"\"></p>\n<ul>\n<li>每年的 WWDC Session 中，都有提及 Core Image 的相关优化。</li>\n<li>从最初的几十种内置滤镜到如今的180多种。</li>\n<li>从最初只支持 macOS，到如今也支持 iOS。</li>\n<li>iOS8 之后支持自定义 Filter。</li>\n<li>iOS8 增强 GPU 渲染，在后台也能继续使用 GPU 进行处理。</li>\n<li>引入 CIDetector，提供一些常用的图片识别功能。包括人脸识别、条形码识别、文本识别等。</li>\n<li>与越来越多的框架相结合：OpenGLES，PhotoExtension，SceneKit，SpriteKit，Metal。</li>\n<li>iOS 10之后，支持对原生 RAW 格式图片的处理。</li>\n<li>…</li>\n</ul>\n<p>So，它真的值得学习！</p>\n<h2 id=\"使用方式\">使用方式</h2><p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/process.png\" alt=\"2016100259378process.png\"></p>\n<p>这里我们从它的基础 API 介绍起。</p>\n<p>Core Image 的 API 主要就是三类：</p>\n<ul>\n<li>CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。</li>\n<li>CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</li>\n<li>CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。</li>\n</ul>\n<p>至于使用，相当的方便。</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/22/original/16.png\" alt=\"\"></p>\n<p>下面以 “动态模糊” 举例，我们使用系统提供的 <strong>CIMotionBlur</strong> 来实现。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传入滤镜名称(e.g. @\"CIMotionBlur\"), 输出处理后的图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)outputImageWithFilterName:(<span class=\"built_in\">NSString</span> *)filterName &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 将UIImage转换成CIImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *ciImage = [[<span class=\"built_in\">CIImage</span> alloc] initWithImage:<span class=\"keyword\">self</span>.imageView.image];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 创建滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.filter = [<span class=\"built_in\">CIFilter</span> filterWithName:filterName keysAndValues:k<span class=\"built_in\">CIInputImageKey</span>, ciImage, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 设置相关参数</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.filter setValue:@(<span class=\"number\">10.</span>f) forKey:<span class=\"string\">@\"inputRadius\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 3. 渲染并输出CIImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *outputImage = [<span class=\"keyword\">self</span>.filter outputImage];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 4. 获取绘制上下文</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithOptions:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 5. 创建输出CGImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"keyword\">self</span>.context create<span class=\"built_in\">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CGImage</span>:cgImage];</span><br><span class=\"line\">    <span class=\"comment\">// 6. 释放CGImage</span></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(cgImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/blurCompre.png\" alt=\"2016100243119blurCompre.png\"></p>\n<p>至于滤镜链，则是和普通滤镜的使用没什么差别。只要把前一个滤镜的输出，当作后一个滤镜的输入，即可实现，就不累述了。</p>\n<p>另外，如果想查阅 Filter 的属性，可以通过 <strong>attributes</strong> 属性来获取。比如这个例子中的 <strong>CIMotionBlur</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"CIAttributeFilterAvailable_Mac\"</span> = <span class=\"string\">\"10.4\"</span>;</span><br><span class=\"line\">    <span class=\"string\">\"CIAttributeFilterAvailable_iOS\"</span> = <span class=\"string\">\"8.3\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeFilterCategories</span> =     (</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryBlur</span>,</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryStillImage</span>,</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryVideo</span>,</span><br><span class=\"line\">        <span class=\"built_in\">CICategoryBuiltIn</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeFilterDisplayName</span> = <span class=\"string\">\"Motion Blur\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeFilterName</span> = <span class=\"built_in\">CIMotionBlur</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CIAttributeReferenceDocumentation</span> = <span class=\"string\">\"http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIMotionBlur\"</span>;</span><br><span class=\"line\">    inputAngle =     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeClass</span> = <span class=\"built_in\">NSNumber</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDefault</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDescription</span> = <span class=\"string\">\"The angle of the motion determines which direction the blur smears.\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDisplayName</span> = Angle;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeIdentity</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMax</span> = <span class=\"string\">\"3.141592653589793\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMin</span> = <span class=\"string\">\"-3.141592653589793\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeType</span> = <span class=\"built_in\">CIAttributeTypeAngle</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    inputImage =     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeClass</span> = <span class=\"built_in\">CIImage</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDescription</span> = <span class=\"string\">\"The image to use as an input image. For filters that also use a background image, this is the foreground image.\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDisplayName</span> = Image;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeType</span> = <span class=\"built_in\">CIAttributeTypeImage</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    inputRadius =     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeClass</span> = <span class=\"built_in\">NSNumber</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDefault</span> = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDescription</span> = <span class=\"string\">\"The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result.\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeDisplayName</span> = Radius;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeIdentity</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeMin</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMax</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeSliderMin</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIAttributeType</span> = <span class=\"built_in\">CIAttributeTypeDistance</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的介绍，可能偏显苍白，但是我想说的是，使用内置的滤镜，就是这么简单。如果你还想了解更多，可以继续阅读以下这几篇文章，它们对 Core Image 的基础概念介绍的更加详细。</p>\n<ul>\n<li><a href=\"https://objccn.io/issue-21-6/\">Core Image 介绍</a> ： ObjC 的文章，值得看看。</li>\n<li><a href=\"http://blog.csdn.net/zhangao0086/article/details/39012231\">iOS8 Core Image In Swift</a> ：这个系列是对官方文档的一个完整实战，讲的比较全面。</li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html\">Core Image Filter Reference</a>：内置的所有滤镜及其用法示例。</li>\n<li><a href=\"https://github.com/FlexMonkey/Filterpedia\">Filterpedia</a> ：演示了内置滤镜及一些自定义滤镜的效果，基于 Swift 实现的。</li>\n</ul>\n<p>下面，才是本文着重想要介绍的，算是 Core Image 的一些高级应用。让我们继续往下看～</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png\" alt=\"goon\"></p>\n<h2 id=\"注意点\">注意点</h2><h3 id=\"1-_image-CIImage_==_nil\">1. image.CIImage == nil</h3><p>为了获取 CIImage，可能有的同学会直接通 UIImage.CIImage 的方式去获取，但是这样的方式是无法保证获取到 CIImage 对象的。定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(nullable,<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CIImage</span> *<span class=\"built_in\">CIImage</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">5</span>_0); </span><br><span class=\"line\"><span class=\"comment\">// returns underlying CIImage or nil if CGImageRef based</span></span><br></pre></td></tr></table></figure>\n<p>这里已经很明确说明了，UIImage 对象可能不是基于 CIImage 创建的（比如它是由 <code>imageWithCIImage:</code> 生成的），这样就无法获取到 CIImage 对象。</p>\n<p>正确的姿势应该是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CIImage</span> *ciImage = [[<span class=\"built_in\">CIImage</span> alloc] initWithImage:<span class=\"keyword\">self</span>.originalImage];</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-_CIContext\">2. CIContext</h3><p>在创建结果 UIImage 的时候，最简单的方式就是通过 <strong>imageWithCIImage</strong> 来实现。这种情况下，不需要显示的声明 <strong>CIContext</strong>，因为 <strong>imageWithCIImage</strong> 内部自动完成了这个步骤。这使得使用 Core Image 更加的方便。当然，它也引起了另外一个问题，每次都会重新创建一个 <strong>CIContext</strong>，然而 <strong>CIContext</strong> 的代价是非常高的。</p>\n<p>并且，CIContext 和 CIImage 对象是不可变的，在线程之间共享这些对象是安全的。所以多个线程可以使用同一个 GPU 或者 CPU CIContext 对象来渲染 CIImage 对象。</p>\n<p>所以重用 CIContext 是很有必要的。这意味着，我们不应该使用 <strong>imageWithCIImage</strong> 来生成 UIImage，而应该自己创建维护 CIContext。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithOptions:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"keyword\">self</span>.context create<span class=\"built_in\">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CGImage</span>:cgImage];</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-_CPU_/_GPU\">3. CPU / GPU</h3><p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p>\n<p>Context 创建的时候，我们可以给它设置为是基于 GPU 还是 CPU。</p>\n<p>基于 GPU 的话，处理速度更快，因为利用了 GPU 硬件的并行优势。可以使用 OpenGLES 或者 Metal 来渲染图像，这种方式CPU完全没有负担，应用程序的运行循环不会受到图像渲染的影响。</p>\n<p>但是 GPU 受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用 CPU，因为当 App 切换到后台状态时 GPU 处理会被打断。使用 CPU 渲染的 iOS 会采用 GCD 来对图像进行渲染，这保证了 CPU 渲染在大部分情况下更可靠，比 GPU 渲染更容易使用，可以在后台实现渲染过程。</p>\n<p>综上，对于复杂的图像滤镜使用 GPU 更好，但是如果在处理视频并保存文件，或保存照片到照片库中时，为避免程序进入后台对图片保存造成影响，这时应该使用 CPU 进行渲染。</p>\n<p>用 Apple 官方的一句话来描述再合适不过了：</p>\n<blockquote>\n<p>CPU is still what will give you the best fidelity where as the GPU will give you the best performance.</p>\n</blockquote>\n<p>具体的设置方式，可以参考下面的例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)</span></span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithOptions: [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:[<span class=\"built_in\">NSNumber</span> numberWithBool:<span class=\"literal\">YES</span>] forKey:k<span class=\"built_in\">CIContextUseSoftwareRenderer</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithOptions: <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class=\"line\">EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithEAGLContext:eaglctx];</span><br></pre></td></tr></table></figure>\n<p>同样是基于  GPU 的，它们之间也是有区别的。</p>\n<p><strong>contextWithOptions</strong> 创建的 context 并没有实时性能， 虽然渲染是在 GPU 上执行，但是其输出的 image 是不能显示的，只有当其被复制回 CPU 存储器上时，才会被转成一个可被显示的 image 类型，比如 UIImage。</p>\n<p>它的渲染过程大致如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/cpu.png\" alt=\"2016100325659cpu.png\"></p>\n<p>当使用 Core Image 在 GPU 上渲染图片的时候，先是把图像传递到 GPU 上，然后执行滤镜相关操作。但是当需要生成  CGImage 对象的时候，图像又被复制回 CPU 上。最后要在视图上显示的时候，又返回 GPU 进行渲染。这样在 GPU 和 CPU 之前来回切换，会造成很严重的性能损耗。</p>\n<p><strong>contextWithEAGLContext</strong> 创建的 context 支持实时渲染，渲染图像的过程始终在 GPU 上进行，并且永远不会复制回 CPU 存储器上，这就保证了更快的渲染速度和更好的性能。</p>\n<p>当然，这个前提是利用实时渲染的特效，而不是每次操作都产生一个 UIImage，然后再设置到视图上。</p>\n<p>比如 OpenGLES：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置 OpenGLES 渲染环境</span></span><br><span class=\"line\">EAGLContext *eaglContext = [[EAGLContext alloc] \t  initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.glkView.context = eaglContext;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithEAGLContext:eaglContext];</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 实时渲染</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.pixellateFilter setValue:@(sender.value) forKey:<span class=\"string\">@\"inputRadius\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.context drawImage:_pixellateFilter.outputImage inRect:_targetBounds  fromRect:_inputImage.extent];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.glkView.context presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>它的渲染过程大致如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/gpu.png\" alt=\"2016100328506gpu.png\"></p>\n<p>并且，iOS8 后增强了 GPU 渲染，在后台也能继续使用 GPU 进行处理。这点会在下文详细说明。</p>\n<p><strong>所以应该尽可能的使用 GPU 去做图像处理。</strong></p>\n<p>另外，Apple 对 Core Image 内部进行了优化，如果通过</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class=\"line\">context = [<span class=\"built_in\">CIContext</span> contextWithOptions: <span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>创建 <strong>context</strong>，那么它内部的渲染器会根据设备最优选择。依次为 <strong>Metal，OpenGLES，CoreGraphics。</strong></p>\n<blockquote>\n<p>PS：Metal 需要 iOS8 + A7，且模拟器不支持 Metal。OpenGLES3 需要 iOS7 + A7</p>\n<p>测试结果：</p>\n<p>iPhone 6s， iOS 10， 模拟器：OpenGLES3</p>\n<p>iPhone 6s，iOS 10，真机：Metal</p>\n<p>iPhone 5，iOS 8， 模拟器：OpenGLES</p>\n</blockquote>\n<h3 id=\"4-_CIFilter\">4. CIFilter</h3><p>之前提到 CIContext 是线程安全的，然而 CIFilter 并不是线程安全的，这意味着 一个 CIFilter 对象不能在多个线程间共享。如果你的操作是多线程的，每个线程都必须创建自己的 CIFilter 对象。否则，你的 App 将产生不可预期的结果。</p>\n<h2 id=\"Core_Image_vs_GPUImage\">Core Image vs GPUImage</h2><p>其他图像处理方案的对比，这里比较有争议的就是 OpenGLES 和 Core Image 了。</p>\n<p>在 OpenGLES 部分，拿主流的 <a href=\"https://github.com/BradLarson/GPUImage\">GPUImage</a> 来做对比，分析一下它们各自的优缺点。只有对比了才知道，Core Image 好在哪里，是否值得使用。</p>\n<blockquote>\n<p>PS：以下的优势阐述，撇去了两个框架都具备的，仅保留对比后各自的优势。</p>\n<p>另外，GPUImage 我没有深入学习过，对于它的一些优势，主要是总结它的开发者 Brad 描述的，以及简单的 Demo 进行对比。</p>\n</blockquote>\n<p><strong>GPUImage 优势：</strong></p>\n<ul>\n<li>最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。</li>\n<li>在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的）</li>\n<li>GPUImage 在视频处理上有更好的表现。</li>\n<li>GPUImage 的代码完成公开，实现透明。</li>\n<li>可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</li>\n</ul>\n<p><strong>Core Image 优势：</strong></p>\n<ul>\n<li>官方框架，使用放心，维护方便。</li>\n<li>支持 CPU 渲染，可以在后台继续处理和保存图片。</li>\n<li>一些滤镜的性能更强劲。例如由 Metal Performance Shaders 支持的模糊滤镜等。</li>\n<li>支持使用 Metal 渲染图像。而 Metal 在 iOS 平台上有更好的表现。</li>\n<li>与 Metal，SpriteKit，SceneKit，Core Animation 等更完美的配合。</li>\n<li>支持图像识别功能。包括人脸识别、条形码识别、文本识别等。</li>\n<li>支持自动增强图像效果，会分析图像的直方图，图像属性，脸部区域，然后通过一组滤镜来改善图像效果。</li>\n<li>支持对原生 RAW 格式图片的处理。</li>\n<li>滤镜链的性能比 GPUImage 高。(没有验证过，GPUImage 的主页上是这么说的)。</li>\n<li>支持对大图进行处理，超过 GPU 纹理限制 (4096 * 4096)的时候，会自动拆分成几个小块处理(Automatic tiling)。GPUImage 当处理超过纹理限制的图像时候，会先做判断，压缩成最大纹理限制的图像，导致图像质量损失。</li>\n</ul>\n<p>至此，我觉得 Core Image 的优势很明显了，尤其是与 Metal 的配合，自动增强图像效果，支持处理大图以及滤镜链的优化。</p>\n<p>下面关于这几点优化，做个简单的描述。</p>\n<h3 id=\"1-_滤镜链\">1. 滤镜链</h3><blockquote>\n<p>if you chain together a sequence of filters, Core Image will automatically concatenate these subroutines into a single program.The idea behind this is to improve performance and quality, by reducing the number of intermediate buffers.</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/filters.png\" alt=\"2016100749763filters.png\"></p>\n<p>Core Image 会自动把多个滤镜组合成一个新的程序（program），通过减少中间缓冲区的数量，来提高性能和质量。</p>\n<h3 id=\"2-_支持大图\">2. 支持大图</h3><p>超过 GPU 纹理限制 （4096 * 4096）的时候，会自动拆分成几个小块处理 （Automatic tiling）。</p>\n<p>图片大小：（8374，7780），验证结果：</p>\n<blockquote>\n<p>PS： rois 表示当前处理区域。 extent 表示图像实际大小。</p>\n<p>这个输出是 Core Image 在处理过程中打印的。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) rois=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">2092</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]  </span><br><span class=\"line\">(<span class=\"number\">2</span>) rois=[<span class=\"number\">2092</span> <span class=\"number\">0</span> <span class=\"number\">2092</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">3</span>) rois=[<span class=\"number\">0</span> <span class=\"number\">3888</span> <span class=\"number\">2092</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">4</span>) rois=[<span class=\"number\">2092</span> <span class=\"number\">3888</span> <span class=\"number\">2092</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">5</span>) rois=[<span class=\"number\">4184</span> <span class=\"number\">0</span> <span class=\"number\">2092</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">6</span>) rois=[<span class=\"number\">6276</span> <span class=\"number\">0</span> <span class=\"number\">2098</span> <span class=\"number\">3888</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">7</span>) rois=[<span class=\"number\">4184</span> <span class=\"number\">3888</span> <span class=\"number\">2092</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br><span class=\"line\">(<span class=\"number\">8</span>) rois=[<span class=\"number\">6276</span> <span class=\"number\">3888</span> <span class=\"number\">2098</span> <span class=\"number\">3892</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">8374</span> <span class=\"number\">7780</span>]</span><br></pre></td></tr></table></figure>\n<p>如果按序讲每个区域进行拼凑，就是原图的实际区域了。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/automatic_tiling.png\" alt=\"2016101313942automatic_tiling.png\"></p>\n<p>另外，Core Image 对大图和小图的处理上，也有所不同。<strong>小图提前解码，大图延迟解码 !</strong></p>\n<p>当传入的 image 是小图 (size &lt; inputImageMaximumSize)时，在调用 <strong>initWithCGImage</strong> 获取输入图像 <strong>CIImage</strong> 的时候，这个 image 就被完全解码了。这是很有必要的。因为小图可能多次被用到，把编码的工作提前并且只做一次，一定程度上优化性能。</p>\n<p>而对于大图来说，它的解码操作是尽可能延后的（<strong>being lazy</strong>），直到真正需要显示， CIContext 执行 render 相关操作。因为大图的解码代价较大，并且不常用，无脑提前解码，放到内存中是没有必要的。</p>\n<p>下面是验证结果，选了两个相差不大的图片，但是介于 4096 左右。</p>\n<p><strong>4000 * 4000，小图：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_memory.png\" alt=\"20161005272964000_memory.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4000_decode.png\" alt=\"20161005205644000_decode.png\"></p>\n<p>很明显的，<strong>Memory 占有率高</strong>，并且调用了 <strong>decode</strong> 相关操作。</p>\n<p><strong>4100 * 4100，大图：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100_memory.png\" alt=\"20161005838734100_memory.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/4100.png\" alt=\"20161005840444100.png\"></p>\n<p>这里的 <strong>Memory 占用较低</strong>，并且没有看到 <strong>decode</strong> 相关操作。</p>\n<p>同样的，当通过 CIImage 获取输出 CGImage 的时候，如果输出 CGImage 是小图的话，那么当 <strong>[CIContext createCGImage]</strong> 调用的时候，image 就被完全渲染了。而对于大图，要等到 CGImage 真正需要渲染显示的时候，这个 image 才会被渲染。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Render the region 'fromRect' of image 'image' into a temporary buffer using</span><br><span class=\"line\"> * the context, then create and return a new CoreGraphics image with</span><br><span class=\"line\"> * the results. The caller is responsible for releasing the returned image.</span><br><span class=\"line\"> * The return value will be null if size is empty or too big. */</span></span><br><span class=\"line\"><span class=\"meta\">#if !defined(SWIFT_CLASS_EXTRA) || (defined(SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH) &amp;&amp; SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH &gt;= 2)</span></span><br><span class=\"line\">- (nullable <span class=\"built_in\">CGImageRef</span>)create<span class=\"built_in\">CGImage</span>:(<span class=\"built_in\">CIImage</span> *)image</span><br><span class=\"line\">                            fromRect:(<span class=\"built_in\">CGRect</span>)fromRect;</span><br></pre></td></tr></table></figure>\n<p>经过这样的优化处理后，对于大图，<a href=\"https://developer.apple.com/videos/play/wwdc2014/514/\">Session 514</a> 给出了直观的数据对比：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/largeCompare.png\" alt=\"2016100518100largeCompare.png\"></p>\n<h3 id=\"3-_GPU_优化\">3. GPU 优化</h3><p>另外一个很重要的优化就是：<strong>提高了 iOS 上 Core Image 使用 GPU 进行渲染的性能</strong></p>\n<p>具体体现在：</p>\n<p><strong>1.后台操作</strong></p>\n<ul>\n<li>短时间内，进入后台后会依旧使用高效的 GPU 进行渲染。</li>\n<li>后台操作的 GPU 优先级低，不会对前台的渲染造成性能影响。</li>\n</ul>\n<p><strong>2.多线程</strong></p>\n<p>iOS 8之前，如果主线程使用 GPU 做相关操作，次要线程想使用 Core Image 的时候，通常要使用安全的 CPU 来实现，避免引起意想不到的问题。</p>\n<p>在 iOS 8之后，可以在次要线程设置 Context 的 <strong>kCIContextPriorityRequestLow</strong> 值为 YES，这样就标记为当前 Context 在 GPU 上渲染的时候优先级低，从而不会影响到 GPU 上高优先级的渲染。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CIContext</span> *context = [<span class=\"built_in\">CIContext</span> contextWithOptions: [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:[<span class=\"built_in\">NSNumber</span> numberWithBool:<span class=\"literal\">YES</span>] forKey:k<span class=\"built_in\">CIContextPriorityRequestLow</span>]];</span><br></pre></td></tr></table></figure>\n<p>所以，应该尽可能的使用 GPU 进行渲染，来提高性能。</p>\n<p><strong>综上，我认为在某需求 Core Image 能实现的时候，使用 Core Image 应该是 iOS 平台上最好的选择。</strong></p>\n<p>至此，我所了解的 Core Image 使用上的注意点已经总结完了，希望你能有所获~</p>\n<p>当然，如果你还想了解更多，那么我的下一篇文章： <a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\">Core Image 自定义 Filter~</a>  值得你期待。</p>\n<p>Have fun~</p>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html\">Core Image Filter Reference</a></p>\n<p>包含了 Core Image 所提供图像滤镜的完整列表以及用法示例。</p>\n<p><a href=\"https://objccn.io/issue-21-6/\">Core Image 介绍</a> </p>\n<p> ObjC 的文章，详细介绍了 Core Image，值得看看。</p>\n<p><a href=\"https://developer.apple.com/search/?q=Core%20Image&amp;type=Videos\">Core Image Sessions</a></p>\n<p>关于 Core Image 的 Session，内容很全。</p>\n<p><a href=\"https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html\">Core Image Programming Guide</a></p>\n<p>官方 Core Image 编程指南。</p>"},{"title":"GLSL 详解（基础篇）","date":"2017-11-11T10:25:12.000Z","_content":"\n上节在绘制三角形的时候，简单讲解了一些着色器，GLSL 的相关概念，可能看的云里雾里的。不要担心，在本节中，我将详细讲解着色语言 GL Shader Language（GLSL）的一些基本的概念。\n\n> PS：\n> 无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。\n\n<!--more-->\n\n## 概览\n\nOpenGL ES 的渲染管线包含有一个可编程的顶点阶段的一个可编程的片段阶段。其余的阶段则有固定的功能，应用程序对其行为的控制非常有限。每个可编程阶段中编译单元的集合组成了一个着色器。在OpenGL ES 2.0 中，每个着色器只支持一个编译单元。着色程序则是一整套编译好并链接在一起的着色器的集合。着色器 shader 的编写需要使用着色语言 GL Shader Language（GLSL），GLSL 的语法与 C 语言很类似。\n\n在上一节中，我们看到了一个非常简单的着色器，如下：\n\n```c\n// 顶点着色器 .vsh\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n\n// 片段着色器 .fsh\nvarying lowp vec4 colorVarying;\n\nvoid main(void) {\n    gl_FragColor = colorVarying;\n}\n```\n\n习惯上，我们一般把顶点着色器命名为 **xx.vsh**，片段着色器命名为 **xx.fsh**。当然，你喜欢怎么样就怎么样~\n\n和 C 语言程序对应，用 GLSL 写出的着色器，它同样包括：\n\n- 变量 position\n- 变量类型 vec4\n- 限定符 attribute\n- main 函数\n- 基本赋值语句 colorVarying = color\n- 内置变量 gl_Position\n- ...\n\n这一切，都是那么像...所以，**在掌握 C 语言的基础上，GLSL 的学习成本是很低的**。\n\n学习一门语言，我们无非是从**变量类型，结构体，数组，语句，函数，限定符等**方面展开。下面，我们就照着这个顺序，学习 GLSL。\n\n\n\n## 使用 GLSL 构建着色器\n\n### 1. 变量\n\n#### 变量及变量类型\n\n| 变量类别  | 变量类型                      | 描述                   |\n| ----- | ------------------------- | -------------------- |\n| 空     | void                      | 用于无返回值的函数或空的参数列表     |\n| 标量    | float, int, bool          | 浮点型，整型，布尔型的标量数据类型    |\n| 浮点型向量 | float, vec2, vec3, vec4   | 包含1，2，3，4个元素的浮点型向量   |\n| 整数型向量 | int, ivec2, ivec3, ivec4  | 包含1，2，3，4个元素的整型向量    |\n| 布尔型向量 | bool, bvec2, bvec3, bvec4 | 包含1，2，3，4个元素的布尔型向量   |\n| 矩阵    | mat2, mat3, mat4          | 尺寸为2x2，3x3，4x4的浮点型矩阵 |\n| 纹理句柄  | sampler2D, samplerCube    | 表示2D，立方体纹理的句柄        |\n\n除上述之外，着色器中还可以将它们构成数组或结构体，以实现更复杂的数据类型。\n\n> PS：\n>\n> GLSL 中没有指针类型。\n\n\n\n#### 变量构造器和类型转换\n\n对于变量运算，GLSL 中有非常严格的规则，即**只有类型一致时，变量才能完成赋值或其它对应的操作。**可以通过对应的构造器来实现类型转换。\n\n##### 标量\n\n标量对应 C 语言的基础数据类型，它的构造和 C 语言一致，如下：\n\n```c\nfloat myFloat = 1.0;\nbool myBool = true;\n\nmyFloat = float(myBool); \t// bool -> float\nmyBool = bool(myFloat);     // float -> bool\n```\n\n##### 向量\n\n当构造向量时，向量构造器中的各参数将会被转换成相同的类型（浮点型、整型或布尔型）。往向量构造器中传递参数有两种形式：\n\n- 如果向量构造器中只提供了一个标量参数，则向量中所有值都会设定为该标量值。\n- 如果提供了多个标量值或提供了向量参数，则会从左至右使用提供的参数来给向量赋值，如果使用多个标量来赋值，则需要确保标量的个数要多于向量构造器中的个数。\n\n向量构造器用法如下：\n\n```c\nvec4 myVec4 = vec4(1.0); \t\t\t// myVec4 = {1.0, 1.0, 1.0, 1.0}\nvec3 myVec3 = vec3(1.0, 0.0, 0.5);  // myVec3 = {1.0, 0.0, 0.5}\n\nvec3 temp = vec3(myVec3); \t\t\t// temp = myVec3\nvec2 myVec2 = vec2(myVec3);         // myVec2 = {myVec3.x, myVec3.y}\n\nmyVec4 = vec4(myVec2, temp, 0.0);   // myVec4 = {myVec2.x, myVec2.y , temp, 0.0 }\n```\n\n##### 矩阵\n\n矩阵的构造方法则更加灵活，有以下规则：\n\n- 如果对矩阵构造器只提供了一个标量参数，该值会作为矩阵的对角线上的值。例如 `mat4(1.0)` 可以构造一个 4 × 4 的单位矩阵\n- 矩阵可以通过多个向量作为参数来构造，例如一个 mat2 可以通过两个 vec2 来构造\n- 矩阵可以通过多个标量作为参数来构造，矩阵中每个值对应一个标量，按照从左到右的顺序\n\n除此之外，矩阵的构造方法还可以更灵活，只要有足够的组件来初始化矩阵，其构造器参数可以是标量和向量的组合。在 OpenGL ES 中，矩阵的值会以**列**的顺序来存储。在构造矩阵时，构造器参数会按照列的顺序来填充矩阵，如下：\n\n```c\nmat3 myMat3 = mat3(1.0, 0.0, 0.0,  // 第一列\n                   0.0, 1.0, 0.0,  // 第二列\n                   0.0, 1.0, 1.0); // 第三列\n```\n\n\n\n#### \b向量和矩阵的分量\n\n单独获得向量中的组件有两种方法：即使用 `\".\"` 符号或使用数组下标方法。依据构成向量的组件个数，向量的组件可以通过 `{x, y, z, w}` ， `{r, g, b, a}` 或 `{s, t, r, q}` 等 swizzle 操作来获取。之所以采用这三种不同的命名方法，是因为向量常常会用来表示数学向量、颜色、纹理坐标等。其中的`x`、`r`、`s` 组件总是表示向量中的第一个元素，如下表：\n\n| 分量访问符     | 符号描述       |\n| --------- | ---------- |\n| (x,y,z,w) | 与位置相关的分量   |\n| (r,g,b,a) | 与颜色相关的分量   |\n| (s,t,p,q) | 与纹理坐标相关的分量 |\n\n不同的命名约定是为了方便使用，所以哪怕是描述位置的向量，也是可以通过 `{r, g, b, a}`  来获取。但是在使用向量时不能混用不同的命名约定，即不能使用 `.xgr` 这样的方式，每次只能使用同一种命名约定。当使用 `\".\"` 操作符时，还可以对向量中的元素重新排序，如下：\n\n```c\nvec3 myVec3 = vec3(0.0, 1.0, 2.0); // myVec3 = {0.0, 1.0, 2.0}\nvec3 temp;\ntemp = myVec3.xyz; // temp = {0.0, 1.0, 2.0}\ntemp = myVec3.xxx; // temp = {0.0, 0.0, 0.0}\ntemp = myVec3.zyx; // temp = {2.0, 1.0, 0.0}\n```\n\n除了使用 `\".\"` 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 `[0]` 对应的是 `x`，元素 `[1]` 对应 `y`，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。\n\n矩阵可以认为是向量的组合。例如一个 mat2 可以认为是两个 vec2，一个 mat3 可以认为是三个 vec3 等等。对于矩阵来说，可以通过数组下标 `“[]”` 来获取某一列的值，然后获取到的向量又可以继续使用向量的操作方法，如下：\n\n```c\nmat4 myMat4 = mat4(1.0); \t// Initialize diagonal to 1.0 (identity)\nvec4 col0 = myMat4[0];\t    // Get col0 vector out of the matrix \nfloat m1_1 = myMat4[1][1];  // Get element at [1][1] in matrix \nfloat m2_2 = myMat4[2].z;   // Get element at [2][2] in matrix\n```\n\n\n\n#### 向量和矩阵的操作\n\n绝大多数情况下，向量和矩阵的计算是逐分量进行的（component-wise）。当运算符作用于向量或矩阵时，该运算独立地作用于向量或矩阵的每个分量。\n以下是一些示例：\n\n```c\nvec3 v, u;\nfloat f;\nv = u + f;\n```\n\n等价于：\n\n```c\nv.x = u.x + f;\nv.y = u.y + f;\nv.z = u.z + f;\n```\n\n再如：\n\n```c\nvec3 v, u, w;\nw = v + u;\n```\n\n等价于：\n\n```c\nw.x = v.x + u.x;\nw.y = v.y + u.y;\nw.z = v.z + u.z;\n```\n\n对于整型和浮点型的向量和矩阵，绝大多数的计算都同上，但是对于向量乘以矩阵、矩阵乘以向量、矩阵乘以矩阵则是不同的计算规则。这三种计算使用线性代数的乘法规则，并且要求参与计算的运算数值有相匹配的尺寸或阶数。\n例如：\n\n```c\nvec3 v, u;\nmat3 m;\nu = v * m;\n```\n\n等价于：\n\n```c\nu.x = dot(v, m[0]); // m[0] is the left column of m\nu.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b\nu.z = dot(v, m[2]);\n```\n\n再如：\n\n```c\nu = m * v;\n```\n\n等价于：\n\n```c\nu.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;\nu.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;\nu.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;\n```\n\n再如：\n\n```c\nmat m, n, r;\nr = m * n;\n```\n\n等价于：\n\n```c\nr[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;\nr[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;\nr[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;\nr[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;\nr[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;\nr[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;\nr[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;\nr[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;\nr[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;\n```\n\n对于2阶和4阶的向量或矩阵也是相似的规则。\n\n\n\n### 2. 结构体\n\n与 C 语言相似，除了基本的数据类型之外，还可以将多个变量聚合到一个结构体中，下边的示例代码演示了在GLSL中如何声明结构体：\n\n```c\nstruct customStruct\n{\n\tvec4 color;\n\tvec2 position;\n} customVertex;\n```\n\n首先，定义会产生一个新的类型叫做 `customStruct` ，及一个名为 `customVertex` 的变量。结构体可以用构造器来初始化，在定义了新的结构体之后，还会定义一个与结构体类型名称相同的构造器。构造器与结构体中的数据类型必须一一对应，如下：\n\n```c\ncustomVertex = customStruct(vec4(0.0, 1.0, 0.0, 0.0), // color\n\t\t\t\t\t\t\tvec2(0.5, 0.5)); \t\t  // position\n```\n\n结构体的构造器是基于类型的名称，以参数的形式来赋值。获取结构体内元素的方法和C语言中一致：\n\n```c\nvec4 color = customVertex.color;\nvec4 position = customVertex.position;\n```\n\n\n\n### 3. 数组\n\n除了结构体外，GLSL 中还支持数组。 语法与 C 语言相似，创建数组的方式如下代码所示：\n\n```c\nfloat floatArray[4];\nvec4 vecArray[2];\n```\n\n与C语言不同，在GLSL中，关于数组有两点需要注意：\n\n- 除了 uniform 变量之外，数组的索引只允许使用常数整型表达式。\n- 在 GLSL 中不能在创建的同时给数组初始化，即数组中的元素需要在定义数组之后逐个初始化，且数组不能使用 const 限定符。\n\n\n\n### 4. 语句\n\n#### 运算符\n\n下表展示了 GLSL 中支持的运算符：\n\n| 优先级    | 运算符类别                              | 运算符           | 结合方向   |\n| ------ | ---------------------------------- | ------------- | ------ |\n| 1 (最高) | 成组操作                               | ()            | 从左向右   |\n|        | 数组下标，函数调用与构造函数，访问分量或结构体的字段，后置自增和自减 | [] () . ++ –  | 从左向右   |\n| 3      | 前置自增和自减，一元正/负数，一元逻辑非               | ++ – + - !    | 从右向左   |\n| 4      | 乘法，除法                              | * /           | 从左向右   |\n| 5      | 加法，减法                              | + -           | 从左向右   |\n| 6      | 关系比较操作                             | < > <= >=     | 从左向右   |\n| 7      | 相等操作                               | == !=         | 从左向右   |\n| 8      | 逻辑与                                | &&            | 从左向右   |\n| 9      | 逻辑异或                               | ^^            | 从左向右   |\n| 10     | 逻辑或                                | \\ \\|\\|        | \\ 从左向右 |\n| 11     | 三元选择操作（问号表达式）                      | ?:            | 从右向左   |\n| 12     | 赋值与算数赋值                            | = += -= *= /= | 从右向左   |\n| 13(最低) | 操作符序列                              | ,             | 从左向右   |\n\n绝大多数的运算符与 C 语言中一致。与 C 语言不同的是：GLSL 中对于参与运算的数据类型要求比较严格，即运算符两侧的变量必须有相同的数据类型。对于二目运算符（*，/，+，-），操作数必须为浮点型或整型，除此之外，乘法操作可以放在不同的数据类型之间如浮点型、向量和矩阵等。\n\n\n\n**前面矩阵的行数就是结果矩阵的行数，后面矩阵的列数就是结果矩阵的列数。**\n\n比较运算符仅能作用于标量，对于向量的比较，GLSL 中有内置的函数，稍后会介绍。\n\n\n\n#### 流程控制语句\n\n流程控制语句与 C 语言非常相似，以下示例代码是 `if-else` 的使用：\n\n```c\nif (color.a < 0.25) {\n\tcolor *= color.a;\n} else {\n\tcolor = vec4(0.0);\n}\n```\n\n判断的内容必须是布尔值或布尔表达式，除了基本的 `if-else` 语句，还可以使用 `for` 循环，在使用 `for` 循环时也有一些约束，如**循环变量的值必须是编译时已知**。\b如下：\n\n```c\nfor (int i = 0; i < 3; i++) {\n\tsum += i;\n}\n```\n\n在 GLSL 中使用循环时一定要注意：只有一个循环变量，循环变量必须使用简单的语句来增减（如 i++, i–, i+=constant, i-=constant等），循环终止条件也必须是循环变量和常量的简单比较，在循环内部不能改变循环变量的值。\n\n以下代码是 GLSL 中不支持的循环用法的示例：\n\n```c\nfloat myArr[4];\nfor (int i = 0; i < 3; i++) {\n  \t// 错误, [ ]中只能为常量或 uniform 变量，不能为整数量变量（如：i，j，k）\n\tsum += myArr[i]; \n}\n...\nuniform int loopIter;\n// 错误, 循环变量 loopIter 的值必须是编译时已知\nfor (int i = 0; i < loopIter; i++) {\n\tsum += i;\n}\n```\n\n\n\n\n\n### 5. 函数\n\nGLSL 函数的声明与 C 语言中很相似，无非就是返回值，函数名，参数列表。\n\nGLSL 着色器同样是从 main 函数开始执行。另外， GLSL 也支持自定义函数。当然，如果一个函数在定以前被调用，则需要先声明其原型。\n\n值得注意的一点是，GLSL 中函数不能够递归调用，且必须声明返回值类型（无返回值时声明为void）。如下：\n\n```c\nvec4 getPosition(){ \n    vec4 v4 = vec4(0.,0.,0.,1.);\n    return v4;\n}\n\nvoid doubleSize(inout float size){\n    size= size*2.0  ;\n}\nvoid main() {\n    float psize= 10.0;\n    doubleSize(psize);\n    gl_Position = getPosition();\n    gl_PointSize = psize;\n}\n```\n\n\n\n\n\n### 6. 限定符\n\n#### 存储限定符\n\n在声明变量时，应根据需要使用存储限定符来修饰，类似 C 语言中的说明符。GLSL 中支持的存储限定符见下表：\n\n| 限定符               | 描述                         |\n| ----------------- | -------------------------- |\n| < none: default > | 局部可读写变量，或者函数的参数            |\n| const             | 编译时常量，或只读的函数参数             |\n| attribute         | 由应用程序传输给顶点着色器的逐顶点的数据       |\n| uniform           | 在图元处理过程中其值保持不变，由应用程序传输给着色器 |\n| varying           | 由顶点着色器传输给片段着色器中的插值数据       |\n\n\n\n- 本地变量和函数参数只能使用 const 限定符，函数返回值和结构体成员不能使用限定符。\n- 数据不能从一个着色器程序传递给下一个阶段的着色器程序，这样会阻止同一个着色器程序在多个顶点或者片段中进行并行计算。\n- 不包含任何限定符或者包含 const 限定符的全局变量可以包含初始化器，这种情况下这些变量会在 main() 函数开始之后第一行代码之前被初始化，这些初始化值必须是常量表达式。\n- 没有任何限定符的全局变量如果没有在定义时初始化或者在程序中被初始化，则其值在进入 main() 函数之后是未定义的。\n- uniform、attribute 和 varying 限定符修饰的变量不能在初始化时被赋值，这些变量的值由 OpenGL ES 计算提供。\n\n##### 默认限定符\n\n如果一个全局变量没有指定限定符，则该变量与应用程序或者其他正在运行的处理单元没有任何联系。不管是全局变量还是本地变量，它们总是在自己的处理单元被分配内存，因此可以对它们执行读和写操作。\n\n\n\n##### const 限定符\n\n任意基础类型的变量都可以声明为常量。常量表示这些变量中的值在着色器中不会发生变化，声明常量只需要在声明时加上限定符 const 即可，声明时必须赋初值。\n\n```c\nconst float zero = 0.0;\nconst float pi = 3.14159;\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\nconst mat4 identity = mat4(1.0);\n```\n\n- 常量声明过的值在代码中不能再改变，这一点和 C 语言或 C++ 一样。\n- 结构体成员不能被声明为常量，但是结构体变量可以被声明为常量，并且需要在初始化时使用构造器初始化其值。\n- 常量必须被初始化为一个常量表达式。数组或者包含数组的结构体不能被声明为常量（因为数组不能在定义时被初始化）。\n\n##### attribute 限定符\n\nGLSL 中另一种特殊的变量类型是 attribute 变量。attribute 变量只用于顶点着色器中，用来存储顶点着色器中每个顶点的输入（per-vertex inputs）。attribute 通常用来存储位置坐标、法向量、纹理坐标和颜色等。注意 attribute 是用来存储单个顶点的信息。如下是包含位置，色值 attribute 的顶点着色器示例：\n\n```c\n// 顶点着色器 .vsh\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n```\n\n着色器中的两个 attribute 变量 `position` 和 `color` 由应用程序加载数值。应用程序会创建一个顶点数组，其中包含了每个顶点的位置坐标和色值信息。可使用的最大 attribute 数量也是有上限的，可以使用  `gl_MaxVertexAttribs` 来获取，也可以使用内置函数 `glGetIntegerv` 来询问 `GL_MAX_VERTEX_ATTRIBS`。OpenGL ES 2.0 实现支持的最少 attribute 个数是8个。\n\n##### uniform 限定符\n\nuniform 是 GLSL 中的一种变量类型限定符，用于存储应用程序通过 GLSL 传递给着色器的只读值。uniform 可以用来存储着色器需要的各种数据，如变换矩阵、光参数和颜色等。传递给着色器的在所有的顶点着色器和片段着色器中保持不变的的任何参数，基本上都应该通过 uniform 来存储。uniform 变量在全局区声明，以下是 uniform 的一些示例：\n\n```c\nuniform mat4 viewProjMatrix;\nuniform mat4 viewMatrix;\nuniform vec3 lightPosition;\n```\n\n需要注意的一点是，顶点着色器和片段着色器共享了 uniform 变量的命名空间。对于连接于同一个着色程序对象的顶点和片段着色器，它们共用同一组 uniform 变量，因此，如果在顶点着色器和片段着色器中都声明了 uniform 变量，二者的声明必须一致。当应用程序通过 API 加载了 uniform 变量时，该变量的值在顶点和片段着色器中都能够获取到。\n\n另一点需要注意的是，uniform 变量通常是存储在硬件中的”常量区”，这一区域是专门分配用来存储常量的，但是由于这一区域尺寸非常有限，因此着色程序中可以使用的 uniform 的个数也是有限的。可以通过读取内置变量 `gl_MaxVertexUniformVectors` 和 `gl_MaxFragmentUniformVectors` 来获得，也可以使用 `glGetIntegerv` 查询 `GL_MAX_VERTEX_UNIFORM_VECTORS` 或者 `GL_MAX_FRAGMENT_UNIFORM_VECTORS` 。OpenGL ES 2.0 的实现必须提供至少 128 个顶点 uniform 向量及 16 片段 uniform 向量。\n\n##### varying 限定符\n\nGLSL 中最后一个要说的存储限定符是 varying。varying 存储的是顶点着色器的输出，同时作为片段着色器的输入，通常顶点着色器都会把需要传递给片段着色器的数据存储在一个或多个 varying 变量中。这些变量在片段着色器中需要有相对应的声明且数据类型一致，然后在光栅化过程中进行插值计算。以下是一些 varying 变量的声明：\n\n```c\nvarying vec2 texCoord;\nvarying vec4 color;\n```\n\n顶点着色器和片段着色器中都会有 varying 变量的声明，由于 varying 是顶点着色器的输出且是片段着色器的输入，所以两处声明必须一致。与 uniform 和 attribute 相同，varying 也有数量的限制，可以使用 `gl_MaxVaryingVectors` 获取或使用 `glGetIntegerv` 查询  `GL_MAX_VARYING_VECTORS` 来获取。OpenGL ES 2.0 实现中的 varying 变量最小支持数为 8。\n\n回顾下最初那个着色器对应的 varying 声明：\n\n```c\n// 顶点着色器 .vsh\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n\n// 片段着色器 .fsh\nvarying lowp vec4 colorVarying;\n\nvoid main(void) {\n    gl_FragColor = colorVarying;\n}\n```\n\n#### invariant 限定符\n\ninvariant 可以作用于顶点着色器输出的任何一个 varying 变量。\n\n当着色器被编译时，编译器会对其进行优化，这种优化操作可能引起指令重排序（instruction reordering），指令重排序可能引起的结果是当两个着色器进行相同的计算时无法保证得到相同的结果。\n例如，在两个顶点着色器中，变量 `gl_Position` 使用相同的表达式赋值，并且当着色程序运行时，在表达式中传入相等的变量值，则两个着色器中 `gl_Position` 的值无法保证相等，这是因为两个着色器是分别单独编译的。这将会引起 multi-pass 算法的几何不一致问题。\n通常情况下，不同着色器之间的这种值的差异是允许存在的。如果要避免这种差异，则可以将变量声明为invariant，可以单独指定某个变量或进行全局设置。\n\n使用 invariant 限定符可以使输出的变量保持不变。invariant 限定符可以作用于之前已声明的变量使其具有不变性，也可以在声明变量时直接作为声明的一部分，可参考以下两段示例代码：\n\n```c\nvarying mediump vec3 Color;\n// 使已存在的 color 变量不可变\ninvariant Color; \n```\n\n或\n\n```c\ninvariant varying mediump vec3 Color;\n```\n\n以上是仅有的使用 invariant 限定符情境。如果在声明时使用 invariant 限定符，则必须保证其放在存储限定符（varying）之前。\n只有以下变量可以声明为 invariant：\n\n- 由顶点着色器输出的内置的特殊变量\n- 由顶点着色器输出的 varying 变量\n- 向片段着色器输入的内置的特殊变量\n- 向片段着色器输入的 varying 变量\n- 由片段着色器输出的内置的特殊变量\n\n为保证由两个着色器输出的特定变量的不变性，必须遵循以下几点：\n\n- 该输出变量在两个着色器中都被声明为 invariant\n- 影响输出变量的所有表达式、流程控制语句的输入值必须相同\n- 对于影响输出值的所有纹理函数，纹理格式、纹理元素值和纹理过滤必须一致\n- 对输入值的所有操作都必须一致。表达式及插值计算的所有操作必须一致，相同的运算数顺序，相同的结合性，并且按相同顺序计算。插值变量和插值函数的声明，必须有相同类型，相同的显式或隐式的精度precision限定符。影响输出值的所有控制流程必须相同，影响决定控制流程的表达式也必须遵循不变性的规则。\n\n最基本的一点是：所有的 invariant 输出量的上游数据流或控制流必须一致。\n\n初始的默认状态下，所有的输出变量不具备不变性，可以在所有的声明之前使用以下 `pragma` 语句强制所有输出变量 invariant：\n\n```c\n#pragma STDGL invariant(all)\n```\n\n输出变量的不变性通常会以优化过程的灵活性为代价，所以使用 invariant 会牺牲整体性能。因此慎用以上的全局设置方法，可以将其用作协助 Debug 的一种方法。\n另一点需要说明的是，这里的不变性指的是对于同一 GPU 的不变性，并不保证不同 OpenGL ES 实现之间的不变性。\n\n\n\n#### 参数限定符\n\nGLSL 提供了一种特殊的限定符用来定义某个变量的值是否可以被函数修改，详见下表：\n\n| 限定符   | 描述                                       |\n| ----- | ---------------------------------------- |\n| in    | 默认使用的缺省限定符，指明参数传递的是值，并且函数不会修改传入的值（C 语言中值传递） |\n| inout | 指明参数传入的是引用，如果在函数中对参数的值进行了修改，当函数结束后参数的值也会修改（C 语言中引用传递） |\n| out   | 参数的值不会传入函数，但是在函数内部修改其值，函数结束后其值会被修改       |\n\n使用的方式如下边的代码：\n\n```c\nvec4 myFunc(inout float myFloat, // inout parameter\n            out vec4 myVec4, \t // out parameter\n            mat4 myMat4); \t\t // in parameter (default)\n```\n\n以下是一个示例函数，函数定义用来计算基础的漫反射光照：\n\n```c\nvec4 diffuse(vec3 normal, vec3 light, vec4 baseColor) {\n\treturn baseColor * dot(normal, light);\n}\n```\n\n\n\n#### 精度限定符\n\nOpenGL ES 与 OpenGL 之间的一个区别就是在 GLSL 中引入了精度限定符。精度限定符可使着色器的编写者明确定义着色器变量计算时使用的精度，变量可以选择被声明为低、中或高精度。精度限定符可告知编译器使其在计算时缩小变量潜在的精度变化范围，当使用低精度时，OpenGL ES 的实现可以更快速和低功耗地运行着色器，效率的提高来自于精度的舍弃，如果精度选择不合理，着色器运行的结果会很失真。\n\nOpenGL ES 对各硬件并未强制要求多种精度的支持。其实现可以使用高精度完成所有的计算并且忽略掉精度限定符，然而某些情况下使用低精度的实现会更有优势，精度限定符可以指定整型或浮点型变量的精度，如 `lowp`，`mediump`，及 `highp`，如下：\n\n| 限定符     | 描述                                       |\n| ------- | ---------------------------------------- |\n| highp   | 满足顶点着色语言的最低要求。对片段着色语言是可选项                |\n| mediump | 满足片段着色语言的最低要求，其对于范围和精度的要求必须不低于lowp并且不高于highp |\n| lowp    | 范围和精度可低于mediump，但仍可以表示所有颜色通道的所有颜色值       |\n\n具体用法参考以下示例：\n\n```c\nhighp vec4 position;\nvarying lowp vec4 color;\nmediump float specularExp;\n```\n\n除了精度限定符，还可以指定默认使用的精度。如果某个变量没有使用精度限定符指定使用何种精度，则会使用该变量类型的默认精度。默认精度限定符放在着色器代码起始位置，以下是一些用例：\n\n```c\nprecision highp float;\nprecision mediump int;\n```\n\n当为 `float` 指定默认精度时，所有基于浮点型的变量都会以此作为默认精度，与此类似，为 `int` 指定默认精度时，所有的基于整型的变量都会以此作为默认精度。在顶点着色器中，如果没有指定默认精度，则 `int` 和 `float` 都使用 `highp`，即顶点着色器中，未使用精度限定符指明精度的变量都默认使用最高精度。在片段着色器中，`float` 并没有默认的精度设置，即片段着色器中必须为 `float` 默认精度或者为每一个 `float` 变量指明精度。OpenGL ES 2.0 并未要求其实现在片段着色器中支持高精度，可用是否定义了宏 `GL_FRAGMENT_PRECISION_HIGH` 来判断是否支持在片段着色器中使用高精度。\n\n在片段着色器中可以使用以下代码：\n\n```c\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n```\n\n这么做可以确保无论实现支持中精度还是高精度都可以完成着色器的编译。注意不同实现中精度的定义及精度的范围都不统一，而是因实现而异的。\n\n精度修饰符声明了底层实现存储这些变量时，必须要使用的最小范围和精度。实现可能会使用比要求更大的范围和精度，但绝对不会比要求少。以下是精度修饰符要求的最低范围和精度：\n\n|         | 浮点数范围          | 浮点数大小范围       | 浮点数精度范围  | 整数范围           |\n| ------- | -------------- | ------------- | -------- | -------------- |\n| highp   | (-2^62 , 2^62) | (2^-62 ,2^62) | 相对：2^-16 | (-2^16 , 2^16) |\n| mediump | (-2^14 , 2^14) | (2^-14 ,2^14) | 相对：2^-10 | (-2^10 , 2^10) |\n| lowp    | (-2, 2)        | (2^-8 ,2)     | 绝对：2^-8  | (-2^8 , 2^8)   |\n\n在具体实现中，着色器编译器支持的不同着色器类型和数值形式的实际的范围及精度可用以下函数获取：\n\n```c\nvoid GetShaderPrecisionFormat( enum shadertype, enum precisiontype, int *range, int *precision );\n```\n\n其中， `shadertype` 必须是 `VERTEX_SHADER` 或 `FRAGMENT_SHADER`；`precisiontype` 必须是 `LOW_FLOAT`、`MEDIUM_FLOAT`、`HIGH_FLOAT`、`LOW_INT`、`MEDIUM_INT` 或 `HIGH_INT`。\n\n`range ` 是指向含有两个整数的数组的指针，这两个整数将会返回数值的范围。如果用 `min` 和 `max` 来代表对应格式的最小和最大值，则 `range` 中返回的整数值可以定义为：\n\n```c\nrange[0] = log2(|min|)\nrange[1] = log2(|max|)\n```\n\n`precision ` 是指向一个整数的指针，返回的该整数是对应格式的精度的位数（number of bits）用 `log2` 取对数的值。\n\n\n\n**Q：如何确定精度:**\n\n**A：**变量的精度首先是由精度限定符决定的，如果没有精度限定符，则要寻找其右侧表达式中，已经确定精度的变量，一旦找到，那么整个表达式都将在该精度下运行。\n\n如果找到多个，则选择精度较高的那种，如果一个都找不到，则使用默认或更大的精度类型。\n\n```c\nuniform highp float h1;\nhighp float h2 = 2.3 * 4.7; // 运算过程和结果都是 highp\nmediump float m;\nm = 3.7 * h1 * h2; \t\t\t// 运算过程是 highp\nh2 = m * h1; \t\t\t\t// 运算过程是 highp\nm = h2 – h1; \t\t\t\t// 运算过程是 highp\nh2 = m + m; \t\t\t\t// 运算过程和结果都是 mediump\nvoid f(highp float p); \t\t// 形参 p 是 highp\nf(3.3);\t\t\t\t\t    // 传入的 3.3 是 highp\n```\n\n\n\n**Q：限定符的顺序**\n\n**A：**当需要用到多个限定符的时候要遵循以下顺序: \n\n- 在一般变量中：invariant > storage > precision （storage：存储，precision：精度）\n- 在函数参数中：storage > parameter > precision （parameter：参数）\n\n我们来举例说明:\n\n```c\ninvariant varying lowp float color; // invariant > storage > precision\n\nvoid doubleSize(const in lowp float s){ //storage > parameter > precision\n    float s1=s;\n}\n```\n\n","source":"_posts/OpenGLES-Lesson04.md","raw":"title: GLSL 详解（基础篇）\n\ndate: 2017-11-11 18:25:12\n\ntags:\n\n- iOS开发\n- OpenGLES\n- 图像处理\n\n------\n\n上节在绘制三角形的时候，简单讲解了一些着色器，GLSL 的相关概念，可能看的云里雾里的。不要担心，在本节中，我将详细讲解着色语言 GL Shader Language（GLSL）的一些基本的概念。\n\n> PS：\n> 无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。\n\n<!--more-->\n\n## 概览\n\nOpenGL ES 的渲染管线包含有一个可编程的顶点阶段的一个可编程的片段阶段。其余的阶段则有固定的功能，应用程序对其行为的控制非常有限。每个可编程阶段中编译单元的集合组成了一个着色器。在OpenGL ES 2.0 中，每个着色器只支持一个编译单元。着色程序则是一整套编译好并链接在一起的着色器的集合。着色器 shader 的编写需要使用着色语言 GL Shader Language（GLSL），GLSL 的语法与 C 语言很类似。\n\n在上一节中，我们看到了一个非常简单的着色器，如下：\n\n```c\n// 顶点着色器 .vsh\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n\n// 片段着色器 .fsh\nvarying lowp vec4 colorVarying;\n\nvoid main(void) {\n    gl_FragColor = colorVarying;\n}\n```\n\n习惯上，我们一般把顶点着色器命名为 **xx.vsh**，片段着色器命名为 **xx.fsh**。当然，你喜欢怎么样就怎么样~\n\n和 C 语言程序对应，用 GLSL 写出的着色器，它同样包括：\n\n- 变量 position\n- 变量类型 vec4\n- 限定符 attribute\n- main 函数\n- 基本赋值语句 colorVarying = color\n- 内置变量 gl_Position\n- ...\n\n这一切，都是那么像...所以，**在掌握 C 语言的基础上，GLSL 的学习成本是很低的**。\n\n学习一门语言，我们无非是从**变量类型，结构体，数组，语句，函数，限定符等**方面展开。下面，我们就照着这个顺序，学习 GLSL。\n\n\n\n## 使用 GLSL 构建着色器\n\n### 1. 变量\n\n#### 变量及变量类型\n\n| 变量类别  | 变量类型                      | 描述                   |\n| ----- | ------------------------- | -------------------- |\n| 空     | void                      | 用于无返回值的函数或空的参数列表     |\n| 标量    | float, int, bool          | 浮点型，整型，布尔型的标量数据类型    |\n| 浮点型向量 | float, vec2, vec3, vec4   | 包含1，2，3，4个元素的浮点型向量   |\n| 整数型向量 | int, ivec2, ivec3, ivec4  | 包含1，2，3，4个元素的整型向量    |\n| 布尔型向量 | bool, bvec2, bvec3, bvec4 | 包含1，2，3，4个元素的布尔型向量   |\n| 矩阵    | mat2, mat3, mat4          | 尺寸为2x2，3x3，4x4的浮点型矩阵 |\n| 纹理句柄  | sampler2D, samplerCube    | 表示2D，立方体纹理的句柄        |\n\n除上述之外，着色器中还可以将它们构成数组或结构体，以实现更复杂的数据类型。\n\n> PS：\n>\n> GLSL 中没有指针类型。\n\n\n\n#### 变量构造器和类型转换\n\n对于变量运算，GLSL 中有非常严格的规则，即**只有类型一致时，变量才能完成赋值或其它对应的操作。**可以通过对应的构造器来实现类型转换。\n\n##### 标量\n\n标量对应 C 语言的基础数据类型，它的构造和 C 语言一致，如下：\n\n```c\nfloat myFloat = 1.0;\nbool myBool = true;\n\nmyFloat = float(myBool); \t// bool -> float\nmyBool = bool(myFloat);     // float -> bool\n```\n\n##### 向量\n\n当构造向量时，向量构造器中的各参数将会被转换成相同的类型（浮点型、整型或布尔型）。往向量构造器中传递参数有两种形式：\n\n- 如果向量构造器中只提供了一个标量参数，则向量中所有值都会设定为该标量值。\n- 如果提供了多个标量值或提供了向量参数，则会从左至右使用提供的参数来给向量赋值，如果使用多个标量来赋值，则需要确保标量的个数要多于向量构造器中的个数。\n\n向量构造器用法如下：\n\n```c\nvec4 myVec4 = vec4(1.0); \t\t\t// myVec4 = {1.0, 1.0, 1.0, 1.0}\nvec3 myVec3 = vec3(1.0, 0.0, 0.5);  // myVec3 = {1.0, 0.0, 0.5}\n\nvec3 temp = vec3(myVec3); \t\t\t// temp = myVec3\nvec2 myVec2 = vec2(myVec3);         // myVec2 = {myVec3.x, myVec3.y}\n\nmyVec4 = vec4(myVec2, temp, 0.0);   // myVec4 = {myVec2.x, myVec2.y , temp, 0.0 }\n```\n\n##### 矩阵\n\n矩阵的构造方法则更加灵活，有以下规则：\n\n- 如果对矩阵构造器只提供了一个标量参数，该值会作为矩阵的对角线上的值。例如 `mat4(1.0)` 可以构造一个 4 × 4 的单位矩阵\n- 矩阵可以通过多个向量作为参数来构造，例如一个 mat2 可以通过两个 vec2 来构造\n- 矩阵可以通过多个标量作为参数来构造，矩阵中每个值对应一个标量，按照从左到右的顺序\n\n除此之外，矩阵的构造方法还可以更灵活，只要有足够的组件来初始化矩阵，其构造器参数可以是标量和向量的组合。在 OpenGL ES 中，矩阵的值会以**列**的顺序来存储。在构造矩阵时，构造器参数会按照列的顺序来填充矩阵，如下：\n\n```c\nmat3 myMat3 = mat3(1.0, 0.0, 0.0,  // 第一列\n                   0.0, 1.0, 0.0,  // 第二列\n                   0.0, 1.0, 1.0); // 第三列\n```\n\n\n\n#### \b向量和矩阵的分量\n\n单独获得向量中的组件有两种方法：即使用 `\".\"` 符号或使用数组下标方法。依据构成向量的组件个数，向量的组件可以通过 `{x, y, z, w}` ， `{r, g, b, a}` 或 `{s, t, r, q}` 等 swizzle 操作来获取。之所以采用这三种不同的命名方法，是因为向量常常会用来表示数学向量、颜色、纹理坐标等。其中的`x`、`r`、`s` 组件总是表示向量中的第一个元素，如下表：\n\n| 分量访问符     | 符号描述       |\n| --------- | ---------- |\n| (x,y,z,w) | 与位置相关的分量   |\n| (r,g,b,a) | 与颜色相关的分量   |\n| (s,t,p,q) | 与纹理坐标相关的分量 |\n\n不同的命名约定是为了方便使用，所以哪怕是描述位置的向量，也是可以通过 `{r, g, b, a}`  来获取。但是在使用向量时不能混用不同的命名约定，即不能使用 `.xgr` 这样的方式，每次只能使用同一种命名约定。当使用 `\".\"` 操作符时，还可以对向量中的元素重新排序，如下：\n\n```c\nvec3 myVec3 = vec3(0.0, 1.0, 2.0); // myVec3 = {0.0, 1.0, 2.0}\nvec3 temp;\ntemp = myVec3.xyz; // temp = {0.0, 1.0, 2.0}\ntemp = myVec3.xxx; // temp = {0.0, 0.0, 0.0}\ntemp = myVec3.zyx; // temp = {2.0, 1.0, 0.0}\n```\n\n除了使用 `\".\"` 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 `[0]` 对应的是 `x`，元素 `[1]` 对应 `y`，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。\n\n矩阵可以认为是向量的组合。例如一个 mat2 可以认为是两个 vec2，一个 mat3 可以认为是三个 vec3 等等。对于矩阵来说，可以通过数组下标 `“[]”` 来获取某一列的值，然后获取到的向量又可以继续使用向量的操作方法，如下：\n\n```c\nmat4 myMat4 = mat4(1.0); \t// Initialize diagonal to 1.0 (identity)\nvec4 col0 = myMat4[0];\t    // Get col0 vector out of the matrix \nfloat m1_1 = myMat4[1][1];  // Get element at [1][1] in matrix \nfloat m2_2 = myMat4[2].z;   // Get element at [2][2] in matrix\n```\n\n\n\n#### 向量和矩阵的操作\n\n绝大多数情况下，向量和矩阵的计算是逐分量进行的（component-wise）。当运算符作用于向量或矩阵时，该运算独立地作用于向量或矩阵的每个分量。\n以下是一些示例：\n\n```c\nvec3 v, u;\nfloat f;\nv = u + f;\n```\n\n等价于：\n\n```c\nv.x = u.x + f;\nv.y = u.y + f;\nv.z = u.z + f;\n```\n\n再如：\n\n```c\nvec3 v, u, w;\nw = v + u;\n```\n\n等价于：\n\n```c\nw.x = v.x + u.x;\nw.y = v.y + u.y;\nw.z = v.z + u.z;\n```\n\n对于整型和浮点型的向量和矩阵，绝大多数的计算都同上，但是对于向量乘以矩阵、矩阵乘以向量、矩阵乘以矩阵则是不同的计算规则。这三种计算使用线性代数的乘法规则，并且要求参与计算的运算数值有相匹配的尺寸或阶数。\n例如：\n\n```c\nvec3 v, u;\nmat3 m;\nu = v * m;\n```\n\n等价于：\n\n```c\nu.x = dot(v, m[0]); // m[0] is the left column of m\nu.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b\nu.z = dot(v, m[2]);\n```\n\n再如：\n\n```c\nu = m * v;\n```\n\n等价于：\n\n```c\nu.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;\nu.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;\nu.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;\n```\n\n再如：\n\n```c\nmat m, n, r;\nr = m * n;\n```\n\n等价于：\n\n```c\nr[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;\nr[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;\nr[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;\nr[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;\nr[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;\nr[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;\nr[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;\nr[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;\nr[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;\n```\n\n对于2阶和4阶的向量或矩阵也是相似的规则。\n\n\n\n### 2. 结构体\n\n与 C 语言相似，除了基本的数据类型之外，还可以将多个变量聚合到一个结构体中，下边的示例代码演示了在GLSL中如何声明结构体：\n\n```c\nstruct customStruct\n{\n\tvec4 color;\n\tvec2 position;\n} customVertex;\n```\n\n首先，定义会产生一个新的类型叫做 `customStruct` ，及一个名为 `customVertex` 的变量。结构体可以用构造器来初始化，在定义了新的结构体之后，还会定义一个与结构体类型名称相同的构造器。构造器与结构体中的数据类型必须一一对应，如下：\n\n```c\ncustomVertex = customStruct(vec4(0.0, 1.0, 0.0, 0.0), // color\n\t\t\t\t\t\t\tvec2(0.5, 0.5)); \t\t  // position\n```\n\n结构体的构造器是基于类型的名称，以参数的形式来赋值。获取结构体内元素的方法和C语言中一致：\n\n```c\nvec4 color = customVertex.color;\nvec4 position = customVertex.position;\n```\n\n\n\n### 3. 数组\n\n除了结构体外，GLSL 中还支持数组。 语法与 C 语言相似，创建数组的方式如下代码所示：\n\n```c\nfloat floatArray[4];\nvec4 vecArray[2];\n```\n\n与C语言不同，在GLSL中，关于数组有两点需要注意：\n\n- 除了 uniform 变量之外，数组的索引只允许使用常数整型表达式。\n- 在 GLSL 中不能在创建的同时给数组初始化，即数组中的元素需要在定义数组之后逐个初始化，且数组不能使用 const 限定符。\n\n\n\n### 4. 语句\n\n#### 运算符\n\n下表展示了 GLSL 中支持的运算符：\n\n| 优先级    | 运算符类别                              | 运算符           | 结合方向   |\n| ------ | ---------------------------------- | ------------- | ------ |\n| 1 (最高) | 成组操作                               | ()            | 从左向右   |\n|        | 数组下标，函数调用与构造函数，访问分量或结构体的字段，后置自增和自减 | [] () . ++ –  | 从左向右   |\n| 3      | 前置自增和自减，一元正/负数，一元逻辑非               | ++ – + - !    | 从右向左   |\n| 4      | 乘法，除法                              | * /           | 从左向右   |\n| 5      | 加法，减法                              | + -           | 从左向右   |\n| 6      | 关系比较操作                             | < > <= >=     | 从左向右   |\n| 7      | 相等操作                               | == !=         | 从左向右   |\n| 8      | 逻辑与                                | &&            | 从左向右   |\n| 9      | 逻辑异或                               | ^^            | 从左向右   |\n| 10     | 逻辑或                                | \\ \\|\\|        | \\ 从左向右 |\n| 11     | 三元选择操作（问号表达式）                      | ?:            | 从右向左   |\n| 12     | 赋值与算数赋值                            | = += -= *= /= | 从右向左   |\n| 13(最低) | 操作符序列                              | ,             | 从左向右   |\n\n绝大多数的运算符与 C 语言中一致。与 C 语言不同的是：GLSL 中对于参与运算的数据类型要求比较严格，即运算符两侧的变量必须有相同的数据类型。对于二目运算符（*，/，+，-），操作数必须为浮点型或整型，除此之外，乘法操作可以放在不同的数据类型之间如浮点型、向量和矩阵等。\n\n\n\n**前面矩阵的行数就是结果矩阵的行数，后面矩阵的列数就是结果矩阵的列数。**\n\n比较运算符仅能作用于标量，对于向量的比较，GLSL 中有内置的函数，稍后会介绍。\n\n\n\n#### 流程控制语句\n\n流程控制语句与 C 语言非常相似，以下示例代码是 `if-else` 的使用：\n\n```c\nif (color.a < 0.25) {\n\tcolor *= color.a;\n} else {\n\tcolor = vec4(0.0);\n}\n```\n\n判断的内容必须是布尔值或布尔表达式，除了基本的 `if-else` 语句，还可以使用 `for` 循环，在使用 `for` 循环时也有一些约束，如**循环变量的值必须是编译时已知**。\b如下：\n\n```c\nfor (int i = 0; i < 3; i++) {\n\tsum += i;\n}\n```\n\n在 GLSL 中使用循环时一定要注意：只有一个循环变量，循环变量必须使用简单的语句来增减（如 i++, i–, i+=constant, i-=constant等），循环终止条件也必须是循环变量和常量的简单比较，在循环内部不能改变循环变量的值。\n\n以下代码是 GLSL 中不支持的循环用法的示例：\n\n```c\nfloat myArr[4];\nfor (int i = 0; i < 3; i++) {\n  \t// 错误, [ ]中只能为常量或 uniform 变量，不能为整数量变量（如：i，j，k）\n\tsum += myArr[i]; \n}\n...\nuniform int loopIter;\n// 错误, 循环变量 loopIter 的值必须是编译时已知\nfor (int i = 0; i < loopIter; i++) {\n\tsum += i;\n}\n```\n\n\n\n\n\n### 5. 函数\n\nGLSL 函数的声明与 C 语言中很相似，无非就是返回值，函数名，参数列表。\n\nGLSL 着色器同样是从 main 函数开始执行。另外， GLSL 也支持自定义函数。当然，如果一个函数在定以前被调用，则需要先声明其原型。\n\n值得注意的一点是，GLSL 中函数不能够递归调用，且必须声明返回值类型（无返回值时声明为void）。如下：\n\n```c\nvec4 getPosition(){ \n    vec4 v4 = vec4(0.,0.,0.,1.);\n    return v4;\n}\n\nvoid doubleSize(inout float size){\n    size= size*2.0  ;\n}\nvoid main() {\n    float psize= 10.0;\n    doubleSize(psize);\n    gl_Position = getPosition();\n    gl_PointSize = psize;\n}\n```\n\n\n\n\n\n### 6. 限定符\n\n#### 存储限定符\n\n在声明变量时，应根据需要使用存储限定符来修饰，类似 C 语言中的说明符。GLSL 中支持的存储限定符见下表：\n\n| 限定符               | 描述                         |\n| ----------------- | -------------------------- |\n| < none: default > | 局部可读写变量，或者函数的参数            |\n| const             | 编译时常量，或只读的函数参数             |\n| attribute         | 由应用程序传输给顶点着色器的逐顶点的数据       |\n| uniform           | 在图元处理过程中其值保持不变，由应用程序传输给着色器 |\n| varying           | 由顶点着色器传输给片段着色器中的插值数据       |\n\n\n\n- 本地变量和函数参数只能使用 const 限定符，函数返回值和结构体成员不能使用限定符。\n- 数据不能从一个着色器程序传递给下一个阶段的着色器程序，这样会阻止同一个着色器程序在多个顶点或者片段中进行并行计算。\n- 不包含任何限定符或者包含 const 限定符的全局变量可以包含初始化器，这种情况下这些变量会在 main() 函数开始之后第一行代码之前被初始化，这些初始化值必须是常量表达式。\n- 没有任何限定符的全局变量如果没有在定义时初始化或者在程序中被初始化，则其值在进入 main() 函数之后是未定义的。\n- uniform、attribute 和 varying 限定符修饰的变量不能在初始化时被赋值，这些变量的值由 OpenGL ES 计算提供。\n\n##### 默认限定符\n\n如果一个全局变量没有指定限定符，则该变量与应用程序或者其他正在运行的处理单元没有任何联系。不管是全局变量还是本地变量，它们总是在自己的处理单元被分配内存，因此可以对它们执行读和写操作。\n\n\n\n##### const 限定符\n\n任意基础类型的变量都可以声明为常量。常量表示这些变量中的值在着色器中不会发生变化，声明常量只需要在声明时加上限定符 const 即可，声明时必须赋初值。\n\n```c\nconst float zero = 0.0;\nconst float pi = 3.14159;\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\nconst mat4 identity = mat4(1.0);\n```\n\n- 常量声明过的值在代码中不能再改变，这一点和 C 语言或 C++ 一样。\n- 结构体成员不能被声明为常量，但是结构体变量可以被声明为常量，并且需要在初始化时使用构造器初始化其值。\n- 常量必须被初始化为一个常量表达式。数组或者包含数组的结构体不能被声明为常量（因为数组不能在定义时被初始化）。\n\n##### attribute 限定符\n\nGLSL 中另一种特殊的变量类型是 attribute 变量。attribute 变量只用于顶点着色器中，用来存储顶点着色器中每个顶点的输入（per-vertex inputs）。attribute 通常用来存储位置坐标、法向量、纹理坐标和颜色等。注意 attribute 是用来存储单个顶点的信息。如下是包含位置，色值 attribute 的顶点着色器示例：\n\n```c\n// 顶点着色器 .vsh\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n```\n\n着色器中的两个 attribute 变量 `position` 和 `color` 由应用程序加载数值。应用程序会创建一个顶点数组，其中包含了每个顶点的位置坐标和色值信息。可使用的最大 attribute 数量也是有上限的，可以使用  `gl_MaxVertexAttribs` 来获取，也可以使用内置函数 `glGetIntegerv` 来询问 `GL_MAX_VERTEX_ATTRIBS`。OpenGL ES 2.0 实现支持的最少 attribute 个数是8个。\n\n##### uniform 限定符\n\nuniform 是 GLSL 中的一种变量类型限定符，用于存储应用程序通过 GLSL 传递给着色器的只读值。uniform 可以用来存储着色器需要的各种数据，如变换矩阵、光参数和颜色等。传递给着色器的在所有的顶点着色器和片段着色器中保持不变的的任何参数，基本上都应该通过 uniform 来存储。uniform 变量在全局区声明，以下是 uniform 的一些示例：\n\n```c\nuniform mat4 viewProjMatrix;\nuniform mat4 viewMatrix;\nuniform vec3 lightPosition;\n```\n\n需要注意的一点是，顶点着色器和片段着色器共享了 uniform 变量的命名空间。对于连接于同一个着色程序对象的顶点和片段着色器，它们共用同一组 uniform 变量，因此，如果在顶点着色器和片段着色器中都声明了 uniform 变量，二者的声明必须一致。当应用程序通过 API 加载了 uniform 变量时，该变量的值在顶点和片段着色器中都能够获取到。\n\n另一点需要注意的是，uniform 变量通常是存储在硬件中的”常量区”，这一区域是专门分配用来存储常量的，但是由于这一区域尺寸非常有限，因此着色程序中可以使用的 uniform 的个数也是有限的。可以通过读取内置变量 `gl_MaxVertexUniformVectors` 和 `gl_MaxFragmentUniformVectors` 来获得，也可以使用 `glGetIntegerv` 查询 `GL_MAX_VERTEX_UNIFORM_VECTORS` 或者 `GL_MAX_FRAGMENT_UNIFORM_VECTORS` 。OpenGL ES 2.0 的实现必须提供至少 128 个顶点 uniform 向量及 16 片段 uniform 向量。\n\n##### varying 限定符\n\nGLSL 中最后一个要说的存储限定符是 varying。varying 存储的是顶点着色器的输出，同时作为片段着色器的输入，通常顶点着色器都会把需要传递给片段着色器的数据存储在一个或多个 varying 变量中。这些变量在片段着色器中需要有相对应的声明且数据类型一致，然后在光栅化过程中进行插值计算。以下是一些 varying 变量的声明：\n\n```c\nvarying vec2 texCoord;\nvarying vec4 color;\n```\n\n顶点着色器和片段着色器中都会有 varying 变量的声明，由于 varying 是顶点着色器的输出且是片段着色器的输入，所以两处声明必须一致。与 uniform 和 attribute 相同，varying 也有数量的限制，可以使用 `gl_MaxVaryingVectors` 获取或使用 `glGetIntegerv` 查询  `GL_MAX_VARYING_VECTORS` 来获取。OpenGL ES 2.0 实现中的 varying 变量最小支持数为 8。\n\n回顾下最初那个着色器对应的 varying 声明：\n\n```c\n// 顶点着色器 .vsh\nattribute vec4 position;\nattribute vec4 color;\n\nvarying vec4 colorVarying;\n\nvoid main(void) {\n    colorVarying = color;\n    gl_Position = position;\n}\n\n// 片段着色器 .fsh\nvarying lowp vec4 colorVarying;\n\nvoid main(void) {\n    gl_FragColor = colorVarying;\n}\n```\n\n#### invariant 限定符\n\ninvariant 可以作用于顶点着色器输出的任何一个 varying 变量。\n\n当着色器被编译时，编译器会对其进行优化，这种优化操作可能引起指令重排序（instruction reordering），指令重排序可能引起的结果是当两个着色器进行相同的计算时无法保证得到相同的结果。\n例如，在两个顶点着色器中，变量 `gl_Position` 使用相同的表达式赋值，并且当着色程序运行时，在表达式中传入相等的变量值，则两个着色器中 `gl_Position` 的值无法保证相等，这是因为两个着色器是分别单独编译的。这将会引起 multi-pass 算法的几何不一致问题。\n通常情况下，不同着色器之间的这种值的差异是允许存在的。如果要避免这种差异，则可以将变量声明为invariant，可以单独指定某个变量或进行全局设置。\n\n使用 invariant 限定符可以使输出的变量保持不变。invariant 限定符可以作用于之前已声明的变量使其具有不变性，也可以在声明变量时直接作为声明的一部分，可参考以下两段示例代码：\n\n```c\nvarying mediump vec3 Color;\n// 使已存在的 color 变量不可变\ninvariant Color; \n```\n\n或\n\n```c\ninvariant varying mediump vec3 Color;\n```\n\n以上是仅有的使用 invariant 限定符情境。如果在声明时使用 invariant 限定符，则必须保证其放在存储限定符（varying）之前。\n只有以下变量可以声明为 invariant：\n\n- 由顶点着色器输出的内置的特殊变量\n- 由顶点着色器输出的 varying 变量\n- 向片段着色器输入的内置的特殊变量\n- 向片段着色器输入的 varying 变量\n- 由片段着色器输出的内置的特殊变量\n\n为保证由两个着色器输出的特定变量的不变性，必须遵循以下几点：\n\n- 该输出变量在两个着色器中都被声明为 invariant\n- 影响输出变量的所有表达式、流程控制语句的输入值必须相同\n- 对于影响输出值的所有纹理函数，纹理格式、纹理元素值和纹理过滤必须一致\n- 对输入值的所有操作都必须一致。表达式及插值计算的所有操作必须一致，相同的运算数顺序，相同的结合性，并且按相同顺序计算。插值变量和插值函数的声明，必须有相同类型，相同的显式或隐式的精度precision限定符。影响输出值的所有控制流程必须相同，影响决定控制流程的表达式也必须遵循不变性的规则。\n\n最基本的一点是：所有的 invariant 输出量的上游数据流或控制流必须一致。\n\n初始的默认状态下，所有的输出变量不具备不变性，可以在所有的声明之前使用以下 `pragma` 语句强制所有输出变量 invariant：\n\n```c\n#pragma STDGL invariant(all)\n```\n\n输出变量的不变性通常会以优化过程的灵活性为代价，所以使用 invariant 会牺牲整体性能。因此慎用以上的全局设置方法，可以将其用作协助 Debug 的一种方法。\n另一点需要说明的是，这里的不变性指的是对于同一 GPU 的不变性，并不保证不同 OpenGL ES 实现之间的不变性。\n\n\n\n#### 参数限定符\n\nGLSL 提供了一种特殊的限定符用来定义某个变量的值是否可以被函数修改，详见下表：\n\n| 限定符   | 描述                                       |\n| ----- | ---------------------------------------- |\n| in    | 默认使用的缺省限定符，指明参数传递的是值，并且函数不会修改传入的值（C 语言中值传递） |\n| inout | 指明参数传入的是引用，如果在函数中对参数的值进行了修改，当函数结束后参数的值也会修改（C 语言中引用传递） |\n| out   | 参数的值不会传入函数，但是在函数内部修改其值，函数结束后其值会被修改       |\n\n使用的方式如下边的代码：\n\n```c\nvec4 myFunc(inout float myFloat, // inout parameter\n            out vec4 myVec4, \t // out parameter\n            mat4 myMat4); \t\t // in parameter (default)\n```\n\n以下是一个示例函数，函数定义用来计算基础的漫反射光照：\n\n```c\nvec4 diffuse(vec3 normal, vec3 light, vec4 baseColor) {\n\treturn baseColor * dot(normal, light);\n}\n```\n\n\n\n#### 精度限定符\n\nOpenGL ES 与 OpenGL 之间的一个区别就是在 GLSL 中引入了精度限定符。精度限定符可使着色器的编写者明确定义着色器变量计算时使用的精度，变量可以选择被声明为低、中或高精度。精度限定符可告知编译器使其在计算时缩小变量潜在的精度变化范围，当使用低精度时，OpenGL ES 的实现可以更快速和低功耗地运行着色器，效率的提高来自于精度的舍弃，如果精度选择不合理，着色器运行的结果会很失真。\n\nOpenGL ES 对各硬件并未强制要求多种精度的支持。其实现可以使用高精度完成所有的计算并且忽略掉精度限定符，然而某些情况下使用低精度的实现会更有优势，精度限定符可以指定整型或浮点型变量的精度，如 `lowp`，`mediump`，及 `highp`，如下：\n\n| 限定符     | 描述                                       |\n| ------- | ---------------------------------------- |\n| highp   | 满足顶点着色语言的最低要求。对片段着色语言是可选项                |\n| mediump | 满足片段着色语言的最低要求，其对于范围和精度的要求必须不低于lowp并且不高于highp |\n| lowp    | 范围和精度可低于mediump，但仍可以表示所有颜色通道的所有颜色值       |\n\n具体用法参考以下示例：\n\n```c\nhighp vec4 position;\nvarying lowp vec4 color;\nmediump float specularExp;\n```\n\n除了精度限定符，还可以指定默认使用的精度。如果某个变量没有使用精度限定符指定使用何种精度，则会使用该变量类型的默认精度。默认精度限定符放在着色器代码起始位置，以下是一些用例：\n\n```c\nprecision highp float;\nprecision mediump int;\n```\n\n当为 `float` 指定默认精度时，所有基于浮点型的变量都会以此作为默认精度，与此类似，为 `int` 指定默认精度时，所有的基于整型的变量都会以此作为默认精度。在顶点着色器中，如果没有指定默认精度，则 `int` 和 `float` 都使用 `highp`，即顶点着色器中，未使用精度限定符指明精度的变量都默认使用最高精度。在片段着色器中，`float` 并没有默认的精度设置，即片段着色器中必须为 `float` 默认精度或者为每一个 `float` 变量指明精度。OpenGL ES 2.0 并未要求其实现在片段着色器中支持高精度，可用是否定义了宏 `GL_FRAGMENT_PRECISION_HIGH` 来判断是否支持在片段着色器中使用高精度。\n\n在片段着色器中可以使用以下代码：\n\n```c\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n```\n\n这么做可以确保无论实现支持中精度还是高精度都可以完成着色器的编译。注意不同实现中精度的定义及精度的范围都不统一，而是因实现而异的。\n\n精度修饰符声明了底层实现存储这些变量时，必须要使用的最小范围和精度。实现可能会使用比要求更大的范围和精度，但绝对不会比要求少。以下是精度修饰符要求的最低范围和精度：\n\n|         | 浮点数范围          | 浮点数大小范围       | 浮点数精度范围  | 整数范围           |\n| ------- | -------------- | ------------- | -------- | -------------- |\n| highp   | (-2^62 , 2^62) | (2^-62 ,2^62) | 相对：2^-16 | (-2^16 , 2^16) |\n| mediump | (-2^14 , 2^14) | (2^-14 ,2^14) | 相对：2^-10 | (-2^10 , 2^10) |\n| lowp    | (-2, 2)        | (2^-8 ,2)     | 绝对：2^-8  | (-2^8 , 2^8)   |\n\n在具体实现中，着色器编译器支持的不同着色器类型和数值形式的实际的范围及精度可用以下函数获取：\n\n```c\nvoid GetShaderPrecisionFormat( enum shadertype, enum precisiontype, int *range, int *precision );\n```\n\n其中， `shadertype` 必须是 `VERTEX_SHADER` 或 `FRAGMENT_SHADER`；`precisiontype` 必须是 `LOW_FLOAT`、`MEDIUM_FLOAT`、`HIGH_FLOAT`、`LOW_INT`、`MEDIUM_INT` 或 `HIGH_INT`。\n\n`range ` 是指向含有两个整数的数组的指针，这两个整数将会返回数值的范围。如果用 `min` 和 `max` 来代表对应格式的最小和最大值，则 `range` 中返回的整数值可以定义为：\n\n```c\nrange[0] = log2(|min|)\nrange[1] = log2(|max|)\n```\n\n`precision ` 是指向一个整数的指针，返回的该整数是对应格式的精度的位数（number of bits）用 `log2` 取对数的值。\n\n\n\n**Q：如何确定精度:**\n\n**A：**变量的精度首先是由精度限定符决定的，如果没有精度限定符，则要寻找其右侧表达式中，已经确定精度的变量，一旦找到，那么整个表达式都将在该精度下运行。\n\n如果找到多个，则选择精度较高的那种，如果一个都找不到，则使用默认或更大的精度类型。\n\n```c\nuniform highp float h1;\nhighp float h2 = 2.3 * 4.7; // 运算过程和结果都是 highp\nmediump float m;\nm = 3.7 * h1 * h2; \t\t\t// 运算过程是 highp\nh2 = m * h1; \t\t\t\t// 运算过程是 highp\nm = h2 – h1; \t\t\t\t// 运算过程是 highp\nh2 = m + m; \t\t\t\t// 运算过程和结果都是 mediump\nvoid f(highp float p); \t\t// 形参 p 是 highp\nf(3.3);\t\t\t\t\t    // 传入的 3.3 是 highp\n```\n\n\n\n**Q：限定符的顺序**\n\n**A：**当需要用到多个限定符的时候要遵循以下顺序: \n\n- 在一般变量中：invariant > storage > precision （storage：存储，precision：精度）\n- 在函数参数中：storage > parameter > precision （parameter：参数）\n\n我们来举例说明:\n\n```c\ninvariant varying lowp float color; // invariant > storage > precision\n\nvoid doubleSize(const in lowp float s){ //storage > parameter > precision\n    float s1=s;\n}\n```\n\n","slug":"OpenGLES-Lesson04","published":1,"updated":"2019-12-23T01:02:31.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1nh002kzwln7j4xf33q","content":"<p>上节在绘制三角形的时候，简单讲解了一些着色器，GLSL 的相关概念，可能看的云里雾里的。不要担心，在本节中，我将详细讲解着色语言 GL Shader Language（GLSL）的一些基本的概念。</p>\n<blockquote>\n<p>PS：<br>无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"概览\">概览</h2><p>OpenGL ES 的渲染管线包含有一个可编程的顶点阶段的一个可编程的片段阶段。其余的阶段则有固定的功能，应用程序对其行为的控制非常有限。每个可编程阶段中编译单元的集合组成了一个着色器。在OpenGL ES 2.0 中，每个着色器只支持一个编译单元。着色程序则是一整套编译好并链接在一起的着色器的集合。着色器 shader 的编写需要使用着色语言 GL Shader Language（GLSL），GLSL 的语法与 C 语言很类似。</p>\n<p>在上一节中，我们看到了一个非常简单的着色器，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点着色器 .vsh</span></span><br><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 片段着色器 .fsh</span></span><br><span class=\"line\">varying lowp vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    gl_FragColor = colorVarying;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>习惯上，我们一般把顶点着色器命名为 <strong>xx.vsh</strong>，片段着色器命名为 <strong>xx.fsh</strong>。当然，你喜欢怎么样就怎么样~</p>\n<p>和 C 语言程序对应，用 GLSL 写出的着色器，它同样包括：</p>\n<ul>\n<li>变量 position</li>\n<li>变量类型 vec4</li>\n<li>限定符 attribute</li>\n<li>main 函数</li>\n<li>基本赋值语句 colorVarying = color</li>\n<li>内置变量 gl_Position</li>\n<li>…</li>\n</ul>\n<p>这一切，都是那么像…所以，<strong>在掌握 C 语言的基础上，GLSL 的学习成本是很低的</strong>。</p>\n<p>学习一门语言，我们无非是从<strong>变量类型，结构体，数组，语句，函数，限定符等</strong>方面展开。下面，我们就照着这个顺序，学习 GLSL。</p>\n<h2 id=\"使用_GLSL_构建着色器\">使用 GLSL 构建着色器</h2><h3 id=\"1-_变量\">1. 变量</h3><h4 id=\"变量及变量类型\">变量及变量类型</h4><table>\n<thead>\n<tr>\n<th>变量类别</th>\n<th>变量类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空</td>\n<td>void</td>\n<td>用于无返回值的函数或空的参数列表</td>\n</tr>\n<tr>\n<td>标量</td>\n<td>float, int, bool</td>\n<td>浮点型，整型，布尔型的标量数据类型</td>\n</tr>\n<tr>\n<td>浮点型向量</td>\n<td>float, vec2, vec3, vec4</td>\n<td>包含1，2，3，4个元素的浮点型向量</td>\n</tr>\n<tr>\n<td>整数型向量</td>\n<td>int, ivec2, ivec3, ivec4</td>\n<td>包含1，2，3，4个元素的整型向量</td>\n</tr>\n<tr>\n<td>布尔型向量</td>\n<td>bool, bvec2, bvec3, bvec4</td>\n<td>包含1，2，3，4个元素的布尔型向量</td>\n</tr>\n<tr>\n<td>矩阵</td>\n<td>mat2, mat3, mat4</td>\n<td>尺寸为2x2，3x3，4x4的浮点型矩阵</td>\n</tr>\n<tr>\n<td>纹理句柄</td>\n<td>sampler2D, samplerCube</td>\n<td>表示2D，立方体纹理的句柄</td>\n</tr>\n</tbody>\n</table>\n<p>除上述之外，着色器中还可以将它们构成数组或结构体，以实现更复杂的数据类型。</p>\n<blockquote>\n<p>PS：</p>\n<p>GLSL 中没有指针类型。</p>\n</blockquote>\n<h4 id=\"变量构造器和类型转换\">变量构造器和类型转换</h4><p>对于变量运算，GLSL 中有非常严格的规则，即<strong>只有类型一致时，变量才能完成赋值或其它对应的操作。</strong>可以通过对应的构造器来实现类型转换。</p>\n<h5 id=\"标量\">标量</h5><p>标量对应 C 语言的基础数据类型，它的构造和 C 语言一致，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> myFloat = <span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> myBool = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myFloat = <span class=\"keyword\">float</span>(myBool); \t<span class=\"comment\">// bool -&gt; float</span></span><br><span class=\"line\">myBool = <span class=\"keyword\">bool</span>(myFloat);     <span class=\"comment\">// float -&gt; bool</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"向量\">向量</h5><p>当构造向量时，向量构造器中的各参数将会被转换成相同的类型（浮点型、整型或布尔型）。往向量构造器中传递参数有两种形式：</p>\n<ul>\n<li>如果向量构造器中只提供了一个标量参数，则向量中所有值都会设定为该标量值。</li>\n<li>如果提供了多个标量值或提供了向量参数，则会从左至右使用提供的参数来给向量赋值，如果使用多个标量来赋值，则需要确保标量的个数要多于向量构造器中的个数。</li>\n</ul>\n<p>向量构造器用法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 myVec4 = vec4(<span class=\"number\">1.0</span>); \t\t\t<span class=\"comment\">// myVec4 = &#123;1.0, 1.0, 1.0, 1.0&#125;</span></span><br><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>);  <span class=\"comment\">// myVec3 = &#123;1.0, 0.0, 0.5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">vec3 temp = vec3(myVec3); \t\t\t<span class=\"comment\">// temp = myVec3</span></span><br><span class=\"line\">vec2 myVec2 = vec2(myVec3);         <span class=\"comment\">// myVec2 = &#123;myVec3.x, myVec3.y&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">myVec4 = vec4(myVec2, temp, <span class=\"number\">0.0</span>);   <span class=\"comment\">// myVec4 = &#123;myVec2.x, myVec2.y , temp, 0.0 &#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"矩阵\">矩阵</h5><p>矩阵的构造方法则更加灵活，有以下规则：</p>\n<ul>\n<li>如果对矩阵构造器只提供了一个标量参数，该值会作为矩阵的对角线上的值。例如 <code>mat4(1.0)</code> 可以构造一个 4 × 4 的单位矩阵</li>\n<li>矩阵可以通过多个向量作为参数来构造，例如一个 mat2 可以通过两个 vec2 来构造</li>\n<li>矩阵可以通过多个标量作为参数来构造，矩阵中每个值对应一个标量，按照从左到右的顺序</li>\n</ul>\n<p>除此之外，矩阵的构造方法还可以更灵活，只要有足够的组件来初始化矩阵，其构造器参数可以是标量和向量的组合。在 OpenGL ES 中，矩阵的值会以<strong>列</strong>的顺序来存储。在构造矩阵时，构造器参数会按照列的顺序来填充矩阵，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat3 myMat3 = mat3(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,  <span class=\"comment\">// 第一列</span></span><br><span class=\"line\">                   <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,  <span class=\"comment\">// 第二列</span></span><br><span class=\"line\">                   <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>); <span class=\"comment\">// 第三列</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"\b向量和矩阵的分量\">\b向量和矩阵的分量</h4><p>单独获得向量中的组件有两种方法：即使用 <code>&quot;.&quot;</code> 符号或使用数组下标方法。依据构成向量的组件个数，向量的组件可以通过 <code>{x, y, z, w}</code> ， <code>{r, g, b, a}</code> 或 <code>{s, t, r, q}</code> 等 swizzle 操作来获取。之所以采用这三种不同的命名方法，是因为向量常常会用来表示数学向量、颜色、纹理坐标等。其中的<code>x</code>、<code>r</code>、<code>s</code> 组件总是表示向量中的第一个元素，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>分量访问符</th>\n<th>符号描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(x,y,z,w)</td>\n<td>与位置相关的分量</td>\n</tr>\n<tr>\n<td>(r,g,b,a)</td>\n<td>与颜色相关的分量</td>\n</tr>\n<tr>\n<td>(s,t,p,q)</td>\n<td>与纹理坐标相关的分量</td>\n</tr>\n</tbody>\n</table>\n<p>不同的命名约定是为了方便使用，所以哪怕是描述位置的向量，也是可以通过 <code>{r, g, b, a}</code>  来获取。但是在使用向量时不能混用不同的命名约定，即不能使用 <code>.xgr</code> 这样的方式，每次只能使用同一种命名约定。当使用 <code>&quot;.&quot;</code> 操作符时，还可以对向量中的元素重新排序，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>); <span class=\"comment\">// myVec3 = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class=\"line\">vec3 temp;</span><br><span class=\"line\">temp = myVec3.xyz; <span class=\"comment\">// temp = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class=\"line\">temp = myVec3.xxx; <span class=\"comment\">// temp = &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class=\"line\">temp = myVec3.zyx; <span class=\"comment\">// temp = &#123;2.0, 1.0, 0.0&#125;</span></span><br></pre></td></tr></table></figure>\n<p>除了使用 <code>&quot;.&quot;</code> 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 <code>[0]</code> 对应的是 <code>x</code>，元素 <code>[1]</code> 对应 <code>y</code>，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。</p>\n<p>矩阵可以认为是向量的组合。例如一个 mat2 可以认为是两个 vec2，一个 mat3 可以认为是三个 vec3 等等。对于矩阵来说，可以通过数组下标 <code>“[]”</code> 来获取某一列的值，然后获取到的向量又可以继续使用向量的操作方法，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat4 myMat4 = mat4(<span class=\"number\">1.0</span>); \t<span class=\"comment\">// Initialize diagonal to 1.0 (identity)</span></span><br><span class=\"line\">vec4 col0 = myMat4[<span class=\"number\">0</span>];\t    <span class=\"comment\">// Get col0 vector out of the matrix </span></span><br><span class=\"line\"><span class=\"keyword\">float</span> m1_1 = myMat4[<span class=\"number\">1</span>][<span class=\"number\">1</span>];  <span class=\"comment\">// Get element at [1][1] in matrix </span></span><br><span class=\"line\"><span class=\"keyword\">float</span> m2_2 = myMat4[<span class=\"number\">2</span>].z;   <span class=\"comment\">// Get element at [2][2] in matrix</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"向量和矩阵的操作\">向量和矩阵的操作</h4><p>绝大多数情况下，向量和矩阵的计算是逐分量进行的（component-wise）。当运算符作用于向量或矩阵时，该运算独立地作用于向量或矩阵的每个分量。<br>以下是一些示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 v, u;</span><br><span class=\"line\"><span class=\"keyword\">float</span> f;</span><br><span class=\"line\">v = u + f;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v.x = u.x + f;</span><br><span class=\"line\">v.y = u.y + f;</span><br><span class=\"line\">v.z = u.z + f;</span><br></pre></td></tr></table></figure>\n<p>再如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 v, u, w;</span><br><span class=\"line\">w = v + u;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w.x = v.x + u.x;</span><br><span class=\"line\">w.y = v.y + u.y;</span><br><span class=\"line\">w.z = v.z + u.z;</span><br></pre></td></tr></table></figure>\n<p>对于整型和浮点型的向量和矩阵，绝大多数的计算都同上，但是对于向量乘以矩阵、矩阵乘以向量、矩阵乘以矩阵则是不同的计算规则。这三种计算使用线性代数的乘法规则，并且要求参与计算的运算数值有相匹配的尺寸或阶数。<br>例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 v, u;</span><br><span class=\"line\">mat3 m;</span><br><span class=\"line\">u = v * m;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u.x = dot(v, m[<span class=\"number\">0</span>]); <span class=\"comment\">// m[0] is the left column of m</span></span><br><span class=\"line\">u.y = dot(v, m[<span class=\"number\">1</span>]); <span class=\"comment\">// dot(a,b) is the inner (dot) product of a and b</span></span><br><span class=\"line\">u.z = dot(v, m[<span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure>\n<p>再如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u = m * v;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u.x = m[<span class=\"number\">0</span>].x * v.x + m[<span class=\"number\">1</span>].x * v.y + m[<span class=\"number\">2</span>].x * v.z;</span><br><span class=\"line\">u.y = m[<span class=\"number\">0</span>].y * v.x + m[<span class=\"number\">1</span>].y * v.y + m[<span class=\"number\">2</span>].y * v.z;</span><br><span class=\"line\">u.z = m[<span class=\"number\">0</span>].z * v.x + m[<span class=\"number\">1</span>].z * v.y + m[<span class=\"number\">2</span>].z * v.z;</span><br></pre></td></tr></table></figure>\n<p>再如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat m, n, r;</span><br><span class=\"line\">r = m * n;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r[<span class=\"number\">0</span>].x = m[<span class=\"number\">0</span>].x * n[<span class=\"number\">0</span>].x + m[<span class=\"number\">1</span>].x * n[<span class=\"number\">0</span>].y + m[<span class=\"number\">2</span>].x * n[<span class=\"number\">0</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">1</span>].x = m[<span class=\"number\">0</span>].x * n[<span class=\"number\">1</span>].x + m[<span class=\"number\">1</span>].x * n[<span class=\"number\">1</span>].y + m[<span class=\"number\">2</span>].x * n[<span class=\"number\">1</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">2</span>].x = m[<span class=\"number\">0</span>].x * n[<span class=\"number\">2</span>].x + m[<span class=\"number\">1</span>].x * n[<span class=\"number\">2</span>].y + m[<span class=\"number\">2</span>].x * n[<span class=\"number\">2</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">0</span>].y = m[<span class=\"number\">0</span>].y * n[<span class=\"number\">0</span>].x + m[<span class=\"number\">1</span>].y * n[<span class=\"number\">0</span>].y + m[<span class=\"number\">2</span>].y * n[<span class=\"number\">0</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">1</span>].y = m[<span class=\"number\">0</span>].y * n[<span class=\"number\">1</span>].x + m[<span class=\"number\">1</span>].y * n[<span class=\"number\">1</span>].y + m[<span class=\"number\">2</span>].y * n[<span class=\"number\">1</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">2</span>].y = m[<span class=\"number\">0</span>].y * n[<span class=\"number\">2</span>].x + m[<span class=\"number\">1</span>].y * n[<span class=\"number\">2</span>].y + m[<span class=\"number\">2</span>].y * n[<span class=\"number\">2</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">0</span>].z = m[<span class=\"number\">0</span>].z * n[<span class=\"number\">0</span>].x + m[<span class=\"number\">1</span>].z * n[<span class=\"number\">0</span>].y + m[<span class=\"number\">2</span>].z * n[<span class=\"number\">0</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">1</span>].z = m[<span class=\"number\">0</span>].z * n[<span class=\"number\">1</span>].x + m[<span class=\"number\">1</span>].z * n[<span class=\"number\">1</span>].y + m[<span class=\"number\">2</span>].z * n[<span class=\"number\">1</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">2</span>].z = m[<span class=\"number\">0</span>].z * n[<span class=\"number\">2</span>].x + m[<span class=\"number\">1</span>].z * n[<span class=\"number\">2</span>].y + m[<span class=\"number\">2</span>].z * n[<span class=\"number\">2</span>].z;</span><br></pre></td></tr></table></figure>\n<p>对于2阶和4阶的向量或矩阵也是相似的规则。</p>\n<h3 id=\"2-_结构体\">2. 结构体</h3><p>与 C 语言相似，除了基本的数据类型之外，还可以将多个变量聚合到一个结构体中，下边的示例代码演示了在GLSL中如何声明结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> customStruct</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvec4 color;</span><br><span class=\"line\">\tvec2 position;</span><br><span class=\"line\">&#125; customVertex;</span><br></pre></td></tr></table></figure>\n<p>首先，定义会产生一个新的类型叫做 <code>customStruct</code> ，及一个名为 <code>customVertex</code> 的变量。结构体可以用构造器来初始化，在定义了新的结构体之后，还会定义一个与结构体类型名称相同的构造器。构造器与结构体中的数据类型必须一一对应，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customVertex = customStruct(vec4(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>), <span class=\"comment\">// color</span></span><br><span class=\"line\">\t\t\t\t\t\t\tvec2(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>)); \t\t  <span class=\"comment\">// position</span></span><br></pre></td></tr></table></figure>\n<p>结构体的构造器是基于类型的名称，以参数的形式来赋值。获取结构体内元素的方法和C语言中一致：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 color = customVertex.color;</span><br><span class=\"line\">vec4 position = customVertex.position;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-_数组\">3. 数组</h3><p>除了结构体外，GLSL 中还支持数组。 语法与 C 语言相似，创建数组的方式如下代码所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> floatArray[<span class=\"number\">4</span>];</span><br><span class=\"line\">vec4 vecArray[<span class=\"number\">2</span>];</span><br></pre></td></tr></table></figure>\n<p>与C语言不同，在GLSL中，关于数组有两点需要注意：</p>\n<ul>\n<li>除了 uniform 变量之外，数组的索引只允许使用常数整型表达式。</li>\n<li>在 GLSL 中不能在创建的同时给数组初始化，即数组中的元素需要在定义数组之后逐个初始化，且数组不能使用 const 限定符。</li>\n</ul>\n<h3 id=\"4-_语句\">4. 语句</h3><h4 id=\"运算符\">运算符</h4><p>下表展示了 GLSL 中支持的运算符：</p>\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>运算符类别</th>\n<th>运算符</th>\n<th>结合方向</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 (最高)</td>\n<td>成组操作</td>\n<td>()</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td></td>\n<td>数组下标，函数调用与构造函数，访问分量或结构体的字段，后置自增和自减</td>\n<td>[] () . ++ –</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>3</td>\n<td>前置自增和自减，一元正/负数，一元逻辑非</td>\n<td>++ – + - !</td>\n<td>从右向左</td>\n</tr>\n<tr>\n<td>4</td>\n<td>乘法，除法</td>\n<td>* /</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>5</td>\n<td>加法，减法</td>\n<td>+ -</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>6</td>\n<td>关系比较操作</td>\n<td>&lt; &gt; &lt;= &gt;=</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>7</td>\n<td>相等操作</td>\n<td>== !=</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>8</td>\n<td>逻辑与</td>\n<td>&amp;&amp;</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>9</td>\n<td>逻辑异或</td>\n<td>^^</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>10</td>\n<td>逻辑或</td>\n<td>\\ \\</td>\n<td>\\</td>\n<td></td>\n<td>\\ 从左向右</td>\n</tr>\n<tr>\n<td>11</td>\n<td>三元选择操作（问号表达式）</td>\n<td>?:</td>\n<td>从右向左</td>\n</tr>\n<tr>\n<td>12</td>\n<td>赋值与算数赋值</td>\n<td>= += -= *= /=</td>\n<td>从右向左</td>\n</tr>\n<tr>\n<td>13(最低)</td>\n<td>操作符序列</td>\n<td>,</td>\n<td>从左向右</td>\n</tr>\n</tbody>\n</table>\n<p>绝大多数的运算符与 C 语言中一致。与 C 语言不同的是：GLSL 中对于参与运算的数据类型要求比较严格，即运算符两侧的变量必须有相同的数据类型。对于二目运算符（*，/，+，-），操作数必须为浮点型或整型，除此之外，乘法操作可以放在不同的数据类型之间如浮点型、向量和矩阵等。</p>\n<p><strong>前面矩阵的行数就是结果矩阵的行数，后面矩阵的列数就是结果矩阵的列数。</strong></p>\n<p>比较运算符仅能作用于标量，对于向量的比较，GLSL 中有内置的函数，稍后会介绍。</p>\n<h4 id=\"流程控制语句\">流程控制语句</h4><p>流程控制语句与 C 语言非常相似，以下示例代码是 <code>if-else</code> 的使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (color.a &lt; <span class=\"number\">0.25</span>) &#123;</span><br><span class=\"line\">\tcolor *= color.a;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tcolor = vec4(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>判断的内容必须是布尔值或布尔表达式，除了基本的 <code>if-else</code> 语句，还可以使用 <code>for</code> 循环，在使用 <code>for</code> 循环时也有一些约束，如<strong>循环变量的值必须是编译时已知</strong>。\b如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">\tsum += i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 GLSL 中使用循环时一定要注意：只有一个循环变量，循环变量必须使用简单的语句来增减（如 i++, i–, i+=constant, i-=constant等），循环终止条件也必须是循环变量和常量的简单比较，在循环内部不能改变循环变量的值。</p>\n<p>以下代码是 GLSL 中不支持的循环用法的示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> myArr[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 错误, [ ]中只能为常量或 uniform 变量，不能为整数量变量（如：i，j，k）</span></span><br><span class=\"line\">\tsum += myArr[i]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">uniform <span class=\"keyword\">int</span> loopIter;</span><br><span class=\"line\"><span class=\"comment\">// 错误, 循环变量 loopIter 的值必须是编译时已知</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; loopIter; i++) &#123;</span><br><span class=\"line\">\tsum += i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-_函数\">5. 函数</h3><p>GLSL 函数的声明与 C 语言中很相似，无非就是返回值，函数名，参数列表。</p>\n<p>GLSL 着色器同样是从 main 函数开始执行。另外， GLSL 也支持自定义函数。当然，如果一个函数在定以前被调用，则需要先声明其原型。</p>\n<p>值得注意的一点是，GLSL 中函数不能够递归调用，且必须声明返回值类型（无返回值时声明为void）。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">getPosition</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">    vec4 v4 = vec4(<span class=\"number\">0.</span>,<span class=\"number\">0.</span>,<span class=\"number\">0.</span>,<span class=\"number\">1.</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleSize</span><span class=\"params\">(inout <span class=\"keyword\">float</span> size)</span></span>&#123;</span><br><span class=\"line\">    size= size*<span class=\"number\">2.0</span>  ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> psize= <span class=\"number\">10.0</span>;</span><br><span class=\"line\">    doubleSize(psize);</span><br><span class=\"line\">    gl_Position = getPosition();</span><br><span class=\"line\">    gl_PointSize = psize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-_限定符\">6. 限定符</h3><h4 id=\"存储限定符\">存储限定符</h4><p>在声明变量时，应根据需要使用存储限定符来修饰，类似 C 语言中的说明符。GLSL 中支持的存储限定符见下表：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt; none: default &gt;</td>\n<td>局部可读写变量，或者函数的参数</td>\n</tr>\n<tr>\n<td>const</td>\n<td>编译时常量，或只读的函数参数</td>\n</tr>\n<tr>\n<td>attribute</td>\n<td>由应用程序传输给顶点着色器的逐顶点的数据</td>\n</tr>\n<tr>\n<td>uniform</td>\n<td>在图元处理过程中其值保持不变，由应用程序传输给着色器</td>\n</tr>\n<tr>\n<td>varying</td>\n<td>由顶点着色器传输给片段着色器中的插值数据</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>本地变量和函数参数只能使用 const 限定符，函数返回值和结构体成员不能使用限定符。</li>\n<li>数据不能从一个着色器程序传递给下一个阶段的着色器程序，这样会阻止同一个着色器程序在多个顶点或者片段中进行并行计算。</li>\n<li>不包含任何限定符或者包含 const 限定符的全局变量可以包含初始化器，这种情况下这些变量会在 main() 函数开始之后第一行代码之前被初始化，这些初始化值必须是常量表达式。</li>\n<li>没有任何限定符的全局变量如果没有在定义时初始化或者在程序中被初始化，则其值在进入 main() 函数之后是未定义的。</li>\n<li>uniform、attribute 和 varying 限定符修饰的变量不能在初始化时被赋值，这些变量的值由 OpenGL ES 计算提供。</li>\n</ul>\n<h5 id=\"默认限定符\">默认限定符</h5><p>如果一个全局变量没有指定限定符，则该变量与应用程序或者其他正在运行的处理单元没有任何联系。不管是全局变量还是本地变量，它们总是在自己的处理单元被分配内存，因此可以对它们执行读和写操作。</p>\n<h5 id=\"const_限定符\">const 限定符</h5><p>任意基础类型的变量都可以声明为常量。常量表示这些变量中的值在着色器中不会发生变化，声明常量只需要在声明时加上限定符 const 即可，声明时必须赋初值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> zero = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> pi = <span class=\"number\">3.14159</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vec4 red = vec4(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mat4 identity = mat4(<span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常量声明过的值在代码中不能再改变，这一点和 C 语言或 C++ 一样。</li>\n<li>结构体成员不能被声明为常量，但是结构体变量可以被声明为常量，并且需要在初始化时使用构造器初始化其值。</li>\n<li>常量必须被初始化为一个常量表达式。数组或者包含数组的结构体不能被声明为常量（因为数组不能在定义时被初始化）。</li>\n</ul>\n<h5 id=\"attribute_限定符\">attribute 限定符</h5><p>GLSL 中另一种特殊的变量类型是 attribute 变量。attribute 变量只用于顶点着色器中，用来存储顶点着色器中每个顶点的输入（per-vertex inputs）。attribute 通常用来存储位置坐标、法向量、纹理坐标和颜色等。注意 attribute 是用来存储单个顶点的信息。如下是包含位置，色值 attribute 的顶点着色器示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点着色器 .vsh</span></span><br><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>着色器中的两个 attribute 变量 <code>position</code> 和 <code>color</code> 由应用程序加载数值。应用程序会创建一个顶点数组，其中包含了每个顶点的位置坐标和色值信息。可使用的最大 attribute 数量也是有上限的，可以使用  <code>gl_MaxVertexAttribs</code> 来获取，也可以使用内置函数 <code>glGetIntegerv</code> 来询问 <code>GL_MAX_VERTEX_ATTRIBS</code>。OpenGL ES 2.0 实现支持的最少 attribute 个数是8个。</p>\n<h5 id=\"uniform_限定符\">uniform 限定符</h5><p>uniform 是 GLSL 中的一种变量类型限定符，用于存储应用程序通过 GLSL 传递给着色器的只读值。uniform 可以用来存储着色器需要的各种数据，如变换矩阵、光参数和颜色等。传递给着色器的在所有的顶点着色器和片段着色器中保持不变的的任何参数，基本上都应该通过 uniform 来存储。uniform 变量在全局区声明，以下是 uniform 的一些示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 viewProjMatrix;</span><br><span class=\"line\">uniform mat4 viewMatrix;</span><br><span class=\"line\">uniform vec3 lightPosition;</span><br></pre></td></tr></table></figure>\n<p>需要注意的一点是，顶点着色器和片段着色器共享了 uniform 变量的命名空间。对于连接于同一个着色程序对象的顶点和片段着色器，它们共用同一组 uniform 变量，因此，如果在顶点着色器和片段着色器中都声明了 uniform 变量，二者的声明必须一致。当应用程序通过 API 加载了 uniform 变量时，该变量的值在顶点和片段着色器中都能够获取到。</p>\n<p>另一点需要注意的是，uniform 变量通常是存储在硬件中的”常量区”，这一区域是专门分配用来存储常量的，但是由于这一区域尺寸非常有限，因此着色程序中可以使用的 uniform 的个数也是有限的。可以通过读取内置变量 <code>gl_MaxVertexUniformVectors</code> 和 <code>gl_MaxFragmentUniformVectors</code> 来获得，也可以使用 <code>glGetIntegerv</code> 查询 <code>GL_MAX_VERTEX_UNIFORM_VECTORS</code> 或者 <code>GL_MAX_FRAGMENT_UNIFORM_VECTORS</code> 。OpenGL ES 2.0 的实现必须提供至少 128 个顶点 uniform 向量及 16 片段 uniform 向量。</p>\n<h5 id=\"varying_限定符\">varying 限定符</h5><p>GLSL 中最后一个要说的存储限定符是 varying。varying 存储的是顶点着色器的输出，同时作为片段着色器的输入，通常顶点着色器都会把需要传递给片段着色器的数据存储在一个或多个 varying 变量中。这些变量在片段着色器中需要有相对应的声明且数据类型一致，然后在光栅化过程中进行插值计算。以下是一些 varying 变量的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying vec2 texCoord;</span><br><span class=\"line\">varying vec4 color;</span><br></pre></td></tr></table></figure>\n<p>顶点着色器和片段着色器中都会有 varying 变量的声明，由于 varying 是顶点着色器的输出且是片段着色器的输入，所以两处声明必须一致。与 uniform 和 attribute 相同，varying 也有数量的限制，可以使用 <code>gl_MaxVaryingVectors</code> 获取或使用 <code>glGetIntegerv</code> 查询  <code>GL_MAX_VARYING_VECTORS</code> 来获取。OpenGL ES 2.0 实现中的 varying 变量最小支持数为 8。</p>\n<p>回顾下最初那个着色器对应的 varying 声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点着色器 .vsh</span></span><br><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 片段着色器 .fsh</span></span><br><span class=\"line\">varying lowp vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    gl_FragColor = colorVarying;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"invariant_限定符\">invariant 限定符</h4><p>invariant 可以作用于顶点着色器输出的任何一个 varying 变量。</p>\n<p>当着色器被编译时，编译器会对其进行优化，这种优化操作可能引起指令重排序（instruction reordering），指令重排序可能引起的结果是当两个着色器进行相同的计算时无法保证得到相同的结果。<br>例如，在两个顶点着色器中，变量 <code>gl_Position</code> 使用相同的表达式赋值，并且当着色程序运行时，在表达式中传入相等的变量值，则两个着色器中 <code>gl_Position</code> 的值无法保证相等，这是因为两个着色器是分别单独编译的。这将会引起 multi-pass 算法的几何不一致问题。<br>通常情况下，不同着色器之间的这种值的差异是允许存在的。如果要避免这种差异，则可以将变量声明为invariant，可以单独指定某个变量或进行全局设置。</p>\n<p>使用 invariant 限定符可以使输出的变量保持不变。invariant 限定符可以作用于之前已声明的变量使其具有不变性，也可以在声明变量时直接作为声明的一部分，可参考以下两段示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying mediump vec3 Color;</span><br><span class=\"line\"><span class=\"comment\">// 使已存在的 color 变量不可变</span></span><br><span class=\"line\">invariant Color;</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invariant varying mediump vec3 Color;</span><br></pre></td></tr></table></figure>\n<p>以上是仅有的使用 invariant 限定符情境。如果在声明时使用 invariant 限定符，则必须保证其放在存储限定符（varying）之前。<br>只有以下变量可以声明为 invariant：</p>\n<ul>\n<li>由顶点着色器输出的内置的特殊变量</li>\n<li>由顶点着色器输出的 varying 变量</li>\n<li>向片段着色器输入的内置的特殊变量</li>\n<li>向片段着色器输入的 varying 变量</li>\n<li>由片段着色器输出的内置的特殊变量</li>\n</ul>\n<p>为保证由两个着色器输出的特定变量的不变性，必须遵循以下几点：</p>\n<ul>\n<li>该输出变量在两个着色器中都被声明为 invariant</li>\n<li>影响输出变量的所有表达式、流程控制语句的输入值必须相同</li>\n<li>对于影响输出值的所有纹理函数，纹理格式、纹理元素值和纹理过滤必须一致</li>\n<li>对输入值的所有操作都必须一致。表达式及插值计算的所有操作必须一致，相同的运算数顺序，相同的结合性，并且按相同顺序计算。插值变量和插值函数的声明，必须有相同类型，相同的显式或隐式的精度precision限定符。影响输出值的所有控制流程必须相同，影响决定控制流程的表达式也必须遵循不变性的规则。</li>\n</ul>\n<p>最基本的一点是：所有的 invariant 输出量的上游数据流或控制流必须一致。</p>\n<p>初始的默认状态下，所有的输出变量不具备不变性，可以在所有的声明之前使用以下 <code>pragma</code> 语句强制所有输出变量 invariant：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> STDGL invariant(all)</span></span><br></pre></td></tr></table></figure>\n<p>输出变量的不变性通常会以优化过程的灵活性为代价，所以使用 invariant 会牺牲整体性能。因此慎用以上的全局设置方法，可以将其用作协助 Debug 的一种方法。<br>另一点需要说明的是，这里的不变性指的是对于同一 GPU 的不变性，并不保证不同 OpenGL ES 实现之间的不变性。</p>\n<h4 id=\"参数限定符\">参数限定符</h4><p>GLSL 提供了一种特殊的限定符用来定义某个变量的值是否可以被函数修改，详见下表：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>in</td>\n<td>默认使用的缺省限定符，指明参数传递的是值，并且函数不会修改传入的值（C 语言中值传递）</td>\n</tr>\n<tr>\n<td>inout</td>\n<td>指明参数传入的是引用，如果在函数中对参数的值进行了修改，当函数结束后参数的值也会修改（C 语言中引用传递）</td>\n</tr>\n<tr>\n<td>out</td>\n<td>参数的值不会传入函数，但是在函数内部修改其值，函数结束后其值会被修改</td>\n</tr>\n</tbody>\n</table>\n<p>使用的方式如下边的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">myFunc</span><span class=\"params\">(inout <span class=\"keyword\">float</span> myFloat, <span class=\"comment\">// inout parameter</span></span><br><span class=\"line\">            out vec4 myVec4, \t <span class=\"comment\">// out parameter</span></span><br><span class=\"line\">            mat4 myMat4)</span></span>; \t\t <span class=\"comment\">// in parameter (default)</span></span><br></pre></td></tr></table></figure>\n<p>以下是一个示例函数，函数定义用来计算基础的漫反射光照：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">diffuse</span><span class=\"params\">(vec3 normal, vec3 light, vec4 baseColor)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\">baseColor * <span class=\"title\">dot</span><span class=\"params\">(normal, light)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"精度限定符\">精度限定符</h4><p>OpenGL ES 与 OpenGL 之间的一个区别就是在 GLSL 中引入了精度限定符。精度限定符可使着色器的编写者明确定义着色器变量计算时使用的精度，变量可以选择被声明为低、中或高精度。精度限定符可告知编译器使其在计算时缩小变量潜在的精度变化范围，当使用低精度时，OpenGL ES 的实现可以更快速和低功耗地运行着色器，效率的提高来自于精度的舍弃，如果精度选择不合理，着色器运行的结果会很失真。</p>\n<p>OpenGL ES 对各硬件并未强制要求多种精度的支持。其实现可以使用高精度完成所有的计算并且忽略掉精度限定符，然而某些情况下使用低精度的实现会更有优势，精度限定符可以指定整型或浮点型变量的精度，如 <code>lowp</code>，<code>mediump</code>，及 <code>highp</code>，如下：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>highp</td>\n<td>满足顶点着色语言的最低要求。对片段着色语言是可选项</td>\n</tr>\n<tr>\n<td>mediump</td>\n<td>满足片段着色语言的最低要求，其对于范围和精度的要求必须不低于lowp并且不高于highp</td>\n</tr>\n<tr>\n<td>lowp</td>\n<td>范围和精度可低于mediump，但仍可以表示所有颜色通道的所有颜色值</td>\n</tr>\n</tbody>\n</table>\n<p>具体用法参考以下示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">highp vec4 position;</span><br><span class=\"line\">varying lowp vec4 color;</span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> specularExp;</span><br></pre></td></tr></table></figure>\n<p>除了精度限定符，还可以指定默认使用的精度。如果某个变量没有使用精度限定符指定使用何种精度，则会使用该变量类型的默认精度。默认精度限定符放在着色器代码起始位置，以下是一些用例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\">precision mediump <span class=\"keyword\">int</span>;</span><br></pre></td></tr></table></figure>\n<p>当为 <code>float</code> 指定默认精度时，所有基于浮点型的变量都会以此作为默认精度，与此类似，为 <code>int</code> 指定默认精度时，所有的基于整型的变量都会以此作为默认精度。在顶点着色器中，如果没有指定默认精度，则 <code>int</code> 和 <code>float</code> 都使用 <code>highp</code>，即顶点着色器中，未使用精度限定符指明精度的变量都默认使用最高精度。在片段着色器中，<code>float</code> 并没有默认的精度设置，即片段着色器中必须为 <code>float</code> 默认精度或者为每一个 <code>float</code> 变量指明精度。OpenGL ES 2.0 并未要求其实现在片段着色器中支持高精度，可用是否定义了宏 <code>GL_FRAGMENT_PRECISION_HIGH</code> 来判断是否支持在片段着色器中使用高精度。</p>\n<p>在片段着色器中可以使用以下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_FRAGMENT_PRECISION_HIGH</span></span><br><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>这么做可以确保无论实现支持中精度还是高精度都可以完成着色器的编译。注意不同实现中精度的定义及精度的范围都不统一，而是因实现而异的。</p>\n<p>精度修饰符声明了底层实现存储这些变量时，必须要使用的最小范围和精度。实现可能会使用比要求更大的范围和精度，但绝对不会比要求少。以下是精度修饰符要求的最低范围和精度：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>浮点数范围</th>\n<th>浮点数大小范围</th>\n<th>浮点数精度范围</th>\n<th>整数范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>highp</td>\n<td>(-2^62 , 2^62)</td>\n<td>(2^-62 ,2^62)</td>\n<td>相对：2^-16</td>\n<td>(-2^16 , 2^16)</td>\n</tr>\n<tr>\n<td>mediump</td>\n<td>(-2^14 , 2^14)</td>\n<td>(2^-14 ,2^14)</td>\n<td>相对：2^-10</td>\n<td>(-2^10 , 2^10)</td>\n</tr>\n<tr>\n<td>lowp</td>\n<td>(-2, 2)</td>\n<td>(2^-8 ,2)</td>\n<td>绝对：2^-8</td>\n<td>(-2^8 , 2^8)</td>\n</tr>\n</tbody>\n</table>\n<p>在具体实现中，着色器编译器支持的不同着色器类型和数值形式的实际的范围及精度可用以下函数获取：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetShaderPrecisionFormat</span><span class=\"params\">( <span class=\"keyword\">enum</span> shadertype, <span class=\"keyword\">enum</span> precisiontype, <span class=\"keyword\">int</span> *range, <span class=\"keyword\">int</span> *precision )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其中， <code>shadertype</code> 必须是 <code>VERTEX_SHADER</code> 或 <code>FRAGMENT_SHADER</code>；<code>precisiontype</code> 必须是 <code>LOW_FLOAT</code>、<code>MEDIUM_FLOAT</code>、<code>HIGH_FLOAT</code>、<code>LOW_INT</code>、<code>MEDIUM_INT</code> 或 <code>HIGH_INT</code>。</p>\n<p><code>range</code> 是指向含有两个整数的数组的指针，这两个整数将会返回数值的范围。如果用 <code>min</code> 和 <code>max</code> 来代表对应格式的最小和最大值，则 <code>range</code> 中返回的整数值可以定义为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">range[<span class=\"number\">0</span>] = log2(|min|)</span><br><span class=\"line\">range[<span class=\"number\">1</span>] = log2(|max|)</span><br></pre></td></tr></table></figure>\n<p><code>precision</code> 是指向一个整数的指针，返回的该整数是对应格式的精度的位数（number of bits）用 <code>log2</code> 取对数的值。</p>\n<p><strong>Q：如何确定精度:</strong></p>\n<p><strong>A：</strong>变量的精度首先是由精度限定符决定的，如果没有精度限定符，则要寻找其右侧表达式中，已经确定精度的变量，一旦找到，那么整个表达式都将在该精度下运行。</p>\n<p>如果找到多个，则选择精度较高的那种，如果一个都找不到，则使用默认或更大的精度类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform highp <span class=\"keyword\">float</span> h1;</span><br><span class=\"line\">highp <span class=\"keyword\">float</span> h2 = <span class=\"number\">2.3</span> * <span class=\"number\">4.7</span>; <span class=\"comment\">// 运算过程和结果都是 highp</span></span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> m;</span><br><span class=\"line\">m = <span class=\"number\">3.7</span> * h1 * h2; \t\t\t<span class=\"comment\">// 运算过程是 highp</span></span><br><span class=\"line\">h2 = m * h1; \t\t\t\t<span class=\"comment\">// 运算过程是 highp</span></span><br><span class=\"line\">m = h2 – h1; \t\t\t\t<span class=\"comment\">// 运算过程是 highp</span></span><br><span class=\"line\">h2 = m + m; \t\t\t\t<span class=\"comment\">// 运算过程和结果都是 mediump</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(highp <span class=\"keyword\">float</span> p)</span></span>; \t\t<span class=\"comment\">// 形参 p 是 highp</span></span><br><span class=\"line\">f(<span class=\"number\">3.3</span>);\t\t\t\t\t    <span class=\"comment\">// 传入的 3.3 是 highp</span></span><br></pre></td></tr></table></figure>\n<p><strong>Q：限定符的顺序</strong></p>\n<p><strong>A：</strong>当需要用到多个限定符的时候要遵循以下顺序: </p>\n<ul>\n<li>在一般变量中：invariant &gt; storage &gt; precision （storage：存储，precision：精度）</li>\n<li>在函数参数中：storage &gt; parameter &gt; precision （parameter：参数）</li>\n</ul>\n<p>我们来举例说明:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invariant varying lowp <span class=\"keyword\">float</span> color; <span class=\"comment\">// invariant &gt; storage &gt; precision</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleSize</span><span class=\"params\">(<span class=\"keyword\">const</span> in lowp <span class=\"keyword\">float</span> s)</span></span>&#123; <span class=\"comment\">//storage &gt; parameter &gt; precision</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> s1=s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"<p>上节在绘制三角形的时候，简单讲解了一些着色器，GLSL 的相关概念，可能看的云里雾里的。不要担心，在本节中，我将详细讲解着色语言 GL Shader Language（GLSL）的一些基本的概念。</p>\n<blockquote>\n<p>PS：<br>无特殊说明，文中的 GLSL 均指 OpenGL ES 2.0 的着色语言。</p>\n</blockquote>","more":"<h2 id=\"概览\">概览</h2><p>OpenGL ES 的渲染管线包含有一个可编程的顶点阶段的一个可编程的片段阶段。其余的阶段则有固定的功能，应用程序对其行为的控制非常有限。每个可编程阶段中编译单元的集合组成了一个着色器。在OpenGL ES 2.0 中，每个着色器只支持一个编译单元。着色程序则是一整套编译好并链接在一起的着色器的集合。着色器 shader 的编写需要使用着色语言 GL Shader Language（GLSL），GLSL 的语法与 C 语言很类似。</p>\n<p>在上一节中，我们看到了一个非常简单的着色器，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点着色器 .vsh</span></span><br><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 片段着色器 .fsh</span></span><br><span class=\"line\">varying lowp vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    gl_FragColor = colorVarying;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>习惯上，我们一般把顶点着色器命名为 <strong>xx.vsh</strong>，片段着色器命名为 <strong>xx.fsh</strong>。当然，你喜欢怎么样就怎么样~</p>\n<p>和 C 语言程序对应，用 GLSL 写出的着色器，它同样包括：</p>\n<ul>\n<li>变量 position</li>\n<li>变量类型 vec4</li>\n<li>限定符 attribute</li>\n<li>main 函数</li>\n<li>基本赋值语句 colorVarying = color</li>\n<li>内置变量 gl_Position</li>\n<li>…</li>\n</ul>\n<p>这一切，都是那么像…所以，<strong>在掌握 C 语言的基础上，GLSL 的学习成本是很低的</strong>。</p>\n<p>学习一门语言，我们无非是从<strong>变量类型，结构体，数组，语句，函数，限定符等</strong>方面展开。下面，我们就照着这个顺序，学习 GLSL。</p>\n<h2 id=\"使用_GLSL_构建着色器\">使用 GLSL 构建着色器</h2><h3 id=\"1-_变量\">1. 变量</h3><h4 id=\"变量及变量类型\">变量及变量类型</h4><table>\n<thead>\n<tr>\n<th>变量类别</th>\n<th>变量类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空</td>\n<td>void</td>\n<td>用于无返回值的函数或空的参数列表</td>\n</tr>\n<tr>\n<td>标量</td>\n<td>float, int, bool</td>\n<td>浮点型，整型，布尔型的标量数据类型</td>\n</tr>\n<tr>\n<td>浮点型向量</td>\n<td>float, vec2, vec3, vec4</td>\n<td>包含1，2，3，4个元素的浮点型向量</td>\n</tr>\n<tr>\n<td>整数型向量</td>\n<td>int, ivec2, ivec3, ivec4</td>\n<td>包含1，2，3，4个元素的整型向量</td>\n</tr>\n<tr>\n<td>布尔型向量</td>\n<td>bool, bvec2, bvec3, bvec4</td>\n<td>包含1，2，3，4个元素的布尔型向量</td>\n</tr>\n<tr>\n<td>矩阵</td>\n<td>mat2, mat3, mat4</td>\n<td>尺寸为2x2，3x3，4x4的浮点型矩阵</td>\n</tr>\n<tr>\n<td>纹理句柄</td>\n<td>sampler2D, samplerCube</td>\n<td>表示2D，立方体纹理的句柄</td>\n</tr>\n</tbody>\n</table>\n<p>除上述之外，着色器中还可以将它们构成数组或结构体，以实现更复杂的数据类型。</p>\n<blockquote>\n<p>PS：</p>\n<p>GLSL 中没有指针类型。</p>\n</blockquote>\n<h4 id=\"变量构造器和类型转换\">变量构造器和类型转换</h4><p>对于变量运算，GLSL 中有非常严格的规则，即<strong>只有类型一致时，变量才能完成赋值或其它对应的操作。</strong>可以通过对应的构造器来实现类型转换。</p>\n<h5 id=\"标量\">标量</h5><p>标量对应 C 语言的基础数据类型，它的构造和 C 语言一致，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> myFloat = <span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> myBool = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myFloat = <span class=\"keyword\">float</span>(myBool); \t<span class=\"comment\">// bool -&gt; float</span></span><br><span class=\"line\">myBool = <span class=\"keyword\">bool</span>(myFloat);     <span class=\"comment\">// float -&gt; bool</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"向量\">向量</h5><p>当构造向量时，向量构造器中的各参数将会被转换成相同的类型（浮点型、整型或布尔型）。往向量构造器中传递参数有两种形式：</p>\n<ul>\n<li>如果向量构造器中只提供了一个标量参数，则向量中所有值都会设定为该标量值。</li>\n<li>如果提供了多个标量值或提供了向量参数，则会从左至右使用提供的参数来给向量赋值，如果使用多个标量来赋值，则需要确保标量的个数要多于向量构造器中的个数。</li>\n</ul>\n<p>向量构造器用法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 myVec4 = vec4(<span class=\"number\">1.0</span>); \t\t\t<span class=\"comment\">// myVec4 = &#123;1.0, 1.0, 1.0, 1.0&#125;</span></span><br><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>);  <span class=\"comment\">// myVec3 = &#123;1.0, 0.0, 0.5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">vec3 temp = vec3(myVec3); \t\t\t<span class=\"comment\">// temp = myVec3</span></span><br><span class=\"line\">vec2 myVec2 = vec2(myVec3);         <span class=\"comment\">// myVec2 = &#123;myVec3.x, myVec3.y&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">myVec4 = vec4(myVec2, temp, <span class=\"number\">0.0</span>);   <span class=\"comment\">// myVec4 = &#123;myVec2.x, myVec2.y , temp, 0.0 &#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"矩阵\">矩阵</h5><p>矩阵的构造方法则更加灵活，有以下规则：</p>\n<ul>\n<li>如果对矩阵构造器只提供了一个标量参数，该值会作为矩阵的对角线上的值。例如 <code>mat4(1.0)</code> 可以构造一个 4 × 4 的单位矩阵</li>\n<li>矩阵可以通过多个向量作为参数来构造，例如一个 mat2 可以通过两个 vec2 来构造</li>\n<li>矩阵可以通过多个标量作为参数来构造，矩阵中每个值对应一个标量，按照从左到右的顺序</li>\n</ul>\n<p>除此之外，矩阵的构造方法还可以更灵活，只要有足够的组件来初始化矩阵，其构造器参数可以是标量和向量的组合。在 OpenGL ES 中，矩阵的值会以<strong>列</strong>的顺序来存储。在构造矩阵时，构造器参数会按照列的顺序来填充矩阵，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat3 myMat3 = mat3(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,  <span class=\"comment\">// 第一列</span></span><br><span class=\"line\">                   <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,  <span class=\"comment\">// 第二列</span></span><br><span class=\"line\">                   <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>); <span class=\"comment\">// 第三列</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"\b向量和矩阵的分量\">\b向量和矩阵的分量</h4><p>单独获得向量中的组件有两种方法：即使用 <code>&quot;.&quot;</code> 符号或使用数组下标方法。依据构成向量的组件个数，向量的组件可以通过 <code>{x, y, z, w}</code> ， <code>{r, g, b, a}</code> 或 <code>{s, t, r, q}</code> 等 swizzle 操作来获取。之所以采用这三种不同的命名方法，是因为向量常常会用来表示数学向量、颜色、纹理坐标等。其中的<code>x</code>、<code>r</code>、<code>s</code> 组件总是表示向量中的第一个元素，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>分量访问符</th>\n<th>符号描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(x,y,z,w)</td>\n<td>与位置相关的分量</td>\n</tr>\n<tr>\n<td>(r,g,b,a)</td>\n<td>与颜色相关的分量</td>\n</tr>\n<tr>\n<td>(s,t,p,q)</td>\n<td>与纹理坐标相关的分量</td>\n</tr>\n</tbody>\n</table>\n<p>不同的命名约定是为了方便使用，所以哪怕是描述位置的向量，也是可以通过 <code>{r, g, b, a}</code>  来获取。但是在使用向量时不能混用不同的命名约定，即不能使用 <code>.xgr</code> 这样的方式，每次只能使用同一种命名约定。当使用 <code>&quot;.&quot;</code> 操作符时，还可以对向量中的元素重新排序，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>); <span class=\"comment\">// myVec3 = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class=\"line\">vec3 temp;</span><br><span class=\"line\">temp = myVec3.xyz; <span class=\"comment\">// temp = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class=\"line\">temp = myVec3.xxx; <span class=\"comment\">// temp = &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class=\"line\">temp = myVec3.zyx; <span class=\"comment\">// temp = &#123;2.0, 1.0, 0.0&#125;</span></span><br></pre></td></tr></table></figure>\n<p>除了使用 <code>&quot;.&quot;</code> 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 <code>[0]</code> 对应的是 <code>x</code>，元素 <code>[1]</code> 对应 <code>y</code>，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。</p>\n<p>矩阵可以认为是向量的组合。例如一个 mat2 可以认为是两个 vec2，一个 mat3 可以认为是三个 vec3 等等。对于矩阵来说，可以通过数组下标 <code>“[]”</code> 来获取某一列的值，然后获取到的向量又可以继续使用向量的操作方法，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat4 myMat4 = mat4(<span class=\"number\">1.0</span>); \t<span class=\"comment\">// Initialize diagonal to 1.0 (identity)</span></span><br><span class=\"line\">vec4 col0 = myMat4[<span class=\"number\">0</span>];\t    <span class=\"comment\">// Get col0 vector out of the matrix </span></span><br><span class=\"line\"><span class=\"keyword\">float</span> m1_1 = myMat4[<span class=\"number\">1</span>][<span class=\"number\">1</span>];  <span class=\"comment\">// Get element at [1][1] in matrix </span></span><br><span class=\"line\"><span class=\"keyword\">float</span> m2_2 = myMat4[<span class=\"number\">2</span>].z;   <span class=\"comment\">// Get element at [2][2] in matrix</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"向量和矩阵的操作\">向量和矩阵的操作</h4><p>绝大多数情况下，向量和矩阵的计算是逐分量进行的（component-wise）。当运算符作用于向量或矩阵时，该运算独立地作用于向量或矩阵的每个分量。<br>以下是一些示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 v, u;</span><br><span class=\"line\"><span class=\"keyword\">float</span> f;</span><br><span class=\"line\">v = u + f;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v.x = u.x + f;</span><br><span class=\"line\">v.y = u.y + f;</span><br><span class=\"line\">v.z = u.z + f;</span><br></pre></td></tr></table></figure>\n<p>再如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 v, u, w;</span><br><span class=\"line\">w = v + u;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w.x = v.x + u.x;</span><br><span class=\"line\">w.y = v.y + u.y;</span><br><span class=\"line\">w.z = v.z + u.z;</span><br></pre></td></tr></table></figure>\n<p>对于整型和浮点型的向量和矩阵，绝大多数的计算都同上，但是对于向量乘以矩阵、矩阵乘以向量、矩阵乘以矩阵则是不同的计算规则。这三种计算使用线性代数的乘法规则，并且要求参与计算的运算数值有相匹配的尺寸或阶数。<br>例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 v, u;</span><br><span class=\"line\">mat3 m;</span><br><span class=\"line\">u = v * m;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u.x = dot(v, m[<span class=\"number\">0</span>]); <span class=\"comment\">// m[0] is the left column of m</span></span><br><span class=\"line\">u.y = dot(v, m[<span class=\"number\">1</span>]); <span class=\"comment\">// dot(a,b) is the inner (dot) product of a and b</span></span><br><span class=\"line\">u.z = dot(v, m[<span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure>\n<p>再如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u = m * v;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u.x = m[<span class=\"number\">0</span>].x * v.x + m[<span class=\"number\">1</span>].x * v.y + m[<span class=\"number\">2</span>].x * v.z;</span><br><span class=\"line\">u.y = m[<span class=\"number\">0</span>].y * v.x + m[<span class=\"number\">1</span>].y * v.y + m[<span class=\"number\">2</span>].y * v.z;</span><br><span class=\"line\">u.z = m[<span class=\"number\">0</span>].z * v.x + m[<span class=\"number\">1</span>].z * v.y + m[<span class=\"number\">2</span>].z * v.z;</span><br></pre></td></tr></table></figure>\n<p>再如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat m, n, r;</span><br><span class=\"line\">r = m * n;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r[<span class=\"number\">0</span>].x = m[<span class=\"number\">0</span>].x * n[<span class=\"number\">0</span>].x + m[<span class=\"number\">1</span>].x * n[<span class=\"number\">0</span>].y + m[<span class=\"number\">2</span>].x * n[<span class=\"number\">0</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">1</span>].x = m[<span class=\"number\">0</span>].x * n[<span class=\"number\">1</span>].x + m[<span class=\"number\">1</span>].x * n[<span class=\"number\">1</span>].y + m[<span class=\"number\">2</span>].x * n[<span class=\"number\">1</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">2</span>].x = m[<span class=\"number\">0</span>].x * n[<span class=\"number\">2</span>].x + m[<span class=\"number\">1</span>].x * n[<span class=\"number\">2</span>].y + m[<span class=\"number\">2</span>].x * n[<span class=\"number\">2</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">0</span>].y = m[<span class=\"number\">0</span>].y * n[<span class=\"number\">0</span>].x + m[<span class=\"number\">1</span>].y * n[<span class=\"number\">0</span>].y + m[<span class=\"number\">2</span>].y * n[<span class=\"number\">0</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">1</span>].y = m[<span class=\"number\">0</span>].y * n[<span class=\"number\">1</span>].x + m[<span class=\"number\">1</span>].y * n[<span class=\"number\">1</span>].y + m[<span class=\"number\">2</span>].y * n[<span class=\"number\">1</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">2</span>].y = m[<span class=\"number\">0</span>].y * n[<span class=\"number\">2</span>].x + m[<span class=\"number\">1</span>].y * n[<span class=\"number\">2</span>].y + m[<span class=\"number\">2</span>].y * n[<span class=\"number\">2</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">0</span>].z = m[<span class=\"number\">0</span>].z * n[<span class=\"number\">0</span>].x + m[<span class=\"number\">1</span>].z * n[<span class=\"number\">0</span>].y + m[<span class=\"number\">2</span>].z * n[<span class=\"number\">0</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">1</span>].z = m[<span class=\"number\">0</span>].z * n[<span class=\"number\">1</span>].x + m[<span class=\"number\">1</span>].z * n[<span class=\"number\">1</span>].y + m[<span class=\"number\">2</span>].z * n[<span class=\"number\">1</span>].z;</span><br><span class=\"line\">r[<span class=\"number\">2</span>].z = m[<span class=\"number\">0</span>].z * n[<span class=\"number\">2</span>].x + m[<span class=\"number\">1</span>].z * n[<span class=\"number\">2</span>].y + m[<span class=\"number\">2</span>].z * n[<span class=\"number\">2</span>].z;</span><br></pre></td></tr></table></figure>\n<p>对于2阶和4阶的向量或矩阵也是相似的规则。</p>\n<h3 id=\"2-_结构体\">2. 结构体</h3><p>与 C 语言相似，除了基本的数据类型之外，还可以将多个变量聚合到一个结构体中，下边的示例代码演示了在GLSL中如何声明结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> customStruct</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvec4 color;</span><br><span class=\"line\">\tvec2 position;</span><br><span class=\"line\">&#125; customVertex;</span><br></pre></td></tr></table></figure>\n<p>首先，定义会产生一个新的类型叫做 <code>customStruct</code> ，及一个名为 <code>customVertex</code> 的变量。结构体可以用构造器来初始化，在定义了新的结构体之后，还会定义一个与结构体类型名称相同的构造器。构造器与结构体中的数据类型必须一一对应，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customVertex = customStruct(vec4(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>), <span class=\"comment\">// color</span></span><br><span class=\"line\">\t\t\t\t\t\t\tvec2(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>)); \t\t  <span class=\"comment\">// position</span></span><br></pre></td></tr></table></figure>\n<p>结构体的构造器是基于类型的名称，以参数的形式来赋值。获取结构体内元素的方法和C语言中一致：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 color = customVertex.color;</span><br><span class=\"line\">vec4 position = customVertex.position;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-_数组\">3. 数组</h3><p>除了结构体外，GLSL 中还支持数组。 语法与 C 语言相似，创建数组的方式如下代码所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> floatArray[<span class=\"number\">4</span>];</span><br><span class=\"line\">vec4 vecArray[<span class=\"number\">2</span>];</span><br></pre></td></tr></table></figure>\n<p>与C语言不同，在GLSL中，关于数组有两点需要注意：</p>\n<ul>\n<li>除了 uniform 变量之外，数组的索引只允许使用常数整型表达式。</li>\n<li>在 GLSL 中不能在创建的同时给数组初始化，即数组中的元素需要在定义数组之后逐个初始化，且数组不能使用 const 限定符。</li>\n</ul>\n<h3 id=\"4-_语句\">4. 语句</h3><h4 id=\"运算符\">运算符</h4><p>下表展示了 GLSL 中支持的运算符：</p>\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>运算符类别</th>\n<th>运算符</th>\n<th>结合方向</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 (最高)</td>\n<td>成组操作</td>\n<td>()</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td></td>\n<td>数组下标，函数调用与构造函数，访问分量或结构体的字段，后置自增和自减</td>\n<td>[] () . ++ –</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>3</td>\n<td>前置自增和自减，一元正/负数，一元逻辑非</td>\n<td>++ – + - !</td>\n<td>从右向左</td>\n</tr>\n<tr>\n<td>4</td>\n<td>乘法，除法</td>\n<td>* /</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>5</td>\n<td>加法，减法</td>\n<td>+ -</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>6</td>\n<td>关系比较操作</td>\n<td>&lt; &gt; &lt;= &gt;=</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>7</td>\n<td>相等操作</td>\n<td>== !=</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>8</td>\n<td>逻辑与</td>\n<td>&amp;&amp;</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>9</td>\n<td>逻辑异或</td>\n<td>^^</td>\n<td>从左向右</td>\n</tr>\n<tr>\n<td>10</td>\n<td>逻辑或</td>\n<td>\\ \\</td>\n<td>\\</td>\n<td></td>\n<td>\\ 从左向右</td>\n</tr>\n<tr>\n<td>11</td>\n<td>三元选择操作（问号表达式）</td>\n<td>?:</td>\n<td>从右向左</td>\n</tr>\n<tr>\n<td>12</td>\n<td>赋值与算数赋值</td>\n<td>= += -= *= /=</td>\n<td>从右向左</td>\n</tr>\n<tr>\n<td>13(最低)</td>\n<td>操作符序列</td>\n<td>,</td>\n<td>从左向右</td>\n</tr>\n</tbody>\n</table>\n<p>绝大多数的运算符与 C 语言中一致。与 C 语言不同的是：GLSL 中对于参与运算的数据类型要求比较严格，即运算符两侧的变量必须有相同的数据类型。对于二目运算符（*，/，+，-），操作数必须为浮点型或整型，除此之外，乘法操作可以放在不同的数据类型之间如浮点型、向量和矩阵等。</p>\n<p><strong>前面矩阵的行数就是结果矩阵的行数，后面矩阵的列数就是结果矩阵的列数。</strong></p>\n<p>比较运算符仅能作用于标量，对于向量的比较，GLSL 中有内置的函数，稍后会介绍。</p>\n<h4 id=\"流程控制语句\">流程控制语句</h4><p>流程控制语句与 C 语言非常相似，以下示例代码是 <code>if-else</code> 的使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (color.a &lt; <span class=\"number\">0.25</span>) &#123;</span><br><span class=\"line\">\tcolor *= color.a;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tcolor = vec4(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>判断的内容必须是布尔值或布尔表达式，除了基本的 <code>if-else</code> 语句，还可以使用 <code>for</code> 循环，在使用 <code>for</code> 循环时也有一些约束，如<strong>循环变量的值必须是编译时已知</strong>。\b如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">\tsum += i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 GLSL 中使用循环时一定要注意：只有一个循环变量，循环变量必须使用简单的语句来增减（如 i++, i–, i+=constant, i-=constant等），循环终止条件也必须是循环变量和常量的简单比较，在循环内部不能改变循环变量的值。</p>\n<p>以下代码是 GLSL 中不支持的循环用法的示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> myArr[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 错误, [ ]中只能为常量或 uniform 变量，不能为整数量变量（如：i，j，k）</span></span><br><span class=\"line\">\tsum += myArr[i]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">uniform <span class=\"keyword\">int</span> loopIter;</span><br><span class=\"line\"><span class=\"comment\">// 错误, 循环变量 loopIter 的值必须是编译时已知</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; loopIter; i++) &#123;</span><br><span class=\"line\">\tsum += i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-_函数\">5. 函数</h3><p>GLSL 函数的声明与 C 语言中很相似，无非就是返回值，函数名，参数列表。</p>\n<p>GLSL 着色器同样是从 main 函数开始执行。另外， GLSL 也支持自定义函数。当然，如果一个函数在定以前被调用，则需要先声明其原型。</p>\n<p>值得注意的一点是，GLSL 中函数不能够递归调用，且必须声明返回值类型（无返回值时声明为void）。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">getPosition</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">    vec4 v4 = vec4(<span class=\"number\">0.</span>,<span class=\"number\">0.</span>,<span class=\"number\">0.</span>,<span class=\"number\">1.</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleSize</span><span class=\"params\">(inout <span class=\"keyword\">float</span> size)</span></span>&#123;</span><br><span class=\"line\">    size= size*<span class=\"number\">2.0</span>  ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> psize= <span class=\"number\">10.0</span>;</span><br><span class=\"line\">    doubleSize(psize);</span><br><span class=\"line\">    gl_Position = getPosition();</span><br><span class=\"line\">    gl_PointSize = psize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-_限定符\">6. 限定符</h3><h4 id=\"存储限定符\">存储限定符</h4><p>在声明变量时，应根据需要使用存储限定符来修饰，类似 C 语言中的说明符。GLSL 中支持的存储限定符见下表：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt; none: default &gt;</td>\n<td>局部可读写变量，或者函数的参数</td>\n</tr>\n<tr>\n<td>const</td>\n<td>编译时常量，或只读的函数参数</td>\n</tr>\n<tr>\n<td>attribute</td>\n<td>由应用程序传输给顶点着色器的逐顶点的数据</td>\n</tr>\n<tr>\n<td>uniform</td>\n<td>在图元处理过程中其值保持不变，由应用程序传输给着色器</td>\n</tr>\n<tr>\n<td>varying</td>\n<td>由顶点着色器传输给片段着色器中的插值数据</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>本地变量和函数参数只能使用 const 限定符，函数返回值和结构体成员不能使用限定符。</li>\n<li>数据不能从一个着色器程序传递给下一个阶段的着色器程序，这样会阻止同一个着色器程序在多个顶点或者片段中进行并行计算。</li>\n<li>不包含任何限定符或者包含 const 限定符的全局变量可以包含初始化器，这种情况下这些变量会在 main() 函数开始之后第一行代码之前被初始化，这些初始化值必须是常量表达式。</li>\n<li>没有任何限定符的全局变量如果没有在定义时初始化或者在程序中被初始化，则其值在进入 main() 函数之后是未定义的。</li>\n<li>uniform、attribute 和 varying 限定符修饰的变量不能在初始化时被赋值，这些变量的值由 OpenGL ES 计算提供。</li>\n</ul>\n<h5 id=\"默认限定符\">默认限定符</h5><p>如果一个全局变量没有指定限定符，则该变量与应用程序或者其他正在运行的处理单元没有任何联系。不管是全局变量还是本地变量，它们总是在自己的处理单元被分配内存，因此可以对它们执行读和写操作。</p>\n<h5 id=\"const_限定符\">const 限定符</h5><p>任意基础类型的变量都可以声明为常量。常量表示这些变量中的值在着色器中不会发生变化，声明常量只需要在声明时加上限定符 const 即可，声明时必须赋初值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> zero = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> pi = <span class=\"number\">3.14159</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vec4 red = vec4(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mat4 identity = mat4(<span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常量声明过的值在代码中不能再改变，这一点和 C 语言或 C++ 一样。</li>\n<li>结构体成员不能被声明为常量，但是结构体变量可以被声明为常量，并且需要在初始化时使用构造器初始化其值。</li>\n<li>常量必须被初始化为一个常量表达式。数组或者包含数组的结构体不能被声明为常量（因为数组不能在定义时被初始化）。</li>\n</ul>\n<h5 id=\"attribute_限定符\">attribute 限定符</h5><p>GLSL 中另一种特殊的变量类型是 attribute 变量。attribute 变量只用于顶点着色器中，用来存储顶点着色器中每个顶点的输入（per-vertex inputs）。attribute 通常用来存储位置坐标、法向量、纹理坐标和颜色等。注意 attribute 是用来存储单个顶点的信息。如下是包含位置，色值 attribute 的顶点着色器示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点着色器 .vsh</span></span><br><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>着色器中的两个 attribute 变量 <code>position</code> 和 <code>color</code> 由应用程序加载数值。应用程序会创建一个顶点数组，其中包含了每个顶点的位置坐标和色值信息。可使用的最大 attribute 数量也是有上限的，可以使用  <code>gl_MaxVertexAttribs</code> 来获取，也可以使用内置函数 <code>glGetIntegerv</code> 来询问 <code>GL_MAX_VERTEX_ATTRIBS</code>。OpenGL ES 2.0 实现支持的最少 attribute 个数是8个。</p>\n<h5 id=\"uniform_限定符\">uniform 限定符</h5><p>uniform 是 GLSL 中的一种变量类型限定符，用于存储应用程序通过 GLSL 传递给着色器的只读值。uniform 可以用来存储着色器需要的各种数据，如变换矩阵、光参数和颜色等。传递给着色器的在所有的顶点着色器和片段着色器中保持不变的的任何参数，基本上都应该通过 uniform 来存储。uniform 变量在全局区声明，以下是 uniform 的一些示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 viewProjMatrix;</span><br><span class=\"line\">uniform mat4 viewMatrix;</span><br><span class=\"line\">uniform vec3 lightPosition;</span><br></pre></td></tr></table></figure>\n<p>需要注意的一点是，顶点着色器和片段着色器共享了 uniform 变量的命名空间。对于连接于同一个着色程序对象的顶点和片段着色器，它们共用同一组 uniform 变量，因此，如果在顶点着色器和片段着色器中都声明了 uniform 变量，二者的声明必须一致。当应用程序通过 API 加载了 uniform 变量时，该变量的值在顶点和片段着色器中都能够获取到。</p>\n<p>另一点需要注意的是，uniform 变量通常是存储在硬件中的”常量区”，这一区域是专门分配用来存储常量的，但是由于这一区域尺寸非常有限，因此着色程序中可以使用的 uniform 的个数也是有限的。可以通过读取内置变量 <code>gl_MaxVertexUniformVectors</code> 和 <code>gl_MaxFragmentUniformVectors</code> 来获得，也可以使用 <code>glGetIntegerv</code> 查询 <code>GL_MAX_VERTEX_UNIFORM_VECTORS</code> 或者 <code>GL_MAX_FRAGMENT_UNIFORM_VECTORS</code> 。OpenGL ES 2.0 的实现必须提供至少 128 个顶点 uniform 向量及 16 片段 uniform 向量。</p>\n<h5 id=\"varying_限定符\">varying 限定符</h5><p>GLSL 中最后一个要说的存储限定符是 varying。varying 存储的是顶点着色器的输出，同时作为片段着色器的输入，通常顶点着色器都会把需要传递给片段着色器的数据存储在一个或多个 varying 变量中。这些变量在片段着色器中需要有相对应的声明且数据类型一致，然后在光栅化过程中进行插值计算。以下是一些 varying 变量的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying vec2 texCoord;</span><br><span class=\"line\">varying vec4 color;</span><br></pre></td></tr></table></figure>\n<p>顶点着色器和片段着色器中都会有 varying 变量的声明，由于 varying 是顶点着色器的输出且是片段着色器的输入，所以两处声明必须一致。与 uniform 和 attribute 相同，varying 也有数量的限制，可以使用 <code>gl_MaxVaryingVectors</code> 获取或使用 <code>glGetIntegerv</code> 查询  <code>GL_MAX_VARYING_VECTORS</code> 来获取。OpenGL ES 2.0 实现中的 varying 变量最小支持数为 8。</p>\n<p>回顾下最初那个着色器对应的 varying 声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点着色器 .vsh</span></span><br><span class=\"line\">attribute vec4 position;</span><br><span class=\"line\">attribute vec4 color;</span><br><span class=\"line\"></span><br><span class=\"line\">varying vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    colorVarying = color;</span><br><span class=\"line\">    gl_Position = position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 片段着色器 .fsh</span></span><br><span class=\"line\">varying lowp vec4 colorVarying;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    gl_FragColor = colorVarying;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"invariant_限定符\">invariant 限定符</h4><p>invariant 可以作用于顶点着色器输出的任何一个 varying 变量。</p>\n<p>当着色器被编译时，编译器会对其进行优化，这种优化操作可能引起指令重排序（instruction reordering），指令重排序可能引起的结果是当两个着色器进行相同的计算时无法保证得到相同的结果。<br>例如，在两个顶点着色器中，变量 <code>gl_Position</code> 使用相同的表达式赋值，并且当着色程序运行时，在表达式中传入相等的变量值，则两个着色器中 <code>gl_Position</code> 的值无法保证相等，这是因为两个着色器是分别单独编译的。这将会引起 multi-pass 算法的几何不一致问题。<br>通常情况下，不同着色器之间的这种值的差异是允许存在的。如果要避免这种差异，则可以将变量声明为invariant，可以单独指定某个变量或进行全局设置。</p>\n<p>使用 invariant 限定符可以使输出的变量保持不变。invariant 限定符可以作用于之前已声明的变量使其具有不变性，也可以在声明变量时直接作为声明的一部分，可参考以下两段示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying mediump vec3 Color;</span><br><span class=\"line\"><span class=\"comment\">// 使已存在的 color 变量不可变</span></span><br><span class=\"line\">invariant Color;</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invariant varying mediump vec3 Color;</span><br></pre></td></tr></table></figure>\n<p>以上是仅有的使用 invariant 限定符情境。如果在声明时使用 invariant 限定符，则必须保证其放在存储限定符（varying）之前。<br>只有以下变量可以声明为 invariant：</p>\n<ul>\n<li>由顶点着色器输出的内置的特殊变量</li>\n<li>由顶点着色器输出的 varying 变量</li>\n<li>向片段着色器输入的内置的特殊变量</li>\n<li>向片段着色器输入的 varying 变量</li>\n<li>由片段着色器输出的内置的特殊变量</li>\n</ul>\n<p>为保证由两个着色器输出的特定变量的不变性，必须遵循以下几点：</p>\n<ul>\n<li>该输出变量在两个着色器中都被声明为 invariant</li>\n<li>影响输出变量的所有表达式、流程控制语句的输入值必须相同</li>\n<li>对于影响输出值的所有纹理函数，纹理格式、纹理元素值和纹理过滤必须一致</li>\n<li>对输入值的所有操作都必须一致。表达式及插值计算的所有操作必须一致，相同的运算数顺序，相同的结合性，并且按相同顺序计算。插值变量和插值函数的声明，必须有相同类型，相同的显式或隐式的精度precision限定符。影响输出值的所有控制流程必须相同，影响决定控制流程的表达式也必须遵循不变性的规则。</li>\n</ul>\n<p>最基本的一点是：所有的 invariant 输出量的上游数据流或控制流必须一致。</p>\n<p>初始的默认状态下，所有的输出变量不具备不变性，可以在所有的声明之前使用以下 <code>pragma</code> 语句强制所有输出变量 invariant：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> STDGL invariant(all)</span></span><br></pre></td></tr></table></figure>\n<p>输出变量的不变性通常会以优化过程的灵活性为代价，所以使用 invariant 会牺牲整体性能。因此慎用以上的全局设置方法，可以将其用作协助 Debug 的一种方法。<br>另一点需要说明的是，这里的不变性指的是对于同一 GPU 的不变性，并不保证不同 OpenGL ES 实现之间的不变性。</p>\n<h4 id=\"参数限定符\">参数限定符</h4><p>GLSL 提供了一种特殊的限定符用来定义某个变量的值是否可以被函数修改，详见下表：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>in</td>\n<td>默认使用的缺省限定符，指明参数传递的是值，并且函数不会修改传入的值（C 语言中值传递）</td>\n</tr>\n<tr>\n<td>inout</td>\n<td>指明参数传入的是引用，如果在函数中对参数的值进行了修改，当函数结束后参数的值也会修改（C 语言中引用传递）</td>\n</tr>\n<tr>\n<td>out</td>\n<td>参数的值不会传入函数，但是在函数内部修改其值，函数结束后其值会被修改</td>\n</tr>\n</tbody>\n</table>\n<p>使用的方式如下边的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">myFunc</span><span class=\"params\">(inout <span class=\"keyword\">float</span> myFloat, <span class=\"comment\">// inout parameter</span></span><br><span class=\"line\">            out vec4 myVec4, \t <span class=\"comment\">// out parameter</span></span><br><span class=\"line\">            mat4 myMat4)</span></span>; \t\t <span class=\"comment\">// in parameter (default)</span></span><br></pre></td></tr></table></figure>\n<p>以下是一个示例函数，函数定义用来计算基础的漫反射光照：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec4 <span class=\"title\">diffuse</span><span class=\"params\">(vec3 normal, vec3 light, vec4 baseColor)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\">baseColor * <span class=\"title\">dot</span><span class=\"params\">(normal, light)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"精度限定符\">精度限定符</h4><p>OpenGL ES 与 OpenGL 之间的一个区别就是在 GLSL 中引入了精度限定符。精度限定符可使着色器的编写者明确定义着色器变量计算时使用的精度，变量可以选择被声明为低、中或高精度。精度限定符可告知编译器使其在计算时缩小变量潜在的精度变化范围，当使用低精度时，OpenGL ES 的实现可以更快速和低功耗地运行着色器，效率的提高来自于精度的舍弃，如果精度选择不合理，着色器运行的结果会很失真。</p>\n<p>OpenGL ES 对各硬件并未强制要求多种精度的支持。其实现可以使用高精度完成所有的计算并且忽略掉精度限定符，然而某些情况下使用低精度的实现会更有优势，精度限定符可以指定整型或浮点型变量的精度，如 <code>lowp</code>，<code>mediump</code>，及 <code>highp</code>，如下：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>highp</td>\n<td>满足顶点着色语言的最低要求。对片段着色语言是可选项</td>\n</tr>\n<tr>\n<td>mediump</td>\n<td>满足片段着色语言的最低要求，其对于范围和精度的要求必须不低于lowp并且不高于highp</td>\n</tr>\n<tr>\n<td>lowp</td>\n<td>范围和精度可低于mediump，但仍可以表示所有颜色通道的所有颜色值</td>\n</tr>\n</tbody>\n</table>\n<p>具体用法参考以下示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">highp vec4 position;</span><br><span class=\"line\">varying lowp vec4 color;</span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> specularExp;</span><br></pre></td></tr></table></figure>\n<p>除了精度限定符，还可以指定默认使用的精度。如果某个变量没有使用精度限定符指定使用何种精度，则会使用该变量类型的默认精度。默认精度限定符放在着色器代码起始位置，以下是一些用例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\">precision mediump <span class=\"keyword\">int</span>;</span><br></pre></td></tr></table></figure>\n<p>当为 <code>float</code> 指定默认精度时，所有基于浮点型的变量都会以此作为默认精度，与此类似，为 <code>int</code> 指定默认精度时，所有的基于整型的变量都会以此作为默认精度。在顶点着色器中，如果没有指定默认精度，则 <code>int</code> 和 <code>float</code> 都使用 <code>highp</code>，即顶点着色器中，未使用精度限定符指明精度的变量都默认使用最高精度。在片段着色器中，<code>float</code> 并没有默认的精度设置，即片段着色器中必须为 <code>float</code> 默认精度或者为每一个 <code>float</code> 变量指明精度。OpenGL ES 2.0 并未要求其实现在片段着色器中支持高精度，可用是否定义了宏 <code>GL_FRAGMENT_PRECISION_HIGH</code> 来判断是否支持在片段着色器中使用高精度。</p>\n<p>在片段着色器中可以使用以下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_FRAGMENT_PRECISION_HIGH</span></span><br><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>这么做可以确保无论实现支持中精度还是高精度都可以完成着色器的编译。注意不同实现中精度的定义及精度的范围都不统一，而是因实现而异的。</p>\n<p>精度修饰符声明了底层实现存储这些变量时，必须要使用的最小范围和精度。实现可能会使用比要求更大的范围和精度，但绝对不会比要求少。以下是精度修饰符要求的最低范围和精度：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>浮点数范围</th>\n<th>浮点数大小范围</th>\n<th>浮点数精度范围</th>\n<th>整数范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>highp</td>\n<td>(-2^62 , 2^62)</td>\n<td>(2^-62 ,2^62)</td>\n<td>相对：2^-16</td>\n<td>(-2^16 , 2^16)</td>\n</tr>\n<tr>\n<td>mediump</td>\n<td>(-2^14 , 2^14)</td>\n<td>(2^-14 ,2^14)</td>\n<td>相对：2^-10</td>\n<td>(-2^10 , 2^10)</td>\n</tr>\n<tr>\n<td>lowp</td>\n<td>(-2, 2)</td>\n<td>(2^-8 ,2)</td>\n<td>绝对：2^-8</td>\n<td>(-2^8 , 2^8)</td>\n</tr>\n</tbody>\n</table>\n<p>在具体实现中，着色器编译器支持的不同着色器类型和数值形式的实际的范围及精度可用以下函数获取：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetShaderPrecisionFormat</span><span class=\"params\">( <span class=\"keyword\">enum</span> shadertype, <span class=\"keyword\">enum</span> precisiontype, <span class=\"keyword\">int</span> *range, <span class=\"keyword\">int</span> *precision )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其中， <code>shadertype</code> 必须是 <code>VERTEX_SHADER</code> 或 <code>FRAGMENT_SHADER</code>；<code>precisiontype</code> 必须是 <code>LOW_FLOAT</code>、<code>MEDIUM_FLOAT</code>、<code>HIGH_FLOAT</code>、<code>LOW_INT</code>、<code>MEDIUM_INT</code> 或 <code>HIGH_INT</code>。</p>\n<p><code>range</code> 是指向含有两个整数的数组的指针，这两个整数将会返回数值的范围。如果用 <code>min</code> 和 <code>max</code> 来代表对应格式的最小和最大值，则 <code>range</code> 中返回的整数值可以定义为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">range[<span class=\"number\">0</span>] = log2(|min|)</span><br><span class=\"line\">range[<span class=\"number\">1</span>] = log2(|max|)</span><br></pre></td></tr></table></figure>\n<p><code>precision</code> 是指向一个整数的指针，返回的该整数是对应格式的精度的位数（number of bits）用 <code>log2</code> 取对数的值。</p>\n<p><strong>Q：如何确定精度:</strong></p>\n<p><strong>A：</strong>变量的精度首先是由精度限定符决定的，如果没有精度限定符，则要寻找其右侧表达式中，已经确定精度的变量，一旦找到，那么整个表达式都将在该精度下运行。</p>\n<p>如果找到多个，则选择精度较高的那种，如果一个都找不到，则使用默认或更大的精度类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform highp <span class=\"keyword\">float</span> h1;</span><br><span class=\"line\">highp <span class=\"keyword\">float</span> h2 = <span class=\"number\">2.3</span> * <span class=\"number\">4.7</span>; <span class=\"comment\">// 运算过程和结果都是 highp</span></span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> m;</span><br><span class=\"line\">m = <span class=\"number\">3.7</span> * h1 * h2; \t\t\t<span class=\"comment\">// 运算过程是 highp</span></span><br><span class=\"line\">h2 = m * h1; \t\t\t\t<span class=\"comment\">// 运算过程是 highp</span></span><br><span class=\"line\">m = h2 – h1; \t\t\t\t<span class=\"comment\">// 运算过程是 highp</span></span><br><span class=\"line\">h2 = m + m; \t\t\t\t<span class=\"comment\">// 运算过程和结果都是 mediump</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(highp <span class=\"keyword\">float</span> p)</span></span>; \t\t<span class=\"comment\">// 形参 p 是 highp</span></span><br><span class=\"line\">f(<span class=\"number\">3.3</span>);\t\t\t\t\t    <span class=\"comment\">// 传入的 3.3 是 highp</span></span><br></pre></td></tr></table></figure>\n<p><strong>Q：限定符的顺序</strong></p>\n<p><strong>A：</strong>当需要用到多个限定符的时候要遵循以下顺序: </p>\n<ul>\n<li>在一般变量中：invariant &gt; storage &gt; precision （storage：存储，precision：精度）</li>\n<li>在函数参数中：storage &gt; parameter &gt; precision （parameter：参数）</li>\n</ul>\n<p>我们来举例说明:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invariant varying lowp <span class=\"keyword\">float</span> color; <span class=\"comment\">// invariant &gt; storage &gt; precision</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleSize</span><span class=\"params\">(<span class=\"keyword\">const</span> in lowp <span class=\"keyword\">float</span> s)</span></span>&#123; <span class=\"comment\">//storage &gt; parameter &gt; precision</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> s1=s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"代码备忘","title":"What's New in iOS 10.0 中文版(上)","date":"2016-06-14T09:20:52.000Z","_content":"\n> 由于原文篇幅较长，为了方便阅读，分为上下篇。\n>\n> 本文是 What's New in iOS 10.0 中文版的上篇，主要描述了iOS 10新引入的一些新特效，概括了重要的变化。\n>\n> 在What's New in iOS 10.0 中文版(下)中，将介绍一些已存在框架的改进以及一些弃用的 API。\n>\n> 原文链接：[What's New in iOS 10.0](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW1)\n\n这篇文章总结了运行在目前 iOS设备上的 iOS 10中与开发者有关的功能，这篇文章还列出了与这些功能相关的详细文档。\n\n<!--more-->\n\n关于目前已知问题的最新新闻和信息，可以查阅 [https://developer.apple.com/ios/download/](https://developer.apple.com/ios/download/) 。添加到 iOS 10中的 API 的完整列表，详见 *[iOS 10.0 API Diffs](https://developer.apple.com/library/prerelease/content/releasenotes/General/iOS10APIDiffs/index.html)*。有关新设备的更多信息，详见 *[iOS Device Compatibility Reference](https://developer.apple.com/library/prerelease/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599)*.\n\n更多关于 Swift,详见 [Swift Language](https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3) and *[The Swift Programming Language (Swift 3)](https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097)*.\n\n## SiriKit\n\nApps 在特定的领域提供服务，可以使用 SiriKit来在 iOS中通过 Siri使用这些服务。 想要提供这些服务，需要创建一个或多个使用这些意图和意图 UI frameworks的   App extensions(app extensions using the Intents and Intents UI frameworks)。SiriKit提供如下领域的服务：\n\n- 音频或视频通话\n- 消息传递\n- 发送或接收付款\n- 搜索照片\n- 乘坐预定\n- 管理训练\n\n当用户发起一个包含了你所提供服务的请求时， SiriKit会向你的 extension发送一个意图对象( intent object )，它描述了用户了请求并且提供了与这个请求相关的所有数据。你使用这个意图对象来提供一个相关的响应对象(response object)，它包含了如何处理用户请求的详情。Siri通常处理所有的用户交互，但是你也可以使用一个 extension来提供自定义 UI，它包含来自你的 App中的品牌或者其他额外信息。\n\nSiriKit还提供了一个机制，你可以使用它来告诉系统发生在你的 App中的交互和活动。 当你告诉系统这些交互，系统会判断你的 App是否可以处理用户当前的请求，如果可以，就把这个请求传递给你的 App。 除了意图，SiriKit还定义了一个交互对象(interaction object)，它把意图(intent)和意图处理过程(intent-handling process)的信息相结合，包含开始时间和特定事件发生的持续时间等细节。如果你的 App注册为可以处理一个活动，这个活动具有一个相同的名称并且作为一个意图，系统可以启动你的 App，并且携带一个包含了意图的交互对象，即使你没有提供一个意图 App extension。\n\nMaps和 Siri 都提供乘坐预定，用户也可以使用 Maps来订餐。你的意图 extension处理源于 Maps的交互，同样地它处理来自 Siri的请求。如果你自定义用户界面，你的意图 UI extension还可以自行配置，取决于你的请求是来自 Siri 还是 Maps。\n\n为了学习如何支持 SiriKit来给用户提供使用服务的新途径，阅读 *[SiriKit Programming Guide](https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875)*. 当你准备实现处理各种意图的 App extensions，参考 *[Intents Framework Reference](https://developer.apple.com/reference/intents)* 和 *[Intents UI Framework Reference](https://developer.apple.com/reference/intentsui)*.\n\n## 积极的建议\n\niOS 10引入了新的方式来来增强与你的 App的交互度(engagement)，通过帮助系统在适当的时机把你的 App推荐给用户。 如果你通过 App搜索你的 iOS 9 App，通过 Spotlight，Safari搜索结果，Handoff以及 Siri建议，允许用户访问你的 App深处的活动(activities)以及内容。 在 iOS 10之后，你可以提供用户在你的 App中做什么的信息，这有助于系统在额外的地方推广你的 App，比如键盘和 QuickType，Maps和 CarPlay，应用切换器(app switcher)，Siri交互和(媒体播放 Apps) 的锁屏界面。这些机会提高与系统的整合，它由一系列的技术支持，比如  `NSUserActivity`，由 [Schema.org](http://schema.org/)定义的 Web标记(web markup)，以及定义在 Core Spotlight，MapKit，UIKit，以及 Media Player框架中的 API。.\n\n在 iOS 10中，`NSUserActivity` 对象包含  `mapItem` 属性，该属性允许你提供可以在上下文(other contexts)使用的位置信息。比如，你的 App展示酒店信息，你可以使用 `mapItem` 属性来保存用户正在浏览的酒店的位置信息，当用户切换到另外一个旅行规划 App，酒店的位置是自动可用的。如果你支持 App搜索，你可以使用 `CSSearchableItemAttributeSet` 中新的基于文本的地址(text-based address)的属性，比如 `thoroughfare` 和 `postalCode`，来指定用户可能想要去的具体位置。注意，当你使用  `mapItem` 属性，系统自动填充  `contentAttributeSet`  属性。\n\n为了与系统共享一个位置，一定要指定 `latitude` 和 `longitude` 值，除了 `CSSearchableItemAttributeSet` 中的地址属性。也建议你提供值给 `namedLocation`，这样用户可以查看位置的名称，以及  `phoneNumbers` 属性，以便用户可以使用 Siri来发起呼叫给指定位置。\n\n在 iOS 9中，将标记添加到你的网站上的结构数据来丰富内容，用户可以在 Spotlight和 Safari搜索结果中看到。在 iOS 10中，你可以使用  [Schema.org](http://schema.org/) 定义的位置相关词汇，比如 [PostalAddress](http://schema.org/PostalAddress)，进一步提高用户体验。例如，如果用户查看你网站上描述的一个位置，系统可以在用户切换到 Maps中的时候建议相同的位置。注意 Safari 同时支持 JSON-LD 和 Microdata 编码的 [Schema.org](http://schema.org/) 词汇。\n\nUIKit介绍了 `UITextInputTraits` 协议中的  `textContentType` 属性，它可以让你指定你希望用户输入文本区域的内容的语义。当你提供这些信息时，系统可以在某些情况下自动选择一个合适的键盘并且提高键盘修正和主动集成来自其他 App或者网站的信息。比如，如果你使用 `UITextContentTypeFullStreetAddress` 来告诉系统你希望用户在文本区域中输入一个完整的地址，系统可以显示用户最近查看的位置地址。\n\n如果你的 App播放多媒体并且使用  `MPPlayableContentManager` APIs， iOS 10 帮你在锁屏界面通过你的 App，使得用户可以查看专辑封面和播放多媒体。\n\n如果你的骑乘共享(ride-sharing) App使用  `MKDirectionsRequest` API，iOS 10 可以在用户想要骑行的时候，在应用程序切换器(app switcher)中展示它。想要注册成一个骑行共享提供者，在 `Info.plist` 文件中设置 [MKDirectionsApplicationSupportedModes](https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW33) 的值为 `MKDirectionsModeRideShare` 。如果你的 App 只提供骑行共享，系统建议你的 App使用这样开头的文本  “Get a ride to…”；如果你的 App支持骑行共享和其他路由类型（如汽车或摩托车），系统建议你使用这样开头的文本  “Get directions to…”。注意 你收到的 `MKMapItem` 对象可能不包含经度和纬度信息，需要地理编码。\n\n## 与 Messages App 交互\n\n在 iOS 10中，你可以创建 App extensions 来与 Messages App交互，使得用户可以发送文本，贴纸，媒体文件以及交互式消息。你也可以支持更新为每个收件人响应消息的交互式消息。你还可以创建两种类型的 App extensions:\n\n- 贴纸包提供一系列的贴纸，用户可以添加到他们的信息内容中。\n\n- *iMessage app* 让你在 Messages App 中展示一个自定义用户界面，创建一个标签的浏览器，包括一次对话中的文本，贴纸和媒体文件，并且创建，发送和更新消息交互。\n\n   iMessage \u001dApp也可以帮助用户搜索保存在你的 App中相关网站的图片，当它们处在  Messages App 中的时候。\n\n你可以创建一个贴纸包而无需编写任何代码：简单地拖拽图片到 Xcode中贴纸包文件夹内贴纸 asset 目录。\n\n为了开发一个  iMessage \u001dApp，你可以使用 Messages 框架中的 API (`Messages.framework`)。更多关于 Messages 框架，详见 *[Messages Framework Reference](https://developer.apple.com/reference/messages)*. 对于创建 App Extensions的普遍信息，详见 *[App Extension Programming Guide](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214)*.\n\n如果你的 App提供图片在 Messages中分享，你想要用户可以使用 Spotlight 的流行图片搜索  (即, “#images”) 来搜索图片，而不用离开 Messages App，首先创建一个 iMessage app。然后遵循下面步骤： \n\n- 给你 App 的 entitlements 添加  `com.apple.developer.associated-domains` 键。包括保存你想要搜索的图片的网站域名的一个列表。对于每个域，指定 `spotlight-image-search` 服务。\n- 添加一个 `apple-app-site-association` 文件到你的网站。为 `spotlight-image-search` 服务添加一个字典，包含你的 app ID, 它是 team ID 或者 app ID 前缀，后跟  bundle ID。你可以指定多打500个路径和模式，应该包含 Spotlight 流行图片搜索索引。 (关于网站路径的一些实例，详见 [Creating and Uploading the Association File](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4)).\n- 允许 Applebot 爬虫 (详见 [About Applebot](https://support.apple.com/en-us/HT204683)).\n\n## 用户通知\n\niOS 10 引入了用户通知框架(`UserNotifications.framework`)，它支持本地和远程通知的发送和处理。你可以使用这个框架的类来安排基于特定条件的本地通知。比如时间或者位置。当它们被发送到用户设备的时候，App 和App extensions 可以使用这个框架来接收和修改本地和远程的通知。\n\n还介绍了在 iOS 10 中，用户通知 UI框架 (`UserNotificationsUI.framework`) 允许你自定义显示在用户设备上的本地和远程推送通知。你使用这个框架来定义一个接收通知数据并且提供相应可视化表示的 App extension 。这个 extension也可以响应相关的自定义动作和通知。 \n\n## 语音识别\n\niOS 10 引入了一个新的 API，支持连续语音识别和帮助你构建支持语音识别并且转换成文本的 App。使用  Speech 框架 (`Speech.framework`) 中的 API，你可以执行实时语音转录和记录音频。例如，你可以得到一个语音识别器，开始简单的语音识别，代码如下所示： \n\n```swift\nlet recognizer = SFSpeechRecognizer()\nlet request = SFSpeechURLRecognitionRequest(url: audioFileURL)\nrecognizer?.recognitionTask(with: request, resultHandler: { (result, error) in\n     print (result?.bestTranscription.formattedString)\n})\n```\n\n与访问其他类型的受保护数据一样，如日历，照片资料，进行语音识别需要用户的授权 (更多关于访问受保护的数据类，详见[Security and Privacy Enhancements](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3))。在语音识别的情况下，许可是必需的，因为数据被传递，并且暂时存储在苹果的服务器上，以提高语音识别的准确性。请求用户的权限，必须在 `Info.plist` 文件中添加`NSSpeechRecognitionUsageDescription`  键。\n\n当你在你的 App中采用语音识别，一定要向用户表明他们的语音将被识别，并且他们不应该使用敏感话语。\n\n## 广泛的颜色\n\n贯穿系统的大多数图形框架，包括 Core Graphics, Core Image, Metal, 和 AVFoundation, 有大幅的改进来支持 extended-range 像素格式和 wide-gamut 颜色空间。通过将此行为扩展到整个图形栈中，它比以往任何时间更容易支持具有宽颜色显示的设备。此外，UIKit 使在新扩展的 sRGB颜色空间上工作标准化，因此很容易混合 sRGB和其他颜色，更广泛的色域没有明显的性能损失。\n\n这里有一些你开始使用广泛颜色的最佳实践。\n\n- \b在 iOS 10 中，[UIColor](https://developer.apple.com/reference/uikit/uicolor) 类使用扩展的 sRGB 颜色空间，并且它的构造器(initializers)不再限制初始值在  `0.0` 和 `1.0` 之间。如果你的应用程序依赖于 UIKit来限制组件(component)值 (无论你是创建一个颜色或者一个颜色的组件值)，当你链接到 iOS 10的时候，你需要改变这些行为。 \n- 当在 iPad Pro (9.7 inch) 的  [UIView](https://developer.apple.com/reference/uikit/uiview) 上执行自定义的绘制时，底层的绘图环境配置了一个扩展的 sRGB颜色空间。\n- 如果你的 App 渲染自定义的图像对象，使用新的  [UIGraphicsImageRenderer](https://developer.apple.com/reference/uikit/uigraphicsimagerenderer) 类来控制目标位图是使用扩展范围(extended-range)还是标准范围 (standard-range) 格式。\n- 如果你使用较低级别的 API，比如 Core Graphics 和 Metal来执行你自己的图像处理，你需要使用一个扩展的颜色空间和一个支持16位浮点值的像素格式的组件值。当限制颜色值是必要的时候，你应该明确这样做。\n- Core Graphics, Core Image,以及 Metal 性能着色器提供了新的选择，可以在颜色空间之间轻松转换颜色和图像。\n\n## 适应真实的色调显示\n\n真实的色调显示使用环境光传感器自动调整显示器的颜色和强度，以配合当前环境的照明条件。为了确保你的 App可以与真实的色调提供的标准颜色变化很好的工作，在 `Info.plist` 中添加新的 [UIWhitePointAdaptivityStyle](https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31) 键来描述你的 App的主要视觉内容。比如： \n\n- 如果你的 App是一个照片编辑应用，颜色的准确性(fidelity)比自动调整环境白点(white point)更重要。在这种情况下，你可以使用 `UIWhitePointAdaptivityStylePhoto` 方式来降低系统提供的真实色调变化的强度。\n- 如果你的 App是一个阅读应用，符合环境白点将为用户提供帮助。在这种情况下，你可以使用 `UIWhitePointAdaptivityStyleReading` 方式来加强系统提供的真实色调变化的强度。\n\n## App搜索 的改进\n\niOS 10 和 Core Spotlight框架介绍了几个 App搜索的改进点： \n\n- 应用内(In-app)搜索\n- 继续搜索(Search continuation)\n- 众包(crowdsourcing:是互联网带来的新的生产组织形式)与差分隐私(differential privacy)的深度链接\n- 可视化的验证结果\n\n新的 `CSSearchQuery` 类支持应用内内容搜索，使用现有的 Core Spotlight APIs。使用这个 API可以消除需要保持你自己单独的搜索索引，让你发挥 Spotlight的强大搜索技术和匹配规则，允许用户搜索内容不离开你的 App，就像他们在 Mail, Messages,和 Notes.\n\n在 iOS 9中，使用搜索 API(比如 Core Spotlight, [NSUserActivity](https://developer.apple.com/reference/foundation/nsuseractivity) 和 web标记) 在你的 App中，让用户使用Spotlight 和 Safari搜索界面来搜索索引的内容。在 iOS 10中，你可以使用新的 Core Spotlight 符号，当用户打开你的 App时候，用户可以继续使用 Spotlight进行搜索。要启用这个功能，在 `Info.plist` 文件中添加 `CoreSpotlightContinuation` 键，并且设置它的值为  `YES`，然后更新你的代码来处理一个  [CSQueryContinuationActionType](https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype) 类型的活动延续。在  [application:continueUserActivity:restorationHandler:](https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application) 方法中收到的 [NSUserActivity](https://developer.apple.com/reference/foundation/nsuseractivity) 对象中的用户信息字典包含了 [CSSearchQueryString](https://developer.apple.com/reference/corespotlight/cssearchquerystring) 键，它的值是一个字符串，表示用户的查询。\n\niOS 10 引入了一个不同的私人方式来帮助提高你的 App的内容在搜索结果中的排名。 iOS 提交一部分差分隐私到 Apple的服务器随着用户使用你的 App 以及  [NSUserActivity](https://developer.apple.com/reference/foundation/nsuseractivity) 对象包含深度链接地址并且它们的 [eligibleForPublicIndexing](https://developer.apple.com/reference/foundation/nsuseractivity/1414701-eligibleforpublicindexing) 属性设置为  `YES` 被提交到 iOS中。差分隐形散列允许 Apple统计流行的深度链接的频率，而不曾与用户关联的链接进行访问。\n\n当你使用 App 搜索 API 验证工具来测试你的网站标记和深度链接，现在展示你的结果的可视化表示，包括支持的标记，比如  [Schema.org](http://schema.org/) 中定义的。验证工具可以帮你看到 Applebot web爬虫索引信息，比如标题，描述，URL和其他支持的元素。你可以在这里获取这个验证工具： [https://search.developer.apple.com/appsearch-validation-tool](https://search.developer.apple.com/appsearch-validation-tool). 更多关于支持深度链接和添加标记，详见： [Mark Up Web Content](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8).\n\n学习如何让你的网站中的图片在 Messages App内可搜索，详见 [Integrating with the Messages App](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4).\n\n## Widget 的改进\n\niOS 10 为锁屏界面引入了一个新的设计，现在可以显示 widgets。为了保证你的 widget 在任何背景下看起来都不错，你可以适当地设置 [widgetPrimaryVibrancyEffect](https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect) 或者 [widgetSecondaryVibrancyEffect](https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect)(使用这些属性取代已废弃的 [notificationCenterVibrancyEffect](https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect) 属性)。此外， widgets现在包括显示模式(由 [NCWidgetDisplayMode](https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode) 表示)的概念，它可以让你描述有多少内容是可用的，并允许用户选择一个紧凑或者扩展型的视图。 \n\n## Apple Pay 的改进\n\n在 iOS 10中，用户可以通过 Siri和 Maps使用网页版的 Apple Pay 来便捷安全的完成支付。对于开发者来说， iOS 10 引入了新的 API，你可以在代码中使用运行在 iOS和  watchOS上，支持动态支付网络的能力和一个新的沙盒测试环境。\n\niOS 10 引入了新的 API，帮助你将 Apple Pay 直接引入你的网站。当你在你的网站支持 Apple Pay，用户在 iOS或者 OS X上通过 Safari浏览的时候，可以通过它们的 iPhone或 Apple Watch来使用 Apple Pay上的信用卡进行支付。 详见 [*ApplePay JS Framework Reference*](https://developer.apple.com/reference/applepayjs).\n\n PassKit框架 (`PassKit.framework`) 介绍了让你在 UIKit不可用的地方支持 Apple Pay的 API。具体来说， [PKPaymentAuthorizationController](https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontroller) 和 [PKPaymentAuthorizationControllerDelegate](https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontrollerdelegate) 使得  [PKPaymentAuthorizationViewController](https://developer.apple.com/reference/passkit/pkpaymentauthorizationviewcontroller) 提供的功能以及它的 delegate 可用，而不需要 UIKit。尽管新的 API 需要在特定的意图下在 watchOS上提供 Apple Pay，还是建议你在代码的任何地方采用它。这样你就可以用一套基础代码来广泛提供 Apple Pay支持。(更多关于意图和 Siri集成，详见 [SiriKit](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5).)\n\n PassKit 框架还增加了新的功能，让信用卡发行机构在它们的 App中展示他们的信用卡。具体来说， `PKPaymentButtonTypeInStore` 按钮类型允许你为信用卡展示一个 Apple Pay 按钮，  `presentPaymentPass:` 方法允许你以编程方式展示信用卡。 ( `presentPaymentPass:` 方法定义在  [PKPassLibrary](https://developer.apple.com/reference/passkit/pkpasslibrary)中)。\n\n当一个新的支付网络可用时，你的 App可用自动支持新的网络，而不需要修改和重新编译你的 App。[availableNetworks](https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks) 方法允许你在运行时发现用户设备可用的网络。此外， [supportedNetworks](https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks) 属性被扩展了，以便可以携带一些支付服务提供商的名字作为参数。然后你的 App自动支持任何支付提供商支持的网络。详见[https://developer.apple.com/apple-pay/](https://developer.apple.com/apple-pay/).\n\niOS 10 引入了一个新的测试环境，它允许你直接在设备上提供测试信用卡。测试环境返回加密后的测试支付数据。要使用这种环境，遵循以下步骤：\n\n1. 在 iTunes Connect上创建一个测试 iCloud账号\n2. 在你的设备上登录该账号\n3. 设置测试所需的区域\n4. 使用 [https://developer.apple.com/apple-pay/](https://developer.apple.com/apple-pay/) 上列举的测试信用卡\n\n**注意:** 当你切换 iCloud账号，环境自动切换。你还必须在实际生产环境中测试支付。\n\n## 安全和隐私的改进\n\niOS 10 引入了一些修改和补充，帮助你提高你的代码的安全和维护用户数据的隐私。更多关于这方面的内容，详见 [Security](https://developer.apple.com/security/ ) .\n\n- `Info.plist` 文件中新的 `NSAllowsArbitraryLoadsInWebContent` 键，提供了一个便捷的方式来允许任意的 web页面加载任务，同时保留 ATS保护你的 App的其余部分。\n- SecKey API包括不对称密钥生成的改进。使用 SecKey API 替代已经弃用的 CDSA(Common Data Security Architecture: 通用数据安全架构) API。\n- RC4 对称加密套件现在默认禁用所有的 SSL/TLS 连接，以及 SSLv3 不再支持安全传输 API。建议你尽快停止使用  SHA-1和 3DES 加密算法。\n- [UIPasteboard](https://developer.apple.com/reference/uikit/uipasteboard) 类支持剪贴板功能，该功能允许用户设置之间复制和粘贴，包括 API可以用来限制一个纸板到特定设备和设置到达过期时间戳后，纸板被清除。此外，命名过的纸板不再重复出现，取而代之的是，你应该使用共享的容器，以及“发现”纸板（也就是说，纸板被  [UIPasteboardNameFind](https://developer.apple.com/reference/uikit/uipasteboardnamefind)  常数定义）是无效的。\n- 你必须静态声明你的应用程序使用受保护的数据类，通过在 `Info.plist` 文件中包含相关的目的字符串键。例如，你必须包含 [NSCalendarsUsageDescription](https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15) 键来访问用户日历的数据。如果你不包含相关的目的字符串键，当你试图访问相关数据的时候，你的 App会退出。\n\n## CallKit\n\n CallKit 框架 (`CallKit.framework`) 让  VoIP App与 iPhone UI相结合，给用户一个很棒的体验。使用这个框架来让用户在锁屏界面查看和接听到来的 VoIP电话，以及管理手机上 Favorites和 Recents视图上的联系人。\n\nCallKit 还介绍了 App extensions，允许来电拦截并且来电识别。你可以创建一个 App extension，将一个电话号码和一个名称联系起来，或者告诉系统某个号码需要被拦截。\n\n## News Publisher 的改进\n\nNews Publisher 可以使用 Apple News格式，很容易地提供设计精美的新闻，杂志和网络内容给 Apple News。任何人都可以注册，从主要的杂志或者新闻机构，到独立的出版商和博客。开始或学习更多关于最近的更新，访问  [https://newsresources.apple.com](https://newsresources.apple.com/).\n\n## Video Subscriber Account\n\niOS 10 引入  Video Subscriber Account 框架 (`VideoSubscriberAccount.framework`) 来帮助 App支持支持身份验证流或验证视频点播(也称为 TV)与他们的有线或卫星 TV提供商进行身份验证。使用这个框架的 API可以帮助你支持一个单一的登录体验，用户登录一次解锁访问所有的视频应用程序订阅支持。\n\n## App Extensions\n\niOS 10 引入了几个可以创建 App extension的新的 extension points，比如：\n\n- Call Directory\n- Intents\n- Intents UI\n- Messages\n- Notification Content\n- Notification Service\n- Sticker Pack\n\n此外，iOS 10包含了如下的第三方键盘 app extensions的改进：\n\n- 你可以使用 `UITextDocumentProxy`  类中的  `documentInputMode` 属性，来自动检测文档的输入语言，并且改变你的键盘 extension来符合这个语言(如果支持的话)。当你用这种方式决定输入的语言时， 你可以做每一种语言的键盘切换，比如为 Messages内建的。\n- 新的 `handleInputModeListFromView:withEvent:` 方法让键盘 extension 显示系统的键盘选择菜单(即地球标志的菜单).\n\n键盘 extension 必须放置地球标志和系统标志相同的位置。此外，如果你需要提供一个自定义的按键来启动键盘设置，例如，你应该把这个按键放在系统键盘听写键的相同位置。\n\n更多关于 App extensions，详见 [*App Extension Programming Guide*](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214).\n\n","source":"_posts/What's_New_in_iOS_10.0_zh_0.md","raw":"layout: \"代码备忘\"\n\ntitle: What's New in iOS 10.0 中文版(上)\n\ndate: 2016-06-14 17:20:52\n\ntags:\n\n- iOS 10\n- 翻译\n\n------\n\n> 由于原文篇幅较长，为了方便阅读，分为上下篇。\n>\n> 本文是 What's New in iOS 10.0 中文版的上篇，主要描述了iOS 10新引入的一些新特效，概括了重要的变化。\n>\n> 在What's New in iOS 10.0 中文版(下)中，将介绍一些已存在框架的改进以及一些弃用的 API。\n>\n> 原文链接：[What's New in iOS 10.0](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW1)\n\n这篇文章总结了运行在目前 iOS设备上的 iOS 10中与开发者有关的功能，这篇文章还列出了与这些功能相关的详细文档。\n\n<!--more-->\n\n关于目前已知问题的最新新闻和信息，可以查阅 [https://developer.apple.com/ios/download/](https://developer.apple.com/ios/download/) 。添加到 iOS 10中的 API 的完整列表，详见 *[iOS 10.0 API Diffs](https://developer.apple.com/library/prerelease/content/releasenotes/General/iOS10APIDiffs/index.html)*。有关新设备的更多信息，详见 *[iOS Device Compatibility Reference](https://developer.apple.com/library/prerelease/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599)*.\n\n更多关于 Swift,详见 [Swift Language](https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3) and *[The Swift Programming Language (Swift 3)](https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097)*.\n\n## SiriKit\n\nApps 在特定的领域提供服务，可以使用 SiriKit来在 iOS中通过 Siri使用这些服务。 想要提供这些服务，需要创建一个或多个使用这些意图和意图 UI frameworks的   App extensions(app extensions using the Intents and Intents UI frameworks)。SiriKit提供如下领域的服务：\n\n- 音频或视频通话\n- 消息传递\n- 发送或接收付款\n- 搜索照片\n- 乘坐预定\n- 管理训练\n\n当用户发起一个包含了你所提供服务的请求时， SiriKit会向你的 extension发送一个意图对象( intent object )，它描述了用户了请求并且提供了与这个请求相关的所有数据。你使用这个意图对象来提供一个相关的响应对象(response object)，它包含了如何处理用户请求的详情。Siri通常处理所有的用户交互，但是你也可以使用一个 extension来提供自定义 UI，它包含来自你的 App中的品牌或者其他额外信息。\n\nSiriKit还提供了一个机制，你可以使用它来告诉系统发生在你的 App中的交互和活动。 当你告诉系统这些交互，系统会判断你的 App是否可以处理用户当前的请求，如果可以，就把这个请求传递给你的 App。 除了意图，SiriKit还定义了一个交互对象(interaction object)，它把意图(intent)和意图处理过程(intent-handling process)的信息相结合，包含开始时间和特定事件发生的持续时间等细节。如果你的 App注册为可以处理一个活动，这个活动具有一个相同的名称并且作为一个意图，系统可以启动你的 App，并且携带一个包含了意图的交互对象，即使你没有提供一个意图 App extension。\n\nMaps和 Siri 都提供乘坐预定，用户也可以使用 Maps来订餐。你的意图 extension处理源于 Maps的交互，同样地它处理来自 Siri的请求。如果你自定义用户界面，你的意图 UI extension还可以自行配置，取决于你的请求是来自 Siri 还是 Maps。\n\n为了学习如何支持 SiriKit来给用户提供使用服务的新途径，阅读 *[SiriKit Programming Guide](https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875)*. 当你准备实现处理各种意图的 App extensions，参考 *[Intents Framework Reference](https://developer.apple.com/reference/intents)* 和 *[Intents UI Framework Reference](https://developer.apple.com/reference/intentsui)*.\n\n## 积极的建议\n\niOS 10引入了新的方式来来增强与你的 App的交互度(engagement)，通过帮助系统在适当的时机把你的 App推荐给用户。 如果你通过 App搜索你的 iOS 9 App，通过 Spotlight，Safari搜索结果，Handoff以及 Siri建议，允许用户访问你的 App深处的活动(activities)以及内容。 在 iOS 10之后，你可以提供用户在你的 App中做什么的信息，这有助于系统在额外的地方推广你的 App，比如键盘和 QuickType，Maps和 CarPlay，应用切换器(app switcher)，Siri交互和(媒体播放 Apps) 的锁屏界面。这些机会提高与系统的整合，它由一系列的技术支持，比如  `NSUserActivity`，由 [Schema.org](http://schema.org/)定义的 Web标记(web markup)，以及定义在 Core Spotlight，MapKit，UIKit，以及 Media Player框架中的 API。.\n\n在 iOS 10中，`NSUserActivity` 对象包含  `mapItem` 属性，该属性允许你提供可以在上下文(other contexts)使用的位置信息。比如，你的 App展示酒店信息，你可以使用 `mapItem` 属性来保存用户正在浏览的酒店的位置信息，当用户切换到另外一个旅行规划 App，酒店的位置是自动可用的。如果你支持 App搜索，你可以使用 `CSSearchableItemAttributeSet` 中新的基于文本的地址(text-based address)的属性，比如 `thoroughfare` 和 `postalCode`，来指定用户可能想要去的具体位置。注意，当你使用  `mapItem` 属性，系统自动填充  `contentAttributeSet`  属性。\n\n为了与系统共享一个位置，一定要指定 `latitude` 和 `longitude` 值，除了 `CSSearchableItemAttributeSet` 中的地址属性。也建议你提供值给 `namedLocation`，这样用户可以查看位置的名称，以及  `phoneNumbers` 属性，以便用户可以使用 Siri来发起呼叫给指定位置。\n\n在 iOS 9中，将标记添加到你的网站上的结构数据来丰富内容，用户可以在 Spotlight和 Safari搜索结果中看到。在 iOS 10中，你可以使用  [Schema.org](http://schema.org/) 定义的位置相关词汇，比如 [PostalAddress](http://schema.org/PostalAddress)，进一步提高用户体验。例如，如果用户查看你网站上描述的一个位置，系统可以在用户切换到 Maps中的时候建议相同的位置。注意 Safari 同时支持 JSON-LD 和 Microdata 编码的 [Schema.org](http://schema.org/) 词汇。\n\nUIKit介绍了 `UITextInputTraits` 协议中的  `textContentType` 属性，它可以让你指定你希望用户输入文本区域的内容的语义。当你提供这些信息时，系统可以在某些情况下自动选择一个合适的键盘并且提高键盘修正和主动集成来自其他 App或者网站的信息。比如，如果你使用 `UITextContentTypeFullStreetAddress` 来告诉系统你希望用户在文本区域中输入一个完整的地址，系统可以显示用户最近查看的位置地址。\n\n如果你的 App播放多媒体并且使用  `MPPlayableContentManager` APIs， iOS 10 帮你在锁屏界面通过你的 App，使得用户可以查看专辑封面和播放多媒体。\n\n如果你的骑乘共享(ride-sharing) App使用  `MKDirectionsRequest` API，iOS 10 可以在用户想要骑行的时候，在应用程序切换器(app switcher)中展示它。想要注册成一个骑行共享提供者，在 `Info.plist` 文件中设置 [MKDirectionsApplicationSupportedModes](https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW33) 的值为 `MKDirectionsModeRideShare` 。如果你的 App 只提供骑行共享，系统建议你的 App使用这样开头的文本  “Get a ride to…”；如果你的 App支持骑行共享和其他路由类型（如汽车或摩托车），系统建议你使用这样开头的文本  “Get directions to…”。注意 你收到的 `MKMapItem` 对象可能不包含经度和纬度信息，需要地理编码。\n\n## 与 Messages App 交互\n\n在 iOS 10中，你可以创建 App extensions 来与 Messages App交互，使得用户可以发送文本，贴纸，媒体文件以及交互式消息。你也可以支持更新为每个收件人响应消息的交互式消息。你还可以创建两种类型的 App extensions:\n\n- 贴纸包提供一系列的贴纸，用户可以添加到他们的信息内容中。\n\n- *iMessage app* 让你在 Messages App 中展示一个自定义用户界面，创建一个标签的浏览器，包括一次对话中的文本，贴纸和媒体文件，并且创建，发送和更新消息交互。\n\n   iMessage \u001dApp也可以帮助用户搜索保存在你的 App中相关网站的图片，当它们处在  Messages App 中的时候。\n\n你可以创建一个贴纸包而无需编写任何代码：简单地拖拽图片到 Xcode中贴纸包文件夹内贴纸 asset 目录。\n\n为了开发一个  iMessage \u001dApp，你可以使用 Messages 框架中的 API (`Messages.framework`)。更多关于 Messages 框架，详见 *[Messages Framework Reference](https://developer.apple.com/reference/messages)*. 对于创建 App Extensions的普遍信息，详见 *[App Extension Programming Guide](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214)*.\n\n如果你的 App提供图片在 Messages中分享，你想要用户可以使用 Spotlight 的流行图片搜索  (即, “#images”) 来搜索图片，而不用离开 Messages App，首先创建一个 iMessage app。然后遵循下面步骤： \n\n- 给你 App 的 entitlements 添加  `com.apple.developer.associated-domains` 键。包括保存你想要搜索的图片的网站域名的一个列表。对于每个域，指定 `spotlight-image-search` 服务。\n- 添加一个 `apple-app-site-association` 文件到你的网站。为 `spotlight-image-search` 服务添加一个字典，包含你的 app ID, 它是 team ID 或者 app ID 前缀，后跟  bundle ID。你可以指定多打500个路径和模式，应该包含 Spotlight 流行图片搜索索引。 (关于网站路径的一些实例，详见 [Creating and Uploading the Association File](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4)).\n- 允许 Applebot 爬虫 (详见 [About Applebot](https://support.apple.com/en-us/HT204683)).\n\n## 用户通知\n\niOS 10 引入了用户通知框架(`UserNotifications.framework`)，它支持本地和远程通知的发送和处理。你可以使用这个框架的类来安排基于特定条件的本地通知。比如时间或者位置。当它们被发送到用户设备的时候，App 和App extensions 可以使用这个框架来接收和修改本地和远程的通知。\n\n还介绍了在 iOS 10 中，用户通知 UI框架 (`UserNotificationsUI.framework`) 允许你自定义显示在用户设备上的本地和远程推送通知。你使用这个框架来定义一个接收通知数据并且提供相应可视化表示的 App extension 。这个 extension也可以响应相关的自定义动作和通知。 \n\n## 语音识别\n\niOS 10 引入了一个新的 API，支持连续语音识别和帮助你构建支持语音识别并且转换成文本的 App。使用  Speech 框架 (`Speech.framework`) 中的 API，你可以执行实时语音转录和记录音频。例如，你可以得到一个语音识别器，开始简单的语音识别，代码如下所示： \n\n```swift\nlet recognizer = SFSpeechRecognizer()\nlet request = SFSpeechURLRecognitionRequest(url: audioFileURL)\nrecognizer?.recognitionTask(with: request, resultHandler: { (result, error) in\n     print (result?.bestTranscription.formattedString)\n})\n```\n\n与访问其他类型的受保护数据一样，如日历，照片资料，进行语音识别需要用户的授权 (更多关于访问受保护的数据类，详见[Security and Privacy Enhancements](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3))。在语音识别的情况下，许可是必需的，因为数据被传递，并且暂时存储在苹果的服务器上，以提高语音识别的准确性。请求用户的权限，必须在 `Info.plist` 文件中添加`NSSpeechRecognitionUsageDescription`  键。\n\n当你在你的 App中采用语音识别，一定要向用户表明他们的语音将被识别，并且他们不应该使用敏感话语。\n\n## 广泛的颜色\n\n贯穿系统的大多数图形框架，包括 Core Graphics, Core Image, Metal, 和 AVFoundation, 有大幅的改进来支持 extended-range 像素格式和 wide-gamut 颜色空间。通过将此行为扩展到整个图形栈中，它比以往任何时间更容易支持具有宽颜色显示的设备。此外，UIKit 使在新扩展的 sRGB颜色空间上工作标准化，因此很容易混合 sRGB和其他颜色，更广泛的色域没有明显的性能损失。\n\n这里有一些你开始使用广泛颜色的最佳实践。\n\n- \b在 iOS 10 中，[UIColor](https://developer.apple.com/reference/uikit/uicolor) 类使用扩展的 sRGB 颜色空间，并且它的构造器(initializers)不再限制初始值在  `0.0` 和 `1.0` 之间。如果你的应用程序依赖于 UIKit来限制组件(component)值 (无论你是创建一个颜色或者一个颜色的组件值)，当你链接到 iOS 10的时候，你需要改变这些行为。 \n- 当在 iPad Pro (9.7 inch) 的  [UIView](https://developer.apple.com/reference/uikit/uiview) 上执行自定义的绘制时，底层的绘图环境配置了一个扩展的 sRGB颜色空间。\n- 如果你的 App 渲染自定义的图像对象，使用新的  [UIGraphicsImageRenderer](https://developer.apple.com/reference/uikit/uigraphicsimagerenderer) 类来控制目标位图是使用扩展范围(extended-range)还是标准范围 (standard-range) 格式。\n- 如果你使用较低级别的 API，比如 Core Graphics 和 Metal来执行你自己的图像处理，你需要使用一个扩展的颜色空间和一个支持16位浮点值的像素格式的组件值。当限制颜色值是必要的时候，你应该明确这样做。\n- Core Graphics, Core Image,以及 Metal 性能着色器提供了新的选择，可以在颜色空间之间轻松转换颜色和图像。\n\n## 适应真实的色调显示\n\n真实的色调显示使用环境光传感器自动调整显示器的颜色和强度，以配合当前环境的照明条件。为了确保你的 App可以与真实的色调提供的标准颜色变化很好的工作，在 `Info.plist` 中添加新的 [UIWhitePointAdaptivityStyle](https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31) 键来描述你的 App的主要视觉内容。比如： \n\n- 如果你的 App是一个照片编辑应用，颜色的准确性(fidelity)比自动调整环境白点(white point)更重要。在这种情况下，你可以使用 `UIWhitePointAdaptivityStylePhoto` 方式来降低系统提供的真实色调变化的强度。\n- 如果你的 App是一个阅读应用，符合环境白点将为用户提供帮助。在这种情况下，你可以使用 `UIWhitePointAdaptivityStyleReading` 方式来加强系统提供的真实色调变化的强度。\n\n## App搜索 的改进\n\niOS 10 和 Core Spotlight框架介绍了几个 App搜索的改进点： \n\n- 应用内(In-app)搜索\n- 继续搜索(Search continuation)\n- 众包(crowdsourcing:是互联网带来的新的生产组织形式)与差分隐私(differential privacy)的深度链接\n- 可视化的验证结果\n\n新的 `CSSearchQuery` 类支持应用内内容搜索，使用现有的 Core Spotlight APIs。使用这个 API可以消除需要保持你自己单独的搜索索引，让你发挥 Spotlight的强大搜索技术和匹配规则，允许用户搜索内容不离开你的 App，就像他们在 Mail, Messages,和 Notes.\n\n在 iOS 9中，使用搜索 API(比如 Core Spotlight, [NSUserActivity](https://developer.apple.com/reference/foundation/nsuseractivity) 和 web标记) 在你的 App中，让用户使用Spotlight 和 Safari搜索界面来搜索索引的内容。在 iOS 10中，你可以使用新的 Core Spotlight 符号，当用户打开你的 App时候，用户可以继续使用 Spotlight进行搜索。要启用这个功能，在 `Info.plist` 文件中添加 `CoreSpotlightContinuation` 键，并且设置它的值为  `YES`，然后更新你的代码来处理一个  [CSQueryContinuationActionType](https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype) 类型的活动延续。在  [application:continueUserActivity:restorationHandler:](https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application) 方法中收到的 [NSUserActivity](https://developer.apple.com/reference/foundation/nsuseractivity) 对象中的用户信息字典包含了 [CSSearchQueryString](https://developer.apple.com/reference/corespotlight/cssearchquerystring) 键，它的值是一个字符串，表示用户的查询。\n\niOS 10 引入了一个不同的私人方式来帮助提高你的 App的内容在搜索结果中的排名。 iOS 提交一部分差分隐私到 Apple的服务器随着用户使用你的 App 以及  [NSUserActivity](https://developer.apple.com/reference/foundation/nsuseractivity) 对象包含深度链接地址并且它们的 [eligibleForPublicIndexing](https://developer.apple.com/reference/foundation/nsuseractivity/1414701-eligibleforpublicindexing) 属性设置为  `YES` 被提交到 iOS中。差分隐形散列允许 Apple统计流行的深度链接的频率，而不曾与用户关联的链接进行访问。\n\n当你使用 App 搜索 API 验证工具来测试你的网站标记和深度链接，现在展示你的结果的可视化表示，包括支持的标记，比如  [Schema.org](http://schema.org/) 中定义的。验证工具可以帮你看到 Applebot web爬虫索引信息，比如标题，描述，URL和其他支持的元素。你可以在这里获取这个验证工具： [https://search.developer.apple.com/appsearch-validation-tool](https://search.developer.apple.com/appsearch-validation-tool). 更多关于支持深度链接和添加标记，详见： [Mark Up Web Content](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8).\n\n学习如何让你的网站中的图片在 Messages App内可搜索，详见 [Integrating with the Messages App](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4).\n\n## Widget 的改进\n\niOS 10 为锁屏界面引入了一个新的设计，现在可以显示 widgets。为了保证你的 widget 在任何背景下看起来都不错，你可以适当地设置 [widgetPrimaryVibrancyEffect](https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect) 或者 [widgetSecondaryVibrancyEffect](https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect)(使用这些属性取代已废弃的 [notificationCenterVibrancyEffect](https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect) 属性)。此外， widgets现在包括显示模式(由 [NCWidgetDisplayMode](https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode) 表示)的概念，它可以让你描述有多少内容是可用的，并允许用户选择一个紧凑或者扩展型的视图。 \n\n## Apple Pay 的改进\n\n在 iOS 10中，用户可以通过 Siri和 Maps使用网页版的 Apple Pay 来便捷安全的完成支付。对于开发者来说， iOS 10 引入了新的 API，你可以在代码中使用运行在 iOS和  watchOS上，支持动态支付网络的能力和一个新的沙盒测试环境。\n\niOS 10 引入了新的 API，帮助你将 Apple Pay 直接引入你的网站。当你在你的网站支持 Apple Pay，用户在 iOS或者 OS X上通过 Safari浏览的时候，可以通过它们的 iPhone或 Apple Watch来使用 Apple Pay上的信用卡进行支付。 详见 [*ApplePay JS Framework Reference*](https://developer.apple.com/reference/applepayjs).\n\n PassKit框架 (`PassKit.framework`) 介绍了让你在 UIKit不可用的地方支持 Apple Pay的 API。具体来说， [PKPaymentAuthorizationController](https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontroller) 和 [PKPaymentAuthorizationControllerDelegate](https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontrollerdelegate) 使得  [PKPaymentAuthorizationViewController](https://developer.apple.com/reference/passkit/pkpaymentauthorizationviewcontroller) 提供的功能以及它的 delegate 可用，而不需要 UIKit。尽管新的 API 需要在特定的意图下在 watchOS上提供 Apple Pay，还是建议你在代码的任何地方采用它。这样你就可以用一套基础代码来广泛提供 Apple Pay支持。(更多关于意图和 Siri集成，详见 [SiriKit](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5).)\n\n PassKit 框架还增加了新的功能，让信用卡发行机构在它们的 App中展示他们的信用卡。具体来说， `PKPaymentButtonTypeInStore` 按钮类型允许你为信用卡展示一个 Apple Pay 按钮，  `presentPaymentPass:` 方法允许你以编程方式展示信用卡。 ( `presentPaymentPass:` 方法定义在  [PKPassLibrary](https://developer.apple.com/reference/passkit/pkpasslibrary)中)。\n\n当一个新的支付网络可用时，你的 App可用自动支持新的网络，而不需要修改和重新编译你的 App。[availableNetworks](https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks) 方法允许你在运行时发现用户设备可用的网络。此外， [supportedNetworks](https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks) 属性被扩展了，以便可以携带一些支付服务提供商的名字作为参数。然后你的 App自动支持任何支付提供商支持的网络。详见[https://developer.apple.com/apple-pay/](https://developer.apple.com/apple-pay/).\n\niOS 10 引入了一个新的测试环境，它允许你直接在设备上提供测试信用卡。测试环境返回加密后的测试支付数据。要使用这种环境，遵循以下步骤：\n\n1. 在 iTunes Connect上创建一个测试 iCloud账号\n2. 在你的设备上登录该账号\n3. 设置测试所需的区域\n4. 使用 [https://developer.apple.com/apple-pay/](https://developer.apple.com/apple-pay/) 上列举的测试信用卡\n\n**注意:** 当你切换 iCloud账号，环境自动切换。你还必须在实际生产环境中测试支付。\n\n## 安全和隐私的改进\n\niOS 10 引入了一些修改和补充，帮助你提高你的代码的安全和维护用户数据的隐私。更多关于这方面的内容，详见 [Security](https://developer.apple.com/security/ ) .\n\n- `Info.plist` 文件中新的 `NSAllowsArbitraryLoadsInWebContent` 键，提供了一个便捷的方式来允许任意的 web页面加载任务，同时保留 ATS保护你的 App的其余部分。\n- SecKey API包括不对称密钥生成的改进。使用 SecKey API 替代已经弃用的 CDSA(Common Data Security Architecture: 通用数据安全架构) API。\n- RC4 对称加密套件现在默认禁用所有的 SSL/TLS 连接，以及 SSLv3 不再支持安全传输 API。建议你尽快停止使用  SHA-1和 3DES 加密算法。\n- [UIPasteboard](https://developer.apple.com/reference/uikit/uipasteboard) 类支持剪贴板功能，该功能允许用户设置之间复制和粘贴，包括 API可以用来限制一个纸板到特定设备和设置到达过期时间戳后，纸板被清除。此外，命名过的纸板不再重复出现，取而代之的是，你应该使用共享的容器，以及“发现”纸板（也就是说，纸板被  [UIPasteboardNameFind](https://developer.apple.com/reference/uikit/uipasteboardnamefind)  常数定义）是无效的。\n- 你必须静态声明你的应用程序使用受保护的数据类，通过在 `Info.plist` 文件中包含相关的目的字符串键。例如，你必须包含 [NSCalendarsUsageDescription](https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15) 键来访问用户日历的数据。如果你不包含相关的目的字符串键，当你试图访问相关数据的时候，你的 App会退出。\n\n## CallKit\n\n CallKit 框架 (`CallKit.framework`) 让  VoIP App与 iPhone UI相结合，给用户一个很棒的体验。使用这个框架来让用户在锁屏界面查看和接听到来的 VoIP电话，以及管理手机上 Favorites和 Recents视图上的联系人。\n\nCallKit 还介绍了 App extensions，允许来电拦截并且来电识别。你可以创建一个 App extension，将一个电话号码和一个名称联系起来，或者告诉系统某个号码需要被拦截。\n\n## News Publisher 的改进\n\nNews Publisher 可以使用 Apple News格式，很容易地提供设计精美的新闻，杂志和网络内容给 Apple News。任何人都可以注册，从主要的杂志或者新闻机构，到独立的出版商和博客。开始或学习更多关于最近的更新，访问  [https://newsresources.apple.com](https://newsresources.apple.com/).\n\n## Video Subscriber Account\n\niOS 10 引入  Video Subscriber Account 框架 (`VideoSubscriberAccount.framework`) 来帮助 App支持支持身份验证流或验证视频点播(也称为 TV)与他们的有线或卫星 TV提供商进行身份验证。使用这个框架的 API可以帮助你支持一个单一的登录体验，用户登录一次解锁访问所有的视频应用程序订阅支持。\n\n## App Extensions\n\niOS 10 引入了几个可以创建 App extension的新的 extension points，比如：\n\n- Call Directory\n- Intents\n- Intents UI\n- Messages\n- Notification Content\n- Notification Service\n- Sticker Pack\n\n此外，iOS 10包含了如下的第三方键盘 app extensions的改进：\n\n- 你可以使用 `UITextDocumentProxy`  类中的  `documentInputMode` 属性，来自动检测文档的输入语言，并且改变你的键盘 extension来符合这个语言(如果支持的话)。当你用这种方式决定输入的语言时， 你可以做每一种语言的键盘切换，比如为 Messages内建的。\n- 新的 `handleInputModeListFromView:withEvent:` 方法让键盘 extension 显示系统的键盘选择菜单(即地球标志的菜单).\n\n键盘 extension 必须放置地球标志和系统标志相同的位置。此外，如果你需要提供一个自定义的按键来启动键盘设置，例如，你应该把这个按键放在系统键盘听写键的相同位置。\n\n更多关于 App extensions，详见 [*App Extension Programming Guide*](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214).\n\n","slug":"What's_New_in_iOS_10.0_zh_0","published":1,"updated":"2019-12-23T01:02:31.290Z","comments":1,"photos":[],"link":"","_id":"ck4hqo1nj002mzwlnzzugh9rl","content":"<blockquote>\n<p>由于原文篇幅较长，为了方便阅读，分为上下篇。</p>\n<p>本文是 What’s New in iOS 10.0 中文版的上篇，主要描述了iOS 10新引入的一些新特效，概括了重要的变化。</p>\n<p>在What’s New in iOS 10.0 中文版(下)中，将介绍一些已存在框架的改进以及一些弃用的 API。</p>\n<p>原文链接：<a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW1\" target=\"_blank\" rel=\"external\">What’s New in iOS 10.0</a></p>\n</blockquote>\n<p>这篇文章总结了运行在目前 iOS设备上的 iOS 10中与开发者有关的功能，这篇文章还列出了与这些功能相关的详细文档。</p>\n<a id=\"more\"></a>\n<p>关于目前已知问题的最新新闻和信息，可以查阅 <a href=\"https://developer.apple.com/ios/download/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/ios/download/</a> 。添加到 iOS 10中的 API 的完整列表，详见 <em><a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/iOS10APIDiffs/index.html\" target=\"_blank\" rel=\"external\">iOS 10.0 API Diffs</a></em>。有关新设备的更多信息，详见 <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599\" target=\"_blank\" rel=\"external\">iOS Device Compatibility Reference</a></em>.</p>\n<p>更多关于 Swift,详见 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3\" target=\"_blank\" rel=\"external\">Swift Language</a> and <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097\" target=\"_blank\" rel=\"external\">The Swift Programming Language (Swift 3)</a></em>.</p>\n<h2 id=\"SiriKit\">SiriKit</h2><p>Apps 在特定的领域提供服务，可以使用 SiriKit来在 iOS中通过 Siri使用这些服务。 想要提供这些服务，需要创建一个或多个使用这些意图和意图 UI frameworks的   App extensions(app extensions using the Intents and Intents UI frameworks)。SiriKit提供如下领域的服务：</p>\n<ul>\n<li>音频或视频通话</li>\n<li>消息传递</li>\n<li>发送或接收付款</li>\n<li>搜索照片</li>\n<li>乘坐预定</li>\n<li>管理训练</li>\n</ul>\n<p>当用户发起一个包含了你所提供服务的请求时， SiriKit会向你的 extension发送一个意图对象( intent object )，它描述了用户了请求并且提供了与这个请求相关的所有数据。你使用这个意图对象来提供一个相关的响应对象(response object)，它包含了如何处理用户请求的详情。Siri通常处理所有的用户交互，但是你也可以使用一个 extension来提供自定义 UI，它包含来自你的 App中的品牌或者其他额外信息。</p>\n<p>SiriKit还提供了一个机制，你可以使用它来告诉系统发生在你的 App中的交互和活动。 当你告诉系统这些交互，系统会判断你的 App是否可以处理用户当前的请求，如果可以，就把这个请求传递给你的 App。 除了意图，SiriKit还定义了一个交互对象(interaction object)，它把意图(intent)和意图处理过程(intent-handling process)的信息相结合，包含开始时间和特定事件发生的持续时间等细节。如果你的 App注册为可以处理一个活动，这个活动具有一个相同的名称并且作为一个意图，系统可以启动你的 App，并且携带一个包含了意图的交互对象，即使你没有提供一个意图 App extension。</p>\n<p>Maps和 Siri 都提供乘坐预定，用户也可以使用 Maps来订餐。你的意图 extension处理源于 Maps的交互，同样地它处理来自 Siri的请求。如果你自定义用户界面，你的意图 UI extension还可以自行配置，取决于你的请求是来自 Siri 还是 Maps。</p>\n<p>为了学习如何支持 SiriKit来给用户提供使用服务的新途径，阅读 <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875\" target=\"_blank\" rel=\"external\">SiriKit Programming Guide</a></em>. 当你准备实现处理各种意图的 App extensions，参考 <em><a href=\"https://developer.apple.com/reference/intents\" target=\"_blank\" rel=\"external\">Intents Framework Reference</a></em> 和 <em><a href=\"https://developer.apple.com/reference/intentsui\" target=\"_blank\" rel=\"external\">Intents UI Framework Reference</a></em>.</p>\n<h2 id=\"积极的建议\">积极的建议</h2><p>iOS 10引入了新的方式来来增强与你的 App的交互度(engagement)，通过帮助系统在适当的时机把你的 App推荐给用户。 如果你通过 App搜索你的 iOS 9 App，通过 Spotlight，Safari搜索结果，Handoff以及 Siri建议，允许用户访问你的 App深处的活动(activities)以及内容。 在 iOS 10之后，你可以提供用户在你的 App中做什么的信息，这有助于系统在额外的地方推广你的 App，比如键盘和 QuickType，Maps和 CarPlay，应用切换器(app switcher)，Siri交互和(媒体播放 Apps) 的锁屏界面。这些机会提高与系统的整合，它由一系列的技术支持，比如  <code>NSUserActivity</code>，由 <a href=\"http://schema.org/\" target=\"_blank\" rel=\"external\">Schema.org</a>定义的 Web标记(web markup)，以及定义在 Core Spotlight，MapKit，UIKit，以及 Media Player框架中的 API。.</p>\n<p>在 iOS 10中，<code>NSUserActivity</code> 对象包含  <code>mapItem</code> 属性，该属性允许你提供可以在上下文(other contexts)使用的位置信息。比如，你的 App展示酒店信息，你可以使用 <code>mapItem</code> 属性来保存用户正在浏览的酒店的位置信息，当用户切换到另外一个旅行规划 App，酒店的位置是自动可用的。如果你支持 App搜索，你可以使用 <code>CSSearchableItemAttributeSet</code> 中新的基于文本的地址(text-based address)的属性，比如 <code>thoroughfare</code> 和 <code>postalCode</code>，来指定用户可能想要去的具体位置。注意，当你使用  <code>mapItem</code> 属性，系统自动填充  <code>contentAttributeSet</code>  属性。</p>\n<p>为了与系统共享一个位置，一定要指定 <code>latitude</code> 和 <code>longitude</code> 值，除了 <code>CSSearchableItemAttributeSet</code> 中的地址属性。也建议你提供值给 <code>namedLocation</code>，这样用户可以查看位置的名称，以及  <code>phoneNumbers</code> 属性，以便用户可以使用 Siri来发起呼叫给指定位置。</p>\n<p>在 iOS 9中，将标记添加到你的网站上的结构数据来丰富内容，用户可以在 Spotlight和 Safari搜索结果中看到。在 iOS 10中，你可以使用  <a href=\"http://schema.org/\" target=\"_blank\" rel=\"external\">Schema.org</a> 定义的位置相关词汇，比如 <a href=\"http://schema.org/PostalAddress\" target=\"_blank\" rel=\"external\">PostalAddress</a>，进一步提高用户体验。例如，如果用户查看你网站上描述的一个位置，系统可以在用户切换到 Maps中的时候建议相同的位置。注意 Safari 同时支持 JSON-LD 和 Microdata 编码的 <a href=\"http://schema.org/\" target=\"_blank\" rel=\"external\">Schema.org</a> 词汇。</p>\n<p>UIKit介绍了 <code>UITextInputTraits</code> 协议中的  <code>textContentType</code> 属性，它可以让你指定你希望用户输入文本区域的内容的语义。当你提供这些信息时，系统可以在某些情况下自动选择一个合适的键盘并且提高键盘修正和主动集成来自其他 App或者网站的信息。比如，如果你使用 <code>UITextContentTypeFullStreetAddress</code> 来告诉系统你希望用户在文本区域中输入一个完整的地址，系统可以显示用户最近查看的位置地址。</p>\n<p>如果你的 App播放多媒体并且使用  <code>MPPlayableContentManager</code> APIs， iOS 10 帮你在锁屏界面通过你的 App，使得用户可以查看专辑封面和播放多媒体。</p>\n<p>如果你的骑乘共享(ride-sharing) App使用  <code>MKDirectionsRequest</code> API，iOS 10 可以在用户想要骑行的时候，在应用程序切换器(app switcher)中展示它。想要注册成一个骑行共享提供者，在 <code>Info.plist</code> 文件中设置 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW33\" target=\"_blank\" rel=\"external\">MKDirectionsApplicationSupportedModes</a> 的值为 <code>MKDirectionsModeRideShare</code> 。如果你的 App 只提供骑行共享，系统建议你的 App使用这样开头的文本  “Get a ride to…”；如果你的 App支持骑行共享和其他路由类型（如汽车或摩托车），系统建议你使用这样开头的文本  “Get directions to…”。注意 你收到的 <code>MKMapItem</code> 对象可能不包含经度和纬度信息，需要地理编码。</p>\n<h2 id=\"与_Messages_App_交互\">与 Messages App 交互</h2><p>在 iOS 10中，你可以创建 App extensions 来与 Messages App交互，使得用户可以发送文本，贴纸，媒体文件以及交互式消息。你也可以支持更新为每个收件人响应消息的交互式消息。你还可以创建两种类型的 App extensions:</p>\n<ul>\n<li><p>贴纸包提供一系列的贴纸，用户可以添加到他们的信息内容中。</p>\n</li>\n<li><p><em>iMessage app</em> 让你在 Messages App 中展示一个自定义用户界面，创建一个标签的浏览器，包括一次对话中的文本，贴纸和媒体文件，并且创建，发送和更新消息交互。</p>\n<p> iMessage \u001dApp也可以帮助用户搜索保存在你的 App中相关网站的图片，当它们处在  Messages App 中的时候。</p>\n</li>\n</ul>\n<p>你可以创建一个贴纸包而无需编写任何代码：简单地拖拽图片到 Xcode中贴纸包文件夹内贴纸 asset 目录。</p>\n<p>为了开发一个  iMessage \u001dApp，你可以使用 Messages 框架中的 API (<code>Messages.framework</code>)。更多关于 Messages 框架，详见 <em><a href=\"https://developer.apple.com/reference/messages\" target=\"_blank\" rel=\"external\">Messages Framework Reference</a></em>. 对于创建 App Extensions的普遍信息，详见 <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214\" target=\"_blank\" rel=\"external\">App Extension Programming Guide</a></em>.</p>\n<p>如果你的 App提供图片在 Messages中分享，你想要用户可以使用 Spotlight 的流行图片搜索  (即, “#images”) 来搜索图片，而不用离开 Messages App，首先创建一个 iMessage app。然后遵循下面步骤： </p>\n<ul>\n<li>给你 App 的 entitlements 添加  <code>com.apple.developer.associated-domains</code> 键。包括保存你想要搜索的图片的网站域名的一个列表。对于每个域，指定 <code>spotlight-image-search</code> 服务。</li>\n<li>添加一个 <code>apple-app-site-association</code> 文件到你的网站。为 <code>spotlight-image-search</code> 服务添加一个字典，包含你的 app ID, 它是 team ID 或者 app ID 前缀，后跟  bundle ID。你可以指定多打500个路径和模式，应该包含 Spotlight 流行图片搜索索引。 (关于网站路径的一些实例，详见 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4\" target=\"_blank\" rel=\"external\">Creating and Uploading the Association File</a>).</li>\n<li>允许 Applebot 爬虫 (详见 <a href=\"https://support.apple.com/en-us/HT204683\" target=\"_blank\" rel=\"external\">About Applebot</a>).</li>\n</ul>\n<h2 id=\"用户通知\">用户通知</h2><p>iOS 10 引入了用户通知框架(<code>UserNotifications.framework</code>)，它支持本地和远程通知的发送和处理。你可以使用这个框架的类来安排基于特定条件的本地通知。比如时间或者位置。当它们被发送到用户设备的时候，App 和App extensions 可以使用这个框架来接收和修改本地和远程的通知。</p>\n<p>还介绍了在 iOS 10 中，用户通知 UI框架 (<code>UserNotificationsUI.framework</code>) 允许你自定义显示在用户设备上的本地和远程推送通知。你使用这个框架来定义一个接收通知数据并且提供相应可视化表示的 App extension 。这个 extension也可以响应相关的自定义动作和通知。 </p>\n<h2 id=\"语音识别\">语音识别</h2><p>iOS 10 引入了一个新的 API，支持连续语音识别和帮助你构建支持语音识别并且转换成文本的 App。使用  Speech 框架 (<code>Speech.framework</code>) 中的 API，你可以执行实时语音转录和记录音频。例如，你可以得到一个语音识别器，开始简单的语音识别，代码如下所示： </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> recognizer = <span class=\"type\">SFSpeechRecognizer</span>()</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">SFSpeechURLRecognitionRequest</span>(url: audioFileURL)</span><br><span class=\"line\">recognizer?.recognitionTask(with: request, resultHandler: &#123; (result, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">     <span class=\"built_in\">print</span> (result?.bestTranscription.formattedString)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>与访问其他类型的受保护数据一样，如日历，照片资料，进行语音识别需要用户的授权 (更多关于访问受保护的数据类，详见<a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3\" target=\"_blank\" rel=\"external\">Security and Privacy Enhancements</a>)。在语音识别的情况下，许可是必需的，因为数据被传递，并且暂时存储在苹果的服务器上，以提高语音识别的准确性。请求用户的权限，必须在 <code>Info.plist</code> 文件中添加<code>NSSpeechRecognitionUsageDescription</code>  键。</p>\n<p>当你在你的 App中采用语音识别，一定要向用户表明他们的语音将被识别，并且他们不应该使用敏感话语。</p>\n<h2 id=\"广泛的颜色\">广泛的颜色</h2><p>贯穿系统的大多数图形框架，包括 Core Graphics, Core Image, Metal, 和 AVFoundation, 有大幅的改进来支持 extended-range 像素格式和 wide-gamut 颜色空间。通过将此行为扩展到整个图形栈中，它比以往任何时间更容易支持具有宽颜色显示的设备。此外，UIKit 使在新扩展的 sRGB颜色空间上工作标准化，因此很容易混合 sRGB和其他颜色，更广泛的色域没有明显的性能损失。</p>\n<p>这里有一些你开始使用广泛颜色的最佳实践。</p>\n<ul>\n<li>\b在 iOS 10 中，<a href=\"https://developer.apple.com/reference/uikit/uicolor\" target=\"_blank\" rel=\"external\">UIColor</a> 类使用扩展的 sRGB 颜色空间，并且它的构造器(initializers)不再限制初始值在  <code>0.0</code> 和 <code>1.0</code> 之间。如果你的应用程序依赖于 UIKit来限制组件(component)值 (无论你是创建一个颜色或者一个颜色的组件值)，当你链接到 iOS 10的时候，你需要改变这些行为。 </li>\n<li>当在 iPad Pro (9.7 inch) 的  <a href=\"https://developer.apple.com/reference/uikit/uiview\" target=\"_blank\" rel=\"external\">UIView</a> 上执行自定义的绘制时，底层的绘图环境配置了一个扩展的 sRGB颜色空间。</li>\n<li>如果你的 App 渲染自定义的图像对象，使用新的  <a href=\"https://developer.apple.com/reference/uikit/uigraphicsimagerenderer\" target=\"_blank\" rel=\"external\">UIGraphicsImageRenderer</a> 类来控制目标位图是使用扩展范围(extended-range)还是标准范围 (standard-range) 格式。</li>\n<li>如果你使用较低级别的 API，比如 Core Graphics 和 Metal来执行你自己的图像处理，你需要使用一个扩展的颜色空间和一个支持16位浮点值的像素格式的组件值。当限制颜色值是必要的时候，你应该明确这样做。</li>\n<li>Core Graphics, Core Image,以及 Metal 性能着色器提供了新的选择，可以在颜色空间之间轻松转换颜色和图像。</li>\n</ul>\n<h2 id=\"适应真实的色调显示\">适应真实的色调显示</h2><p>真实的色调显示使用环境光传感器自动调整显示器的颜色和强度，以配合当前环境的照明条件。为了确保你的 App可以与真实的色调提供的标准颜色变化很好的工作，在 <code>Info.plist</code> 中添加新的 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31\" target=\"_blank\" rel=\"external\">UIWhitePointAdaptivityStyle</a> 键来描述你的 App的主要视觉内容。比如： </p>\n<ul>\n<li>如果你的 App是一个照片编辑应用，颜色的准确性(fidelity)比自动调整环境白点(white point)更重要。在这种情况下，你可以使用 <code>UIWhitePointAdaptivityStylePhoto</code> 方式来降低系统提供的真实色调变化的强度。</li>\n<li>如果你的 App是一个阅读应用，符合环境白点将为用户提供帮助。在这种情况下，你可以使用 <code>UIWhitePointAdaptivityStyleReading</code> 方式来加强系统提供的真实色调变化的强度。</li>\n</ul>\n<h2 id=\"App搜索_的改进\">App搜索 的改进</h2><p>iOS 10 和 Core Spotlight框架介绍了几个 App搜索的改进点： </p>\n<ul>\n<li>应用内(In-app)搜索</li>\n<li>继续搜索(Search continuation)</li>\n<li>众包(crowdsourcing:是互联网带来的新的生产组织形式)与差分隐私(differential privacy)的深度链接</li>\n<li>可视化的验证结果</li>\n</ul>\n<p>新的 <code>CSSearchQuery</code> 类支持应用内内容搜索，使用现有的 Core Spotlight APIs。使用这个 API可以消除需要保持你自己单独的搜索索引，让你发挥 Spotlight的强大搜索技术和匹配规则，允许用户搜索内容不离开你的 App，就像他们在 Mail, Messages,和 Notes.</p>\n<p>在 iOS 9中，使用搜索 API(比如 Core Spotlight, <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity\" target=\"_blank\" rel=\"external\">NSUserActivity</a> 和 web标记) 在你的 App中，让用户使用Spotlight 和 Safari搜索界面来搜索索引的内容。在 iOS 10中，你可以使用新的 Core Spotlight 符号，当用户打开你的 App时候，用户可以继续使用 Spotlight进行搜索。要启用这个功能，在 <code>Info.plist</code> 文件中添加 <code>CoreSpotlightContinuation</code> 键，并且设置它的值为  <code>YES</code>，然后更新你的代码来处理一个  <a href=\"https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype\" target=\"_blank\" rel=\"external\">CSQueryContinuationActionType</a> 类型的活动延续。在  <a href=\"https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application\" target=\"_blank\" rel=\"external\">application:continueUserActivity:restorationHandler:</a> 方法中收到的 <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity\" target=\"_blank\" rel=\"external\">NSUserActivity</a> 对象中的用户信息字典包含了 <a href=\"https://developer.apple.com/reference/corespotlight/cssearchquerystring\" target=\"_blank\" rel=\"external\">CSSearchQueryString</a> 键，它的值是一个字符串，表示用户的查询。</p>\n<p>iOS 10 引入了一个不同的私人方式来帮助提高你的 App的内容在搜索结果中的排名。 iOS 提交一部分差分隐私到 Apple的服务器随着用户使用你的 App 以及  <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity\" target=\"_blank\" rel=\"external\">NSUserActivity</a> 对象包含深度链接地址并且它们的 <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity/1414701-eligibleforpublicindexing\" target=\"_blank\" rel=\"external\">eligibleForPublicIndexing</a> 属性设置为  <code>YES</code> 被提交到 iOS中。差分隐形散列允许 Apple统计流行的深度链接的频率，而不曾与用户关联的链接进行访问。</p>\n<p>当你使用 App 搜索 API 验证工具来测试你的网站标记和深度链接，现在展示你的结果的可视化表示，包括支持的标记，比如  <a href=\"http://schema.org/\" target=\"_blank\" rel=\"external\">Schema.org</a> 中定义的。验证工具可以帮你看到 Applebot web爬虫索引信息，比如标题，描述，URL和其他支持的元素。你可以在这里获取这个验证工具： <a href=\"https://search.developer.apple.com/appsearch-validation-tool\" target=\"_blank\" rel=\"external\">https://search.developer.apple.com/appsearch-validation-tool</a>. 更多关于支持深度链接和添加标记，详见： <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8\" target=\"_blank\" rel=\"external\">Mark Up Web Content</a>.</p>\n<p>学习如何让你的网站中的图片在 Messages App内可搜索，详见 <a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4\" target=\"_blank\" rel=\"external\">Integrating with the Messages App</a>.</p>\n<h2 id=\"Widget_的改进\">Widget 的改进</h2><p>iOS 10 为锁屏界面引入了一个新的设计，现在可以显示 widgets。为了保证你的 widget 在任何背景下看起来都不错，你可以适当地设置 <a href=\"https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect\" target=\"_blank\" rel=\"external\">widgetPrimaryVibrancyEffect</a> 或者 <a href=\"https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect\" target=\"_blank\" rel=\"external\">widgetSecondaryVibrancyEffect</a>(使用这些属性取代已废弃的 <a href=\"https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect\" target=\"_blank\" rel=\"external\">notificationCenterVibrancyEffect</a> 属性)。此外， widgets现在包括显示模式(由 <a href=\"https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode\" target=\"_blank\" rel=\"external\">NCWidgetDisplayMode</a> 表示)的概念，它可以让你描述有多少内容是可用的，并允许用户选择一个紧凑或者扩展型的视图。 </p>\n<h2 id=\"Apple_Pay_的改进\">Apple Pay 的改进</h2><p>在 iOS 10中，用户可以通过 Siri和 Maps使用网页版的 Apple Pay 来便捷安全的完成支付。对于开发者来说， iOS 10 引入了新的 API，你可以在代码中使用运行在 iOS和  watchOS上，支持动态支付网络的能力和一个新的沙盒测试环境。</p>\n<p>iOS 10 引入了新的 API，帮助你将 Apple Pay 直接引入你的网站。当你在你的网站支持 Apple Pay，用户在 iOS或者 OS X上通过 Safari浏览的时候，可以通过它们的 iPhone或 Apple Watch来使用 Apple Pay上的信用卡进行支付。 详见 <a href=\"https://developer.apple.com/reference/applepayjs\" target=\"_blank\" rel=\"external\"><em>ApplePay JS Framework Reference</em></a>.</p>\n<p> PassKit框架 (<code>PassKit.framework</code>) 介绍了让你在 UIKit不可用的地方支持 Apple Pay的 API。具体来说， <a href=\"https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontroller\" target=\"_blank\" rel=\"external\">PKPaymentAuthorizationController</a> 和 <a href=\"https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontrollerdelegate\" target=\"_blank\" rel=\"external\">PKPaymentAuthorizationControllerDelegate</a> 使得  <a href=\"https://developer.apple.com/reference/passkit/pkpaymentauthorizationviewcontroller\" target=\"_blank\" rel=\"external\">PKPaymentAuthorizationViewController</a> 提供的功能以及它的 delegate 可用，而不需要 UIKit。尽管新的 API 需要在特定的意图下在 watchOS上提供 Apple Pay，还是建议你在代码的任何地方采用它。这样你就可以用一套基础代码来广泛提供 Apple Pay支持。(更多关于意图和 Siri集成，详见 <a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5\" target=\"_blank\" rel=\"external\">SiriKit</a>.)</p>\n<p> PassKit 框架还增加了新的功能，让信用卡发行机构在它们的 App中展示他们的信用卡。具体来说， <code>PKPaymentButtonTypeInStore</code> 按钮类型允许你为信用卡展示一个 Apple Pay 按钮，  <code>presentPaymentPass:</code> 方法允许你以编程方式展示信用卡。 ( <code>presentPaymentPass:</code> 方法定义在  <a href=\"https://developer.apple.com/reference/passkit/pkpasslibrary\" target=\"_blank\" rel=\"external\">PKPassLibrary</a>中)。</p>\n<p>当一个新的支付网络可用时，你的 App可用自动支持新的网络，而不需要修改和重新编译你的 App。<a href=\"https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks\" target=\"_blank\" rel=\"external\">availableNetworks</a> 方法允许你在运行时发现用户设备可用的网络。此外， <a href=\"https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks\" target=\"_blank\" rel=\"external\">supportedNetworks</a> 属性被扩展了，以便可以携带一些支付服务提供商的名字作为参数。然后你的 App自动支持任何支付提供商支持的网络。详见<a href=\"https://developer.apple.com/apple-pay/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/apple-pay/</a>.</p>\n<p>iOS 10 引入了一个新的测试环境，它允许你直接在设备上提供测试信用卡。测试环境返回加密后的测试支付数据。要使用这种环境，遵循以下步骤：</p>\n<ol>\n<li>在 iTunes Connect上创建一个测试 iCloud账号</li>\n<li>在你的设备上登录该账号</li>\n<li>设置测试所需的区域</li>\n<li>使用 <a href=\"https://developer.apple.com/apple-pay/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/apple-pay/</a> 上列举的测试信用卡</li>\n</ol>\n<p><strong>注意:</strong> 当你切换 iCloud账号，环境自动切换。你还必须在实际生产环境中测试支付。</p>\n<h2 id=\"安全和隐私的改进\">安全和隐私的改进</h2><p>iOS 10 引入了一些修改和补充，帮助你提高你的代码的安全和维护用户数据的隐私。更多关于这方面的内容，详见 <a href=\"https://developer.apple.com/security/\" target=\"_blank\" rel=\"external\">Security</a> .</p>\n<ul>\n<li><code>Info.plist</code> 文件中新的 <code>NSAllowsArbitraryLoadsInWebContent</code> 键，提供了一个便捷的方式来允许任意的 web页面加载任务，同时保留 ATS保护你的 App的其余部分。</li>\n<li>SecKey API包括不对称密钥生成的改进。使用 SecKey API 替代已经弃用的 CDSA(Common Data Security Architecture: 通用数据安全架构) API。</li>\n<li>RC4 对称加密套件现在默认禁用所有的 SSL/TLS 连接，以及 SSLv3 不再支持安全传输 API。建议你尽快停止使用  SHA-1和 3DES 加密算法。</li>\n<li><a href=\"https://developer.apple.com/reference/uikit/uipasteboard\" target=\"_blank\" rel=\"external\">UIPasteboard</a> 类支持剪贴板功能，该功能允许用户设置之间复制和粘贴，包括 API可以用来限制一个纸板到特定设备和设置到达过期时间戳后，纸板被清除。此外，命名过的纸板不再重复出现，取而代之的是，你应该使用共享的容器，以及“发现”纸板（也就是说，纸板被  <a href=\"https://developer.apple.com/reference/uikit/uipasteboardnamefind\" target=\"_blank\" rel=\"external\">UIPasteboardNameFind</a>  常数定义）是无效的。</li>\n<li>你必须静态声明你的应用程序使用受保护的数据类，通过在 <code>Info.plist</code> 文件中包含相关的目的字符串键。例如，你必须包含 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15\" target=\"_blank\" rel=\"external\">NSCalendarsUsageDescription</a> 键来访问用户日历的数据。如果你不包含相关的目的字符串键，当你试图访问相关数据的时候，你的 App会退出。</li>\n</ul>\n<h2 id=\"CallKit\">CallKit</h2><p> CallKit 框架 (<code>CallKit.framework</code>) 让  VoIP App与 iPhone UI相结合，给用户一个很棒的体验。使用这个框架来让用户在锁屏界面查看和接听到来的 VoIP电话，以及管理手机上 Favorites和 Recents视图上的联系人。</p>\n<p>CallKit 还介绍了 App extensions，允许来电拦截并且来电识别。你可以创建一个 App extension，将一个电话号码和一个名称联系起来，或者告诉系统某个号码需要被拦截。</p>\n<h2 id=\"News_Publisher_的改进\">News Publisher 的改进</h2><p>News Publisher 可以使用 Apple News格式，很容易地提供设计精美的新闻，杂志和网络内容给 Apple News。任何人都可以注册，从主要的杂志或者新闻机构，到独立的出版商和博客。开始或学习更多关于最近的更新，访问  <a href=\"https://newsresources.apple.com/\" target=\"_blank\" rel=\"external\">https://newsresources.apple.com</a>.</p>\n<h2 id=\"Video_Subscriber_Account\">Video Subscriber Account</h2><p>iOS 10 引入  Video Subscriber Account 框架 (<code>VideoSubscriberAccount.framework</code>) 来帮助 App支持支持身份验证流或验证视频点播(也称为 TV)与他们的有线或卫星 TV提供商进行身份验证。使用这个框架的 API可以帮助你支持一个单一的登录体验，用户登录一次解锁访问所有的视频应用程序订阅支持。</p>\n<h2 id=\"App_Extensions\">App Extensions</h2><p>iOS 10 引入了几个可以创建 App extension的新的 extension points，比如：</p>\n<ul>\n<li>Call Directory</li>\n<li>Intents</li>\n<li>Intents UI</li>\n<li>Messages</li>\n<li>Notification Content</li>\n<li>Notification Service</li>\n<li>Sticker Pack</li>\n</ul>\n<p>此外，iOS 10包含了如下的第三方键盘 app extensions的改进：</p>\n<ul>\n<li>你可以使用 <code>UITextDocumentProxy</code>  类中的  <code>documentInputMode</code> 属性，来自动检测文档的输入语言，并且改变你的键盘 extension来符合这个语言(如果支持的话)。当你用这种方式决定输入的语言时， 你可以做每一种语言的键盘切换，比如为 Messages内建的。</li>\n<li>新的 <code>handleInputModeListFromView:withEvent:</code> 方法让键盘 extension 显示系统的键盘选择菜单(即地球标志的菜单).</li>\n</ul>\n<p>键盘 extension 必须放置地球标志和系统标志相同的位置。此外，如果你需要提供一个自定义的按键来启动键盘设置，例如，你应该把这个按键放在系统键盘听写键的相同位置。</p>\n<p>更多关于 App extensions，详见 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214\" target=\"_blank\" rel=\"external\"><em>App Extension Programming Guide</em></a>.</p>\n","excerpt":"<blockquote>\n<p>由于原文篇幅较长，为了方便阅读，分为上下篇。</p>\n<p>本文是 What’s New in iOS 10.0 中文版的上篇，主要描述了iOS 10新引入的一些新特效，概括了重要的变化。</p>\n<p>在What’s New in iOS 10.0 中文版(下)中，将介绍一些已存在框架的改进以及一些弃用的 API。</p>\n<p>原文链接：<a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW1\">What’s New in iOS 10.0</a></p>\n</blockquote>\n<p>这篇文章总结了运行在目前 iOS设备上的 iOS 10中与开发者有关的功能，这篇文章还列出了与这些功能相关的详细文档。</p>","more":"<p>关于目前已知问题的最新新闻和信息，可以查阅 <a href=\"https://developer.apple.com/ios/download/\">https://developer.apple.com/ios/download/</a> 。添加到 iOS 10中的 API 的完整列表，详见 <em><a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/iOS10APIDiffs/index.html\">iOS 10.0 API Diffs</a></em>。有关新设备的更多信息，详见 <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599\">iOS Device Compatibility Reference</a></em>.</p>\n<p>更多关于 Swift,详见 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3\">Swift Language</a> and <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097\">The Swift Programming Language (Swift 3)</a></em>.</p>\n<h2 id=\"SiriKit\">SiriKit</h2><p>Apps 在特定的领域提供服务，可以使用 SiriKit来在 iOS中通过 Siri使用这些服务。 想要提供这些服务，需要创建一个或多个使用这些意图和意图 UI frameworks的   App extensions(app extensions using the Intents and Intents UI frameworks)。SiriKit提供如下领域的服务：</p>\n<ul>\n<li>音频或视频通话</li>\n<li>消息传递</li>\n<li>发送或接收付款</li>\n<li>搜索照片</li>\n<li>乘坐预定</li>\n<li>管理训练</li>\n</ul>\n<p>当用户发起一个包含了你所提供服务的请求时， SiriKit会向你的 extension发送一个意图对象( intent object )，它描述了用户了请求并且提供了与这个请求相关的所有数据。你使用这个意图对象来提供一个相关的响应对象(response object)，它包含了如何处理用户请求的详情。Siri通常处理所有的用户交互，但是你也可以使用一个 extension来提供自定义 UI，它包含来自你的 App中的品牌或者其他额外信息。</p>\n<p>SiriKit还提供了一个机制，你可以使用它来告诉系统发生在你的 App中的交互和活动。 当你告诉系统这些交互，系统会判断你的 App是否可以处理用户当前的请求，如果可以，就把这个请求传递给你的 App。 除了意图，SiriKit还定义了一个交互对象(interaction object)，它把意图(intent)和意图处理过程(intent-handling process)的信息相结合，包含开始时间和特定事件发生的持续时间等细节。如果你的 App注册为可以处理一个活动，这个活动具有一个相同的名称并且作为一个意图，系统可以启动你的 App，并且携带一个包含了意图的交互对象，即使你没有提供一个意图 App extension。</p>\n<p>Maps和 Siri 都提供乘坐预定，用户也可以使用 Maps来订餐。你的意图 extension处理源于 Maps的交互，同样地它处理来自 Siri的请求。如果你自定义用户界面，你的意图 UI extension还可以自行配置，取决于你的请求是来自 Siri 还是 Maps。</p>\n<p>为了学习如何支持 SiriKit来给用户提供使用服务的新途径，阅读 <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875\">SiriKit Programming Guide</a></em>. 当你准备实现处理各种意图的 App extensions，参考 <em><a href=\"https://developer.apple.com/reference/intents\">Intents Framework Reference</a></em> 和 <em><a href=\"https://developer.apple.com/reference/intentsui\">Intents UI Framework Reference</a></em>.</p>\n<h2 id=\"积极的建议\">积极的建议</h2><p>iOS 10引入了新的方式来来增强与你的 App的交互度(engagement)，通过帮助系统在适当的时机把你的 App推荐给用户。 如果你通过 App搜索你的 iOS 9 App，通过 Spotlight，Safari搜索结果，Handoff以及 Siri建议，允许用户访问你的 App深处的活动(activities)以及内容。 在 iOS 10之后，你可以提供用户在你的 App中做什么的信息，这有助于系统在额外的地方推广你的 App，比如键盘和 QuickType，Maps和 CarPlay，应用切换器(app switcher)，Siri交互和(媒体播放 Apps) 的锁屏界面。这些机会提高与系统的整合，它由一系列的技术支持，比如  <code>NSUserActivity</code>，由 <a href=\"http://schema.org/\">Schema.org</a>定义的 Web标记(web markup)，以及定义在 Core Spotlight，MapKit，UIKit，以及 Media Player框架中的 API。.</p>\n<p>在 iOS 10中，<code>NSUserActivity</code> 对象包含  <code>mapItem</code> 属性，该属性允许你提供可以在上下文(other contexts)使用的位置信息。比如，你的 App展示酒店信息，你可以使用 <code>mapItem</code> 属性来保存用户正在浏览的酒店的位置信息，当用户切换到另外一个旅行规划 App，酒店的位置是自动可用的。如果你支持 App搜索，你可以使用 <code>CSSearchableItemAttributeSet</code> 中新的基于文本的地址(text-based address)的属性，比如 <code>thoroughfare</code> 和 <code>postalCode</code>，来指定用户可能想要去的具体位置。注意，当你使用  <code>mapItem</code> 属性，系统自动填充  <code>contentAttributeSet</code>  属性。</p>\n<p>为了与系统共享一个位置，一定要指定 <code>latitude</code> 和 <code>longitude</code> 值，除了 <code>CSSearchableItemAttributeSet</code> 中的地址属性。也建议你提供值给 <code>namedLocation</code>，这样用户可以查看位置的名称，以及  <code>phoneNumbers</code> 属性，以便用户可以使用 Siri来发起呼叫给指定位置。</p>\n<p>在 iOS 9中，将标记添加到你的网站上的结构数据来丰富内容，用户可以在 Spotlight和 Safari搜索结果中看到。在 iOS 10中，你可以使用  <a href=\"http://schema.org/\">Schema.org</a> 定义的位置相关词汇，比如 <a href=\"http://schema.org/PostalAddress\">PostalAddress</a>，进一步提高用户体验。例如，如果用户查看你网站上描述的一个位置，系统可以在用户切换到 Maps中的时候建议相同的位置。注意 Safari 同时支持 JSON-LD 和 Microdata 编码的 <a href=\"http://schema.org/\">Schema.org</a> 词汇。</p>\n<p>UIKit介绍了 <code>UITextInputTraits</code> 协议中的  <code>textContentType</code> 属性，它可以让你指定你希望用户输入文本区域的内容的语义。当你提供这些信息时，系统可以在某些情况下自动选择一个合适的键盘并且提高键盘修正和主动集成来自其他 App或者网站的信息。比如，如果你使用 <code>UITextContentTypeFullStreetAddress</code> 来告诉系统你希望用户在文本区域中输入一个完整的地址，系统可以显示用户最近查看的位置地址。</p>\n<p>如果你的 App播放多媒体并且使用  <code>MPPlayableContentManager</code> APIs， iOS 10 帮你在锁屏界面通过你的 App，使得用户可以查看专辑封面和播放多媒体。</p>\n<p>如果你的骑乘共享(ride-sharing) App使用  <code>MKDirectionsRequest</code> API，iOS 10 可以在用户想要骑行的时候，在应用程序切换器(app switcher)中展示它。想要注册成一个骑行共享提供者，在 <code>Info.plist</code> 文件中设置 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW33\">MKDirectionsApplicationSupportedModes</a> 的值为 <code>MKDirectionsModeRideShare</code> 。如果你的 App 只提供骑行共享，系统建议你的 App使用这样开头的文本  “Get a ride to…”；如果你的 App支持骑行共享和其他路由类型（如汽车或摩托车），系统建议你使用这样开头的文本  “Get directions to…”。注意 你收到的 <code>MKMapItem</code> 对象可能不包含经度和纬度信息，需要地理编码。</p>\n<h2 id=\"与_Messages_App_交互\">与 Messages App 交互</h2><p>在 iOS 10中，你可以创建 App extensions 来与 Messages App交互，使得用户可以发送文本，贴纸，媒体文件以及交互式消息。你也可以支持更新为每个收件人响应消息的交互式消息。你还可以创建两种类型的 App extensions:</p>\n<ul>\n<li><p>贴纸包提供一系列的贴纸，用户可以添加到他们的信息内容中。</p>\n</li>\n<li><p><em>iMessage app</em> 让你在 Messages App 中展示一个自定义用户界面，创建一个标签的浏览器，包括一次对话中的文本，贴纸和媒体文件，并且创建，发送和更新消息交互。</p>\n<p> iMessage \u001dApp也可以帮助用户搜索保存在你的 App中相关网站的图片，当它们处在  Messages App 中的时候。</p>\n</li>\n</ul>\n<p>你可以创建一个贴纸包而无需编写任何代码：简单地拖拽图片到 Xcode中贴纸包文件夹内贴纸 asset 目录。</p>\n<p>为了开发一个  iMessage \u001dApp，你可以使用 Messages 框架中的 API (<code>Messages.framework</code>)。更多关于 Messages 框架，详见 <em><a href=\"https://developer.apple.com/reference/messages\">Messages Framework Reference</a></em>. 对于创建 App Extensions的普遍信息，详见 <em><a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214\">App Extension Programming Guide</a></em>.</p>\n<p>如果你的 App提供图片在 Messages中分享，你想要用户可以使用 Spotlight 的流行图片搜索  (即, “#images”) 来搜索图片，而不用离开 Messages App，首先创建一个 iMessage app。然后遵循下面步骤： </p>\n<ul>\n<li>给你 App 的 entitlements 添加  <code>com.apple.developer.associated-domains</code> 键。包括保存你想要搜索的图片的网站域名的一个列表。对于每个域，指定 <code>spotlight-image-search</code> 服务。</li>\n<li>添加一个 <code>apple-app-site-association</code> 文件到你的网站。为 <code>spotlight-image-search</code> 服务添加一个字典，包含你的 app ID, 它是 team ID 或者 app ID 前缀，后跟  bundle ID。你可以指定多打500个路径和模式，应该包含 Spotlight 流行图片搜索索引。 (关于网站路径的一些实例，详见 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4\">Creating and Uploading the Association File</a>).</li>\n<li>允许 Applebot 爬虫 (详见 <a href=\"https://support.apple.com/en-us/HT204683\">About Applebot</a>).</li>\n</ul>\n<h2 id=\"用户通知\">用户通知</h2><p>iOS 10 引入了用户通知框架(<code>UserNotifications.framework</code>)，它支持本地和远程通知的发送和处理。你可以使用这个框架的类来安排基于特定条件的本地通知。比如时间或者位置。当它们被发送到用户设备的时候，App 和App extensions 可以使用这个框架来接收和修改本地和远程的通知。</p>\n<p>还介绍了在 iOS 10 中，用户通知 UI框架 (<code>UserNotificationsUI.framework</code>) 允许你自定义显示在用户设备上的本地和远程推送通知。你使用这个框架来定义一个接收通知数据并且提供相应可视化表示的 App extension 。这个 extension也可以响应相关的自定义动作和通知。 </p>\n<h2 id=\"语音识别\">语音识别</h2><p>iOS 10 引入了一个新的 API，支持连续语音识别和帮助你构建支持语音识别并且转换成文本的 App。使用  Speech 框架 (<code>Speech.framework</code>) 中的 API，你可以执行实时语音转录和记录音频。例如，你可以得到一个语音识别器，开始简单的语音识别，代码如下所示： </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> recognizer = <span class=\"type\">SFSpeechRecognizer</span>()</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">SFSpeechURLRecognitionRequest</span>(url: audioFileURL)</span><br><span class=\"line\">recognizer?.recognitionTask(with: request, resultHandler: &#123; (result, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">     <span class=\"built_in\">print</span> (result?.bestTranscription.formattedString)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>与访问其他类型的受保护数据一样，如日历，照片资料，进行语音识别需要用户的授权 (更多关于访问受保护的数据类，详见<a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3\">Security and Privacy Enhancements</a>)。在语音识别的情况下，许可是必需的，因为数据被传递，并且暂时存储在苹果的服务器上，以提高语音识别的准确性。请求用户的权限，必须在 <code>Info.plist</code> 文件中添加<code>NSSpeechRecognitionUsageDescription</code>  键。</p>\n<p>当你在你的 App中采用语音识别，一定要向用户表明他们的语音将被识别，并且他们不应该使用敏感话语。</p>\n<h2 id=\"广泛的颜色\">广泛的颜色</h2><p>贯穿系统的大多数图形框架，包括 Core Graphics, Core Image, Metal, 和 AVFoundation, 有大幅的改进来支持 extended-range 像素格式和 wide-gamut 颜色空间。通过将此行为扩展到整个图形栈中，它比以往任何时间更容易支持具有宽颜色显示的设备。此外，UIKit 使在新扩展的 sRGB颜色空间上工作标准化，因此很容易混合 sRGB和其他颜色，更广泛的色域没有明显的性能损失。</p>\n<p>这里有一些你开始使用广泛颜色的最佳实践。</p>\n<ul>\n<li>\b在 iOS 10 中，<a href=\"https://developer.apple.com/reference/uikit/uicolor\">UIColor</a> 类使用扩展的 sRGB 颜色空间，并且它的构造器(initializers)不再限制初始值在  <code>0.0</code> 和 <code>1.0</code> 之间。如果你的应用程序依赖于 UIKit来限制组件(component)值 (无论你是创建一个颜色或者一个颜色的组件值)，当你链接到 iOS 10的时候，你需要改变这些行为。 </li>\n<li>当在 iPad Pro (9.7 inch) 的  <a href=\"https://developer.apple.com/reference/uikit/uiview\">UIView</a> 上执行自定义的绘制时，底层的绘图环境配置了一个扩展的 sRGB颜色空间。</li>\n<li>如果你的 App 渲染自定义的图像对象，使用新的  <a href=\"https://developer.apple.com/reference/uikit/uigraphicsimagerenderer\">UIGraphicsImageRenderer</a> 类来控制目标位图是使用扩展范围(extended-range)还是标准范围 (standard-range) 格式。</li>\n<li>如果你使用较低级别的 API，比如 Core Graphics 和 Metal来执行你自己的图像处理，你需要使用一个扩展的颜色空间和一个支持16位浮点值的像素格式的组件值。当限制颜色值是必要的时候，你应该明确这样做。</li>\n<li>Core Graphics, Core Image,以及 Metal 性能着色器提供了新的选择，可以在颜色空间之间轻松转换颜色和图像。</li>\n</ul>\n<h2 id=\"适应真实的色调显示\">适应真实的色调显示</h2><p>真实的色调显示使用环境光传感器自动调整显示器的颜色和强度，以配合当前环境的照明条件。为了确保你的 App可以与真实的色调提供的标准颜色变化很好的工作，在 <code>Info.plist</code> 中添加新的 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31\">UIWhitePointAdaptivityStyle</a> 键来描述你的 App的主要视觉内容。比如： </p>\n<ul>\n<li>如果你的 App是一个照片编辑应用，颜色的准确性(fidelity)比自动调整环境白点(white point)更重要。在这种情况下，你可以使用 <code>UIWhitePointAdaptivityStylePhoto</code> 方式来降低系统提供的真实色调变化的强度。</li>\n<li>如果你的 App是一个阅读应用，符合环境白点将为用户提供帮助。在这种情况下，你可以使用 <code>UIWhitePointAdaptivityStyleReading</code> 方式来加强系统提供的真实色调变化的强度。</li>\n</ul>\n<h2 id=\"App搜索_的改进\">App搜索 的改进</h2><p>iOS 10 和 Core Spotlight框架介绍了几个 App搜索的改进点： </p>\n<ul>\n<li>应用内(In-app)搜索</li>\n<li>继续搜索(Search continuation)</li>\n<li>众包(crowdsourcing:是互联网带来的新的生产组织形式)与差分隐私(differential privacy)的深度链接</li>\n<li>可视化的验证结果</li>\n</ul>\n<p>新的 <code>CSSearchQuery</code> 类支持应用内内容搜索，使用现有的 Core Spotlight APIs。使用这个 API可以消除需要保持你自己单独的搜索索引，让你发挥 Spotlight的强大搜索技术和匹配规则，允许用户搜索内容不离开你的 App，就像他们在 Mail, Messages,和 Notes.</p>\n<p>在 iOS 9中，使用搜索 API(比如 Core Spotlight, <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity\">NSUserActivity</a> 和 web标记) 在你的 App中，让用户使用Spotlight 和 Safari搜索界面来搜索索引的内容。在 iOS 10中，你可以使用新的 Core Spotlight 符号，当用户打开你的 App时候，用户可以继续使用 Spotlight进行搜索。要启用这个功能，在 <code>Info.plist</code> 文件中添加 <code>CoreSpotlightContinuation</code> 键，并且设置它的值为  <code>YES</code>，然后更新你的代码来处理一个  <a href=\"https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype\">CSQueryContinuationActionType</a> 类型的活动延续。在  <a href=\"https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application\">application:continueUserActivity:restorationHandler:</a> 方法中收到的 <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity\">NSUserActivity</a> 对象中的用户信息字典包含了 <a href=\"https://developer.apple.com/reference/corespotlight/cssearchquerystring\">CSSearchQueryString</a> 键，它的值是一个字符串，表示用户的查询。</p>\n<p>iOS 10 引入了一个不同的私人方式来帮助提高你的 App的内容在搜索结果中的排名。 iOS 提交一部分差分隐私到 Apple的服务器随着用户使用你的 App 以及  <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity\">NSUserActivity</a> 对象包含深度链接地址并且它们的 <a href=\"https://developer.apple.com/reference/foundation/nsuseractivity/1414701-eligibleforpublicindexing\">eligibleForPublicIndexing</a> 属性设置为  <code>YES</code> 被提交到 iOS中。差分隐形散列允许 Apple统计流行的深度链接的频率，而不曾与用户关联的链接进行访问。</p>\n<p>当你使用 App 搜索 API 验证工具来测试你的网站标记和深度链接，现在展示你的结果的可视化表示，包括支持的标记，比如  <a href=\"http://schema.org/\">Schema.org</a> 中定义的。验证工具可以帮你看到 Applebot web爬虫索引信息，比如标题，描述，URL和其他支持的元素。你可以在这里获取这个验证工具： <a href=\"https://search.developer.apple.com/appsearch-validation-tool\">https://search.developer.apple.com/appsearch-validation-tool</a>. 更多关于支持深度链接和添加标记，详见： <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8\">Mark Up Web Content</a>.</p>\n<p>学习如何让你的网站中的图片在 Messages App内可搜索，详见 <a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4\">Integrating with the Messages App</a>.</p>\n<h2 id=\"Widget_的改进\">Widget 的改进</h2><p>iOS 10 为锁屏界面引入了一个新的设计，现在可以显示 widgets。为了保证你的 widget 在任何背景下看起来都不错，你可以适当地设置 <a href=\"https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect\">widgetPrimaryVibrancyEffect</a> 或者 <a href=\"https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect\">widgetSecondaryVibrancyEffect</a>(使用这些属性取代已废弃的 <a href=\"https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect\">notificationCenterVibrancyEffect</a> 属性)。此外， widgets现在包括显示模式(由 <a href=\"https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode\">NCWidgetDisplayMode</a> 表示)的概念，它可以让你描述有多少内容是可用的，并允许用户选择一个紧凑或者扩展型的视图。 </p>\n<h2 id=\"Apple_Pay_的改进\">Apple Pay 的改进</h2><p>在 iOS 10中，用户可以通过 Siri和 Maps使用网页版的 Apple Pay 来便捷安全的完成支付。对于开发者来说， iOS 10 引入了新的 API，你可以在代码中使用运行在 iOS和  watchOS上，支持动态支付网络的能力和一个新的沙盒测试环境。</p>\n<p>iOS 10 引入了新的 API，帮助你将 Apple Pay 直接引入你的网站。当你在你的网站支持 Apple Pay，用户在 iOS或者 OS X上通过 Safari浏览的时候，可以通过它们的 iPhone或 Apple Watch来使用 Apple Pay上的信用卡进行支付。 详见 <a href=\"https://developer.apple.com/reference/applepayjs\"><em>ApplePay JS Framework Reference</em></a>.</p>\n<p> PassKit框架 (<code>PassKit.framework</code>) 介绍了让你在 UIKit不可用的地方支持 Apple Pay的 API。具体来说， <a href=\"https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontroller\">PKPaymentAuthorizationController</a> 和 <a href=\"https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontrollerdelegate\">PKPaymentAuthorizationControllerDelegate</a> 使得  <a href=\"https://developer.apple.com/reference/passkit/pkpaymentauthorizationviewcontroller\">PKPaymentAuthorizationViewController</a> 提供的功能以及它的 delegate 可用，而不需要 UIKit。尽管新的 API 需要在特定的意图下在 watchOS上提供 Apple Pay，还是建议你在代码的任何地方采用它。这样你就可以用一套基础代码来广泛提供 Apple Pay支持。(更多关于意图和 Siri集成，详见 <a href=\"https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5\">SiriKit</a>.)</p>\n<p> PassKit 框架还增加了新的功能，让信用卡发行机构在它们的 App中展示他们的信用卡。具体来说， <code>PKPaymentButtonTypeInStore</code> 按钮类型允许你为信用卡展示一个 Apple Pay 按钮，  <code>presentPaymentPass:</code> 方法允许你以编程方式展示信用卡。 ( <code>presentPaymentPass:</code> 方法定义在  <a href=\"https://developer.apple.com/reference/passkit/pkpasslibrary\">PKPassLibrary</a>中)。</p>\n<p>当一个新的支付网络可用时，你的 App可用自动支持新的网络，而不需要修改和重新编译你的 App。<a href=\"https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks\">availableNetworks</a> 方法允许你在运行时发现用户设备可用的网络。此外， <a href=\"https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks\">supportedNetworks</a> 属性被扩展了，以便可以携带一些支付服务提供商的名字作为参数。然后你的 App自动支持任何支付提供商支持的网络。详见<a href=\"https://developer.apple.com/apple-pay/\">https://developer.apple.com/apple-pay/</a>.</p>\n<p>iOS 10 引入了一个新的测试环境，它允许你直接在设备上提供测试信用卡。测试环境返回加密后的测试支付数据。要使用这种环境，遵循以下步骤：</p>\n<ol>\n<li>在 iTunes Connect上创建一个测试 iCloud账号</li>\n<li>在你的设备上登录该账号</li>\n<li>设置测试所需的区域</li>\n<li>使用 <a href=\"https://developer.apple.com/apple-pay/\">https://developer.apple.com/apple-pay/</a> 上列举的测试信用卡</li>\n</ol>\n<p><strong>注意:</strong> 当你切换 iCloud账号，环境自动切换。你还必须在实际生产环境中测试支付。</p>\n<h2 id=\"安全和隐私的改进\">安全和隐私的改进</h2><p>iOS 10 引入了一些修改和补充，帮助你提高你的代码的安全和维护用户数据的隐私。更多关于这方面的内容，详见 <a href=\"https://developer.apple.com/security/\">Security</a> .</p>\n<ul>\n<li><code>Info.plist</code> 文件中新的 <code>NSAllowsArbitraryLoadsInWebContent</code> 键，提供了一个便捷的方式来允许任意的 web页面加载任务，同时保留 ATS保护你的 App的其余部分。</li>\n<li>SecKey API包括不对称密钥生成的改进。使用 SecKey API 替代已经弃用的 CDSA(Common Data Security Architecture: 通用数据安全架构) API。</li>\n<li>RC4 对称加密套件现在默认禁用所有的 SSL/TLS 连接，以及 SSLv3 不再支持安全传输 API。建议你尽快停止使用  SHA-1和 3DES 加密算法。</li>\n<li><a href=\"https://developer.apple.com/reference/uikit/uipasteboard\">UIPasteboard</a> 类支持剪贴板功能，该功能允许用户设置之间复制和粘贴，包括 API可以用来限制一个纸板到特定设备和设置到达过期时间戳后，纸板被清除。此外，命名过的纸板不再重复出现，取而代之的是，你应该使用共享的容器，以及“发现”纸板（也就是说，纸板被  <a href=\"https://developer.apple.com/reference/uikit/uipasteboardnamefind\">UIPasteboardNameFind</a>  常数定义）是无效的。</li>\n<li>你必须静态声明你的应用程序使用受保护的数据类，通过在 <code>Info.plist</code> 文件中包含相关的目的字符串键。例如，你必须包含 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15\">NSCalendarsUsageDescription</a> 键来访问用户日历的数据。如果你不包含相关的目的字符串键，当你试图访问相关数据的时候，你的 App会退出。</li>\n</ul>\n<h2 id=\"CallKit\">CallKit</h2><p> CallKit 框架 (<code>CallKit.framework</code>) 让  VoIP App与 iPhone UI相结合，给用户一个很棒的体验。使用这个框架来让用户在锁屏界面查看和接听到来的 VoIP电话，以及管理手机上 Favorites和 Recents视图上的联系人。</p>\n<p>CallKit 还介绍了 App extensions，允许来电拦截并且来电识别。你可以创建一个 App extension，将一个电话号码和一个名称联系起来，或者告诉系统某个号码需要被拦截。</p>\n<h2 id=\"News_Publisher_的改进\">News Publisher 的改进</h2><p>News Publisher 可以使用 Apple News格式，很容易地提供设计精美的新闻，杂志和网络内容给 Apple News。任何人都可以注册，从主要的杂志或者新闻机构，到独立的出版商和博客。开始或学习更多关于最近的更新，访问  <a href=\"https://newsresources.apple.com/\">https://newsresources.apple.com</a>.</p>\n<h2 id=\"Video_Subscriber_Account\">Video Subscriber Account</h2><p>iOS 10 引入  Video Subscriber Account 框架 (<code>VideoSubscriberAccount.framework</code>) 来帮助 App支持支持身份验证流或验证视频点播(也称为 TV)与他们的有线或卫星 TV提供商进行身份验证。使用这个框架的 API可以帮助你支持一个单一的登录体验，用户登录一次解锁访问所有的视频应用程序订阅支持。</p>\n<h2 id=\"App_Extensions\">App Extensions</h2><p>iOS 10 引入了几个可以创建 App extension的新的 extension points，比如：</p>\n<ul>\n<li>Call Directory</li>\n<li>Intents</li>\n<li>Intents UI</li>\n<li>Messages</li>\n<li>Notification Content</li>\n<li>Notification Service</li>\n<li>Sticker Pack</li>\n</ul>\n<p>此外，iOS 10包含了如下的第三方键盘 app extensions的改进：</p>\n<ul>\n<li>你可以使用 <code>UITextDocumentProxy</code>  类中的  <code>documentInputMode</code> 属性，来自动检测文档的输入语言，并且改变你的键盘 extension来符合这个语言(如果支持的话)。当你用这种方式决定输入的语言时， 你可以做每一种语言的键盘切换，比如为 Messages内建的。</li>\n<li>新的 <code>handleInputModeListFromView:withEvent:</code> 方法让键盘 extension 显示系统的键盘选择菜单(即地球标志的菜单).</li>\n</ul>\n<p>键盘 extension 必须放置地球标志和系统标志相同的位置。此外，如果你需要提供一个自定义的按键来启动键盘设置，例如，你应该把这个按键放在系统键盘听写键的相同位置。</p>\n<p>更多关于 App extensions，详见 <a href=\"https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214\"><em>App Extension Programming Guide</em></a>.</p>"},{"title":"Core Image 之自定义 Filter~","date":"2016-10-21T14:37:08.000Z","_content":"\nCore Image 系列，目前的文章如下：\n\n- [Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)\n- [Core Image 之自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)\n- [Core Image【3】—— 2017 新特性](https://xiaozhuanlan.com/topic/3095648721)\n- [Core Image【4】—— 2018 新特性](https://xiaozhuanlan.com/topic/5094762183)\n\n\n\n------\n\n\n\n## 前言\n\n最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~\n\n本文主要讲解 Core Image 自定义滤镜部分的内容，包括如何使用自定义 Filter，如何编写 kernel，QC 工具介绍，注意点以及一些开发技巧。\n\n在这之前，我默认你了解 Core Image 的基本原理以及使用方式。如果没有，我建议你花点时间看看我的上一篇文章：[Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)，它介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比，想必会有所收获。\n\n现在，开始吧～![](http://wanzao2.b0.upaiyun.com/system/pictures/1/original/27.png)\n\n\n\n<!--more-->\n\n\n\n## 自定义 Filter 流程\n\n自定义的 Filter 和系统内置的各种 CIFilter，使用起来方式是一样的。我们唯一要做的，就是实现一个符合规范的 CIFilter 的子类，然后该怎么用怎么用。\n\n这里总结起来就3步：\n\n- 编写 CIKernel：使用 CIKL，自定义滤镜效果。\n- 加载 CIKernel：CIFilter 读取编写好的 CIKernel。\n- 设置参数：设置 CIKernel 需要的输入参数以及 DOD 和 ROI。\n\n不难看出，这些操作都是围绕 **CIKernel** 展开的，那么，它是什么？ CIKL，DOD，ROI 又是什么鬼？![](http://wanzao2.b0.upaiyun.com/system/pictures/14/original/5.png)\n\n\n\n先撇开这些麻烦的东西，我们先这样简单的认为：\n\n- CIKernel 是我们 Filter 对应的脚本，它描述 Filter 的具体工作原理。\n- CIKL （Core Image Kernel Language）是编写 CIKernel 的语言。\n- DOD，ROI 当做普通的参数处理。\n\n\n\n弄清了这些，我们再来看具体操作过程。\n\n拿一个图片翻转效果举例，效果如下：\n\n![2016101449356mirrorX.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mirrorX.png)\n\n### 1. 编写 CIKernel\n\n**File —> New —> File —> Empty**， 创建一个名为 **MirrorX.cikernel** 的文件。\n\n编辑 .cikernel 文件，比如：\n\n```objc\nkernel vec2 mirrorX ( float imageWidth ) \n{\n  \t// 获取待处理点的位置\n  \tvec2 currentVec = destCoord();\n    // 返回最终显示位置\n  \treturn vec2 ( imageWidth - currentVec.x , currentVec.y ); \n}\n```\n\n> PS：这个 kernel 如果有不懂的，可以先跳过。下文会重点说明。\n\n\n\n### 2. 加载 CIKernel\n\n**File —> New —> File —> Cocoa Touch Clas**，新建一个继承自 CIFilter 的类，比如 **MirrorXFilter**。\n\n在 **MirrorXFilter.m** 中，添加如下代码：\n\n```objc\nstatic CIKernel *customKernel = nil;\n\n- (instancetype)init {\n    \n    self = [super init];\n    if (self) {\n        if (customKernel == nil)\n        {\n            NSBundle *bundle = [NSBundle bundleForClass: [self class]];\n            NSURL *kernelURL = [bundle URLForResource:@\"MirrorX\" withExtension:@\"cikernel\"];\n            \n            NSError *error;\n            NSString *kernelCode = [NSString stringWithContentsOfURL:kernelURL\n                                                            encoding:NSUTF8StringEncoding error:&error];\n            if (kernelCode == nil) {\n                NSLog(@\"Error loading kernel code string in %@\\n%@\",\n                      NSStringFromSelector(_cmd),\n                      [error localizedDescription]);\n                abort();\n            }\n            \n            NSArray *kernels = [CIKernel kernelsWithString:kernelCode];\n            customKernel = [kernels objectAtIndex:0];\n        }\n    }\n    return self;\n}\n```\n\n\n\n这段代码很简单，重写 **init** 方法，主要就是读取 .cikernel 文件中代表 CIKernel 的字符串（当然， CIKernel 也可以直接写在 NSString 里头，免去文件读取这步），然后使用 **kernelsWithString**\n\n方法获取到真正的 CIKernel 对象。\n\n```objc\n+ (nullable NSArray<CIKernel *> *)kernelsWithString:(NSString *)string  NS_AVAILABLE(10_4, 8_0);\n```\n\n至此，CIKernel 加载完毕。\n\n\n\n### 3. 设置参数\n\n在 **MirrorXFilter.m** 中，添加需要的成员变量。\n\n```objc\n@interface MirrorXFilter () {\n    CIImage  *inputImage;\n}\n```\n\n这里只需要一个成员变量，**inputImage** 表示我们的输入图片。\n\n之后，就是设置参数，传入 kernel 中。\n\n```objc\n// 使用\n- (CIImage *)outputImage\n{\n    CGFloat inputWidth = inputImage.extent.size.width;\n    CIImage *result = [customKernel applyWithExtent: inputImage.extent roiCallback: ^( int index, CGRect rect ) {\n        return rect;\n    } inputImage: inputImage arguments: @[@(inputWidth)]];\n    return result;\n}\n```\n\n这里只需要重写 outputImage 方法即可。\n\n**extent** 用于返回 CIImage 对象对应的 bounds，通过它可以拿到图片的宽度。\n\n```objc\n/* Return a rect the defines the bounds of non-(0,0,0,0) pixels */\n@property (NS_NONATOMIC_IOSONLY, readonly) CGRect extent;\n```\n\n然后通过  applyWithExtent 来设置对应的参数。\n\n```objc\n- (nullable CIImage *)applyWithExtent:(CGRect)extent\n                          roiCallback:(CIKernelROICallback)callback\n                           inputImage:(CIImage*)image\n                            arguments:(nullable NSArray<id> *)args;\n```\n\n这里有4个参数。\n\n- extent，也就是之前提到的 DOD，暂且略过。\n- callback，也就是之前提到的 ROI，暂且略过。\n- image，缺省的 inputImage，传入我们的成员变量 inputImage 即可。\n- args，输入参数数组，与 CIKernel 中定义的一一对应。这里只有一个 inputWidth。\n\n> PS：这里可能有同学会有疑惑，为什么 inputImage 可以缺省，inputWidth 就需要传入呢。这里暂且不纠结，下面会详细说明~\n\n如此，一个自定义 Filter 就完成了。简单吧~\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png)\n\n\n\n### 4. 使用\n\n至于使用上，则和普通的 CIFilter 基本一致。\n\n```objc\n#import \"MirrorXFilter.h\"\n\n// 1. 将UIImage转换成CIImage\nCIImage *ciImage = [[CIImage alloc] initWithImage:self.imageView.image];\n\n// 2. 创建滤镜\nself.filter = [[MirrorXFilter alloc] init];\n// 设置相关参数\n[self.filter setValue:ciImage forKey:@\"inputImage\"];\n\n// 3. 渲染并输出CIImage\nCIImage *outputImage = [self.filter outputImage];\n\n// 4. 获取绘制上下文\nself.context = [CIContext contextWithOptions:nil];\n\n// 5. 创建输出CGImage\nCGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]];\nUIImage *image = [UIImage imageWithCGImage:cgImage];\n// 6. 释放CGImage\nCGImageRelease(cgImage);\n```\n\n如此，我们便可得到翻转后的图片。\n\n\n\n### 5. 更多\n\n当然，如果你是一个完美主义者，我觉得你还还可以做更多~\n\n```objc\n- (NSDictionary *)customAttributes\n{\n    return @{\n        @\"inputDistance\" :  @{\n            kCIAttributeMin       : @0.0,\n            kCIAttributeMax       : @1.0,\n            kCIAttributeSliderMin : @0.0,\n            kCIAttributeSliderMax : @0.7,\n            kCIAttributeDefault   : @0.2,\n            kCIAttributeIdentity  : @0.0,\n            kCIAttributeType      : kCIAttributeTypeScalar\n            },\n        @\"inputSlope\" : @{\n            kCIAttributeSliderMin : @-0.01,\n            kCIAttributeSliderMax : @0.01,\n            kCIAttributeDefault   : @0.00,\n            kCIAttributeIdentity  : @0.00,\n            kCIAttributeType      : kCIAttributeTypeScalar\n            },\n         kCIInputColorKey : @{\n         kCIAttributeDefault : [CIColor colorWithRed:1.0\n                                               green:1.0\n                                                blue:1.0\n                                               alpha:1.0]\n           },\n   };\n}\n```\n\n可以为自定义的 Filter 添加对应的参数描述，以及默认值，范围限制等。\n\n这不是必须的，但却是可取的。至于如何设置，可以参考 CIFilter 对应的 **attributes** 属性，或者参照上面这个例子。\n\n\n\n另外，iOS 9之后，引入了 **registerFilterName** , 你可以通过重写 `+ (CIFilter *)filterWithName: (NSString *)name;` ，然后外部使用的时候，跟 CIFilter 一模一样。\n\n```objc\n/** Publishes a new filter called 'name'.\n\n The constructor object 'anObject' should implement the filterWithName: method.\n That method will be invoked with the name of the filter to create.\n The class attributes must have a kCIAttributeFilterCategories key associated with a set of categories.\n @param   attributes    Dictionary of the registration attributes of the filter. See below for attribute keys.\n*/\n+ (void)registerFilterName:(NSString *)name\n               constructor:(id<CIFilterConstructor>)anObject\n           classAttributes:(NSDictionary<NSString *,id> *)attributes NS_AVAILABLE(10_4, 9_0);\n```\n\n不过需要 iOS 9以上才支持，另外一般用于打包成 Image Units 给他人使用。\n\n正常情况下应该是用不到。如果真有这个需求，可以参考这篇文章： [Packaging and Loading Image Units](https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_image_units/ci_image_units.html#//apple_ref/doc/uid/TP30001185-CH7-SW12)。\n\n\n\n至此，自定义 Filter 的流程就算走完了，我们很容易就可以配置好需要的环境。\n\n然而，真正的自定义部分，才刚刚开始！\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/183/original/%E5%BC%80%E5%BF%8336.png)\n\n\n\n## DOD & ROI\n\n### 1. DOD\n\nDOD ( domain of definition ) ，简单来说就是 Filter 处理后，输入的图片区域。\n\n一般来说，Filter 操作都是基于原图，添加上效果，但是并不会改变图片的大小，显示区域。所以一般与原图的一致即可。\n\n```objc\nCGRect dod = inputImage.extent; \n```\n\n但是针对形变类的 Filter，则需要根据输出图片大小，设置正确的 DOD。\n\n\n\n### 2. ROI\n\nROI ( region of interest )，在一定的时间内特别感兴趣的区域，即当前处理区域。\n\n可以简单的理解为：当前处理区域对应于原图中的哪个区域。\n\nROI 的定义如下：\n\n```objc\n/* Block callback used by Core Image to ask what rectangles of a kernel's input images\n * are needed to produce a desired rectangle of the kernel's output image.\n *\n * 'index' is the 0-based index specifying which of the kernel's input images is being queried.\n * 'destRect' is the extent rectangle of kernel's output image being queried.\n *\n * Returns the rectangle of the index'th input image that is needed to produce destRect.\n * Returning CGRectNull indicates that the index'th input image is not needed to produce destRect.\n * The returned rectangle need not be contained by the extent of the index'th input image.\n */\ntypedef CGRect (^CIKernelROICallback)(int index, CGRect destRect);\n```\n\nCIKernelROICallback 在 Core Image 内部进行处理的时候，会多次调用。\n\n**index** 表示输入图片的下标，顺序和 kernel 中的入参顺序一致，从0开始。\n\n**destRect** 表示输出图片的区域。 也就是我们先前设置的 DOD。\n\n那，我们为什么要显示设置 ROI 呢 ？\n\n因为输入图片中，参与处理的实际区域，Core Image 是无法知道的，我们需要显式的告诉 CI 这个区域。\n\n这么讲可能有点难以理解，下面我们看两个具体的例子。\n\n先看一个旋转的例子。\n\n![2016101449433roi_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/roi_1.png)\n\n这里就是进行了 x，y 互换操作。很容易得到我们的 DOD：\n\n```objc\nCGRect dod = CGRectMake(inputImage.extent.origin.y, inputImage.extent.origin.x, inputImage.extent.size.height, inputImage.extent.size.width);\n\n// e.g.\n// 原图片extent (0, 0, 200, 300)\n// 旋转后的输出图片 (0, 0, 300, 200)，也就是 DOD\n```\n\n那 ROI 应该怎么设置呢 ？我们之前说过，ROI 计算就是计算当前处理区域对应于原图中的哪个区域。\n\n也就是一个逆向过程。\n\n假如，A：输入图片中的某点   B：输出图片中的某点。那么 ROI 计算可以理解成  ROI（B）= A。\n\n理解好这点，我们不难写出这个操作对应的 ROI：\n\n```objc\nCIKernelROICallback callback = ^(int index, CGRect rect) {\n    return CGRectMake(rect.origin.y, rect.origin.x, rect.size.height, rect.size.width);\n};\n```\n\n另外，当输入图片不止一个的时候，则需要根据 **index** 来做区别。因为这里的 **rect** 每次都是返回 **DOD**，而不是当前图片的 extent。\n\n\n\n## CIKernel 介绍\n\n终于到了本文最重要的部分了，CIKernel 介绍！\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/187/original/%E5%BC%80%E5%BF%83ForeverAloneExcited.png)\n\n在此之前，我们先了解下它的一些背景知识。\n\nCIKernel 需要使用 Core Image Kernel Language (CIKL) 来编写，CIKL 是 OpenGL Shading Language (GLSL) 的子集，如果你之前有过 OpenGL 着色器编写的经验，这部分你会感觉格外亲切。CIKL 集成了 GLSL 绝大部分的参数类型和内置函数，另外它还添加了一些适应 Core Image 的参数类似和函数。\n\n一个 kernel 的处理过程，可以用下面伪代码表示：\n\n```objc\nfor i in 1 ... image.width\n    for j in 1 ... image.height\n        New_Image[i][j] = CustomKernel(Current_Image[i][j])\n    end\nend\n```\n\n也就是说，每个需要处理的 fragment 都会调用一次 kernel 相关操作，每次操作的目的就是返回当前 fragment 对应的结果 fragment，这里 fragment 可以理解为像素点。\n\n所以我们的 kernel，应该是针对一个点，而不是一张图片。\n\n\n\nCore Image 内置了3种适用于不同场景的 Kernel，可以根据实际需求来选择。\n\n- CIColorKernel：用于处理色值变化的 Filter。\n- CIWarpKernel：用于处理形变的 Filter。\n- CIKernel：通用。\n\nCIColorKernel，CIWarpKernel 是官方推荐使用的。某个 Filter，在使用它们能实现的情况下，应该使用它们，即使是一个 CIKernel 拆分成多个 CIColorKernel 以及 CIWarpKernel，也应该用这种方式。因为 Core Image 内部对这两张 Kernel 做了优化。\n\n当然，它们的使用时有限制的。目的一定要很纯粹，比如 CIColorKernel 只能处理色值上的变化。否则就算定义为 CIColorKernel，如果实现上涉及了其他 CIColorKernel 不允许的操作，Core Image 也会当做普通的 CIFilter 处理。\n\n另外，kernel 的入参只支持下面这么几种：\n\n| Kernel routine input parameter | Object    |\n| ------------------------------ | --------- |\n| sampler                        | CISampler |\n| __table sampler                | CISampler |\n| __color                        | `CIColor` |\n| float                          | NSNumber  |\n| vec2, vec3, or vec4            | CIVector  |\n\n简单说明一下：\n\n- sampler：可以理解成纹理，或者图片。外部以 CIImage 形式传入。\n- __table sampler：表示颜色查找表（lookup table），虽然它也是图片，但是添加该声明可以避免被修改。外部以 CIImage 形式传入。\n- __color：表示颜色。外部以 CIColor 形式传入。\n- float：kernel 内部处理都是 float 类型。外部以 NSNumber 形式传入。\n- vecN：表示一个多元向量。比如 vec2 可以表示一个点，vec4 可以表示一个色值。外部以 CIVector 形式传入。\n\n至于 kernel 中可以使用的函数，那就太多了。这里不一一枚举，在下面的具体讲解中，会说明几个常用的。如果想了解更多，可以参考  [Core Image Kernel Language Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397)，以及 [OpenGL ES Shading Language Reference](http://www.shaderific.com/glsl/)。\n\n\n\n下面我会通过一个 Demo，讲解这三种 Kernel 的具体用法。\n\n> PS：建议阅读之前，下载 [源码](https://github.com/colin1994/CoreImageDemo) 配合着看。\n\n\n\n### 1. CIColorKernel\n\n首先看下官方的定义：\n\n```objc\n/*\n * CIColorKernel is an object that encapsulates a Core Image Kernel Language\n * routine that processes only the color information in images.\n *\n * Color kernels functions are declared akin to this example:\n *   kernel vec4 myColorKernel (__sample fore, __sample back, vec4 params)\n *\n * The function must take a __sample argument for each input image.\n * Additional arguments can be of type float, vec2, vec3, vec4, or __color.\n * The destination pixel location is obtained by calling destCoord().\n * The kernel should not call sample(), sampleCoord(), or samplerTransform().\n * The function must return a vec4 pixel color.\n */\nNS_CLASS_AVAILABLE(10_11, 8_0)\n@interface CIColorKernel : CIKernel\n```\n\n很重要的一点：**processes only the color information in images**，它只处理图片的颜色信息。\n\n所以在使用它之前，一定要确保该 Filter 只涉及颜色处理。\n\nCIKL 的语法和大多数 C 阵营一样，变量，运算符，控制结构，函数等都大同小异，所以它的学习成本是很低的。\n\n真正的核心应该是：**如果用这样的语言来实现这个滤镜，也就是我们经常说的算法。**\n\n下面我们以一个 **Vignette** 来实际讲解一下。\n\n它的效果如下所示：\n\n![2016101796011vignette_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette_demo.gif)\n\n不难看出，Vignette 滤镜，它实际上就是一个FOV（Field of View） 的效果，即视野中央看的最清楚，清晰程度与到中心距离呈反比，与人类的视觉是类似的。\n\n![2016101524815vignette.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette.png)\n\n所以针对图片上的每个像素点 A，经过 Vignette 滤镜处理后得到的 B，应该满足：\n\nVignette（A）＝ A * Darken ＝ B； 而 Darken 的计算依赖 A 与中心点的距离。\n\n如此，我们可以很容易的写出对应的 kernel：\n\n```objc\nkernel vec4 vignetteKernel(__sample image, vec2 center, float radius, float alpha)\n{\n    // 计算出当前点与中心的距离\n    float distance = distance(destCoord(), center) ;\n    // 根据距离计算出暗淡程度\n    float darken = 1.0 - (distance / radius * alpha);\n    // 返回该像素点最终的色值\n    image.rgb *= darken;\n\n    return image.rgba;\n}\n```\n\n和 C 语言的一样，函数需要具备：\n\n- 返回类型：vec4\n- 函数名：vignetteKernel\n- 参数列表：__sample image, vec2 center, float radius, float alpha）\n- 函数体：｛｝中的具体实现\n\n有所不同的，kernel 函数需要带上 kernel 关键字，与其它普通函数做区分。一个 .cikernel 文件中，允许包括多个函数，甚至是多个 kernel 函数，不过**函数调用要出现在函数定义之后**！\n\n另外，这里有个特别的参数类型，**__sample** ，和之前讲的 **sampler** 有所不同。因为这里我们使用的是 **CIColorKernel**，在得到高效性能的同时，也有一定的局限性。因为只是处理图片当前位置的颜色信息，所以 **__sample** 提供的 **rgba** 变量足够了，无法获取一些其它的信息。\n\n> 比如在 CIKernel 中，可以通过 sample() 等函数获取其它位置的色值，而在 CIColorKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。\n\n下面逐行解释这个 kernel。\n\n```objc\n// 计算出当前点与中心的距离\nfloat distance = distance(destCoord(), center) ;\n```\n\n**destCoord**\n\n- `varying vec2 destCoord ()`\n\n  返回当前正在处理的像素点所处坐标。(working space coordinates)\n\n这里使用的 CIKL 内置的函数 destCoord，它返回的坐标是基于 **working space** 的。所谓 working space，即工作空间，它的取值范围对应图片实际大小。比如 inputImage 的大小为 300 * 200，那么 destCoord() 返回坐标的取值范围在 (0, 0) - (300, 200)。\n\n**distance**\n\n- `float distance (vec2 p0, vec2 p1)`\n\n  计算向量p0，p1之间的距离\n\n如此便能很容易得到当前点与中心的距离。\n\n```objc\n// 根据距离计算出暗淡程度\nfloat darken = 1.0 - (distance / radius * alpha);\n```\n\n之后根据清晰程度与到中心距离呈反比这一原理，结合外部控制的 **alpha** 变量，计算出暗淡程度。\n\n```objc\n// 返回该像素点最终的色值\nimage.rgb *= darken;\nreturn image.rgba;\n```\n\n这里之前提到，**__sample** 有个 rgba 变量，通过它可以获取到当前处理点的色值。\n\n在 CIKL 中，vec4 的任何一个分量都可以单独获取，也可以组合获取，例如 **image.a**，**image.rrgg** 等，都是可行的。\n\nCIColorKernel 是针对色值的处理，所以它的返回值必须是一个代表色值的 vec4 类型变量。\n\n至此，这个 vignetteKernel 就分析完毕了。很简单吧～\n\n\n\n### 2. CIWarpKernel\n\n同样，先看下文档定义：\n\n```objc\n/*\n * CIWarpKernel is an object that encapsulates a Core Image Kernel Language\n * function that processes only the geometry of an image.\n *\n * Warp kernels functions are declared akin to this example:\n *   kernel vec2 myWarpKernel (vec4 params)\n *\n * Additional arguments can be of type float, vec2, vec3, vec4.\n * The destination pixel location is obtained by calling destCoord().\n * The kernel should not call sample(), sampleCoord(), or samplerTransform().\n * The function must return a vec2 source location.\n */\nNS_CLASS_AVAILABLE(10_11, 8_0)\n@interface CIWarpKernel : CIKernel\n```\n\n同样，它也有很重要一点：**processes only the geometry of an image**。它只处理图片的几何形状。\n\n所谓的改变几何形状，也就是形变，把原本放置在 A 处的点，用 B 处的点去填充，或者反过来，把原本 B 处的点，挪到 A 处去，也是一样的。\n\n它可以用这个表达式表示：**Warp（A）＝ B；**\n\n所以它和之前的 CIColorKernel 不同，它的返回值是 vec2，代表点的坐标。另外它只允许传入一张图片，所以这里的 inputImage 缺省了。\n\n> 同样的，在 CIWarpKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。\n\n\n\n下面以一个马赛克，像素化（Pixellate）的例子来讲解。它的效果如下：\n\n![2016101762677pixellate_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/pixellate_demo.gif)\n\n马赛克，比较简单的一种算法是按照固定的间隔取像素点，将图片分割成一些小块，然后每个小块内选择一个像素点，然后把这个区域全部用这个像素点填充即可。这里的每个小块，称作晶格，晶格越大，马赛克效果越好。\n\n依照这个简单算法，我们可以很容易的写出对应的 kernel：\n\n```objc\nkernel vec2 pixellateKernel(float radius)\n{\n    vec2 positionOfDestPixel, centerPoint;\n    // 获取当前点坐标\n    positionOfDestPixel = destCoord();\n    // 获取对应晶格内的中心像素点\n    centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * 2.0) + radius;\n    centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * 2.0) + radius;\n\n    return centerPoint;\n}\n```\n\n同样的，先是获取到当前处理点的坐标，positionOfDestPixel。\n\n```objc\n// 获取对应晶格内的中心像素点\ncenterPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * 2.0) + radius;\ncenterPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * 2.0) + radius;\n```\n\n然后这里的 **mod (x, y)** 和平时使用的一样，计算 **x / y 的余数**。\n\n至于为什么这个式子能获得**中心像素点坐标**，想必一看就懂了吧～（不懂的可以拿张纸画画）\n\n最后返回中心点坐标，替换当前点。\n\n如此，一个简单的马赛克就完成了～\n\n\n\n### 3. CIKernel\n\n我们之前说过，CIColorKernel 和 CIWarpKernel 内部做了优化，要尽可能的使用它们。除非真的有特殊需求，是它们无法实现的。下面罗列了 CIColorKernel 和 CIWarpKernel 的一些局限：\n\n**CIColorKernel ：**\n\n- 只处理当前处理点色值，无法获取到其它点的状态。\n\n**CIWarpKernel：**\n\n- 只处理当前处理点位置，无法获取到其它点的状态。\n- 只能传入一张图片。\n\n比如说，美图秀秀里面的一些简单马赛克，效果如下：\n\n![2016101864134mosaic_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mosaic_demo.gif)\n\n\n\n它的实现方式，我们可以简单的这么理解：\n\n1. 判断当前点是否在传入点的处理范围内。\n2. 如果在，返回马赛克贴图中对应的像素点色值。\n3. 如果不在，返回当前点色值。\n\n很明显，它需要两张图片，一张我们的待处理图片，一张马赛克贴图。所以 CIWarpKernel 不适用。\n\n另外，待处理图片与马赛克贴图之前不是一一对应关系，在第二步，返回马赛克贴图中对应的像素点色值中，需要一个映射计算，即当前点对应马赛克贴图中的某点。所以 CIColorKernel 也不适用。\n\n这种情况下，就要使用通用的 CIKernel 了。\n\n下面是对应的 kernel：\n\n```objc\nkernel vec4 mosaicKernel(sampler image, sampler maskImage, float radius, vec2 point, float maskWidth, float maskHeight)\n{\n    // 获取当前点坐标\n    vec2 textureCoordinate = destCoord();\n    // 计算当前点与传入点的距离\n    float distance = distance(textureCoordinate, point);\n    if (distance < radius) {\n        // 在处理范围内, 计算对应马赛克贴图中的位置\n        float resultX = mod(textureCoordinate.x, maskWidth);\n        float resultY = mod(textureCoordinate.y, maskHeight);\n        return sample(maskImage, samplerTransform(maskImage, vec2(resultX, resultY)));\n    }\n    else {\n        // 返回原图对应像素点色值\n        return sample(image, samplerTransform(image, textureCoordinate));\n    }\n}\n```\n\n\n\n这里参数比较多，分别对应：\n\n- image：待处理图片\n- maskImage：马赛克贴图\n- radius：处理范围，半径\n- point：传入点，即当前触摸的点\n- maskWidth：马赛克贴图宽度\n- maskHeight：马赛克贴图高度\n\n上面的 kernel，使用了两个新的函数，sample 和 samplerTransform。\n\n> `vec4 sample (uniform sampler src, vec2 point)` \n> Returns the pixel value produced from sampler src at the position point, where point is specified in sampler space.\n>\n> 返回图片 src 指定点 point 处的色值。point 是基于 sampler space。\n>\n> `vec2 samplerTransform (uniform sampler src, vec2 point)` \n> Returns the position in the coordinate space of the source (the first argument) that is associated with the position defined in working-space coordinates (the second argument). (Keep in mind that the working space coordinates reflect any transformations that you applied to the working space.) For example, if you are modifying a pixel in the working space, and you need to retrieve the pixels that surround this pixel in the original image, you would make calls similar to the following, where d is the location of the pixel you are modifying in the working space, and image is the image source for the pixels.\n>\n> 返回图片 src 指定点 point 处坐标对应的基于 sampler space 的坐标。point 是基于working space。\n>\n> sampler space 的取值是 0.0 - 1.0，左下角为原点，向右，向上递增。\n\n了解了这两个函数的用法，想必这段代码就没什么需要特别说明的地方了，注释已经很清楚，不再累述。\n\n\n\n## 注意点\n\n### 1. premultiply\n\n> `vec4 premultiply (vec4 color)` \n> Multiplies the red, green, and blue components of the color parameter by its alpha component.\n\n将颜色变量的r、g、b元素值分别于 alpha 相乘，返回一个新的四维颜色向量。\n\n> `vec4 unpremultiply (vec4 color)` \n> If the alpha component of the color parameter is greater than 0, divides the red, green and blue components by alpha. If alpha is 0, this function returns color.\n\n将颜色变量的r、g、b元素值分别除以 alpha ，返回一个新的四维颜色向量。\n\npixel（R, G, B, A） —— (premultiply) ——> (R＊A, G＊A, B＊A, A)\n\n—— (unpremultiply) ——> （R, G, B, A）。\n\n在 Core Image 中，默认颜色空间是 sRGB，在 kernel 中得到的色值，都经过了 Premultiplied Alpha 处理。\n\n至于为什么要执行 Premultiplied Alpha 操作，具体的可以参考这篇文章：[为什么要PREMULTIPLIED ALPHA呢？](https://boundary.cc/2015/07/why-premultiplied-alpha/)\n\n\n\n所以如果 kernel 涉及 alpha 相关操作，则需要先执行 unpremultiply，返回正确的 rgba。处理完之后，再执行 premultiply 操作。\n\n比如一个反相滤镜，\n\n![2016101643860rever_1.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_1.gif)![20161016903rever_2.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_2.gif)\n\n\n\n它对应的 kernel 应该是这样的：\n\n```objc\nkernel vec4 _invertColor(sampler source_image)\n{\n    vec4 pixValue;\n    // samplerCoord 返回当前像素点在 sampler space 中的位置\n    // kernel 无法知道该图片是否进行了某些变换操作，所以确保转换为 sampler space 中的位置 是有必要的\n    pixValue = sample(source_image, samplerCoord(source_image));\n    // 执行 unpremultiply 操作, 得到真正的 RGB 值\n    // (R＊A, G＊A, B＊A, A) ——(unpremultiply)——> (R, G, B, A)\n    // Core Image is always RGB based.\n    unpremultiply(pixValue); \n    // invertColor\n    pixValue.r = 1.0 - pixValue.r; \n    pixValue.g = 1.0 - pixValue.g;\n    pixValue.b = 1.0 - pixValue.b;\n    // premultiply. (R, G, B, A) —> (R＊A, G＊A, B＊A, A)\n    return premultiply(pixValue); \n}\n\n\n// 优化：\n// 避免了 unpremultiply 和 premultiply 操作，能更高效执行。\n// pixValue 是 (R＊A, G＊A, B＊A, A)， pixValue.a - pixValue.r = (1-r)*a. 和最终 premultiply 得到的结果一样.\nkernel vec4 _invertColor(sampler source_image)\n{\n    vec4 pixValue;\n    pixValue = sample(source_image, samplerCoord(source_image));\n    pixValue.rgb = pixValue.aaa - pixValue.rgb;\n    return pixValue;\n}\n```\n\n\n\n### 2. 关键字\n\n和 C 语言等一样，CIKL 中变量的命名不能和关键字相同。\n\n下面是官方 Session 中翻转对应的 kernel 脚本，这里用到了 input 关键字，导致整个 kernel 错误。\n\n![2016101638470session_error.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/session_error.png)\n\n\n\n所以这点一定要牢记。\n\n下面是在 Github 上引起的灾难..\n\n![2016101685335error_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_1.png)\n\n![2016101697866error_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_2.png)\n\n\n\n### 3. GLSL\n\nCIKL 是 GLSL 的子集，所以**不是 GLSL 中定义的任何东西在 CIKL 中都适用**。但是 glsl 中大多数关键字都是可以用的。另外，CIKL 还提供了 glsl 不支持的，额外的数据类型，关键字，方法，来完善 CIKernel。\n\n\n\n### 4. Array, Mat\n\n In addition, the following are not implemented:\n\n- Data types: `mat2`, `mat3`, `mat4`, `struct`, `arrays`\n\n这些数据类型 Core Image 不支持。但是在 kernel 内部却可以使用 … \n\n如果当做参数传入，则会报错：\n\n**invalid kernel parameter type; valid types are:  'float', 'vec2', 'vec3', 'vec4', 'sampler’, ‘sample’, ‘color’**\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/229/original/%E6%82%B2%E4%BC%A41.png)\n\n\n\n这也导致了一些依赖关键点的算法无法实现。\n\n\n\n### 5. 坐标系\n\nUIKit 坐标系，原点在屏幕左上，x轴向右，y轴向下。\n\nCore Image 和 OpenGL 坐标系原点在屏幕的左下，x轴向右，y轴向上。\n\n所以位置的处理上要注意。\n\n\n\n### 6. 局限\n\nkernel 的输入和输出像素可以相互映射。大多数像素处理都可以用这种方式表达，但是有的图像处理操作很困难，甚至不可能。\n\nkernel 的使用上还是有一定的局限性。比如说通过输入图像映射计算直方图是很困难的。也不可以执行种子填充算法或者其他需要复杂条件语句的图像分析操作。\n\n\n\n### 7. 性能优化\n\nkernel 中的内容要尽可能简单，高效。\n\n- 展开循环操作会更快。\n- 外部能传入的变量，尽量不要在 kernel 中计算获取。\n\n\n\n## 开发技巧\n\n### 1. Log\n\n**+(id)kernelsWithString:(id)arg1 messageLog:(id)arg2 ;**\n\n这是  [CIKernel.h](https://github.com/CPDigitalDarkroom/iOS9-SpringBoard-Headers/blob/a11be523d5644a178614585ff57f9638300c2cc0/System/Library/Frameworks/CoreImage.framework/CIKernel.h) 里面的私有方法，在调试阶段可以利用它来打印 kernel 中的错误。\n\n比如：\n\n```objc\nNSMutableArray *messageLog = [NSMutableArray array];\nNSArray *kernels = [[CIKernel class] \t\t performSelector:@selector(kernelsWithString:messageLog:) withObject:kernelCode withObject:messageLog];\nif ( messageLog.count > 0) \n  \tNSLog(@\"Error: %@\", messageLog.description);\ncustomKernel = [kernels objectAtIndex:0];\n\n// 错误 log\nError: (\n        {\n        CIKernelMessageLineNumber = 5;\n        CIKernelMessageType = CIKernelMessageTypeError;\n        kCIKernelMessageDescription = \"unkown type or function name 'destCoordE'; did you mean 'destCoord'?\";\n        kCIKernelMessageOffset = 142;\n    },\n        {\n        CIKernelMessageLineNumber = 7;\n        CIKernelMessageType = CIKernelMessageTypeError;\n        kCIKernelMessageDescription = \"invalid operands to binary expression ('float' and 'int')\";\n        kCIKernelMessageOffset = 281;\n    }\n)\n```\n\n\n\n### 2. CI_PRINT_TREE\n\n这里 Core Image 中非常实用的一个环境变量，通过设置它，可以很方便的查看 Core Image 工作过程中到底做了什么。比如：\n\n- 工作在 GPU 还是 CPU 上？\n- 各个 kernel 的参数值？\n- Core Image 是如何链接 kernel？\n- DOD，ROI 如何设置的？\n- 对于大图如何拆分处理？\n- ...\n\n> PS ： 至于 CI_PRINT_TREE 具体应该如何使用，没有找到相关资料，只是在 Session 中提到过。\n>\n> 包括 ObjC 中国 上的翻译：你可以通过在 Xcode 中设置计划配置（scheme configuration）里的 CI_PRINT_TREE 环境变量为 1 来决定用 CPU 还是 GPU 来渲染，也是很不准确的。\n>\n> 这里的结论都是自己摸索后的总结，所以可能存在错误或者遗漏，欢迎补充交流～\n\nCI_PRINT_TREE 的设置大致是这样的：分成 A B 两部分，它们可以结合使用。\n\n其中 A 是主要分类，B 是辅助功能。\n\nA 包括：\n\n- 1  initial graph \n- 2  optimized graph \n- 4  tile graph \n- 8  programs graph \n- 16  timing graph \n\nB 包括：\n\n- graphviz \n- dump-inputs \n- dump-intermediates \n- skip-cpu \n- skip-gpu  \n- skip-small \n- frame-<number> \n\n使用上，比如简单的查看 initial graph 做了什么，即我们添加这个 Filter 的时候，初始化过程执行了什么，传入了哪些参数。当然，这个过程它并没有真正得到渲染，只是一个操作流程列表。设置 CI_PRINT_TREE ＝ 1，如下：\n\n![2016101786999ci_print_tree.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/ci_print_tree.png)\n\n它的结果如下：\n\n```objc\ninitial graph render_to_display (opengles2 context 1 frame 1) format=RGBA8 roi=[0 156 750 748] = \n  clamptoalpha roi=[0 156 750 748] extent=[0 156 750 748] opaque\n    colormatch workingspace-to-devicergb roi=[0 156 750 748] extent=[0 156 750 748] opaque\n      affine [2 0 0 2 0 156] roi=[0 156 750 748] extent=[0 156 750 748] opaque\n        colorkernel \n  roi=[0 0 375 374] extent=[0 0 375 374] opaque\n          affine [1 0 0 -1 0 374] roi=[0 0 375 374] extent=[0 0 375 374] opaque\n            colormatch \"sRGB IEC61966-2.1\"-to-workingspace roi=[0 0 375 374] extent=[0 0 375 374] opaque\n              CGImageRef 0x1701c4380 RGBX8 375x374  alpha_one roi=[0 0 375 374] extent=[0 0 375 374] opaque\n```\n\n这里有很多关键信息，十分详细。它的阅读顺序是从下往上，我们简单分析下：\n\n- **CGImageRef**： 指代我们传入的图片。\n- 每个阶段的 **ROI，DOD**。\n- **colormatch \"sRGB IEC61966-2.1\"-to-workingspace** ：传入的颜色空间\n- **vignetteKernel(image,center=[187.5 187],radius=187.5,alpha=0.0537634)** ：kernel 的每个参数\n- **colormatch workingspace-to-devicergb**：  输出的颜色空间\n- **opengles2** ：工作在 GPU 上\n- **context 1 frame 1** ：分别指代当前 context 以及第几帧。每次渲染 frame + 1\n\n当然，这只是 CI_PRINT_TREE 的一部分功能，如果你设置 CI_PRINT_TREE = 8 (programs graph )，你又会得到这样的信息：\n\n```objc\nprograms graph render_to_display (opengles2 context 1 frame 4 tile 1) format=RGBA8 roi=[0 111 640 640] = \n  program affine(clamp_to_alpha(linear_to_srgb(vignetteKernel(affine(srgb_to_linear(swizzle_bgr1())))))) rois=[0 111 640 640] extent=[0 111 640 640]\n    IOSurface 0x60000019ddc0 RGBA8 375x374 alpha_one edge_clamp rois=[0 0 375 374] extent=[infinite][0 0 375 374] opaque\n```\n\n这里描述了程序图表，即真正涉及到的操作。\n\n如果觉得这样看比较杂乱，可以试试添加 B 类辅助功能。 比如：**CI_PRINT_TREE = 8 graphviz** ，这样就可以导出 DOT 语言脚本。然后使用 [Graphviz](http://www.graphviz.org/) 工具，即可绘制这个 DOT 语言脚本描述的图形。\n\n比如上面 Log 对应绘制得到的图形如下：\n\n![201610186930programs_graph.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/programs_graph.png)\n\n同样是从下往上看，各个操作的层级关系就很明显了。除了我们提供的 vignetteKernel，Core Image 内部还做了其他的操作，比如 **linear_to_srgb，clamp_to_alpha** 等。它们的具体实现如下：\n\n```objc\nFilter DAG:\nNode: 0\n  original source: vec4 _ci_clamp_to_alpha(vec4 s) { return clamp(s, 0.0, s.a); }\n  printed AST: vec4 _ci_clamp_to_alpha(vec4 s) {\n  return clamp(s, 0.000000e+00, s.a);\n}\n  children: 1\nEnd Filter Node\n\nNode: 1\n  original source: vec4 _ci_premultiply(vec4 s) { return vec4(s.rgb*s.a, s.a); }\n  printed AST: vec4 _ci_premultiply(vec4 s) {\n  return vec4(s.rgb * s.a, s.a);\n}\n  children: 2\nEnd Filter Node\n\nNode: 2\n  original source: vec4 _ci_linear_to_srgb(vec4 s)\n{\n  s.rgb = sign(s.rgb)*mix(s.rgb*12.92, pow(abs(s.rgb), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s.rgb)));\n  return s;\n}\n  printed AST: vec4 _ci_linear_to_srgb(vec4 s) {\n  s.rgb = sign(s.rgb) * mix(s.rgb * 1.292000e+01, (pow(abs(s.rgb), vec3(4.166667e-01)) * 1.055000e+00) - 5.500000e-02, step(3.130800e-03, abs(s.rgb)));\n  return s;\n}\n  children: 3\nEnd Filter Node\n\nNode: 3\n  original source: vec4 _ci_unpremultiply(vec4 s) { return vec4(s.rgb/max(s.a,0.00001), s.a); }\n  printed AST: vec4 _ci_unpremultiply(vec4 s) {\n  return vec4(s.rgb / max(s.a, 1.000000e-05), s.a);\n}\n  children: 6\nEnd Filter Node\n\nNode: 6\n  <sample with transform>\n  original source: vec4 read_pixel(sampler2D image, vec2 c, mat3 m){ return texture2D(image, (vec3(c, 1.0) * m).xy);}\n  printed AST: vec4 read_pixel_6(sampler2D image, vec2 c, mat3 m) {\n  return texture2D(image, (vec3(c, 1.000000e+00) * m).xy);\n}\n  children: 4 7 5\nEnd Filter Node\n\nNode: 4\n  image: 6\n  printed: uniform lowp sampler2D image6_0\nEnd Filter Node\n\nNode: 7\n  position use <_dc>\nEnd Filter Node\n\nNode: 5\n  <transform>\n  uniform: 6\nEnd Filter Node\n```\n\n这个 DAG（有向无环图），具体描述了相关操作的实现过程，比较简单，可以自己看看，这里不累述。\n\n\n\n## 工具介绍\n\nQuartz Composer 是一款图形化的编程工具，专门用来生成各种动态视觉效果，包括可交互的界面原型。当然，它也支持 Core Image 滤镜图表的原型。\n\n![2016092073920quartz_1.png](http://7xkc7a.com1.z0.glb.clouddn.com/2016092073920quartz_1.png)\n\n另外，在 QC 上编写 Kernel，除了代码高亮，实时调整效果也很棒。\n\n![2016101158579quartz_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/quartz_2.png)\n\n\n\n> PS ：[Quartz Composer 下载地址](https://developer.apple.com/downloads/) \n>\n> 有精力的话建议把 QC 内自带的所有 example 找出来仔细研究，苹果自己的例子是最好的。它们藏在 /Applications/Quartz Composer.app/Contents/Resources/Examples/Patches（找到 Quartz Composer.app 点右键，选择「Show Package Content」）\n>\n>  简单了解 Quartz Composer。QCDesigners 上有比较简要的介绍：[QC Designers](https://link.zhihu.com/?target=http%3A//qcdesigners.com/index.php/forums/topic/2/new-to-quartz-composer-start-he)\n\n\n\n![2016092059430download_Graphic_Tools_for_XCode.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/download_Graphic_Tools_for_XCode.png)\n\n\n\nQC 已经内置了适合 Core Image 的模板，并且实现了动态模糊滤镜效果。不过这里为了了解 QC 的使用方式，不使用内置的模板，从头开始。**File —> New Blank**，创建一个空白的 QC 工程。\n\n> PS： QC 的功能很强大，这里只介绍 Core Image Filter 编辑过程中会用到的，以及我所掌握的...\n\n### 0. 概念介绍\n\n在讲解使用方式之前，介绍几个基本概念。\n\n一次滤镜操作，可以简单理解成： **输入—>(Patch)—>输出**。\n\nPatch 可以理解成 Kernel。\n\n输入则与 Kernel 的参数相对应，可以是 image，color，float...\n\n输入这里一般就是处理后的图像。\n\n还有一个比较特殊的 Patch，Layer。相当于画布，可以把结果图显示在上面，它也有层的概念。\n\n\n\n### 1.  工作区介绍\n\n**编辑区：** 这是主面板，主要衔接各个 Patch，以及它们的输入，输出。\n\n![2016101175676panel_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_1.png)\n\n\n\n**Library：** 这里陈列了 QC 内置的所有 Patch（也可以添加自定义的 Patch 进来），以及它们的详细使用介绍。(通过点击主面板左上角的 Patch Library 打开)\n\n![2016101159731panel_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_2.png)\n\n**参数区：** 这里设置各个 Patch 需要的输入参数。(通过点击主面板工具栏上的 Parameters 打开)\n\n![2016101163517panel_3.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_3.png)\n\n**Viewer：** 显示窗口，这里可以对 Layer 做处理，也可以响应用户操作。比如鼠标点击，移动，滑动等。\n\n![2016101121147panel_4.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_4.png)\n\n\n\n### 2. Filter 编辑 & 放大眼睛实战\n\n首先，点击 Patch Library，添加一个 Core Image Filter。\n\n![2016101898471qc_demo_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_1.png)\n\n\n\n选中这个 Filter，点击 Patch Inspector，选择 Settings，进入编辑页面。\n\n改成如下放大眼睛核心代码：\n\n```objc\nkernel vec4 coreImageKernel(sampler image, vec2 centerPostion, float radius, float scaleRatio, float aspectRatio)\n{\n\tvec2 currentPosition = destCoord();\n\tvec2 positionToUse = currentPosition;\n\n     vec2 currentPositionToUse = vec2(currentPosition.x, currentPosition.y * aspectRatio + 0.5 - 0.5 * aspectRatio);\n     vec2 centerPostionToUse = vec2(centerPostion.x, centerPostion.y * aspectRatio + 0.5 - 0.5 * aspectRatio);\n     \n     float r = distance(currentPositionToUse, centerPostionToUse);\n     \n     if(r < radius)\n     {\n         float alpha = 1.0 - scaleRatio * (r / radius - 1.0)*( r / radius - 1.0);\n         positionToUse = centerPostion + alpha * (currentPosition - centerPostion);\n         return sample(image, samplerTransform(image, positionToUse));\n     }\n     else\n     {\n     \treturn sample(image, samplerTransform(image, positionToUse));\n     }\n}\n```\n\n![201610185070qc_demo_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_2.png)\n\n> PS：这里不再讲解这个眼睛放大 kernel 的实现原理。\n>\n> 我强烈建议你在了解了前面的内容后，自己试着解读这个 kernel。\n\n另外，这里还有几个需要说明的地方。\n\n- Define Outp Image Domain of Definition as Union of Input Sampler DODs：输入输出图片的 DOD 一致。\n- Show Advanced Input Sampler Options：显示更多选项。\n- Edit Filter Function：编辑 Filter 函数。\n\n一般选中第一项就好。 如果有特殊需求，需要自定义 DOD，ROI，则选择 **Edit Filter Function**，进入编辑模式。\n\n```objc\nfunction __image main(__image image, __vec2 centerPostion, __number radius, __number scaleRatio, __number aspectRatio) {\n      return coreImageKernel.apply(image.definition, null, image, centerPostion, radius, scaleRatio, aspectRatio);\n}\n```\n\n这样就可以对默认的 function 进行编辑。在这个 Demo 里面我们不需要，感兴趣可以自己实践下，很简单。\n\n这个时候，主面板应该长这样：\n\n![201610184625qc_demo_3.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_3.png)\n\n然后拖拽一张图片到主面板中，把图片的 Output Image 与 Filter 的 Input Image 想连接。\n\n再从 Patch Library 中选择 Billboard。把 Filter 的 Output Image 与 Billboard 的 Input Image 相连接。\n\n![2016101846779qc_demo_4.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_4.png)\n\n然后选中 Filter，打开 Parameters 面板，输入参数值，即可。\n\n当然，放大眼睛这里需要定位到眼睛的位置，是否可以通过鼠标操作来获取点呢？再或者，眼睛放大效果不够直观，有没有办法鼠标按下显示效果图，松开显示原图呢？在 QC 里头，这些都不是问题~不过工具类的使用，更多的还是得靠自己去摸索，这里不再累述。可以参考 EnlargeEyes.qtz 文件，了解更多的操作。\n\n最终的效果应该是这样的：\n\n![201610184575enlargeEyes_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/enlargeEyes_demo.gif)\n\n\n\n\n\n## 总结\n\n至此，关于 Core Image 自定义 Filter 相关的内容，就已经都讲完了。这篇近万字的文章，花了很多功夫总结出来，希望，对你有所帮助！\n\n那么，打开脑洞，创造更有趣的 Filter 吧~\n\nHave fun~   \n\n\n\n**PS：源码下载地址：** [CoreImageDemo](https://github.com/colin1994/CoreImageDemo)\n\n\n\n## 延伸阅读\n\n[Core Image Kernel Language Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397-CH1-SW1)\n\nCore Image Kernel Language 官方概述。\n\n[Writing Kernels](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingKernels/WritingKernels.html)\n\n官方教程。\n\n[Kernel Routine Rules](http://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW4)\n\n官方准则。\n\n[Region-of-Interest Methods](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW2) \n\nROI 教程。\n\n[Quartz Composer User Guide](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/QuartzComposerUserGuide/qc_intro/qc_intro.html#//apple_ref/doc/uid/TP40005381-CH201-TPXREF101)\n\nQC 官方指南。\n\n","source":"_posts/Core-Image-Custom-Filter.md","raw":"title: Core Image 之自定义 Filter~\ndate: 2016-10-21 22:37:08\n\ntags:\n\n- Core Image\n\n------\n\nCore Image 系列，目前的文章如下：\n\n- [Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)\n- [Core Image 之自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)\n- [Core Image【3】—— 2017 新特性](https://xiaozhuanlan.com/topic/3095648721)\n- [Core Image【4】—— 2018 新特性](https://xiaozhuanlan.com/topic/5094762183)\n\n\n\n------\n\n\n\n## 前言\n\n最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~\n\n本文主要讲解 Core Image 自定义滤镜部分的内容，包括如何使用自定义 Filter，如何编写 kernel，QC 工具介绍，注意点以及一些开发技巧。\n\n在这之前，我默认你了解 Core Image 的基本原理以及使用方式。如果没有，我建议你花点时间看看我的上一篇文章：[Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)，它介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比，想必会有所收获。\n\n现在，开始吧～![](http://wanzao2.b0.upaiyun.com/system/pictures/1/original/27.png)\n\n\n\n<!--more-->\n\n\n\n## 自定义 Filter 流程\n\n自定义的 Filter 和系统内置的各种 CIFilter，使用起来方式是一样的。我们唯一要做的，就是实现一个符合规范的 CIFilter 的子类，然后该怎么用怎么用。\n\n这里总结起来就3步：\n\n- 编写 CIKernel：使用 CIKL，自定义滤镜效果。\n- 加载 CIKernel：CIFilter 读取编写好的 CIKernel。\n- 设置参数：设置 CIKernel 需要的输入参数以及 DOD 和 ROI。\n\n不难看出，这些操作都是围绕 **CIKernel** 展开的，那么，它是什么？ CIKL，DOD，ROI 又是什么鬼？![](http://wanzao2.b0.upaiyun.com/system/pictures/14/original/5.png)\n\n\n\n先撇开这些麻烦的东西，我们先这样简单的认为：\n\n- CIKernel 是我们 Filter 对应的脚本，它描述 Filter 的具体工作原理。\n- CIKL （Core Image Kernel Language）是编写 CIKernel 的语言。\n- DOD，ROI 当做普通的参数处理。\n\n\n\n弄清了这些，我们再来看具体操作过程。\n\n拿一个图片翻转效果举例，效果如下：\n\n![2016101449356mirrorX.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mirrorX.png)\n\n### 1. 编写 CIKernel\n\n**File —> New —> File —> Empty**， 创建一个名为 **MirrorX.cikernel** 的文件。\n\n编辑 .cikernel 文件，比如：\n\n```objc\nkernel vec2 mirrorX ( float imageWidth ) \n{\n  \t// 获取待处理点的位置\n  \tvec2 currentVec = destCoord();\n    // 返回最终显示位置\n  \treturn vec2 ( imageWidth - currentVec.x , currentVec.y ); \n}\n```\n\n> PS：这个 kernel 如果有不懂的，可以先跳过。下文会重点说明。\n\n\n\n### 2. 加载 CIKernel\n\n**File —> New —> File —> Cocoa Touch Clas**，新建一个继承自 CIFilter 的类，比如 **MirrorXFilter**。\n\n在 **MirrorXFilter.m** 中，添加如下代码：\n\n```objc\nstatic CIKernel *customKernel = nil;\n\n- (instancetype)init {\n    \n    self = [super init];\n    if (self) {\n        if (customKernel == nil)\n        {\n            NSBundle *bundle = [NSBundle bundleForClass: [self class]];\n            NSURL *kernelURL = [bundle URLForResource:@\"MirrorX\" withExtension:@\"cikernel\"];\n            \n            NSError *error;\n            NSString *kernelCode = [NSString stringWithContentsOfURL:kernelURL\n                                                            encoding:NSUTF8StringEncoding error:&error];\n            if (kernelCode == nil) {\n                NSLog(@\"Error loading kernel code string in %@\\n%@\",\n                      NSStringFromSelector(_cmd),\n                      [error localizedDescription]);\n                abort();\n            }\n            \n            NSArray *kernels = [CIKernel kernelsWithString:kernelCode];\n            customKernel = [kernels objectAtIndex:0];\n        }\n    }\n    return self;\n}\n```\n\n\n\n这段代码很简单，重写 **init** 方法，主要就是读取 .cikernel 文件中代表 CIKernel 的字符串（当然， CIKernel 也可以直接写在 NSString 里头，免去文件读取这步），然后使用 **kernelsWithString**\n\n方法获取到真正的 CIKernel 对象。\n\n```objc\n+ (nullable NSArray<CIKernel *> *)kernelsWithString:(NSString *)string  NS_AVAILABLE(10_4, 8_0);\n```\n\n至此，CIKernel 加载完毕。\n\n\n\n### 3. 设置参数\n\n在 **MirrorXFilter.m** 中，添加需要的成员变量。\n\n```objc\n@interface MirrorXFilter () {\n    CIImage  *inputImage;\n}\n```\n\n这里只需要一个成员变量，**inputImage** 表示我们的输入图片。\n\n之后，就是设置参数，传入 kernel 中。\n\n```objc\n// 使用\n- (CIImage *)outputImage\n{\n    CGFloat inputWidth = inputImage.extent.size.width;\n    CIImage *result = [customKernel applyWithExtent: inputImage.extent roiCallback: ^( int index, CGRect rect ) {\n        return rect;\n    } inputImage: inputImage arguments: @[@(inputWidth)]];\n    return result;\n}\n```\n\n这里只需要重写 outputImage 方法即可。\n\n**extent** 用于返回 CIImage 对象对应的 bounds，通过它可以拿到图片的宽度。\n\n```objc\n/* Return a rect the defines the bounds of non-(0,0,0,0) pixels */\n@property (NS_NONATOMIC_IOSONLY, readonly) CGRect extent;\n```\n\n然后通过  applyWithExtent 来设置对应的参数。\n\n```objc\n- (nullable CIImage *)applyWithExtent:(CGRect)extent\n                          roiCallback:(CIKernelROICallback)callback\n                           inputImage:(CIImage*)image\n                            arguments:(nullable NSArray<id> *)args;\n```\n\n这里有4个参数。\n\n- extent，也就是之前提到的 DOD，暂且略过。\n- callback，也就是之前提到的 ROI，暂且略过。\n- image，缺省的 inputImage，传入我们的成员变量 inputImage 即可。\n- args，输入参数数组，与 CIKernel 中定义的一一对应。这里只有一个 inputWidth。\n\n> PS：这里可能有同学会有疑惑，为什么 inputImage 可以缺省，inputWidth 就需要传入呢。这里暂且不纠结，下面会详细说明~\n\n如此，一个自定义 Filter 就完成了。简单吧~\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png)\n\n\n\n### 4. 使用\n\n至于使用上，则和普通的 CIFilter 基本一致。\n\n```objc\n#import \"MirrorXFilter.h\"\n\n// 1. 将UIImage转换成CIImage\nCIImage *ciImage = [[CIImage alloc] initWithImage:self.imageView.image];\n\n// 2. 创建滤镜\nself.filter = [[MirrorXFilter alloc] init];\n// 设置相关参数\n[self.filter setValue:ciImage forKey:@\"inputImage\"];\n\n// 3. 渲染并输出CIImage\nCIImage *outputImage = [self.filter outputImage];\n\n// 4. 获取绘制上下文\nself.context = [CIContext contextWithOptions:nil];\n\n// 5. 创建输出CGImage\nCGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]];\nUIImage *image = [UIImage imageWithCGImage:cgImage];\n// 6. 释放CGImage\nCGImageRelease(cgImage);\n```\n\n如此，我们便可得到翻转后的图片。\n\n\n\n### 5. 更多\n\n当然，如果你是一个完美主义者，我觉得你还还可以做更多~\n\n```objc\n- (NSDictionary *)customAttributes\n{\n    return @{\n        @\"inputDistance\" :  @{\n            kCIAttributeMin       : @0.0,\n            kCIAttributeMax       : @1.0,\n            kCIAttributeSliderMin : @0.0,\n            kCIAttributeSliderMax : @0.7,\n            kCIAttributeDefault   : @0.2,\n            kCIAttributeIdentity  : @0.0,\n            kCIAttributeType      : kCIAttributeTypeScalar\n            },\n        @\"inputSlope\" : @{\n            kCIAttributeSliderMin : @-0.01,\n            kCIAttributeSliderMax : @0.01,\n            kCIAttributeDefault   : @0.00,\n            kCIAttributeIdentity  : @0.00,\n            kCIAttributeType      : kCIAttributeTypeScalar\n            },\n         kCIInputColorKey : @{\n         kCIAttributeDefault : [CIColor colorWithRed:1.0\n                                               green:1.0\n                                                blue:1.0\n                                               alpha:1.0]\n           },\n   };\n}\n```\n\n可以为自定义的 Filter 添加对应的参数描述，以及默认值，范围限制等。\n\n这不是必须的，但却是可取的。至于如何设置，可以参考 CIFilter 对应的 **attributes** 属性，或者参照上面这个例子。\n\n\n\n另外，iOS 9之后，引入了 **registerFilterName** , 你可以通过重写 `+ (CIFilter *)filterWithName: (NSString *)name;` ，然后外部使用的时候，跟 CIFilter 一模一样。\n\n```objc\n/** Publishes a new filter called 'name'.\n\n The constructor object 'anObject' should implement the filterWithName: method.\n That method will be invoked with the name of the filter to create.\n The class attributes must have a kCIAttributeFilterCategories key associated with a set of categories.\n @param   attributes    Dictionary of the registration attributes of the filter. See below for attribute keys.\n*/\n+ (void)registerFilterName:(NSString *)name\n               constructor:(id<CIFilterConstructor>)anObject\n           classAttributes:(NSDictionary<NSString *,id> *)attributes NS_AVAILABLE(10_4, 9_0);\n```\n\n不过需要 iOS 9以上才支持，另外一般用于打包成 Image Units 给他人使用。\n\n正常情况下应该是用不到。如果真有这个需求，可以参考这篇文章： [Packaging and Loading Image Units](https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_image_units/ci_image_units.html#//apple_ref/doc/uid/TP30001185-CH7-SW12)。\n\n\n\n至此，自定义 Filter 的流程就算走完了，我们很容易就可以配置好需要的环境。\n\n然而，真正的自定义部分，才刚刚开始！\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/183/original/%E5%BC%80%E5%BF%8336.png)\n\n\n\n## DOD & ROI\n\n### 1. DOD\n\nDOD ( domain of definition ) ，简单来说就是 Filter 处理后，输入的图片区域。\n\n一般来说，Filter 操作都是基于原图，添加上效果，但是并不会改变图片的大小，显示区域。所以一般与原图的一致即可。\n\n```objc\nCGRect dod = inputImage.extent; \n```\n\n但是针对形变类的 Filter，则需要根据输出图片大小，设置正确的 DOD。\n\n\n\n### 2. ROI\n\nROI ( region of interest )，在一定的时间内特别感兴趣的区域，即当前处理区域。\n\n可以简单的理解为：当前处理区域对应于原图中的哪个区域。\n\nROI 的定义如下：\n\n```objc\n/* Block callback used by Core Image to ask what rectangles of a kernel's input images\n * are needed to produce a desired rectangle of the kernel's output image.\n *\n * 'index' is the 0-based index specifying which of the kernel's input images is being queried.\n * 'destRect' is the extent rectangle of kernel's output image being queried.\n *\n * Returns the rectangle of the index'th input image that is needed to produce destRect.\n * Returning CGRectNull indicates that the index'th input image is not needed to produce destRect.\n * The returned rectangle need not be contained by the extent of the index'th input image.\n */\ntypedef CGRect (^CIKernelROICallback)(int index, CGRect destRect);\n```\n\nCIKernelROICallback 在 Core Image 内部进行处理的时候，会多次调用。\n\n**index** 表示输入图片的下标，顺序和 kernel 中的入参顺序一致，从0开始。\n\n**destRect** 表示输出图片的区域。 也就是我们先前设置的 DOD。\n\n那，我们为什么要显示设置 ROI 呢 ？\n\n因为输入图片中，参与处理的实际区域，Core Image 是无法知道的，我们需要显式的告诉 CI 这个区域。\n\n这么讲可能有点难以理解，下面我们看两个具体的例子。\n\n先看一个旋转的例子。\n\n![2016101449433roi_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/roi_1.png)\n\n这里就是进行了 x，y 互换操作。很容易得到我们的 DOD：\n\n```objc\nCGRect dod = CGRectMake(inputImage.extent.origin.y, inputImage.extent.origin.x, inputImage.extent.size.height, inputImage.extent.size.width);\n\n// e.g.\n// 原图片extent (0, 0, 200, 300)\n// 旋转后的输出图片 (0, 0, 300, 200)，也就是 DOD\n```\n\n那 ROI 应该怎么设置呢 ？我们之前说过，ROI 计算就是计算当前处理区域对应于原图中的哪个区域。\n\n也就是一个逆向过程。\n\n假如，A：输入图片中的某点   B：输出图片中的某点。那么 ROI 计算可以理解成  ROI（B）= A。\n\n理解好这点，我们不难写出这个操作对应的 ROI：\n\n```objc\nCIKernelROICallback callback = ^(int index, CGRect rect) {\n    return CGRectMake(rect.origin.y, rect.origin.x, rect.size.height, rect.size.width);\n};\n```\n\n另外，当输入图片不止一个的时候，则需要根据 **index** 来做区别。因为这里的 **rect** 每次都是返回 **DOD**，而不是当前图片的 extent。\n\n\n\n## CIKernel 介绍\n\n终于到了本文最重要的部分了，CIKernel 介绍！\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/187/original/%E5%BC%80%E5%BF%83ForeverAloneExcited.png)\n\n在此之前，我们先了解下它的一些背景知识。\n\nCIKernel 需要使用 Core Image Kernel Language (CIKL) 来编写，CIKL 是 OpenGL Shading Language (GLSL) 的子集，如果你之前有过 OpenGL 着色器编写的经验，这部分你会感觉格外亲切。CIKL 集成了 GLSL 绝大部分的参数类型和内置函数，另外它还添加了一些适应 Core Image 的参数类似和函数。\n\n一个 kernel 的处理过程，可以用下面伪代码表示：\n\n```objc\nfor i in 1 ... image.width\n    for j in 1 ... image.height\n        New_Image[i][j] = CustomKernel(Current_Image[i][j])\n    end\nend\n```\n\n也就是说，每个需要处理的 fragment 都会调用一次 kernel 相关操作，每次操作的目的就是返回当前 fragment 对应的结果 fragment，这里 fragment 可以理解为像素点。\n\n所以我们的 kernel，应该是针对一个点，而不是一张图片。\n\n\n\nCore Image 内置了3种适用于不同场景的 Kernel，可以根据实际需求来选择。\n\n- CIColorKernel：用于处理色值变化的 Filter。\n- CIWarpKernel：用于处理形变的 Filter。\n- CIKernel：通用。\n\nCIColorKernel，CIWarpKernel 是官方推荐使用的。某个 Filter，在使用它们能实现的情况下，应该使用它们，即使是一个 CIKernel 拆分成多个 CIColorKernel 以及 CIWarpKernel，也应该用这种方式。因为 Core Image 内部对这两张 Kernel 做了优化。\n\n当然，它们的使用时有限制的。目的一定要很纯粹，比如 CIColorKernel 只能处理色值上的变化。否则就算定义为 CIColorKernel，如果实现上涉及了其他 CIColorKernel 不允许的操作，Core Image 也会当做普通的 CIFilter 处理。\n\n另外，kernel 的入参只支持下面这么几种：\n\n| Kernel routine input parameter | Object    |\n| ------------------------------ | --------- |\n| sampler                        | CISampler |\n| __table sampler                | CISampler |\n| __color                        | `CIColor` |\n| float                          | NSNumber  |\n| vec2, vec3, or vec4            | CIVector  |\n\n简单说明一下：\n\n- sampler：可以理解成纹理，或者图片。外部以 CIImage 形式传入。\n- __table sampler：表示颜色查找表（lookup table），虽然它也是图片，但是添加该声明可以避免被修改。外部以 CIImage 形式传入。\n- __color：表示颜色。外部以 CIColor 形式传入。\n- float：kernel 内部处理都是 float 类型。外部以 NSNumber 形式传入。\n- vecN：表示一个多元向量。比如 vec2 可以表示一个点，vec4 可以表示一个色值。外部以 CIVector 形式传入。\n\n至于 kernel 中可以使用的函数，那就太多了。这里不一一枚举，在下面的具体讲解中，会说明几个常用的。如果想了解更多，可以参考  [Core Image Kernel Language Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397)，以及 [OpenGL ES Shading Language Reference](http://www.shaderific.com/glsl/)。\n\n\n\n下面我会通过一个 Demo，讲解这三种 Kernel 的具体用法。\n\n> PS：建议阅读之前，下载 [源码](https://github.com/colin1994/CoreImageDemo) 配合着看。\n\n\n\n### 1. CIColorKernel\n\n首先看下官方的定义：\n\n```objc\n/*\n * CIColorKernel is an object that encapsulates a Core Image Kernel Language\n * routine that processes only the color information in images.\n *\n * Color kernels functions are declared akin to this example:\n *   kernel vec4 myColorKernel (__sample fore, __sample back, vec4 params)\n *\n * The function must take a __sample argument for each input image.\n * Additional arguments can be of type float, vec2, vec3, vec4, or __color.\n * The destination pixel location is obtained by calling destCoord().\n * The kernel should not call sample(), sampleCoord(), or samplerTransform().\n * The function must return a vec4 pixel color.\n */\nNS_CLASS_AVAILABLE(10_11, 8_0)\n@interface CIColorKernel : CIKernel\n```\n\n很重要的一点：**processes only the color information in images**，它只处理图片的颜色信息。\n\n所以在使用它之前，一定要确保该 Filter 只涉及颜色处理。\n\nCIKL 的语法和大多数 C 阵营一样，变量，运算符，控制结构，函数等都大同小异，所以它的学习成本是很低的。\n\n真正的核心应该是：**如果用这样的语言来实现这个滤镜，也就是我们经常说的算法。**\n\n下面我们以一个 **Vignette** 来实际讲解一下。\n\n它的效果如下所示：\n\n![2016101796011vignette_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette_demo.gif)\n\n不难看出，Vignette 滤镜，它实际上就是一个FOV（Field of View） 的效果，即视野中央看的最清楚，清晰程度与到中心距离呈反比，与人类的视觉是类似的。\n\n![2016101524815vignette.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette.png)\n\n所以针对图片上的每个像素点 A，经过 Vignette 滤镜处理后得到的 B，应该满足：\n\nVignette（A）＝ A * Darken ＝ B； 而 Darken 的计算依赖 A 与中心点的距离。\n\n如此，我们可以很容易的写出对应的 kernel：\n\n```objc\nkernel vec4 vignetteKernel(__sample image, vec2 center, float radius, float alpha)\n{\n    // 计算出当前点与中心的距离\n    float distance = distance(destCoord(), center) ;\n    // 根据距离计算出暗淡程度\n    float darken = 1.0 - (distance / radius * alpha);\n    // 返回该像素点最终的色值\n    image.rgb *= darken;\n\n    return image.rgba;\n}\n```\n\n和 C 语言的一样，函数需要具备：\n\n- 返回类型：vec4\n- 函数名：vignetteKernel\n- 参数列表：__sample image, vec2 center, float radius, float alpha）\n- 函数体：｛｝中的具体实现\n\n有所不同的，kernel 函数需要带上 kernel 关键字，与其它普通函数做区分。一个 .cikernel 文件中，允许包括多个函数，甚至是多个 kernel 函数，不过**函数调用要出现在函数定义之后**！\n\n另外，这里有个特别的参数类型，**__sample** ，和之前讲的 **sampler** 有所不同。因为这里我们使用的是 **CIColorKernel**，在得到高效性能的同时，也有一定的局限性。因为只是处理图片当前位置的颜色信息，所以 **__sample** 提供的 **rgba** 变量足够了，无法获取一些其它的信息。\n\n> 比如在 CIKernel 中，可以通过 sample() 等函数获取其它位置的色值，而在 CIColorKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。\n\n下面逐行解释这个 kernel。\n\n```objc\n// 计算出当前点与中心的距离\nfloat distance = distance(destCoord(), center) ;\n```\n\n**destCoord**\n\n- `varying vec2 destCoord ()`\n\n  返回当前正在处理的像素点所处坐标。(working space coordinates)\n\n这里使用的 CIKL 内置的函数 destCoord，它返回的坐标是基于 **working space** 的。所谓 working space，即工作空间，它的取值范围对应图片实际大小。比如 inputImage 的大小为 300 * 200，那么 destCoord() 返回坐标的取值范围在 (0, 0) - (300, 200)。\n\n**distance**\n\n- `float distance (vec2 p0, vec2 p1)`\n\n  计算向量p0，p1之间的距离\n\n如此便能很容易得到当前点与中心的距离。\n\n```objc\n// 根据距离计算出暗淡程度\nfloat darken = 1.0 - (distance / radius * alpha);\n```\n\n之后根据清晰程度与到中心距离呈反比这一原理，结合外部控制的 **alpha** 变量，计算出暗淡程度。\n\n```objc\n// 返回该像素点最终的色值\nimage.rgb *= darken;\nreturn image.rgba;\n```\n\n这里之前提到，**__sample** 有个 rgba 变量，通过它可以获取到当前处理点的色值。\n\n在 CIKL 中，vec4 的任何一个分量都可以单独获取，也可以组合获取，例如 **image.a**，**image.rrgg** 等，都是可行的。\n\nCIColorKernel 是针对色值的处理，所以它的返回值必须是一个代表色值的 vec4 类型变量。\n\n至此，这个 vignetteKernel 就分析完毕了。很简单吧～\n\n\n\n### 2. CIWarpKernel\n\n同样，先看下文档定义：\n\n```objc\n/*\n * CIWarpKernel is an object that encapsulates a Core Image Kernel Language\n * function that processes only the geometry of an image.\n *\n * Warp kernels functions are declared akin to this example:\n *   kernel vec2 myWarpKernel (vec4 params)\n *\n * Additional arguments can be of type float, vec2, vec3, vec4.\n * The destination pixel location is obtained by calling destCoord().\n * The kernel should not call sample(), sampleCoord(), or samplerTransform().\n * The function must return a vec2 source location.\n */\nNS_CLASS_AVAILABLE(10_11, 8_0)\n@interface CIWarpKernel : CIKernel\n```\n\n同样，它也有很重要一点：**processes only the geometry of an image**。它只处理图片的几何形状。\n\n所谓的改变几何形状，也就是形变，把原本放置在 A 处的点，用 B 处的点去填充，或者反过来，把原本 B 处的点，挪到 A 处去，也是一样的。\n\n它可以用这个表达式表示：**Warp（A）＝ B；**\n\n所以它和之前的 CIColorKernel 不同，它的返回值是 vec2，代表点的坐标。另外它只允许传入一张图片，所以这里的 inputImage 缺省了。\n\n> 同样的，在 CIWarpKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。\n\n\n\n下面以一个马赛克，像素化（Pixellate）的例子来讲解。它的效果如下：\n\n![2016101762677pixellate_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/pixellate_demo.gif)\n\n马赛克，比较简单的一种算法是按照固定的间隔取像素点，将图片分割成一些小块，然后每个小块内选择一个像素点，然后把这个区域全部用这个像素点填充即可。这里的每个小块，称作晶格，晶格越大，马赛克效果越好。\n\n依照这个简单算法，我们可以很容易的写出对应的 kernel：\n\n```objc\nkernel vec2 pixellateKernel(float radius)\n{\n    vec2 positionOfDestPixel, centerPoint;\n    // 获取当前点坐标\n    positionOfDestPixel = destCoord();\n    // 获取对应晶格内的中心像素点\n    centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * 2.0) + radius;\n    centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * 2.0) + radius;\n\n    return centerPoint;\n}\n```\n\n同样的，先是获取到当前处理点的坐标，positionOfDestPixel。\n\n```objc\n// 获取对应晶格内的中心像素点\ncenterPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * 2.0) + radius;\ncenterPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * 2.0) + radius;\n```\n\n然后这里的 **mod (x, y)** 和平时使用的一样，计算 **x / y 的余数**。\n\n至于为什么这个式子能获得**中心像素点坐标**，想必一看就懂了吧～（不懂的可以拿张纸画画）\n\n最后返回中心点坐标，替换当前点。\n\n如此，一个简单的马赛克就完成了～\n\n\n\n### 3. CIKernel\n\n我们之前说过，CIColorKernel 和 CIWarpKernel 内部做了优化，要尽可能的使用它们。除非真的有特殊需求，是它们无法实现的。下面罗列了 CIColorKernel 和 CIWarpKernel 的一些局限：\n\n**CIColorKernel ：**\n\n- 只处理当前处理点色值，无法获取到其它点的状态。\n\n**CIWarpKernel：**\n\n- 只处理当前处理点位置，无法获取到其它点的状态。\n- 只能传入一张图片。\n\n比如说，美图秀秀里面的一些简单马赛克，效果如下：\n\n![2016101864134mosaic_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mosaic_demo.gif)\n\n\n\n它的实现方式，我们可以简单的这么理解：\n\n1. 判断当前点是否在传入点的处理范围内。\n2. 如果在，返回马赛克贴图中对应的像素点色值。\n3. 如果不在，返回当前点色值。\n\n很明显，它需要两张图片，一张我们的待处理图片，一张马赛克贴图。所以 CIWarpKernel 不适用。\n\n另外，待处理图片与马赛克贴图之前不是一一对应关系，在第二步，返回马赛克贴图中对应的像素点色值中，需要一个映射计算，即当前点对应马赛克贴图中的某点。所以 CIColorKernel 也不适用。\n\n这种情况下，就要使用通用的 CIKernel 了。\n\n下面是对应的 kernel：\n\n```objc\nkernel vec4 mosaicKernel(sampler image, sampler maskImage, float radius, vec2 point, float maskWidth, float maskHeight)\n{\n    // 获取当前点坐标\n    vec2 textureCoordinate = destCoord();\n    // 计算当前点与传入点的距离\n    float distance = distance(textureCoordinate, point);\n    if (distance < radius) {\n        // 在处理范围内, 计算对应马赛克贴图中的位置\n        float resultX = mod(textureCoordinate.x, maskWidth);\n        float resultY = mod(textureCoordinate.y, maskHeight);\n        return sample(maskImage, samplerTransform(maskImage, vec2(resultX, resultY)));\n    }\n    else {\n        // 返回原图对应像素点色值\n        return sample(image, samplerTransform(image, textureCoordinate));\n    }\n}\n```\n\n\n\n这里参数比较多，分别对应：\n\n- image：待处理图片\n- maskImage：马赛克贴图\n- radius：处理范围，半径\n- point：传入点，即当前触摸的点\n- maskWidth：马赛克贴图宽度\n- maskHeight：马赛克贴图高度\n\n上面的 kernel，使用了两个新的函数，sample 和 samplerTransform。\n\n> `vec4 sample (uniform sampler src, vec2 point)` \n> Returns the pixel value produced from sampler src at the position point, where point is specified in sampler space.\n>\n> 返回图片 src 指定点 point 处的色值。point 是基于 sampler space。\n>\n> `vec2 samplerTransform (uniform sampler src, vec2 point)` \n> Returns the position in the coordinate space of the source (the first argument) that is associated with the position defined in working-space coordinates (the second argument). (Keep in mind that the working space coordinates reflect any transformations that you applied to the working space.) For example, if you are modifying a pixel in the working space, and you need to retrieve the pixels that surround this pixel in the original image, you would make calls similar to the following, where d is the location of the pixel you are modifying in the working space, and image is the image source for the pixels.\n>\n> 返回图片 src 指定点 point 处坐标对应的基于 sampler space 的坐标。point 是基于working space。\n>\n> sampler space 的取值是 0.0 - 1.0，左下角为原点，向右，向上递增。\n\n了解了这两个函数的用法，想必这段代码就没什么需要特别说明的地方了，注释已经很清楚，不再累述。\n\n\n\n## 注意点\n\n### 1. premultiply\n\n> `vec4 premultiply (vec4 color)` \n> Multiplies the red, green, and blue components of the color parameter by its alpha component.\n\n将颜色变量的r、g、b元素值分别于 alpha 相乘，返回一个新的四维颜色向量。\n\n> `vec4 unpremultiply (vec4 color)` \n> If the alpha component of the color parameter is greater than 0, divides the red, green and blue components by alpha. If alpha is 0, this function returns color.\n\n将颜色变量的r、g、b元素值分别除以 alpha ，返回一个新的四维颜色向量。\n\npixel（R, G, B, A） —— (premultiply) ——> (R＊A, G＊A, B＊A, A)\n\n—— (unpremultiply) ——> （R, G, B, A）。\n\n在 Core Image 中，默认颜色空间是 sRGB，在 kernel 中得到的色值，都经过了 Premultiplied Alpha 处理。\n\n至于为什么要执行 Premultiplied Alpha 操作，具体的可以参考这篇文章：[为什么要PREMULTIPLIED ALPHA呢？](https://boundary.cc/2015/07/why-premultiplied-alpha/)\n\n\n\n所以如果 kernel 涉及 alpha 相关操作，则需要先执行 unpremultiply，返回正确的 rgba。处理完之后，再执行 premultiply 操作。\n\n比如一个反相滤镜，\n\n![2016101643860rever_1.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_1.gif)![20161016903rever_2.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_2.gif)\n\n\n\n它对应的 kernel 应该是这样的：\n\n```objc\nkernel vec4 _invertColor(sampler source_image)\n{\n    vec4 pixValue;\n    // samplerCoord 返回当前像素点在 sampler space 中的位置\n    // kernel 无法知道该图片是否进行了某些变换操作，所以确保转换为 sampler space 中的位置 是有必要的\n    pixValue = sample(source_image, samplerCoord(source_image));\n    // 执行 unpremultiply 操作, 得到真正的 RGB 值\n    // (R＊A, G＊A, B＊A, A) ——(unpremultiply)——> (R, G, B, A)\n    // Core Image is always RGB based.\n    unpremultiply(pixValue); \n    // invertColor\n    pixValue.r = 1.0 - pixValue.r; \n    pixValue.g = 1.0 - pixValue.g;\n    pixValue.b = 1.0 - pixValue.b;\n    // premultiply. (R, G, B, A) —> (R＊A, G＊A, B＊A, A)\n    return premultiply(pixValue); \n}\n\n\n// 优化：\n// 避免了 unpremultiply 和 premultiply 操作，能更高效执行。\n// pixValue 是 (R＊A, G＊A, B＊A, A)， pixValue.a - pixValue.r = (1-r)*a. 和最终 premultiply 得到的结果一样.\nkernel vec4 _invertColor(sampler source_image)\n{\n    vec4 pixValue;\n    pixValue = sample(source_image, samplerCoord(source_image));\n    pixValue.rgb = pixValue.aaa - pixValue.rgb;\n    return pixValue;\n}\n```\n\n\n\n### 2. 关键字\n\n和 C 语言等一样，CIKL 中变量的命名不能和关键字相同。\n\n下面是官方 Session 中翻转对应的 kernel 脚本，这里用到了 input 关键字，导致整个 kernel 错误。\n\n![2016101638470session_error.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/session_error.png)\n\n\n\n所以这点一定要牢记。\n\n下面是在 Github 上引起的灾难..\n\n![2016101685335error_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_1.png)\n\n![2016101697866error_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_2.png)\n\n\n\n### 3. GLSL\n\nCIKL 是 GLSL 的子集，所以**不是 GLSL 中定义的任何东西在 CIKL 中都适用**。但是 glsl 中大多数关键字都是可以用的。另外，CIKL 还提供了 glsl 不支持的，额外的数据类型，关键字，方法，来完善 CIKernel。\n\n\n\n### 4. Array, Mat\n\n In addition, the following are not implemented:\n\n- Data types: `mat2`, `mat3`, `mat4`, `struct`, `arrays`\n\n这些数据类型 Core Image 不支持。但是在 kernel 内部却可以使用 … \n\n如果当做参数传入，则会报错：\n\n**invalid kernel parameter type; valid types are:  'float', 'vec2', 'vec3', 'vec4', 'sampler’, ‘sample’, ‘color’**\n\n![](http://wanzao2.b0.upaiyun.com/system/pictures/229/original/%E6%82%B2%E4%BC%A41.png)\n\n\n\n这也导致了一些依赖关键点的算法无法实现。\n\n\n\n### 5. 坐标系\n\nUIKit 坐标系，原点在屏幕左上，x轴向右，y轴向下。\n\nCore Image 和 OpenGL 坐标系原点在屏幕的左下，x轴向右，y轴向上。\n\n所以位置的处理上要注意。\n\n\n\n### 6. 局限\n\nkernel 的输入和输出像素可以相互映射。大多数像素处理都可以用这种方式表达，但是有的图像处理操作很困难，甚至不可能。\n\nkernel 的使用上还是有一定的局限性。比如说通过输入图像映射计算直方图是很困难的。也不可以执行种子填充算法或者其他需要复杂条件语句的图像分析操作。\n\n\n\n### 7. 性能优化\n\nkernel 中的内容要尽可能简单，高效。\n\n- 展开循环操作会更快。\n- 外部能传入的变量，尽量不要在 kernel 中计算获取。\n\n\n\n## 开发技巧\n\n### 1. Log\n\n**+(id)kernelsWithString:(id)arg1 messageLog:(id)arg2 ;**\n\n这是  [CIKernel.h](https://github.com/CPDigitalDarkroom/iOS9-SpringBoard-Headers/blob/a11be523d5644a178614585ff57f9638300c2cc0/System/Library/Frameworks/CoreImage.framework/CIKernel.h) 里面的私有方法，在调试阶段可以利用它来打印 kernel 中的错误。\n\n比如：\n\n```objc\nNSMutableArray *messageLog = [NSMutableArray array];\nNSArray *kernels = [[CIKernel class] \t\t performSelector:@selector(kernelsWithString:messageLog:) withObject:kernelCode withObject:messageLog];\nif ( messageLog.count > 0) \n  \tNSLog(@\"Error: %@\", messageLog.description);\ncustomKernel = [kernels objectAtIndex:0];\n\n// 错误 log\nError: (\n        {\n        CIKernelMessageLineNumber = 5;\n        CIKernelMessageType = CIKernelMessageTypeError;\n        kCIKernelMessageDescription = \"unkown type or function name 'destCoordE'; did you mean 'destCoord'?\";\n        kCIKernelMessageOffset = 142;\n    },\n        {\n        CIKernelMessageLineNumber = 7;\n        CIKernelMessageType = CIKernelMessageTypeError;\n        kCIKernelMessageDescription = \"invalid operands to binary expression ('float' and 'int')\";\n        kCIKernelMessageOffset = 281;\n    }\n)\n```\n\n\n\n### 2. CI_PRINT_TREE\n\n这里 Core Image 中非常实用的一个环境变量，通过设置它，可以很方便的查看 Core Image 工作过程中到底做了什么。比如：\n\n- 工作在 GPU 还是 CPU 上？\n- 各个 kernel 的参数值？\n- Core Image 是如何链接 kernel？\n- DOD，ROI 如何设置的？\n- 对于大图如何拆分处理？\n- ...\n\n> PS ： 至于 CI_PRINT_TREE 具体应该如何使用，没有找到相关资料，只是在 Session 中提到过。\n>\n> 包括 ObjC 中国 上的翻译：你可以通过在 Xcode 中设置计划配置（scheme configuration）里的 CI_PRINT_TREE 环境变量为 1 来决定用 CPU 还是 GPU 来渲染，也是很不准确的。\n>\n> 这里的结论都是自己摸索后的总结，所以可能存在错误或者遗漏，欢迎补充交流～\n\nCI_PRINT_TREE 的设置大致是这样的：分成 A B 两部分，它们可以结合使用。\n\n其中 A 是主要分类，B 是辅助功能。\n\nA 包括：\n\n- 1  initial graph \n- 2  optimized graph \n- 4  tile graph \n- 8  programs graph \n- 16  timing graph \n\nB 包括：\n\n- graphviz \n- dump-inputs \n- dump-intermediates \n- skip-cpu \n- skip-gpu  \n- skip-small \n- frame-<number> \n\n使用上，比如简单的查看 initial graph 做了什么，即我们添加这个 Filter 的时候，初始化过程执行了什么，传入了哪些参数。当然，这个过程它并没有真正得到渲染，只是一个操作流程列表。设置 CI_PRINT_TREE ＝ 1，如下：\n\n![2016101786999ci_print_tree.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/ci_print_tree.png)\n\n它的结果如下：\n\n```objc\ninitial graph render_to_display (opengles2 context 1 frame 1) format=RGBA8 roi=[0 156 750 748] = \n  clamptoalpha roi=[0 156 750 748] extent=[0 156 750 748] opaque\n    colormatch workingspace-to-devicergb roi=[0 156 750 748] extent=[0 156 750 748] opaque\n      affine [2 0 0 2 0 156] roi=[0 156 750 748] extent=[0 156 750 748] opaque\n        colorkernel \n  roi=[0 0 375 374] extent=[0 0 375 374] opaque\n          affine [1 0 0 -1 0 374] roi=[0 0 375 374] extent=[0 0 375 374] opaque\n            colormatch \"sRGB IEC61966-2.1\"-to-workingspace roi=[0 0 375 374] extent=[0 0 375 374] opaque\n              CGImageRef 0x1701c4380 RGBX8 375x374  alpha_one roi=[0 0 375 374] extent=[0 0 375 374] opaque\n```\n\n这里有很多关键信息，十分详细。它的阅读顺序是从下往上，我们简单分析下：\n\n- **CGImageRef**： 指代我们传入的图片。\n- 每个阶段的 **ROI，DOD**。\n- **colormatch \"sRGB IEC61966-2.1\"-to-workingspace** ：传入的颜色空间\n- **vignetteKernel(image,center=[187.5 187],radius=187.5,alpha=0.0537634)** ：kernel 的每个参数\n- **colormatch workingspace-to-devicergb**：  输出的颜色空间\n- **opengles2** ：工作在 GPU 上\n- **context 1 frame 1** ：分别指代当前 context 以及第几帧。每次渲染 frame + 1\n\n当然，这只是 CI_PRINT_TREE 的一部分功能，如果你设置 CI_PRINT_TREE = 8 (programs graph )，你又会得到这样的信息：\n\n```objc\nprograms graph render_to_display (opengles2 context 1 frame 4 tile 1) format=RGBA8 roi=[0 111 640 640] = \n  program affine(clamp_to_alpha(linear_to_srgb(vignetteKernel(affine(srgb_to_linear(swizzle_bgr1())))))) rois=[0 111 640 640] extent=[0 111 640 640]\n    IOSurface 0x60000019ddc0 RGBA8 375x374 alpha_one edge_clamp rois=[0 0 375 374] extent=[infinite][0 0 375 374] opaque\n```\n\n这里描述了程序图表，即真正涉及到的操作。\n\n如果觉得这样看比较杂乱，可以试试添加 B 类辅助功能。 比如：**CI_PRINT_TREE = 8 graphviz** ，这样就可以导出 DOT 语言脚本。然后使用 [Graphviz](http://www.graphviz.org/) 工具，即可绘制这个 DOT 语言脚本描述的图形。\n\n比如上面 Log 对应绘制得到的图形如下：\n\n![201610186930programs_graph.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/programs_graph.png)\n\n同样是从下往上看，各个操作的层级关系就很明显了。除了我们提供的 vignetteKernel，Core Image 内部还做了其他的操作，比如 **linear_to_srgb，clamp_to_alpha** 等。它们的具体实现如下：\n\n```objc\nFilter DAG:\nNode: 0\n  original source: vec4 _ci_clamp_to_alpha(vec4 s) { return clamp(s, 0.0, s.a); }\n  printed AST: vec4 _ci_clamp_to_alpha(vec4 s) {\n  return clamp(s, 0.000000e+00, s.a);\n}\n  children: 1\nEnd Filter Node\n\nNode: 1\n  original source: vec4 _ci_premultiply(vec4 s) { return vec4(s.rgb*s.a, s.a); }\n  printed AST: vec4 _ci_premultiply(vec4 s) {\n  return vec4(s.rgb * s.a, s.a);\n}\n  children: 2\nEnd Filter Node\n\nNode: 2\n  original source: vec4 _ci_linear_to_srgb(vec4 s)\n{\n  s.rgb = sign(s.rgb)*mix(s.rgb*12.92, pow(abs(s.rgb), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s.rgb)));\n  return s;\n}\n  printed AST: vec4 _ci_linear_to_srgb(vec4 s) {\n  s.rgb = sign(s.rgb) * mix(s.rgb * 1.292000e+01, (pow(abs(s.rgb), vec3(4.166667e-01)) * 1.055000e+00) - 5.500000e-02, step(3.130800e-03, abs(s.rgb)));\n  return s;\n}\n  children: 3\nEnd Filter Node\n\nNode: 3\n  original source: vec4 _ci_unpremultiply(vec4 s) { return vec4(s.rgb/max(s.a,0.00001), s.a); }\n  printed AST: vec4 _ci_unpremultiply(vec4 s) {\n  return vec4(s.rgb / max(s.a, 1.000000e-05), s.a);\n}\n  children: 6\nEnd Filter Node\n\nNode: 6\n  <sample with transform>\n  original source: vec4 read_pixel(sampler2D image, vec2 c, mat3 m){ return texture2D(image, (vec3(c, 1.0) * m).xy);}\n  printed AST: vec4 read_pixel_6(sampler2D image, vec2 c, mat3 m) {\n  return texture2D(image, (vec3(c, 1.000000e+00) * m).xy);\n}\n  children: 4 7 5\nEnd Filter Node\n\nNode: 4\n  image: 6\n  printed: uniform lowp sampler2D image6_0\nEnd Filter Node\n\nNode: 7\n  position use <_dc>\nEnd Filter Node\n\nNode: 5\n  <transform>\n  uniform: 6\nEnd Filter Node\n```\n\n这个 DAG（有向无环图），具体描述了相关操作的实现过程，比较简单，可以自己看看，这里不累述。\n\n\n\n## 工具介绍\n\nQuartz Composer 是一款图形化的编程工具，专门用来生成各种动态视觉效果，包括可交互的界面原型。当然，它也支持 Core Image 滤镜图表的原型。\n\n![2016092073920quartz_1.png](http://7xkc7a.com1.z0.glb.clouddn.com/2016092073920quartz_1.png)\n\n另外，在 QC 上编写 Kernel，除了代码高亮，实时调整效果也很棒。\n\n![2016101158579quartz_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/quartz_2.png)\n\n\n\n> PS ：[Quartz Composer 下载地址](https://developer.apple.com/downloads/) \n>\n> 有精力的话建议把 QC 内自带的所有 example 找出来仔细研究，苹果自己的例子是最好的。它们藏在 /Applications/Quartz Composer.app/Contents/Resources/Examples/Patches（找到 Quartz Composer.app 点右键，选择「Show Package Content」）\n>\n>  简单了解 Quartz Composer。QCDesigners 上有比较简要的介绍：[QC Designers](https://link.zhihu.com/?target=http%3A//qcdesigners.com/index.php/forums/topic/2/new-to-quartz-composer-start-he)\n\n\n\n![2016092059430download_Graphic_Tools_for_XCode.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/download_Graphic_Tools_for_XCode.png)\n\n\n\nQC 已经内置了适合 Core Image 的模板，并且实现了动态模糊滤镜效果。不过这里为了了解 QC 的使用方式，不使用内置的模板，从头开始。**File —> New Blank**，创建一个空白的 QC 工程。\n\n> PS： QC 的功能很强大，这里只介绍 Core Image Filter 编辑过程中会用到的，以及我所掌握的...\n\n### 0. 概念介绍\n\n在讲解使用方式之前，介绍几个基本概念。\n\n一次滤镜操作，可以简单理解成： **输入—>(Patch)—>输出**。\n\nPatch 可以理解成 Kernel。\n\n输入则与 Kernel 的参数相对应，可以是 image，color，float...\n\n输入这里一般就是处理后的图像。\n\n还有一个比较特殊的 Patch，Layer。相当于画布，可以把结果图显示在上面，它也有层的概念。\n\n\n\n### 1.  工作区介绍\n\n**编辑区：** 这是主面板，主要衔接各个 Patch，以及它们的输入，输出。\n\n![2016101175676panel_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_1.png)\n\n\n\n**Library：** 这里陈列了 QC 内置的所有 Patch（也可以添加自定义的 Patch 进来），以及它们的详细使用介绍。(通过点击主面板左上角的 Patch Library 打开)\n\n![2016101159731panel_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_2.png)\n\n**参数区：** 这里设置各个 Patch 需要的输入参数。(通过点击主面板工具栏上的 Parameters 打开)\n\n![2016101163517panel_3.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_3.png)\n\n**Viewer：** 显示窗口，这里可以对 Layer 做处理，也可以响应用户操作。比如鼠标点击，移动，滑动等。\n\n![2016101121147panel_4.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_4.png)\n\n\n\n### 2. Filter 编辑 & 放大眼睛实战\n\n首先，点击 Patch Library，添加一个 Core Image Filter。\n\n![2016101898471qc_demo_1.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_1.png)\n\n\n\n选中这个 Filter，点击 Patch Inspector，选择 Settings，进入编辑页面。\n\n改成如下放大眼睛核心代码：\n\n```objc\nkernel vec4 coreImageKernel(sampler image, vec2 centerPostion, float radius, float scaleRatio, float aspectRatio)\n{\n\tvec2 currentPosition = destCoord();\n\tvec2 positionToUse = currentPosition;\n\n     vec2 currentPositionToUse = vec2(currentPosition.x, currentPosition.y * aspectRatio + 0.5 - 0.5 * aspectRatio);\n     vec2 centerPostionToUse = vec2(centerPostion.x, centerPostion.y * aspectRatio + 0.5 - 0.5 * aspectRatio);\n     \n     float r = distance(currentPositionToUse, centerPostionToUse);\n     \n     if(r < radius)\n     {\n         float alpha = 1.0 - scaleRatio * (r / radius - 1.0)*( r / radius - 1.0);\n         positionToUse = centerPostion + alpha * (currentPosition - centerPostion);\n         return sample(image, samplerTransform(image, positionToUse));\n     }\n     else\n     {\n     \treturn sample(image, samplerTransform(image, positionToUse));\n     }\n}\n```\n\n![201610185070qc_demo_2.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_2.png)\n\n> PS：这里不再讲解这个眼睛放大 kernel 的实现原理。\n>\n> 我强烈建议你在了解了前面的内容后，自己试着解读这个 kernel。\n\n另外，这里还有几个需要说明的地方。\n\n- Define Outp Image Domain of Definition as Union of Input Sampler DODs：输入输出图片的 DOD 一致。\n- Show Advanced Input Sampler Options：显示更多选项。\n- Edit Filter Function：编辑 Filter 函数。\n\n一般选中第一项就好。 如果有特殊需求，需要自定义 DOD，ROI，则选择 **Edit Filter Function**，进入编辑模式。\n\n```objc\nfunction __image main(__image image, __vec2 centerPostion, __number radius, __number scaleRatio, __number aspectRatio) {\n      return coreImageKernel.apply(image.definition, null, image, centerPostion, radius, scaleRatio, aspectRatio);\n}\n```\n\n这样就可以对默认的 function 进行编辑。在这个 Demo 里面我们不需要，感兴趣可以自己实践下，很简单。\n\n这个时候，主面板应该长这样：\n\n![201610184625qc_demo_3.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_3.png)\n\n然后拖拽一张图片到主面板中，把图片的 Output Image 与 Filter 的 Input Image 想连接。\n\n再从 Patch Library 中选择 Billboard。把 Filter 的 Output Image 与 Billboard 的 Input Image 相连接。\n\n![2016101846779qc_demo_4.png](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_4.png)\n\n然后选中 Filter，打开 Parameters 面板，输入参数值，即可。\n\n当然，放大眼睛这里需要定位到眼睛的位置，是否可以通过鼠标操作来获取点呢？再或者，眼睛放大效果不够直观，有没有办法鼠标按下显示效果图，松开显示原图呢？在 QC 里头，这些都不是问题~不过工具类的使用，更多的还是得靠自己去摸索，这里不再累述。可以参考 EnlargeEyes.qtz 文件，了解更多的操作。\n\n最终的效果应该是这样的：\n\n![201610184575enlargeEyes_demo.gif](https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/enlargeEyes_demo.gif)\n\n\n\n\n\n## 总结\n\n至此，关于 Core Image 自定义 Filter 相关的内容，就已经都讲完了。这篇近万字的文章，花了很多功夫总结出来，希望，对你有所帮助！\n\n那么，打开脑洞，创造更有趣的 Filter 吧~\n\nHave fun~   \n\n\n\n**PS：源码下载地址：** [CoreImageDemo](https://github.com/colin1994/CoreImageDemo)\n\n\n\n## 延伸阅读\n\n[Core Image Kernel Language Reference](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397-CH1-SW1)\n\nCore Image Kernel Language 官方概述。\n\n[Writing Kernels](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingKernels/WritingKernels.html)\n\n官方教程。\n\n[Kernel Routine Rules](http://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW4)\n\n官方准则。\n\n[Region-of-Interest Methods](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW2) \n\nROI 教程。\n\n[Quartz Composer User Guide](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/QuartzComposerUserGuide/qc_intro/qc_intro.html#//apple_ref/doc/uid/TP40005381-CH201-TPXREF101)\n\nQC 官方指南。\n\n","slug":"Core-Image-Custom-Filter","published":1,"updated":"2019-12-23T01:02:31.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqo1nm002uzwln0ek9vfog","content":"<p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\" target=\"_blank\" rel=\"external\">Core Image 你需要了解的那些事~</a></li>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\" target=\"_blank\" rel=\"external\">Core Image 之自定义 Filter~</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/3095648721\" target=\"_blank\" rel=\"external\">Core Image【3】—— 2017 新特性</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/5094762183\" target=\"_blank\" rel=\"external\">Core Image【4】—— 2018 新特性</a></li>\n</ul>\n<hr>\n<h2 id=\"前言\">前言</h2><p>最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~</p>\n<p>本文主要讲解 Core Image 自定义滤镜部分的内容，包括如何使用自定义 Filter，如何编写 kernel，QC 工具介绍，注意点以及一些开发技巧。</p>\n<p>在这之前，我默认你了解 Core Image 的基本原理以及使用方式。如果没有，我建议你花点时间看看我的上一篇文章：<a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\" target=\"_blank\" rel=\"external\">Core Image 你需要了解的那些事~</a>，它介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比，想必会有所收获。</p>\n<p>现在，开始吧～<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/1/original/27.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"自定义_Filter_流程\">自定义 Filter 流程</h2><p>自定义的 Filter 和系统内置的各种 CIFilter，使用起来方式是一样的。我们唯一要做的，就是实现一个符合规范的 CIFilter 的子类，然后该怎么用怎么用。</p>\n<p>这里总结起来就3步：</p>\n<ul>\n<li>编写 CIKernel：使用 CIKL，自定义滤镜效果。</li>\n<li>加载 CIKernel：CIFilter 读取编写好的 CIKernel。</li>\n<li>设置参数：设置 CIKernel 需要的输入参数以及 DOD 和 ROI。</li>\n</ul>\n<p>不难看出，这些操作都是围绕 <strong>CIKernel</strong> 展开的，那么，它是什么？ CIKL，DOD，ROI 又是什么鬼？<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/14/original/5.png\" alt=\"\"></p>\n<p>先撇开这些麻烦的东西，我们先这样简单的认为：</p>\n<ul>\n<li>CIKernel 是我们 Filter 对应的脚本，它描述 Filter 的具体工作原理。</li>\n<li>CIKL （Core Image Kernel Language）是编写 CIKernel 的语言。</li>\n<li>DOD，ROI 当做普通的参数处理。</li>\n</ul>\n<p>弄清了这些，我们再来看具体操作过程。</p>\n<p>拿一个图片翻转效果举例，效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mirrorX.png\" alt=\"2016101449356mirrorX.png\"></p>\n<h3 id=\"1-_编写_CIKernel\">1. 编写 CIKernel</h3><p><strong>File —&gt; New —&gt; File —&gt; Empty</strong>， 创建一个名为 <strong>MirrorX.cikernel</strong> 的文件。</p>\n<p>编辑 .cikernel 文件，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec2 mirrorX ( <span class=\"keyword\">float</span> imageWidth ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 获取待处理点的位置</span></span><br><span class=\"line\">  \tvec2 currentVec = destCoord();</span><br><span class=\"line\">    <span class=\"comment\">// 返回最终显示位置</span></span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> vec2 ( imageWidth - currentVec.x , currentVec.y ); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：这个 kernel 如果有不懂的，可以先跳过。下文会重点说明。</p>\n</blockquote>\n<h3 id=\"2-_加载_CIKernel\">2. 加载 CIKernel</h3><p><strong>File —&gt; New —&gt; File —&gt; Cocoa Touch Clas</strong>，新建一个继承自 CIFilter 的类，比如 <strong>MirrorXFilter</strong>。</p>\n<p>在 <strong>MirrorXFilter.m</strong> 中，添加如下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CIKernel</span> *customKernel = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (customKernel == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSBundle</span> *bundle = [<span class=\"built_in\">NSBundle</span> bundleForClass: [<span class=\"keyword\">self</span> class]];</span><br><span class=\"line\">            <span class=\"built_in\">NSURL</span> *kernelURL = [bundle URLForResource:<span class=\"string\">@\"MirrorX\"</span> withExtension:<span class=\"string\">@\"cikernel\"</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> *kernelCode = [<span class=\"built_in\">NSString</span> stringWithContentsOfURL:kernelURL</span><br><span class=\"line\">                                                            encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (kernelCode == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error loading kernel code string in %@\\n%@\"</span>,</span><br><span class=\"line\">                      <span class=\"built_in\">NSStringFromSelector</span>(_cmd),</span><br><span class=\"line\">                      [error localizedDescription]);</span><br><span class=\"line\">                abort();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSArray</span> *kernels = [<span class=\"built_in\">CIKernel</span> kernelsWithString:kernelCode];</span><br><span class=\"line\">            customKernel = [kernels objectAtIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，重写 <strong>init</strong> 方法，主要就是读取 .cikernel 文件中代表 CIKernel 的字符串（当然， CIKernel 也可以直接写在 NSString 里头，免去文件读取这步），然后使用 <strong>kernelsWithString</strong></p>\n<p>方法获取到真正的 CIKernel 对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">CIKernel</span> *&gt; *)kernelsWithString:(<span class=\"built_in\">NSString</span> *)string  <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_4, <span class=\"number\">8</span>_0);</span><br></pre></td></tr></table></figure>\n<p>至此，CIKernel 加载完毕。</p>\n<h3 id=\"3-_设置参数\">3. 设置参数</h3><p>在 <strong>MirrorXFilter.m</strong> 中，添加需要的成员变量。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MirrorXFilter</span> () </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span>  *inputImage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只需要一个成员变量，<strong>inputImage</strong> 表示我们的输入图片。</p>\n<p>之后，就是设置参数，传入 kernel 中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">- (<span class=\"built_in\">CIImage</span> *)outputImage</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> inputWidth = inputImage.extent.size.width;</span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *result = [customKernel applyWithExtent: inputImage.extent roiCallback: ^( <span class=\"keyword\">int</span> index, <span class=\"built_in\">CGRect</span> rect ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rect;</span><br><span class=\"line\">    &#125; inputImage: inputImage arguments: @[@(inputWidth)]];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只需要重写 outputImage 方法即可。</p>\n<p><strong>extent</strong> 用于返回 CIImage 对象对应的 bounds，通过它可以拿到图片的宽度。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Return a rect the defines the bounds of non-(0,0,0,0) pixels */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"built_in\">NS_NONATOMIC_IOSONLY</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGRect</span> extent;</span><br></pre></td></tr></table></figure>\n<p>然后通过  applyWithExtent 来设置对应的参数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">CIImage</span> *)applyWithExtent:(<span class=\"built_in\">CGRect</span>)extent</span><br><span class=\"line\">                          roiCallback:(<span class=\"built_in\">CIKernelROICallback</span>)callback</span><br><span class=\"line\">                           inputImage:(<span class=\"built_in\">CIImage</span>*)image</span><br><span class=\"line\">                            arguments:(nullable <span class=\"built_in\">NSArray</span>&lt;<span class=\"keyword\">id</span>&gt; *)args;</span><br></pre></td></tr></table></figure>\n<p>这里有4个参数。</p>\n<ul>\n<li>extent，也就是之前提到的 DOD，暂且略过。</li>\n<li>callback，也就是之前提到的 ROI，暂且略过。</li>\n<li>image，缺省的 inputImage，传入我们的成员变量 inputImage 即可。</li>\n<li>args，输入参数数组，与 CIKernel 中定义的一一对应。这里只有一个 inputWidth。</li>\n</ul>\n<blockquote>\n<p>PS：这里可能有同学会有疑惑，为什么 inputImage 可以缺省，inputWidth 就需要传入呢。这里暂且不纠结，下面会详细说明~</p>\n</blockquote>\n<p>如此，一个自定义 Filter 就完成了。简单吧~</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png\" alt=\"\"></p>\n<h3 id=\"4-_使用\">4. 使用</h3><p>至于使用上，则和普通的 CIFilter 基本一致。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MirrorXFilter.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 将UIImage转换成CIImage</span></span><br><span class=\"line\"><span class=\"built_in\">CIImage</span> *ciImage = [[<span class=\"built_in\">CIImage</span> alloc] initWithImage:<span class=\"keyword\">self</span>.imageView.image];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建滤镜</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.filter = [[MirrorXFilter alloc] init];</span><br><span class=\"line\"><span class=\"comment\">// 设置相关参数</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.filter setValue:ciImage forKey:<span class=\"string\">@\"inputImage\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 渲染并输出CIImage</span></span><br><span class=\"line\"><span class=\"built_in\">CIImage</span> *outputImage = [<span class=\"keyword\">self</span>.filter outputImage];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 获取绘制上下文</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithOptions:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 创建输出CGImage</span></span><br><span class=\"line\"><span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"keyword\">self</span>.context create<span class=\"built_in\">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CGImage</span>:cgImage];</span><br><span class=\"line\"><span class=\"comment\">// 6. 释放CGImage</span></span><br><span class=\"line\"><span class=\"built_in\">CGImageRelease</span>(cgImage);</span><br></pre></td></tr></table></figure>\n<p>如此，我们便可得到翻转后的图片。</p>\n<h3 id=\"5-_更多\">5. 更多</h3><p>当然，如果你是一个完美主义者，我觉得你还还可以做更多~</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)customAttributes</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> @&#123;</span><br><span class=\"line\">        <span class=\"string\">@\"inputDistance\"</span> :  @&#123;</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeMin</span>       : @<span class=\"number\">0.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeMax</span>       : @<span class=\"number\">1.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMin</span> : @<span class=\"number\">0.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMax</span> : @<span class=\"number\">0.7</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeDefault</span>   : @<span class=\"number\">0.2</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeIdentity</span>  : @<span class=\"number\">0.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeType</span>      : k<span class=\"built_in\">CIAttributeTypeScalar</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        <span class=\"string\">@\"inputSlope\"</span> : @&#123;</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMin</span> : @<span class=\"number\">-0.01</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMax</span> : @<span class=\"number\">0.01</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeDefault</span>   : @<span class=\"number\">0.00</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeIdentity</span>  : @<span class=\"number\">0.00</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeType</span>      : k<span class=\"built_in\">CIAttributeTypeScalar</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">         k<span class=\"built_in\">CIInputColorKey</span> : @&#123;</span><br><span class=\"line\">         k<span class=\"built_in\">CIAttributeDefault</span> : [<span class=\"built_in\">CIColor</span> colorWithRed:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                               green:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                                blue:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                               alpha:<span class=\"number\">1.0</span>]</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以为自定义的 Filter 添加对应的参数描述，以及默认值，范围限制等。</p>\n<p>这不是必须的，但却是可取的。至于如何设置，可以参考 CIFilter 对应的 <strong>attributes</strong> 属性，或者参照上面这个例子。</p>\n<p>另外，iOS 9之后，引入了 <strong>registerFilterName</strong> , 你可以通过重写 <code>+ (CIFilter *)filterWithName: (NSString *)name;</code> ，然后外部使用的时候，跟 CIFilter 一模一样。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Publishes a new filter called 'name'.</span><br><span class=\"line\"></span><br><span class=\"line\"> The constructor object 'anObject' should implement the filterWithName: method.</span><br><span class=\"line\"> That method will be invoked with the name of the filter to create.</span><br><span class=\"line\"> The class attributes must have a kCIAttributeFilterCategories key associated with a set of categories.</span><br><span class=\"line\"> @param   attributes    Dictionary of the registration attributes of the filter. See below for attribute keys.</span><br><span class=\"line\">*/</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)registerFilterName:(<span class=\"built_in\">NSString</span> *)name</span><br><span class=\"line\">               constructor:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">CIFilterConstructor</span>&gt;)anObject</span><br><span class=\"line\">           classAttributes:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)attributes <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_4, <span class=\"number\">9</span>_0);</span><br></pre></td></tr></table></figure>\n<p>不过需要 iOS 9以上才支持，另外一般用于打包成 Image Units 给他人使用。</p>\n<p>正常情况下应该是用不到。如果真有这个需求，可以参考这篇文章： <a href=\"https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_image_units/ci_image_units.html#//apple_ref/doc/uid/TP30001185-CH7-SW12\" target=\"_blank\" rel=\"external\">Packaging and Loading Image Units</a>。</p>\n<p>至此，自定义 Filter 的流程就算走完了，我们很容易就可以配置好需要的环境。</p>\n<p>然而，真正的自定义部分，才刚刚开始！</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/183/original/%E5%BC%80%E5%BF%8336.png\" alt=\"\"></p>\n<h2 id=\"DOD_&amp;_ROI\">DOD &amp; ROI</h2><h3 id=\"1-_DOD\">1. DOD</h3><p>DOD ( domain of definition ) ，简单来说就是 Filter 处理后，输入的图片区域。</p>\n<p>一般来说，Filter 操作都是基于原图，添加上效果，但是并不会改变图片的大小，显示区域。所以一般与原图的一致即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGRect</span> dod = inputImage.extent;</span><br></pre></td></tr></table></figure>\n<p>但是针对形变类的 Filter，则需要根据输出图片大小，设置正确的 DOD。</p>\n<h3 id=\"2-_ROI\">2. ROI</h3><p>ROI ( region of interest )，在一定的时间内特别感兴趣的区域，即当前处理区域。</p>\n<p>可以简单的理解为：当前处理区域对应于原图中的哪个区域。</p>\n<p>ROI 的定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Block callback used by Core Image to ask what rectangles of a kernel's input images</span><br><span class=\"line\"> * are needed to produce a desired rectangle of the kernel's output image.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 'index' is the 0-based index specifying which of the kernel's input images is being queried.</span><br><span class=\"line\"> * 'destRect' is the extent rectangle of kernel's output image being queried.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Returns the rectangle of the index'th input image that is needed to produce destRect.</span><br><span class=\"line\"> * Returning CGRectNull indicates that the index'th input image is not needed to produce destRect.</span><br><span class=\"line\"> * The returned rectangle need not be contained by the extent of the index'th input image.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CGRect</span> (^<span class=\"built_in\">CIKernelROICallback</span>)(<span class=\"keyword\">int</span> index, <span class=\"built_in\">CGRect</span> destRect);</span><br></pre></td></tr></table></figure>\n<p>CIKernelROICallback 在 Core Image 内部进行处理的时候，会多次调用。</p>\n<p><strong>index</strong> 表示输入图片的下标，顺序和 kernel 中的入参顺序一致，从0开始。</p>\n<p><strong>destRect</strong> 表示输出图片的区域。 也就是我们先前设置的 DOD。</p>\n<p>那，我们为什么要显示设置 ROI 呢 ？</p>\n<p>因为输入图片中，参与处理的实际区域，Core Image 是无法知道的，我们需要显式的告诉 CI 这个区域。</p>\n<p>这么讲可能有点难以理解，下面我们看两个具体的例子。</p>\n<p>先看一个旋转的例子。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/roi_1.png\" alt=\"2016101449433roi_1.png\"></p>\n<p>这里就是进行了 x，y 互换操作。很容易得到我们的 DOD：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGRect</span> dod = <span class=\"built_in\">CGRectMake</span>(inputImage.extent.origin.y, inputImage.extent.origin.x, inputImage.extent.size.height, inputImage.extent.size.width);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// e.g.</span></span><br><span class=\"line\"><span class=\"comment\">// 原图片extent (0, 0, 200, 300)</span></span><br><span class=\"line\"><span class=\"comment\">// 旋转后的输出图片 (0, 0, 300, 200)，也就是 DOD</span></span><br></pre></td></tr></table></figure>\n<p>那 ROI 应该怎么设置呢 ？我们之前说过，ROI 计算就是计算当前处理区域对应于原图中的哪个区域。</p>\n<p>也就是一个逆向过程。</p>\n<p>假如，A：输入图片中的某点   B：输出图片中的某点。那么 ROI 计算可以理解成  ROI（B）= A。</p>\n<p>理解好这点，我们不难写出这个操作对应的 ROI：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CIKernelROICallback</span> callback = ^(<span class=\"keyword\">int</span> index, <span class=\"built_in\">CGRect</span> rect) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGRectMake</span>(rect.origin.y, rect.origin.x, rect.size.height, rect.size.width);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另外，当输入图片不止一个的时候，则需要根据 <strong>index</strong> 来做区别。因为这里的 <strong>rect</strong> 每次都是返回 <strong>DOD</strong>，而不是当前图片的 extent。</p>\n<h2 id=\"CIKernel_介绍\">CIKernel 介绍</h2><p>终于到了本文最重要的部分了，CIKernel 介绍！</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/187/original/%E5%BC%80%E5%BF%83ForeverAloneExcited.png\" alt=\"\"></p>\n<p>在此之前，我们先了解下它的一些背景知识。</p>\n<p>CIKernel 需要使用 Core Image Kernel Language (CIKL) 来编写，CIKL 是 OpenGL Shading Language (GLSL) 的子集，如果你之前有过 OpenGL 着色器编写的经验，这部分你会感觉格外亲切。CIKL 集成了 GLSL 绝大部分的参数类型和内置函数，另外它还添加了一些适应 Core Image 的参数类似和函数。</p>\n<p>一个 kernel 的处理过程，可以用下面伪代码表示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... image.width</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... image.height</span><br><span class=\"line\">        New_Image[i][j] = CustomKernel(Current_Image[i][j])</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>也就是说，每个需要处理的 fragment 都会调用一次 kernel 相关操作，每次操作的目的就是返回当前 fragment 对应的结果 fragment，这里 fragment 可以理解为像素点。</p>\n<p>所以我们的 kernel，应该是针对一个点，而不是一张图片。</p>\n<p>Core Image 内置了3种适用于不同场景的 Kernel，可以根据实际需求来选择。</p>\n<ul>\n<li>CIColorKernel：用于处理色值变化的 Filter。</li>\n<li>CIWarpKernel：用于处理形变的 Filter。</li>\n<li>CIKernel：通用。</li>\n</ul>\n<p>CIColorKernel，CIWarpKernel 是官方推荐使用的。某个 Filter，在使用它们能实现的情况下，应该使用它们，即使是一个 CIKernel 拆分成多个 CIColorKernel 以及 CIWarpKernel，也应该用这种方式。因为 Core Image 内部对这两张 Kernel 做了优化。</p>\n<p>当然，它们的使用时有限制的。目的一定要很纯粹，比如 CIColorKernel 只能处理色值上的变化。否则就算定义为 CIColorKernel，如果实现上涉及了其他 CIColorKernel 不允许的操作，Core Image 也会当做普通的 CIFilter 处理。</p>\n<p>另外，kernel 的入参只支持下面这么几种：</p>\n<table>\n<thead>\n<tr>\n<th>Kernel routine input parameter</th>\n<th>Object</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sampler</td>\n<td>CISampler</td>\n</tr>\n<tr>\n<td>__table sampler</td>\n<td>CISampler</td>\n</tr>\n<tr>\n<td>__color</td>\n<td><code>CIColor</code></td>\n</tr>\n<tr>\n<td>float</td>\n<td>NSNumber</td>\n</tr>\n<tr>\n<td>vec2, vec3, or vec4</td>\n<td>CIVector</td>\n</tr>\n</tbody>\n</table>\n<p>简单说明一下：</p>\n<ul>\n<li>sampler：可以理解成纹理，或者图片。外部以 CIImage 形式传入。</li>\n<li>__table sampler：表示颜色查找表（lookup table），虽然它也是图片，但是添加该声明可以避免被修改。外部以 CIImage 形式传入。</li>\n<li>__color：表示颜色。外部以 CIColor 形式传入。</li>\n<li>float：kernel 内部处理都是 float 类型。外部以 NSNumber 形式传入。</li>\n<li>vecN：表示一个多元向量。比如 vec2 可以表示一个点，vec4 可以表示一个色值。外部以 CIVector 形式传入。</li>\n</ul>\n<p>至于 kernel 中可以使用的函数，那就太多了。这里不一一枚举，在下面的具体讲解中，会说明几个常用的。如果想了解更多，可以参考  <a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397\" target=\"_blank\" rel=\"external\">Core Image Kernel Language Reference</a>，以及 <a href=\"http://www.shaderific.com/glsl/\" target=\"_blank\" rel=\"external\">OpenGL ES Shading Language Reference</a>。</p>\n<p>下面我会通过一个 Demo，讲解这三种 Kernel 的具体用法。</p>\n<blockquote>\n<p>PS：建议阅读之前，下载 <a href=\"https://github.com/colin1994/CoreImageDemo\" target=\"_blank\" rel=\"external\">源码</a> 配合着看。</p>\n</blockquote>\n<h3 id=\"1-_CIColorKernel\">1. CIColorKernel</h3><p>首先看下官方的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * CIColorKernel is an object that encapsulates a Core Image Kernel Language</span><br><span class=\"line\"> * routine that processes only the color information in images.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Color kernels functions are declared akin to this example:</span><br><span class=\"line\"> *   kernel vec4 myColorKernel (__sample fore, __sample back, vec4 params)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The function must take a __sample argument for each input image.</span><br><span class=\"line\"> * Additional arguments can be of type float, vec2, vec3, vec4, or __color.</span><br><span class=\"line\"> * The destination pixel location is obtained by calling destCoord().</span><br><span class=\"line\"> * The kernel should not call sample(), sampleCoord(), or samplerTransform().</span><br><span class=\"line\"> * The function must return a vec4 pixel color.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE</span>(<span class=\"number\">10</span>_11, <span class=\"number\">8</span>_0)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CIColorKernel</span> : <span class=\"title\">CIKernel</span></span></span><br></pre></td></tr></table></figure>\n<p>很重要的一点：<strong>processes only the color information in images</strong>，它只处理图片的颜色信息。</p>\n<p>所以在使用它之前，一定要确保该 Filter 只涉及颜色处理。</p>\n<p>CIKL 的语法和大多数 C 阵营一样，变量，运算符，控制结构，函数等都大同小异，所以它的学习成本是很低的。</p>\n<p>真正的核心应该是：<strong>如果用这样的语言来实现这个滤镜，也就是我们经常说的算法。</strong></p>\n<p>下面我们以一个 <strong>Vignette</strong> 来实际讲解一下。</p>\n<p>它的效果如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette_demo.gif\" alt=\"2016101796011vignette_demo.gif\"></p>\n<p>不难看出，Vignette 滤镜，它实际上就是一个FOV（Field of View） 的效果，即视野中央看的最清楚，清晰程度与到中心距离呈反比，与人类的视觉是类似的。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette.png\" alt=\"2016101524815vignette.png\"></p>\n<p>所以针对图片上的每个像素点 A，经过 Vignette 滤镜处理后得到的 B，应该满足：</p>\n<p>Vignette（A）＝ A * Darken ＝ B； 而 Darken 的计算依赖 A 与中心点的距离。</p>\n<p>如此，我们可以很容易的写出对应的 kernel：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 vignetteKernel(__sample image, vec2 center, <span class=\"keyword\">float</span> radius, <span class=\"keyword\">float</span> alpha)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出当前点与中心的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> distance = distance(destCoord(), center) ;</span><br><span class=\"line\">    <span class=\"comment\">// 根据距离计算出暗淡程度</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> darken = <span class=\"number\">1.0</span> - (distance / radius * alpha);</span><br><span class=\"line\">    <span class=\"comment\">// 返回该像素点最终的色值</span></span><br><span class=\"line\">    image.rgb *= darken;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> image.rgba;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和 C 语言的一样，函数需要具备：</p>\n<ul>\n<li>返回类型：vec4</li>\n<li>函数名：vignetteKernel</li>\n<li>参数列表：__sample image, vec2 center, float radius, float alpha）</li>\n<li>函数体：｛｝中的具体实现</li>\n</ul>\n<p>有所不同的，kernel 函数需要带上 kernel 关键字，与其它普通函数做区分。一个 .cikernel 文件中，允许包括多个函数，甚至是多个 kernel 函数，不过<strong>函数调用要出现在函数定义之后</strong>！</p>\n<p>另外，这里有个特别的参数类型，<strong>__sample</strong> ，和之前讲的 <strong>sampler</strong> 有所不同。因为这里我们使用的是 <strong>CIColorKernel</strong>，在得到高效性能的同时，也有一定的局限性。因为只是处理图片当前位置的颜色信息，所以 <strong>__sample</strong> 提供的 <strong>rgba</strong> 变量足够了，无法获取一些其它的信息。</p>\n<blockquote>\n<p>比如在 CIKernel 中，可以通过 sample() 等函数获取其它位置的色值，而在 CIColorKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。</p>\n</blockquote>\n<p>下面逐行解释这个 kernel。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算出当前点与中心的距离</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> distance = distance(destCoord(), center) ;</span><br></pre></td></tr></table></figure>\n<p><strong>destCoord</strong></p>\n<ul>\n<li><p><code>varying vec2 destCoord ()</code></p>\n<p>返回当前正在处理的像素点所处坐标。(working space coordinates)</p>\n</li>\n</ul>\n<p>这里使用的 CIKL 内置的函数 destCoord，它返回的坐标是基于 <strong>working space</strong> 的。所谓 working space，即工作空间，它的取值范围对应图片实际大小。比如 inputImage 的大小为 300 * 200，那么 destCoord() 返回坐标的取值范围在 (0, 0) - (300, 200)。</p>\n<p><strong>distance</strong></p>\n<ul>\n<li><p><code>float distance (vec2 p0, vec2 p1)</code></p>\n<p>计算向量p0，p1之间的距离</p>\n</li>\n</ul>\n<p>如此便能很容易得到当前点与中心的距离。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据距离计算出暗淡程度</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> darken = <span class=\"number\">1.0</span> - (distance / radius * alpha);</span><br></pre></td></tr></table></figure>\n<p>之后根据清晰程度与到中心距离呈反比这一原理，结合外部控制的 <strong>alpha</strong> 变量，计算出暗淡程度。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回该像素点最终的色值</span></span><br><span class=\"line\">image.rgb *= darken;</span><br><span class=\"line\"><span class=\"keyword\">return</span> image.rgba;</span><br></pre></td></tr></table></figure>\n<p>这里之前提到，<strong>__sample</strong> 有个 rgba 变量，通过它可以获取到当前处理点的色值。</p>\n<p>在 CIKL 中，vec4 的任何一个分量都可以单独获取，也可以组合获取，例如 <strong>image.a</strong>，<strong>image.rrgg</strong> 等，都是可行的。</p>\n<p>CIColorKernel 是针对色值的处理，所以它的返回值必须是一个代表色值的 vec4 类型变量。</p>\n<p>至此，这个 vignetteKernel 就分析完毕了。很简单吧～</p>\n<h3 id=\"2-_CIWarpKernel\">2. CIWarpKernel</h3><p>同样，先看下文档定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * CIWarpKernel is an object that encapsulates a Core Image Kernel Language</span><br><span class=\"line\"> * function that processes only the geometry of an image.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Warp kernels functions are declared akin to this example:</span><br><span class=\"line\"> *   kernel vec2 myWarpKernel (vec4 params)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Additional arguments can be of type float, vec2, vec3, vec4.</span><br><span class=\"line\"> * The destination pixel location is obtained by calling destCoord().</span><br><span class=\"line\"> * The kernel should not call sample(), sampleCoord(), or samplerTransform().</span><br><span class=\"line\"> * The function must return a vec2 source location.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE</span>(<span class=\"number\">10</span>_11, <span class=\"number\">8</span>_0)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CIWarpKernel</span> : <span class=\"title\">CIKernel</span></span></span><br></pre></td></tr></table></figure>\n<p>同样，它也有很重要一点：<strong>processes only the geometry of an image</strong>。它只处理图片的几何形状。</p>\n<p>所谓的改变几何形状，也就是形变，把原本放置在 A 处的点，用 B 处的点去填充，或者反过来，把原本 B 处的点，挪到 A 处去，也是一样的。</p>\n<p>它可以用这个表达式表示：<strong>Warp（A）＝ B；</strong></p>\n<p>所以它和之前的 CIColorKernel 不同，它的返回值是 vec2，代表点的坐标。另外它只允许传入一张图片，所以这里的 inputImage 缺省了。</p>\n<blockquote>\n<p>同样的，在 CIWarpKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。</p>\n</blockquote>\n<p>下面以一个马赛克，像素化（Pixellate）的例子来讲解。它的效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/pixellate_demo.gif\" alt=\"2016101762677pixellate_demo.gif\"></p>\n<p>马赛克，比较简单的一种算法是按照固定的间隔取像素点，将图片分割成一些小块，然后每个小块内选择一个像素点，然后把这个区域全部用这个像素点填充即可。这里的每个小块，称作晶格，晶格越大，马赛克效果越好。</p>\n<p>依照这个简单算法，我们可以很容易的写出对应的 kernel：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec2 pixellateKernel(<span class=\"keyword\">float</span> radius)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec2 positionOfDestPixel, centerPoint;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前点坐标</span></span><br><span class=\"line\">    positionOfDestPixel = destCoord();</span><br><span class=\"line\">    <span class=\"comment\">// 获取对应晶格内的中心像素点</span></span><br><span class=\"line\">    centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * <span class=\"number\">2.0</span>) + radius;</span><br><span class=\"line\">    centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * <span class=\"number\">2.0</span>) + radius;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> centerPoint;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，先是获取到当前处理点的坐标，positionOfDestPixel。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取对应晶格内的中心像素点</span></span><br><span class=\"line\">centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * <span class=\"number\">2.0</span>) + radius;</span><br><span class=\"line\">centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * <span class=\"number\">2.0</span>) + radius;</span><br></pre></td></tr></table></figure>\n<p>然后这里的 <strong>mod (x, y)</strong> 和平时使用的一样，计算 <strong>x / y 的余数</strong>。</p>\n<p>至于为什么这个式子能获得<strong>中心像素点坐标</strong>，想必一看就懂了吧～（不懂的可以拿张纸画画）</p>\n<p>最后返回中心点坐标，替换当前点。</p>\n<p>如此，一个简单的马赛克就完成了～</p>\n<h3 id=\"3-_CIKernel\">3. CIKernel</h3><p>我们之前说过，CIColorKernel 和 CIWarpKernel 内部做了优化，要尽可能的使用它们。除非真的有特殊需求，是它们无法实现的。下面罗列了 CIColorKernel 和 CIWarpKernel 的一些局限：</p>\n<p><strong>CIColorKernel ：</strong></p>\n<ul>\n<li>只处理当前处理点色值，无法获取到其它点的状态。</li>\n</ul>\n<p><strong>CIWarpKernel：</strong></p>\n<ul>\n<li>只处理当前处理点位置，无法获取到其它点的状态。</li>\n<li>只能传入一张图片。</li>\n</ul>\n<p>比如说，美图秀秀里面的一些简单马赛克，效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mosaic_demo.gif\" alt=\"2016101864134mosaic_demo.gif\"></p>\n<p>它的实现方式，我们可以简单的这么理解：</p>\n<ol>\n<li>判断当前点是否在传入点的处理范围内。</li>\n<li>如果在，返回马赛克贴图中对应的像素点色值。</li>\n<li>如果不在，返回当前点色值。</li>\n</ol>\n<p>很明显，它需要两张图片，一张我们的待处理图片，一张马赛克贴图。所以 CIWarpKernel 不适用。</p>\n<p>另外，待处理图片与马赛克贴图之前不是一一对应关系，在第二步，返回马赛克贴图中对应的像素点色值中，需要一个映射计算，即当前点对应马赛克贴图中的某点。所以 CIColorKernel 也不适用。</p>\n<p>这种情况下，就要使用通用的 CIKernel 了。</p>\n<p>下面是对应的 kernel：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 mosaicKernel(sampler image, sampler maskImage, <span class=\"keyword\">float</span> radius, vec2 point, <span class=\"keyword\">float</span> maskWidth, <span class=\"keyword\">float</span> maskHeight)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前点坐标</span></span><br><span class=\"line\">    vec2 textureCoordinate = destCoord();</span><br><span class=\"line\">    <span class=\"comment\">// 计算当前点与传入点的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> distance = distance(textureCoordinate, point);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (distance &lt; radius) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在处理范围内, 计算对应马赛克贴图中的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> resultX = mod(textureCoordinate.x, maskWidth);</span><br><span class=\"line\">        <span class=\"keyword\">float</span> resultY = mod(textureCoordinate.y, maskHeight);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sample(maskImage, samplerTransform(maskImage, vec2(resultX, resultY)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回原图对应像素点色值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sample(image, samplerTransform(image, textureCoordinate));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里参数比较多，分别对应：</p>\n<ul>\n<li>image：待处理图片</li>\n<li>maskImage：马赛克贴图</li>\n<li>radius：处理范围，半径</li>\n<li>point：传入点，即当前触摸的点</li>\n<li>maskWidth：马赛克贴图宽度</li>\n<li>maskHeight：马赛克贴图高度</li>\n</ul>\n<p>上面的 kernel，使用了两个新的函数，sample 和 samplerTransform。</p>\n<blockquote>\n<p><code>vec4 sample (uniform sampler src, vec2 point)</code><br>Returns the pixel value produced from sampler src at the position point, where point is specified in sampler space.</p>\n<p>返回图片 src 指定点 point 处的色值。point 是基于 sampler space。</p>\n<p><code>vec2 samplerTransform (uniform sampler src, vec2 point)</code><br>Returns the position in the coordinate space of the source (the first argument) that is associated with the position defined in working-space coordinates (the second argument). (Keep in mind that the working space coordinates reflect any transformations that you applied to the working space.) For example, if you are modifying a pixel in the working space, and you need to retrieve the pixels that surround this pixel in the original image, you would make calls similar to the following, where d is the location of the pixel you are modifying in the working space, and image is the image source for the pixels.</p>\n<p>返回图片 src 指定点 point 处坐标对应的基于 sampler space 的坐标。point 是基于working space。</p>\n<p>sampler space 的取值是 0.0 - 1.0，左下角为原点，向右，向上递增。</p>\n</blockquote>\n<p>了解了这两个函数的用法，想必这段代码就没什么需要特别说明的地方了，注释已经很清楚，不再累述。</p>\n<h2 id=\"注意点\">注意点</h2><h3 id=\"1-_premultiply\">1. premultiply</h3><blockquote>\n<p><code>vec4 premultiply (vec4 color)</code><br>Multiplies the red, green, and blue components of the color parameter by its alpha component.</p>\n</blockquote>\n<p>将颜色变量的r、g、b元素值分别于 alpha 相乘，返回一个新的四维颜色向量。</p>\n<blockquote>\n<p><code>vec4 unpremultiply (vec4 color)</code><br>If the alpha component of the color parameter is greater than 0, divides the red, green and blue components by alpha. If alpha is 0, this function returns color.</p>\n</blockquote>\n<p>将颜色变量的r、g、b元素值分别除以 alpha ，返回一个新的四维颜色向量。</p>\n<p>pixel（R, G, B, A） —— (premultiply) ——&gt; (R＊A, G＊A, B＊A, A)</p>\n<p>—— (unpremultiply) ——&gt; （R, G, B, A）。</p>\n<p>在 Core Image 中，默认颜色空间是 sRGB，在 kernel 中得到的色值，都经过了 Premultiplied Alpha 处理。</p>\n<p>至于为什么要执行 Premultiplied Alpha 操作，具体的可以参考这篇文章：<a href=\"https://boundary.cc/2015/07/why-premultiplied-alpha/\" target=\"_blank\" rel=\"external\">为什么要PREMULTIPLIED ALPHA呢？</a></p>\n<p>所以如果 kernel 涉及 alpha 相关操作，则需要先执行 unpremultiply，返回正确的 rgba。处理完之后，再执行 premultiply 操作。</p>\n<p>比如一个反相滤镜，</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_1.gif\" alt=\"2016101643860rever_1.gif\"><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_2.gif\" alt=\"20161016903rever_2.gif\"></p>\n<p>它对应的 kernel 应该是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 _invertColor(sampler source_image)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 pixValue;</span><br><span class=\"line\">    <span class=\"comment\">// samplerCoord 返回当前像素点在 sampler space 中的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// kernel 无法知道该图片是否进行了某些变换操作，所以确保转换为 sampler space 中的位置 是有必要的</span></span><br><span class=\"line\">    pixValue = sample(source_image, samplerCoord(source_image));</span><br><span class=\"line\">    <span class=\"comment\">// 执行 unpremultiply 操作, 得到真正的 RGB 值</span></span><br><span class=\"line\">    <span class=\"comment\">// (R＊A, G＊A, B＊A, A) ——(unpremultiply)——&gt; (R, G, B, A)</span></span><br><span class=\"line\">    <span class=\"comment\">// Core Image is always RGB based.</span></span><br><span class=\"line\">    unpremultiply(pixValue); </span><br><span class=\"line\">    <span class=\"comment\">// invertColor</span></span><br><span class=\"line\">    pixValue.r = <span class=\"number\">1.0</span> - pixValue.r; </span><br><span class=\"line\">    pixValue.g = <span class=\"number\">1.0</span> - pixValue.g;</span><br><span class=\"line\">    pixValue.b = <span class=\"number\">1.0</span> - pixValue.b;</span><br><span class=\"line\">    <span class=\"comment\">// premultiply. (R, G, B, A) —&gt; (R＊A, G＊A, B＊A, A)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> premultiply(pixValue); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化：</span></span><br><span class=\"line\"><span class=\"comment\">// 避免了 unpremultiply 和 premultiply 操作，能更高效执行。</span></span><br><span class=\"line\"><span class=\"comment\">// pixValue 是 (R＊A, G＊A, B＊A, A)， pixValue.a - pixValue.r = (1-r)*a. 和最终 premultiply 得到的结果一样.</span></span><br><span class=\"line\">kernel vec4 _invertColor(sampler source_image)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 pixValue;</span><br><span class=\"line\">    pixValue = sample(source_image, samplerCoord(source_image));</span><br><span class=\"line\">    pixValue.rgb = pixValue.aaa - pixValue.rgb;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pixValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-_关键字\">2. 关键字</h3><p>和 C 语言等一样，CIKL 中变量的命名不能和关键字相同。</p>\n<p>下面是官方 Session 中翻转对应的 kernel 脚本，这里用到了 input 关键字，导致整个 kernel 错误。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/session_error.png\" alt=\"2016101638470session_error.png\"></p>\n<p>所以这点一定要牢记。</p>\n<p>下面是在 Github 上引起的灾难..</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_1.png\" alt=\"2016101685335error_1.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_2.png\" alt=\"2016101697866error_2.png\"></p>\n<h3 id=\"3-_GLSL\">3. GLSL</h3><p>CIKL 是 GLSL 的子集，所以<strong>不是 GLSL 中定义的任何东西在 CIKL 中都适用</strong>。但是 glsl 中大多数关键字都是可以用的。另外，CIKL 还提供了 glsl 不支持的，额外的数据类型，关键字，方法，来完善 CIKernel。</p>\n<h3 id=\"4-_Array,_Mat\">4. Array, Mat</h3><p> In addition, the following are not implemented:</p>\n<ul>\n<li>Data types: <code>mat2</code>, <code>mat3</code>, <code>mat4</code>, <code>struct</code>, <code>arrays</code></li>\n</ul>\n<p>这些数据类型 Core Image 不支持。但是在 kernel 内部却可以使用 … </p>\n<p>如果当做参数传入，则会报错：</p>\n<p><strong>invalid kernel parameter type; valid types are:  ‘float’, ‘vec2’, ‘vec3’, ‘vec4’, ‘sampler’, ‘sample’, ‘color’</strong></p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/229/original/%E6%82%B2%E4%BC%A41.png\" alt=\"\"></p>\n<p>这也导致了一些依赖关键点的算法无法实现。</p>\n<h3 id=\"5-_坐标系\">5. 坐标系</h3><p>UIKit 坐标系，原点在屏幕左上，x轴向右，y轴向下。</p>\n<p>Core Image 和 OpenGL 坐标系原点在屏幕的左下，x轴向右，y轴向上。</p>\n<p>所以位置的处理上要注意。</p>\n<h3 id=\"6-_局限\">6. 局限</h3><p>kernel 的输入和输出像素可以相互映射。大多数像素处理都可以用这种方式表达，但是有的图像处理操作很困难，甚至不可能。</p>\n<p>kernel 的使用上还是有一定的局限性。比如说通过输入图像映射计算直方图是很困难的。也不可以执行种子填充算法或者其他需要复杂条件语句的图像分析操作。</p>\n<h3 id=\"7-_性能优化\">7. 性能优化</h3><p>kernel 中的内容要尽可能简单，高效。</p>\n<ul>\n<li>展开循环操作会更快。</li>\n<li>外部能传入的变量，尽量不要在 kernel 中计算获取。</li>\n</ul>\n<h2 id=\"开发技巧\">开发技巧</h2><h3 id=\"1-_Log\">1. Log</h3><p><strong>+(id)kernelsWithString:(id)arg1 messageLog:(id)arg2 ;</strong></p>\n<p>这是  <a href=\"https://github.com/CPDigitalDarkroom/iOS9-SpringBoard-Headers/blob/a11be523d5644a178614585ff57f9638300c2cc0/System/Library/Frameworks/CoreImage.framework/CIKernel.h\" target=\"_blank\" rel=\"external\">CIKernel.h</a> 里面的私有方法，在调试阶段可以利用它来打印 kernel 中的错误。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *messageLog = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *kernels = [[<span class=\"built_in\">CIKernel</span> class] \t\t performSelector:<span class=\"keyword\">@selector</span>(kernelsWithString:messageLog:) withObject:kernelCode withObject:messageLog];</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( messageLog.count &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">  \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error: %@\"</span>, messageLog.description);</span><br><span class=\"line\">customKernel = [kernels objectAtIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误 log</span></span><br><span class=\"line\">Error: (</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageLineNumber</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageType</span> = <span class=\"built_in\">CIKernelMessageTypeError</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageDescription</span> = <span class=\"string\">\"unkown type or function name 'destCoordE'; did you mean 'destCoord'?\"</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageOffset</span> = <span class=\"number\">142</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageLineNumber</span> = <span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageType</span> = <span class=\"built_in\">CIKernelMessageTypeError</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageDescription</span> = <span class=\"string\">\"invalid operands to binary expression ('float' and 'int')\"</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageOffset</span> = <span class=\"number\">281</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-_CI_PRINT_TREE\">2. CI_PRINT_TREE</h3><p>这里 Core Image 中非常实用的一个环境变量，通过设置它，可以很方便的查看 Core Image 工作过程中到底做了什么。比如：</p>\n<ul>\n<li>工作在 GPU 还是 CPU 上？</li>\n<li>各个 kernel 的参数值？</li>\n<li>Core Image 是如何链接 kernel？</li>\n<li>DOD，ROI 如何设置的？</li>\n<li>对于大图如何拆分处理？</li>\n<li>…</li>\n</ul>\n<blockquote>\n<p>PS ： 至于 CI_PRINT_TREE 具体应该如何使用，没有找到相关资料，只是在 Session 中提到过。</p>\n<p>包括 ObjC 中国 上的翻译：你可以通过在 Xcode 中设置计划配置（scheme configuration）里的 CI_PRINT_TREE 环境变量为 1 来决定用 CPU 还是 GPU 来渲染，也是很不准确的。</p>\n<p>这里的结论都是自己摸索后的总结，所以可能存在错误或者遗漏，欢迎补充交流～</p>\n</blockquote>\n<p>CI_PRINT_TREE 的设置大致是这样的：分成 A B 两部分，它们可以结合使用。</p>\n<p>其中 A 是主要分类，B 是辅助功能。</p>\n<p>A 包括：</p>\n<ul>\n<li>1  initial graph </li>\n<li>2  optimized graph </li>\n<li>4  tile graph </li>\n<li>8  programs graph </li>\n<li>16  timing graph </li>\n</ul>\n<p>B 包括：</p>\n<ul>\n<li>graphviz </li>\n<li>dump-inputs </li>\n<li>dump-intermediates </li>\n<li>skip-cpu </li>\n<li>skip-gpu  </li>\n<li>skip-small </li>\n<li>frame-<number> </number></li>\n</ul>\n<p>使用上，比如简单的查看 initial graph 做了什么，即我们添加这个 Filter 的时候，初始化过程执行了什么，传入了哪些参数。当然，这个过程它并没有真正得到渲染，只是一个操作流程列表。设置 CI_PRINT_TREE ＝ 1，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/ci_print_tree.png\" alt=\"2016101786999ci_print_tree.png\"></p>\n<p>它的结果如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initial graph render_to_display (opengles2 context <span class=\"number\">1</span> frame <span class=\"number\">1</span>) format=RGBA8 roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] = </span><br><span class=\"line\">  clamptoalpha roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] opaque</span><br><span class=\"line\">    colormatch workingspace-to-devicergb roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] opaque</span><br><span class=\"line\">      affine [<span class=\"number\">2</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">2</span> <span class=\"number\">0</span> <span class=\"number\">156</span>] roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] opaque</span><br><span class=\"line\">        colorkernel </span><br><span class=\"line\">  roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br><span class=\"line\">          affine [<span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">-1</span> <span class=\"number\">0</span> <span class=\"number\">374</span>] roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br><span class=\"line\">            colormatch <span class=\"string\">\"sRGB IEC61966-2.1\"</span>-to-workingspace roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br><span class=\"line\">              <span class=\"built_in\">CGImageRef</span> <span class=\"number\">0x1701c4380</span> RGBX8 <span class=\"number\">375</span>x374  alpha_one roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br></pre></td></tr></table></figure>\n<p>这里有很多关键信息，十分详细。它的阅读顺序是从下往上，我们简单分析下：</p>\n<ul>\n<li><strong>CGImageRef</strong>： 指代我们传入的图片。</li>\n<li>每个阶段的 <strong>ROI，DOD</strong>。</li>\n<li><strong>colormatch “sRGB IEC61966-2.1”-to-workingspace</strong> ：传入的颜色空间</li>\n<li><strong>vignetteKernel(image,center=[187.5 187],radius=187.5,alpha=0.0537634)</strong> ：kernel 的每个参数</li>\n<li><strong>colormatch workingspace-to-devicergb</strong>：  输出的颜色空间</li>\n<li><strong>opengles2</strong> ：工作在 GPU 上</li>\n<li><strong>context 1 frame 1</strong> ：分别指代当前 context 以及第几帧。每次渲染 frame + 1</li>\n</ul>\n<p>当然，这只是 CI_PRINT_TREE 的一部分功能，如果你设置 CI_PRINT_TREE = 8 (programs graph )，你又会得到这样的信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">programs graph render_to_display (opengles2 context <span class=\"number\">1</span> frame <span class=\"number\">4</span> tile <span class=\"number\">1</span>) format=RGBA8 roi=[<span class=\"number\">0</span> <span class=\"number\">111</span> <span class=\"number\">640</span> <span class=\"number\">640</span>] = </span><br><span class=\"line\">  program affine(clamp_to_alpha(linear_to_srgb(vignetteKernel(affine(srgb_to_linear(swizzle_bgr1())))))) rois=[<span class=\"number\">0</span> <span class=\"number\">111</span> <span class=\"number\">640</span> <span class=\"number\">640</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">111</span> <span class=\"number\">640</span> <span class=\"number\">640</span>]</span><br><span class=\"line\">    IOSurface <span class=\"number\">0x60000019ddc0</span> RGBA8 <span class=\"number\">375</span>x374 alpha_one edge_clamp rois=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[infinite][<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br></pre></td></tr></table></figure>\n<p>这里描述了程序图表，即真正涉及到的操作。</p>\n<p>如果觉得这样看比较杂乱，可以试试添加 B 类辅助功能。 比如：<strong>CI_PRINT_TREE = 8 graphviz</strong> ，这样就可以导出 DOT 语言脚本。然后使用 <a href=\"http://www.graphviz.org/\" target=\"_blank\" rel=\"external\">Graphviz</a> 工具，即可绘制这个 DOT 语言脚本描述的图形。</p>\n<p>比如上面 Log 对应绘制得到的图形如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/programs_graph.png\" alt=\"201610186930programs_graph.png\"></p>\n<p>同样是从下往上看，各个操作的层级关系就很明显了。除了我们提供的 vignetteKernel，Core Image 内部还做了其他的操作，比如 <strong>linear_to_srgb，clamp_to_alpha</strong> 等。它们的具体实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Filter DAG:</span><br><span class=\"line\">Node: <span class=\"number\">0</span></span><br><span class=\"line\">  original source: vec4 _ci_clamp_to_alpha(vec4 s) &#123; <span class=\"keyword\">return</span> clamp(s, <span class=\"number\">0.0</span>, s.a); &#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_clamp_to_alpha(vec4 s) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clamp(s, <span class=\"number\">0.000000e+00</span>, s.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">1</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">1</span></span><br><span class=\"line\">  original source: vec4 _ci_premultiply(vec4 s) &#123; <span class=\"keyword\">return</span> vec4(s.rgb*s.a, s.a); &#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_premultiply(vec4 s) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vec4(s.rgb * s.a, s.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">2</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">2</span></span><br><span class=\"line\">  original source: vec4 _ci_linear_to_srgb(vec4 s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  s.rgb = sign(s.rgb)*mix(s.rgb*<span class=\"number\">12.92</span>, pow(abs(s.rgb), vec3(<span class=\"number\">0.4166667</span>)) * <span class=\"number\">1.055</span> - <span class=\"number\">0.055</span>, step(<span class=\"number\">0.0031308</span>, abs(s.rgb)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_linear_to_srgb(vec4 s) &#123;</span><br><span class=\"line\">  s.rgb = sign(s.rgb) * mix(s.rgb * <span class=\"number\">1.292000e+01</span>, (pow(abs(s.rgb), vec3(<span class=\"number\">4.166667e-01</span>)) * <span class=\"number\">1.055000e+00</span>) - <span class=\"number\">5.500000e-02</span>, step(<span class=\"number\">3.130800e-03</span>, abs(s.rgb)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">3</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">3</span></span><br><span class=\"line\">  original source: vec4 _ci_unpremultiply(vec4 s) &#123; <span class=\"keyword\">return</span> vec4(s.rgb/max(s.a,<span class=\"number\">0.00001</span>), s.a); &#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_unpremultiply(vec4 s) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vec4(s.rgb / max(s.a, <span class=\"number\">1.000000e-05</span>), s.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">6</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">6</span></span><br><span class=\"line\">  &lt;sample with transform&gt;</span><br><span class=\"line\">  original source: vec4 read_pixel(sampler2D image, vec2 c, mat3 m)&#123; <span class=\"keyword\">return</span> texture2D(image, (vec3(c, <span class=\"number\">1.0</span>) * m).xy);&#125;</span><br><span class=\"line\">  printed AST: vec4 read_pixel_6(sampler2D image, vec2 c, mat3 m) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> texture2D(image, (vec3(c, <span class=\"number\">1.000000e+00</span>) * m).xy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">4</span> <span class=\"number\">7</span> <span class=\"number\">5</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">4</span></span><br><span class=\"line\">  image: <span class=\"number\">6</span></span><br><span class=\"line\">  printed: uniform lowp sampler2D image6_0</span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">7</span></span><br><span class=\"line\">  position use &lt;_dc&gt;</span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">5</span></span><br><span class=\"line\">  &lt;transform&gt;</span><br><span class=\"line\">  uniform: <span class=\"number\">6</span></span><br><span class=\"line\">End Filter Node</span><br></pre></td></tr></table></figure>\n<p>这个 DAG（有向无环图），具体描述了相关操作的实现过程，比较简单，可以自己看看，这里不累述。</p>\n<h2 id=\"工具介绍\">工具介绍</h2><p>Quartz Composer 是一款图形化的编程工具，专门用来生成各种动态视觉效果，包括可交互的界面原型。当然，它也支持 Core Image 滤镜图表的原型。</p>\n<p><img src=\"http://7xkc7a.com1.z0.glb.clouddn.com/2016092073920quartz_1.png\" alt=\"2016092073920quartz_1.png\"></p>\n<p>另外，在 QC 上编写 Kernel，除了代码高亮，实时调整效果也很棒。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/quartz_2.png\" alt=\"2016101158579quartz_2.png\"></p>\n<blockquote>\n<p>PS ：<a href=\"https://developer.apple.com/downloads/\" target=\"_blank\" rel=\"external\">Quartz Composer 下载地址</a> </p>\n<p>有精力的话建议把 QC 内自带的所有 example 找出来仔细研究，苹果自己的例子是最好的。它们藏在 /Applications/Quartz Composer.app/Contents/Resources/Examples/Patches（找到 Quartz Composer.app 点右键，选择「Show Package Content」）</p>\n<p> 简单了解 Quartz Composer。QCDesigners 上有比较简要的介绍：<a href=\"https://link.zhihu.com/?target=http%3A//qcdesigners.com/index.php/forums/topic/2/new-to-quartz-composer-start-he\" target=\"_blank\" rel=\"external\">QC Designers</a></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/download_Graphic_Tools_for_XCode.png\" alt=\"2016092059430download_Graphic_Tools_for_XCode.png\"></p>\n<p>QC 已经内置了适合 Core Image 的模板，并且实现了动态模糊滤镜效果。不过这里为了了解 QC 的使用方式，不使用内置的模板，从头开始。<strong>File —&gt; New Blank</strong>，创建一个空白的 QC 工程。</p>\n<blockquote>\n<p>PS： QC 的功能很强大，这里只介绍 Core Image Filter 编辑过程中会用到的，以及我所掌握的…</p>\n</blockquote>\n<h3 id=\"0-_概念介绍\">0. 概念介绍</h3><p>在讲解使用方式之前，介绍几个基本概念。</p>\n<p>一次滤镜操作，可以简单理解成： <strong>输入—&gt;(Patch)—&gt;输出</strong>。</p>\n<p>Patch 可以理解成 Kernel。</p>\n<p>输入则与 Kernel 的参数相对应，可以是 image，color，float…</p>\n<p>输入这里一般就是处理后的图像。</p>\n<p>还有一个比较特殊的 Patch，Layer。相当于画布，可以把结果图显示在上面，它也有层的概念。</p>\n<h3 id=\"1-_工作区介绍\">1.  工作区介绍</h3><p><strong>编辑区：</strong> 这是主面板，主要衔接各个 Patch，以及它们的输入，输出。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_1.png\" alt=\"2016101175676panel_1.png\"></p>\n<p><strong>Library：</strong> 这里陈列了 QC 内置的所有 Patch（也可以添加自定义的 Patch 进来），以及它们的详细使用介绍。(通过点击主面板左上角的 Patch Library 打开)</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_2.png\" alt=\"2016101159731panel_2.png\"></p>\n<p><strong>参数区：</strong> 这里设置各个 Patch 需要的输入参数。(通过点击主面板工具栏上的 Parameters 打开)</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_3.png\" alt=\"2016101163517panel_3.png\"></p>\n<p><strong>Viewer：</strong> 显示窗口，这里可以对 Layer 做处理，也可以响应用户操作。比如鼠标点击，移动，滑动等。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_4.png\" alt=\"2016101121147panel_4.png\"></p>\n<h3 id=\"2-_Filter_编辑_&amp;_放大眼睛实战\">2. Filter 编辑 &amp; 放大眼睛实战</h3><p>首先，点击 Patch Library，添加一个 Core Image Filter。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_1.png\" alt=\"2016101898471qc_demo_1.png\"></p>\n<p>选中这个 Filter，点击 Patch Inspector，选择 Settings，进入编辑页面。</p>\n<p>改成如下放大眼睛核心代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 coreImageKernel(sampler image, vec2 centerPostion, <span class=\"keyword\">float</span> radius, <span class=\"keyword\">float</span> scaleRatio, <span class=\"keyword\">float</span> aspectRatio)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvec2 currentPosition = destCoord();</span><br><span class=\"line\">\tvec2 positionToUse = currentPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">     vec2 currentPositionToUse = vec2(currentPosition.x, currentPosition.y * aspectRatio + <span class=\"number\">0.5</span> - <span class=\"number\">0.5</span> * aspectRatio);</span><br><span class=\"line\">     vec2 centerPostionToUse = vec2(centerPostion.x, centerPostion.y * aspectRatio + <span class=\"number\">0.5</span> - <span class=\"number\">0.5</span> * aspectRatio);</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">float</span> r = distance(currentPositionToUse, centerPostionToUse);</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">if</span>(r &lt; radius)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">float</span> alpha = <span class=\"number\">1.0</span> - scaleRatio * (r / radius - <span class=\"number\">1.0</span>)*( r / radius - <span class=\"number\">1.0</span>);</span><br><span class=\"line\">         positionToUse = centerPostion + alpha * (currentPosition - centerPostion);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> sample(image, samplerTransform(image, positionToUse));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">     \t<span class=\"keyword\">return</span> sample(image, samplerTransform(image, positionToUse));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_2.png\" alt=\"201610185070qc_demo_2.png\"></p>\n<blockquote>\n<p>PS：这里不再讲解这个眼睛放大 kernel 的实现原理。</p>\n<p>我强烈建议你在了解了前面的内容后，自己试着解读这个 kernel。</p>\n</blockquote>\n<p>另外，这里还有几个需要说明的地方。</p>\n<ul>\n<li>Define Outp Image Domain of Definition as Union of Input Sampler DODs：输入输出图片的 DOD 一致。</li>\n<li>Show Advanced Input Sampler Options：显示更多选项。</li>\n<li>Edit Filter Function：编辑 Filter 函数。</li>\n</ul>\n<p>一般选中第一项就好。 如果有特殊需求，需要自定义 DOD，ROI，则选择 <strong>Edit Filter Function</strong>，进入编辑模式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function __image main(__image image, __vec2 centerPostion, __number radius, __number scaleRatio, __number aspectRatio) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> coreImageKernel.apply(image.definition, null, image, centerPostion, radius, scaleRatio, aspectRatio);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以对默认的 function 进行编辑。在这个 Demo 里面我们不需要，感兴趣可以自己实践下，很简单。</p>\n<p>这个时候，主面板应该长这样：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_3.png\" alt=\"201610184625qc_demo_3.png\"></p>\n<p>然后拖拽一张图片到主面板中，把图片的 Output Image 与 Filter 的 Input Image 想连接。</p>\n<p>再从 Patch Library 中选择 Billboard。把 Filter 的 Output Image 与 Billboard 的 Input Image 相连接。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_4.png\" alt=\"2016101846779qc_demo_4.png\"></p>\n<p>然后选中 Filter，打开 Parameters 面板，输入参数值，即可。</p>\n<p>当然，放大眼睛这里需要定位到眼睛的位置，是否可以通过鼠标操作来获取点呢？再或者，眼睛放大效果不够直观，有没有办法鼠标按下显示效果图，松开显示原图呢？在 QC 里头，这些都不是问题~不过工具类的使用，更多的还是得靠自己去摸索，这里不再累述。可以参考 EnlargeEyes.qtz 文件，了解更多的操作。</p>\n<p>最终的效果应该是这样的：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/enlargeEyes_demo.gif\" alt=\"201610184575enlargeEyes_demo.gif\"></p>\n<h2 id=\"总结\">总结</h2><p>至此，关于 Core Image 自定义 Filter 相关的内容，就已经都讲完了。这篇近万字的文章，花了很多功夫总结出来，希望，对你有所帮助！</p>\n<p>那么，打开脑洞，创造更有趣的 Filter 吧~</p>\n<p>Have fun~   </p>\n<p><strong>PS：源码下载地址：</strong> <a href=\"https://github.com/colin1994/CoreImageDemo\" target=\"_blank\" rel=\"external\">CoreImageDemo</a></p>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397-CH1-SW1\" target=\"_blank\" rel=\"external\">Core Image Kernel Language Reference</a></p>\n<p>Core Image Kernel Language 官方概述。</p>\n<p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingKernels/WritingKernels.html\" target=\"_blank\" rel=\"external\">Writing Kernels</a></p>\n<p>官方教程。</p>\n<p><a href=\"http://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW4\" target=\"_blank\" rel=\"external\">Kernel Routine Rules</a></p>\n<p>官方准则。</p>\n<p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW2\" target=\"_blank\" rel=\"external\">Region-of-Interest Methods</a> </p>\n<p>ROI 教程。</p>\n<p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/QuartzComposerUserGuide/qc_intro/qc_intro.html#//apple_ref/doc/uid/TP40005381-CH201-TPXREF101\" target=\"_blank\" rel=\"external\">Quartz Composer User Guide</a></p>\n<p>QC 官方指南。</p>\n","excerpt":"<p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\">Core Image 你需要了解的那些事~</a></li>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\">Core Image 之自定义 Filter~</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/3095648721\">Core Image【3】—— 2017 新特性</a></li>\n<li><a href=\"https://xiaozhuanlan.com/topic/5094762183\">Core Image【4】—— 2018 新特性</a></li>\n</ul>\n<hr>\n<h2 id=\"前言\">前言</h2><p>最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~</p>\n<p>本文主要讲解 Core Image 自定义滤镜部分的内容，包括如何使用自定义 Filter，如何编写 kernel，QC 工具介绍，注意点以及一些开发技巧。</p>\n<p>在这之前，我默认你了解 Core Image 的基本原理以及使用方式。如果没有，我建议你花点时间看看我的上一篇文章：<a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\">Core Image 你需要了解的那些事~</a>，它介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比，想必会有所收获。</p>\n<p>现在，开始吧～<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/1/original/27.png\" alt=\"\"></p>","more":"<h2 id=\"自定义_Filter_流程\">自定义 Filter 流程</h2><p>自定义的 Filter 和系统内置的各种 CIFilter，使用起来方式是一样的。我们唯一要做的，就是实现一个符合规范的 CIFilter 的子类，然后该怎么用怎么用。</p>\n<p>这里总结起来就3步：</p>\n<ul>\n<li>编写 CIKernel：使用 CIKL，自定义滤镜效果。</li>\n<li>加载 CIKernel：CIFilter 读取编写好的 CIKernel。</li>\n<li>设置参数：设置 CIKernel 需要的输入参数以及 DOD 和 ROI。</li>\n</ul>\n<p>不难看出，这些操作都是围绕 <strong>CIKernel</strong> 展开的，那么，它是什么？ CIKL，DOD，ROI 又是什么鬼？<img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/14/original/5.png\" alt=\"\"></p>\n<p>先撇开这些麻烦的东西，我们先这样简单的认为：</p>\n<ul>\n<li>CIKernel 是我们 Filter 对应的脚本，它描述 Filter 的具体工作原理。</li>\n<li>CIKL （Core Image Kernel Language）是编写 CIKernel 的语言。</li>\n<li>DOD，ROI 当做普通的参数处理。</li>\n</ul>\n<p>弄清了这些，我们再来看具体操作过程。</p>\n<p>拿一个图片翻转效果举例，效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mirrorX.png\" alt=\"2016101449356mirrorX.png\"></p>\n<h3 id=\"1-_编写_CIKernel\">1. 编写 CIKernel</h3><p><strong>File —&gt; New —&gt; File —&gt; Empty</strong>， 创建一个名为 <strong>MirrorX.cikernel</strong> 的文件。</p>\n<p>编辑 .cikernel 文件，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec2 mirrorX ( <span class=\"keyword\">float</span> imageWidth ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 获取待处理点的位置</span></span><br><span class=\"line\">  \tvec2 currentVec = destCoord();</span><br><span class=\"line\">    <span class=\"comment\">// 返回最终显示位置</span></span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> vec2 ( imageWidth - currentVec.x , currentVec.y ); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：这个 kernel 如果有不懂的，可以先跳过。下文会重点说明。</p>\n</blockquote>\n<h3 id=\"2-_加载_CIKernel\">2. 加载 CIKernel</h3><p><strong>File —&gt; New —&gt; File —&gt; Cocoa Touch Clas</strong>，新建一个继承自 CIFilter 的类，比如 <strong>MirrorXFilter</strong>。</p>\n<p>在 <strong>MirrorXFilter.m</strong> 中，添加如下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CIKernel</span> *customKernel = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (customKernel == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSBundle</span> *bundle = [<span class=\"built_in\">NSBundle</span> bundleForClass: [<span class=\"keyword\">self</span> class]];</span><br><span class=\"line\">            <span class=\"built_in\">NSURL</span> *kernelURL = [bundle URLForResource:<span class=\"string\">@\"MirrorX\"</span> withExtension:<span class=\"string\">@\"cikernel\"</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> *kernelCode = [<span class=\"built_in\">NSString</span> stringWithContentsOfURL:kernelURL</span><br><span class=\"line\">                                                            encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (kernelCode == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error loading kernel code string in %@\\n%@\"</span>,</span><br><span class=\"line\">                      <span class=\"built_in\">NSStringFromSelector</span>(_cmd),</span><br><span class=\"line\">                      [error localizedDescription]);</span><br><span class=\"line\">                abort();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSArray</span> *kernels = [<span class=\"built_in\">CIKernel</span> kernelsWithString:kernelCode];</span><br><span class=\"line\">            customKernel = [kernels objectAtIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，重写 <strong>init</strong> 方法，主要就是读取 .cikernel 文件中代表 CIKernel 的字符串（当然， CIKernel 也可以直接写在 NSString 里头，免去文件读取这步），然后使用 <strong>kernelsWithString</strong></p>\n<p>方法获取到真正的 CIKernel 对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">CIKernel</span> *&gt; *)kernelsWithString:(<span class=\"built_in\">NSString</span> *)string  <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_4, <span class=\"number\">8</span>_0);</span><br></pre></td></tr></table></figure>\n<p>至此，CIKernel 加载完毕。</p>\n<h3 id=\"3-_设置参数\">3. 设置参数</h3><p>在 <strong>MirrorXFilter.m</strong> 中，添加需要的成员变量。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MirrorXFilter</span> () </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span>  *inputImage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只需要一个成员变量，<strong>inputImage</strong> 表示我们的输入图片。</p>\n<p>之后，就是设置参数，传入 kernel 中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">- (<span class=\"built_in\">CIImage</span> *)outputImage</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> inputWidth = inputImage.extent.size.width;</span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *result = [customKernel applyWithExtent: inputImage.extent roiCallback: ^( <span class=\"keyword\">int</span> index, <span class=\"built_in\">CGRect</span> rect ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rect;</span><br><span class=\"line\">    &#125; inputImage: inputImage arguments: @[@(inputWidth)]];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只需要重写 outputImage 方法即可。</p>\n<p><strong>extent</strong> 用于返回 CIImage 对象对应的 bounds，通过它可以拿到图片的宽度。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Return a rect the defines the bounds of non-(0,0,0,0) pixels */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"built_in\">NS_NONATOMIC_IOSONLY</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGRect</span> extent;</span><br></pre></td></tr></table></figure>\n<p>然后通过  applyWithExtent 来设置对应的参数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">CIImage</span> *)applyWithExtent:(<span class=\"built_in\">CGRect</span>)extent</span><br><span class=\"line\">                          roiCallback:(<span class=\"built_in\">CIKernelROICallback</span>)callback</span><br><span class=\"line\">                           inputImage:(<span class=\"built_in\">CIImage</span>*)image</span><br><span class=\"line\">                            arguments:(nullable <span class=\"built_in\">NSArray</span>&lt;<span class=\"keyword\">id</span>&gt; *)args;</span><br></pre></td></tr></table></figure>\n<p>这里有4个参数。</p>\n<ul>\n<li>extent，也就是之前提到的 DOD，暂且略过。</li>\n<li>callback，也就是之前提到的 ROI，暂且略过。</li>\n<li>image，缺省的 inputImage，传入我们的成员变量 inputImage 即可。</li>\n<li>args，输入参数数组，与 CIKernel 中定义的一一对应。这里只有一个 inputWidth。</li>\n</ul>\n<blockquote>\n<p>PS：这里可能有同学会有疑惑，为什么 inputImage 可以缺省，inputWidth 就需要传入呢。这里暂且不纠结，下面会详细说明~</p>\n</blockquote>\n<p>如此，一个自定义 Filter 就完成了。简单吧~</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png\" alt=\"\"></p>\n<h3 id=\"4-_使用\">4. 使用</h3><p>至于使用上，则和普通的 CIFilter 基本一致。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MirrorXFilter.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 将UIImage转换成CIImage</span></span><br><span class=\"line\"><span class=\"built_in\">CIImage</span> *ciImage = [[<span class=\"built_in\">CIImage</span> alloc] initWithImage:<span class=\"keyword\">self</span>.imageView.image];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建滤镜</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.filter = [[MirrorXFilter alloc] init];</span><br><span class=\"line\"><span class=\"comment\">// 设置相关参数</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.filter setValue:ciImage forKey:<span class=\"string\">@\"inputImage\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 渲染并输出CIImage</span></span><br><span class=\"line\"><span class=\"built_in\">CIImage</span> *outputImage = [<span class=\"keyword\">self</span>.filter outputImage];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 获取绘制上下文</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.context = [<span class=\"built_in\">CIContext</span> contextWithOptions:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 创建输出CGImage</span></span><br><span class=\"line\"><span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"keyword\">self</span>.context create<span class=\"built_in\">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CGImage</span>:cgImage];</span><br><span class=\"line\"><span class=\"comment\">// 6. 释放CGImage</span></span><br><span class=\"line\"><span class=\"built_in\">CGImageRelease</span>(cgImage);</span><br></pre></td></tr></table></figure>\n<p>如此，我们便可得到翻转后的图片。</p>\n<h3 id=\"5-_更多\">5. 更多</h3><p>当然，如果你是一个完美主义者，我觉得你还还可以做更多~</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)customAttributes</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> @&#123;</span><br><span class=\"line\">        <span class=\"string\">@\"inputDistance\"</span> :  @&#123;</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeMin</span>       : @<span class=\"number\">0.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeMax</span>       : @<span class=\"number\">1.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMin</span> : @<span class=\"number\">0.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMax</span> : @<span class=\"number\">0.7</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeDefault</span>   : @<span class=\"number\">0.2</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeIdentity</span>  : @<span class=\"number\">0.0</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeType</span>      : k<span class=\"built_in\">CIAttributeTypeScalar</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        <span class=\"string\">@\"inputSlope\"</span> : @&#123;</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMin</span> : @<span class=\"number\">-0.01</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeSliderMax</span> : @<span class=\"number\">0.01</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeDefault</span>   : @<span class=\"number\">0.00</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeIdentity</span>  : @<span class=\"number\">0.00</span>,</span><br><span class=\"line\">            k<span class=\"built_in\">CIAttributeType</span>      : k<span class=\"built_in\">CIAttributeTypeScalar</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">         k<span class=\"built_in\">CIInputColorKey</span> : @&#123;</span><br><span class=\"line\">         k<span class=\"built_in\">CIAttributeDefault</span> : [<span class=\"built_in\">CIColor</span> colorWithRed:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                               green:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                                blue:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                               alpha:<span class=\"number\">1.0</span>]</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以为自定义的 Filter 添加对应的参数描述，以及默认值，范围限制等。</p>\n<p>这不是必须的，但却是可取的。至于如何设置，可以参考 CIFilter 对应的 <strong>attributes</strong> 属性，或者参照上面这个例子。</p>\n<p>另外，iOS 9之后，引入了 <strong>registerFilterName</strong> , 你可以通过重写 <code>+ (CIFilter *)filterWithName: (NSString *)name;</code> ，然后外部使用的时候，跟 CIFilter 一模一样。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Publishes a new filter called 'name'.</span><br><span class=\"line\"></span><br><span class=\"line\"> The constructor object 'anObject' should implement the filterWithName: method.</span><br><span class=\"line\"> That method will be invoked with the name of the filter to create.</span><br><span class=\"line\"> The class attributes must have a kCIAttributeFilterCategories key associated with a set of categories.</span><br><span class=\"line\"> @param   attributes    Dictionary of the registration attributes of the filter. See below for attribute keys.</span><br><span class=\"line\">*/</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)registerFilterName:(<span class=\"built_in\">NSString</span> *)name</span><br><span class=\"line\">               constructor:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">CIFilterConstructor</span>&gt;)anObject</span><br><span class=\"line\">           classAttributes:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)attributes <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_4, <span class=\"number\">9</span>_0);</span><br></pre></td></tr></table></figure>\n<p>不过需要 iOS 9以上才支持，另外一般用于打包成 Image Units 给他人使用。</p>\n<p>正常情况下应该是用不到。如果真有这个需求，可以参考这篇文章： <a href=\"https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_image_units/ci_image_units.html#//apple_ref/doc/uid/TP30001185-CH7-SW12\">Packaging and Loading Image Units</a>。</p>\n<p>至此，自定义 Filter 的流程就算走完了，我们很容易就可以配置好需要的环境。</p>\n<p>然而，真正的自定义部分，才刚刚开始！</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/183/original/%E5%BC%80%E5%BF%8336.png\" alt=\"\"></p>\n<h2 id=\"DOD_&amp;_ROI\">DOD &amp; ROI</h2><h3 id=\"1-_DOD\">1. DOD</h3><p>DOD ( domain of definition ) ，简单来说就是 Filter 处理后，输入的图片区域。</p>\n<p>一般来说，Filter 操作都是基于原图，添加上效果，但是并不会改变图片的大小，显示区域。所以一般与原图的一致即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGRect</span> dod = inputImage.extent;</span><br></pre></td></tr></table></figure>\n<p>但是针对形变类的 Filter，则需要根据输出图片大小，设置正确的 DOD。</p>\n<h3 id=\"2-_ROI\">2. ROI</h3><p>ROI ( region of interest )，在一定的时间内特别感兴趣的区域，即当前处理区域。</p>\n<p>可以简单的理解为：当前处理区域对应于原图中的哪个区域。</p>\n<p>ROI 的定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Block callback used by Core Image to ask what rectangles of a kernel's input images</span><br><span class=\"line\"> * are needed to produce a desired rectangle of the kernel's output image.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 'index' is the 0-based index specifying which of the kernel's input images is being queried.</span><br><span class=\"line\"> * 'destRect' is the extent rectangle of kernel's output image being queried.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Returns the rectangle of the index'th input image that is needed to produce destRect.</span><br><span class=\"line\"> * Returning CGRectNull indicates that the index'th input image is not needed to produce destRect.</span><br><span class=\"line\"> * The returned rectangle need not be contained by the extent of the index'th input image.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CGRect</span> (^<span class=\"built_in\">CIKernelROICallback</span>)(<span class=\"keyword\">int</span> index, <span class=\"built_in\">CGRect</span> destRect);</span><br></pre></td></tr></table></figure>\n<p>CIKernelROICallback 在 Core Image 内部进行处理的时候，会多次调用。</p>\n<p><strong>index</strong> 表示输入图片的下标，顺序和 kernel 中的入参顺序一致，从0开始。</p>\n<p><strong>destRect</strong> 表示输出图片的区域。 也就是我们先前设置的 DOD。</p>\n<p>那，我们为什么要显示设置 ROI 呢 ？</p>\n<p>因为输入图片中，参与处理的实际区域，Core Image 是无法知道的，我们需要显式的告诉 CI 这个区域。</p>\n<p>这么讲可能有点难以理解，下面我们看两个具体的例子。</p>\n<p>先看一个旋转的例子。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/roi_1.png\" alt=\"2016101449433roi_1.png\"></p>\n<p>这里就是进行了 x，y 互换操作。很容易得到我们的 DOD：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGRect</span> dod = <span class=\"built_in\">CGRectMake</span>(inputImage.extent.origin.y, inputImage.extent.origin.x, inputImage.extent.size.height, inputImage.extent.size.width);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// e.g.</span></span><br><span class=\"line\"><span class=\"comment\">// 原图片extent (0, 0, 200, 300)</span></span><br><span class=\"line\"><span class=\"comment\">// 旋转后的输出图片 (0, 0, 300, 200)，也就是 DOD</span></span><br></pre></td></tr></table></figure>\n<p>那 ROI 应该怎么设置呢 ？我们之前说过，ROI 计算就是计算当前处理区域对应于原图中的哪个区域。</p>\n<p>也就是一个逆向过程。</p>\n<p>假如，A：输入图片中的某点   B：输出图片中的某点。那么 ROI 计算可以理解成  ROI（B）= A。</p>\n<p>理解好这点，我们不难写出这个操作对应的 ROI：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CIKernelROICallback</span> callback = ^(<span class=\"keyword\">int</span> index, <span class=\"built_in\">CGRect</span> rect) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGRectMake</span>(rect.origin.y, rect.origin.x, rect.size.height, rect.size.width);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另外，当输入图片不止一个的时候，则需要根据 <strong>index</strong> 来做区别。因为这里的 <strong>rect</strong> 每次都是返回 <strong>DOD</strong>，而不是当前图片的 extent。</p>\n<h2 id=\"CIKernel_介绍\">CIKernel 介绍</h2><p>终于到了本文最重要的部分了，CIKernel 介绍！</p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/187/original/%E5%BC%80%E5%BF%83ForeverAloneExcited.png\" alt=\"\"></p>\n<p>在此之前，我们先了解下它的一些背景知识。</p>\n<p>CIKernel 需要使用 Core Image Kernel Language (CIKL) 来编写，CIKL 是 OpenGL Shading Language (GLSL) 的子集，如果你之前有过 OpenGL 着色器编写的经验，这部分你会感觉格外亲切。CIKL 集成了 GLSL 绝大部分的参数类型和内置函数，另外它还添加了一些适应 Core Image 的参数类似和函数。</p>\n<p>一个 kernel 的处理过程，可以用下面伪代码表示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... image.width</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... image.height</span><br><span class=\"line\">        New_Image[i][j] = CustomKernel(Current_Image[i][j])</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>也就是说，每个需要处理的 fragment 都会调用一次 kernel 相关操作，每次操作的目的就是返回当前 fragment 对应的结果 fragment，这里 fragment 可以理解为像素点。</p>\n<p>所以我们的 kernel，应该是针对一个点，而不是一张图片。</p>\n<p>Core Image 内置了3种适用于不同场景的 Kernel，可以根据实际需求来选择。</p>\n<ul>\n<li>CIColorKernel：用于处理色值变化的 Filter。</li>\n<li>CIWarpKernel：用于处理形变的 Filter。</li>\n<li>CIKernel：通用。</li>\n</ul>\n<p>CIColorKernel，CIWarpKernel 是官方推荐使用的。某个 Filter，在使用它们能实现的情况下，应该使用它们，即使是一个 CIKernel 拆分成多个 CIColorKernel 以及 CIWarpKernel，也应该用这种方式。因为 Core Image 内部对这两张 Kernel 做了优化。</p>\n<p>当然，它们的使用时有限制的。目的一定要很纯粹，比如 CIColorKernel 只能处理色值上的变化。否则就算定义为 CIColorKernel，如果实现上涉及了其他 CIColorKernel 不允许的操作，Core Image 也会当做普通的 CIFilter 处理。</p>\n<p>另外，kernel 的入参只支持下面这么几种：</p>\n<table>\n<thead>\n<tr>\n<th>Kernel routine input parameter</th>\n<th>Object</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sampler</td>\n<td>CISampler</td>\n</tr>\n<tr>\n<td>__table sampler</td>\n<td>CISampler</td>\n</tr>\n<tr>\n<td>__color</td>\n<td><code>CIColor</code></td>\n</tr>\n<tr>\n<td>float</td>\n<td>NSNumber</td>\n</tr>\n<tr>\n<td>vec2, vec3, or vec4</td>\n<td>CIVector</td>\n</tr>\n</tbody>\n</table>\n<p>简单说明一下：</p>\n<ul>\n<li>sampler：可以理解成纹理，或者图片。外部以 CIImage 形式传入。</li>\n<li>__table sampler：表示颜色查找表（lookup table），虽然它也是图片，但是添加该声明可以避免被修改。外部以 CIImage 形式传入。</li>\n<li>__color：表示颜色。外部以 CIColor 形式传入。</li>\n<li>float：kernel 内部处理都是 float 类型。外部以 NSNumber 形式传入。</li>\n<li>vecN：表示一个多元向量。比如 vec2 可以表示一个点，vec4 可以表示一个色值。外部以 CIVector 形式传入。</li>\n</ul>\n<p>至于 kernel 中可以使用的函数，那就太多了。这里不一一枚举，在下面的具体讲解中，会说明几个常用的。如果想了解更多，可以参考  <a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397\">Core Image Kernel Language Reference</a>，以及 <a href=\"http://www.shaderific.com/glsl/\">OpenGL ES Shading Language Reference</a>。</p>\n<p>下面我会通过一个 Demo，讲解这三种 Kernel 的具体用法。</p>\n<blockquote>\n<p>PS：建议阅读之前，下载 <a href=\"https://github.com/colin1994/CoreImageDemo\">源码</a> 配合着看。</p>\n</blockquote>\n<h3 id=\"1-_CIColorKernel\">1. CIColorKernel</h3><p>首先看下官方的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * CIColorKernel is an object that encapsulates a Core Image Kernel Language</span><br><span class=\"line\"> * routine that processes only the color information in images.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Color kernels functions are declared akin to this example:</span><br><span class=\"line\"> *   kernel vec4 myColorKernel (__sample fore, __sample back, vec4 params)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The function must take a __sample argument for each input image.</span><br><span class=\"line\"> * Additional arguments can be of type float, vec2, vec3, vec4, or __color.</span><br><span class=\"line\"> * The destination pixel location is obtained by calling destCoord().</span><br><span class=\"line\"> * The kernel should not call sample(), sampleCoord(), or samplerTransform().</span><br><span class=\"line\"> * The function must return a vec4 pixel color.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE</span>(<span class=\"number\">10</span>_11, <span class=\"number\">8</span>_0)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CIColorKernel</span> : <span class=\"title\">CIKernel</span></span></span><br></pre></td></tr></table></figure>\n<p>很重要的一点：<strong>processes only the color information in images</strong>，它只处理图片的颜色信息。</p>\n<p>所以在使用它之前，一定要确保该 Filter 只涉及颜色处理。</p>\n<p>CIKL 的语法和大多数 C 阵营一样，变量，运算符，控制结构，函数等都大同小异，所以它的学习成本是很低的。</p>\n<p>真正的核心应该是：<strong>如果用这样的语言来实现这个滤镜，也就是我们经常说的算法。</strong></p>\n<p>下面我们以一个 <strong>Vignette</strong> 来实际讲解一下。</p>\n<p>它的效果如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette_demo.gif\" alt=\"2016101796011vignette_demo.gif\"></p>\n<p>不难看出，Vignette 滤镜，它实际上就是一个FOV（Field of View） 的效果，即视野中央看的最清楚，清晰程度与到中心距离呈反比，与人类的视觉是类似的。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/vignette.png\" alt=\"2016101524815vignette.png\"></p>\n<p>所以针对图片上的每个像素点 A，经过 Vignette 滤镜处理后得到的 B，应该满足：</p>\n<p>Vignette（A）＝ A * Darken ＝ B； 而 Darken 的计算依赖 A 与中心点的距离。</p>\n<p>如此，我们可以很容易的写出对应的 kernel：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 vignetteKernel(__sample image, vec2 center, <span class=\"keyword\">float</span> radius, <span class=\"keyword\">float</span> alpha)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出当前点与中心的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> distance = distance(destCoord(), center) ;</span><br><span class=\"line\">    <span class=\"comment\">// 根据距离计算出暗淡程度</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> darken = <span class=\"number\">1.0</span> - (distance / radius * alpha);</span><br><span class=\"line\">    <span class=\"comment\">// 返回该像素点最终的色值</span></span><br><span class=\"line\">    image.rgb *= darken;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> image.rgba;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和 C 语言的一样，函数需要具备：</p>\n<ul>\n<li>返回类型：vec4</li>\n<li>函数名：vignetteKernel</li>\n<li>参数列表：__sample image, vec2 center, float radius, float alpha）</li>\n<li>函数体：｛｝中的具体实现</li>\n</ul>\n<p>有所不同的，kernel 函数需要带上 kernel 关键字，与其它普通函数做区分。一个 .cikernel 文件中，允许包括多个函数，甚至是多个 kernel 函数，不过<strong>函数调用要出现在函数定义之后</strong>！</p>\n<p>另外，这里有个特别的参数类型，<strong>__sample</strong> ，和之前讲的 <strong>sampler</strong> 有所不同。因为这里我们使用的是 <strong>CIColorKernel</strong>，在得到高效性能的同时，也有一定的局限性。因为只是处理图片当前位置的颜色信息，所以 <strong>__sample</strong> 提供的 <strong>rgba</strong> 变量足够了，无法获取一些其它的信息。</p>\n<blockquote>\n<p>比如在 CIKernel 中，可以通过 sample() 等函数获取其它位置的色值，而在 CIColorKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。</p>\n</blockquote>\n<p>下面逐行解释这个 kernel。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算出当前点与中心的距离</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> distance = distance(destCoord(), center) ;</span><br></pre></td></tr></table></figure>\n<p><strong>destCoord</strong></p>\n<ul>\n<li><p><code>varying vec2 destCoord ()</code></p>\n<p>返回当前正在处理的像素点所处坐标。(working space coordinates)</p>\n</li>\n</ul>\n<p>这里使用的 CIKL 内置的函数 destCoord，它返回的坐标是基于 <strong>working space</strong> 的。所谓 working space，即工作空间，它的取值范围对应图片实际大小。比如 inputImage 的大小为 300 * 200，那么 destCoord() 返回坐标的取值范围在 (0, 0) - (300, 200)。</p>\n<p><strong>distance</strong></p>\n<ul>\n<li><p><code>float distance (vec2 p0, vec2 p1)</code></p>\n<p>计算向量p0，p1之间的距离</p>\n</li>\n</ul>\n<p>如此便能很容易得到当前点与中心的距离。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据距离计算出暗淡程度</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> darken = <span class=\"number\">1.0</span> - (distance / radius * alpha);</span><br></pre></td></tr></table></figure>\n<p>之后根据清晰程度与到中心距离呈反比这一原理，结合外部控制的 <strong>alpha</strong> 变量，计算出暗淡程度。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回该像素点最终的色值</span></span><br><span class=\"line\">image.rgb *= darken;</span><br><span class=\"line\"><span class=\"keyword\">return</span> image.rgba;</span><br></pre></td></tr></table></figure>\n<p>这里之前提到，<strong>__sample</strong> 有个 rgba 变量，通过它可以获取到当前处理点的色值。</p>\n<p>在 CIKL 中，vec4 的任何一个分量都可以单独获取，也可以组合获取，例如 <strong>image.a</strong>，<strong>image.rrgg</strong> 等，都是可行的。</p>\n<p>CIColorKernel 是针对色值的处理，所以它的返回值必须是一个代表色值的 vec4 类型变量。</p>\n<p>至此，这个 vignetteKernel 就分析完毕了。很简单吧～</p>\n<h3 id=\"2-_CIWarpKernel\">2. CIWarpKernel</h3><p>同样，先看下文档定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * CIWarpKernel is an object that encapsulates a Core Image Kernel Language</span><br><span class=\"line\"> * function that processes only the geometry of an image.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Warp kernels functions are declared akin to this example:</span><br><span class=\"line\"> *   kernel vec2 myWarpKernel (vec4 params)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Additional arguments can be of type float, vec2, vec3, vec4.</span><br><span class=\"line\"> * The destination pixel location is obtained by calling destCoord().</span><br><span class=\"line\"> * The kernel should not call sample(), sampleCoord(), or samplerTransform().</span><br><span class=\"line\"> * The function must return a vec2 source location.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE</span>(<span class=\"number\">10</span>_11, <span class=\"number\">8</span>_0)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CIWarpKernel</span> : <span class=\"title\">CIKernel</span></span></span><br></pre></td></tr></table></figure>\n<p>同样，它也有很重要一点：<strong>processes only the geometry of an image</strong>。它只处理图片的几何形状。</p>\n<p>所谓的改变几何形状，也就是形变，把原本放置在 A 处的点，用 B 处的点去填充，或者反过来，把原本 B 处的点，挪到 A 处去，也是一样的。</p>\n<p>它可以用这个表达式表示：<strong>Warp（A）＝ B；</strong></p>\n<p>所以它和之前的 CIColorKernel 不同，它的返回值是 vec2，代表点的坐标。另外它只允许传入一张图片，所以这里的 inputImage 缺省了。</p>\n<blockquote>\n<p>同样的，在 CIWarpKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。</p>\n</blockquote>\n<p>下面以一个马赛克，像素化（Pixellate）的例子来讲解。它的效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/pixellate_demo.gif\" alt=\"2016101762677pixellate_demo.gif\"></p>\n<p>马赛克，比较简单的一种算法是按照固定的间隔取像素点，将图片分割成一些小块，然后每个小块内选择一个像素点，然后把这个区域全部用这个像素点填充即可。这里的每个小块，称作晶格，晶格越大，马赛克效果越好。</p>\n<p>依照这个简单算法，我们可以很容易的写出对应的 kernel：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec2 pixellateKernel(<span class=\"keyword\">float</span> radius)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec2 positionOfDestPixel, centerPoint;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前点坐标</span></span><br><span class=\"line\">    positionOfDestPixel = destCoord();</span><br><span class=\"line\">    <span class=\"comment\">// 获取对应晶格内的中心像素点</span></span><br><span class=\"line\">    centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * <span class=\"number\">2.0</span>) + radius;</span><br><span class=\"line\">    centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * <span class=\"number\">2.0</span>) + radius;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> centerPoint;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，先是获取到当前处理点的坐标，positionOfDestPixel。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取对应晶格内的中心像素点</span></span><br><span class=\"line\">centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * <span class=\"number\">2.0</span>) + radius;</span><br><span class=\"line\">centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * <span class=\"number\">2.0</span>) + radius;</span><br></pre></td></tr></table></figure>\n<p>然后这里的 <strong>mod (x, y)</strong> 和平时使用的一样，计算 <strong>x / y 的余数</strong>。</p>\n<p>至于为什么这个式子能获得<strong>中心像素点坐标</strong>，想必一看就懂了吧～（不懂的可以拿张纸画画）</p>\n<p>最后返回中心点坐标，替换当前点。</p>\n<p>如此，一个简单的马赛克就完成了～</p>\n<h3 id=\"3-_CIKernel\">3. CIKernel</h3><p>我们之前说过，CIColorKernel 和 CIWarpKernel 内部做了优化，要尽可能的使用它们。除非真的有特殊需求，是它们无法实现的。下面罗列了 CIColorKernel 和 CIWarpKernel 的一些局限：</p>\n<p><strong>CIColorKernel ：</strong></p>\n<ul>\n<li>只处理当前处理点色值，无法获取到其它点的状态。</li>\n</ul>\n<p><strong>CIWarpKernel：</strong></p>\n<ul>\n<li>只处理当前处理点位置，无法获取到其它点的状态。</li>\n<li>只能传入一张图片。</li>\n</ul>\n<p>比如说，美图秀秀里面的一些简单马赛克，效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/mosaic_demo.gif\" alt=\"2016101864134mosaic_demo.gif\"></p>\n<p>它的实现方式，我们可以简单的这么理解：</p>\n<ol>\n<li>判断当前点是否在传入点的处理范围内。</li>\n<li>如果在，返回马赛克贴图中对应的像素点色值。</li>\n<li>如果不在，返回当前点色值。</li>\n</ol>\n<p>很明显，它需要两张图片，一张我们的待处理图片，一张马赛克贴图。所以 CIWarpKernel 不适用。</p>\n<p>另外，待处理图片与马赛克贴图之前不是一一对应关系，在第二步，返回马赛克贴图中对应的像素点色值中，需要一个映射计算，即当前点对应马赛克贴图中的某点。所以 CIColorKernel 也不适用。</p>\n<p>这种情况下，就要使用通用的 CIKernel 了。</p>\n<p>下面是对应的 kernel：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 mosaicKernel(sampler image, sampler maskImage, <span class=\"keyword\">float</span> radius, vec2 point, <span class=\"keyword\">float</span> maskWidth, <span class=\"keyword\">float</span> maskHeight)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前点坐标</span></span><br><span class=\"line\">    vec2 textureCoordinate = destCoord();</span><br><span class=\"line\">    <span class=\"comment\">// 计算当前点与传入点的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> distance = distance(textureCoordinate, point);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (distance &lt; radius) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在处理范围内, 计算对应马赛克贴图中的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> resultX = mod(textureCoordinate.x, maskWidth);</span><br><span class=\"line\">        <span class=\"keyword\">float</span> resultY = mod(textureCoordinate.y, maskHeight);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sample(maskImage, samplerTransform(maskImage, vec2(resultX, resultY)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回原图对应像素点色值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sample(image, samplerTransform(image, textureCoordinate));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里参数比较多，分别对应：</p>\n<ul>\n<li>image：待处理图片</li>\n<li>maskImage：马赛克贴图</li>\n<li>radius：处理范围，半径</li>\n<li>point：传入点，即当前触摸的点</li>\n<li>maskWidth：马赛克贴图宽度</li>\n<li>maskHeight：马赛克贴图高度</li>\n</ul>\n<p>上面的 kernel，使用了两个新的函数，sample 和 samplerTransform。</p>\n<blockquote>\n<p><code>vec4 sample (uniform sampler src, vec2 point)</code><br>Returns the pixel value produced from sampler src at the position point, where point is specified in sampler space.</p>\n<p>返回图片 src 指定点 point 处的色值。point 是基于 sampler space。</p>\n<p><code>vec2 samplerTransform (uniform sampler src, vec2 point)</code><br>Returns the position in the coordinate space of the source (the first argument) that is associated with the position defined in working-space coordinates (the second argument). (Keep in mind that the working space coordinates reflect any transformations that you applied to the working space.) For example, if you are modifying a pixel in the working space, and you need to retrieve the pixels that surround this pixel in the original image, you would make calls similar to the following, where d is the location of the pixel you are modifying in the working space, and image is the image source for the pixels.</p>\n<p>返回图片 src 指定点 point 处坐标对应的基于 sampler space 的坐标。point 是基于working space。</p>\n<p>sampler space 的取值是 0.0 - 1.0，左下角为原点，向右，向上递增。</p>\n</blockquote>\n<p>了解了这两个函数的用法，想必这段代码就没什么需要特别说明的地方了，注释已经很清楚，不再累述。</p>\n<h2 id=\"注意点\">注意点</h2><h3 id=\"1-_premultiply\">1. premultiply</h3><blockquote>\n<p><code>vec4 premultiply (vec4 color)</code><br>Multiplies the red, green, and blue components of the color parameter by its alpha component.</p>\n</blockquote>\n<p>将颜色变量的r、g、b元素值分别于 alpha 相乘，返回一个新的四维颜色向量。</p>\n<blockquote>\n<p><code>vec4 unpremultiply (vec4 color)</code><br>If the alpha component of the color parameter is greater than 0, divides the red, green and blue components by alpha. If alpha is 0, this function returns color.</p>\n</blockquote>\n<p>将颜色变量的r、g、b元素值分别除以 alpha ，返回一个新的四维颜色向量。</p>\n<p>pixel（R, G, B, A） —— (premultiply) ——&gt; (R＊A, G＊A, B＊A, A)</p>\n<p>—— (unpremultiply) ——&gt; （R, G, B, A）。</p>\n<p>在 Core Image 中，默认颜色空间是 sRGB，在 kernel 中得到的色值，都经过了 Premultiplied Alpha 处理。</p>\n<p>至于为什么要执行 Premultiplied Alpha 操作，具体的可以参考这篇文章：<a href=\"https://boundary.cc/2015/07/why-premultiplied-alpha/\">为什么要PREMULTIPLIED ALPHA呢？</a></p>\n<p>所以如果 kernel 涉及 alpha 相关操作，则需要先执行 unpremultiply，返回正确的 rgba。处理完之后，再执行 premultiply 操作。</p>\n<p>比如一个反相滤镜，</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_1.gif\" alt=\"2016101643860rever_1.gif\"><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/rever_2.gif\" alt=\"20161016903rever_2.gif\"></p>\n<p>它对应的 kernel 应该是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 _invertColor(sampler source_image)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 pixValue;</span><br><span class=\"line\">    <span class=\"comment\">// samplerCoord 返回当前像素点在 sampler space 中的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// kernel 无法知道该图片是否进行了某些变换操作，所以确保转换为 sampler space 中的位置 是有必要的</span></span><br><span class=\"line\">    pixValue = sample(source_image, samplerCoord(source_image));</span><br><span class=\"line\">    <span class=\"comment\">// 执行 unpremultiply 操作, 得到真正的 RGB 值</span></span><br><span class=\"line\">    <span class=\"comment\">// (R＊A, G＊A, B＊A, A) ——(unpremultiply)——&gt; (R, G, B, A)</span></span><br><span class=\"line\">    <span class=\"comment\">// Core Image is always RGB based.</span></span><br><span class=\"line\">    unpremultiply(pixValue); </span><br><span class=\"line\">    <span class=\"comment\">// invertColor</span></span><br><span class=\"line\">    pixValue.r = <span class=\"number\">1.0</span> - pixValue.r; </span><br><span class=\"line\">    pixValue.g = <span class=\"number\">1.0</span> - pixValue.g;</span><br><span class=\"line\">    pixValue.b = <span class=\"number\">1.0</span> - pixValue.b;</span><br><span class=\"line\">    <span class=\"comment\">// premultiply. (R, G, B, A) —&gt; (R＊A, G＊A, B＊A, A)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> premultiply(pixValue); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化：</span></span><br><span class=\"line\"><span class=\"comment\">// 避免了 unpremultiply 和 premultiply 操作，能更高效执行。</span></span><br><span class=\"line\"><span class=\"comment\">// pixValue 是 (R＊A, G＊A, B＊A, A)， pixValue.a - pixValue.r = (1-r)*a. 和最终 premultiply 得到的结果一样.</span></span><br><span class=\"line\">kernel vec4 _invertColor(sampler source_image)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 pixValue;</span><br><span class=\"line\">    pixValue = sample(source_image, samplerCoord(source_image));</span><br><span class=\"line\">    pixValue.rgb = pixValue.aaa - pixValue.rgb;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pixValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-_关键字\">2. 关键字</h3><p>和 C 语言等一样，CIKL 中变量的命名不能和关键字相同。</p>\n<p>下面是官方 Session 中翻转对应的 kernel 脚本，这里用到了 input 关键字，导致整个 kernel 错误。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/session_error.png\" alt=\"2016101638470session_error.png\"></p>\n<p>所以这点一定要牢记。</p>\n<p>下面是在 Github 上引起的灾难..</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_1.png\" alt=\"2016101685335error_1.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/error_2.png\" alt=\"2016101697866error_2.png\"></p>\n<h3 id=\"3-_GLSL\">3. GLSL</h3><p>CIKL 是 GLSL 的子集，所以<strong>不是 GLSL 中定义的任何东西在 CIKL 中都适用</strong>。但是 glsl 中大多数关键字都是可以用的。另外，CIKL 还提供了 glsl 不支持的，额外的数据类型，关键字，方法，来完善 CIKernel。</p>\n<h3 id=\"4-_Array,_Mat\">4. Array, Mat</h3><p> In addition, the following are not implemented:</p>\n<ul>\n<li>Data types: <code>mat2</code>, <code>mat3</code>, <code>mat4</code>, <code>struct</code>, <code>arrays</code></li>\n</ul>\n<p>这些数据类型 Core Image 不支持。但是在 kernel 内部却可以使用 … </p>\n<p>如果当做参数传入，则会报错：</p>\n<p><strong>invalid kernel parameter type; valid types are:  ‘float’, ‘vec2’, ‘vec3’, ‘vec4’, ‘sampler’, ‘sample’, ‘color’</strong></p>\n<p><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/229/original/%E6%82%B2%E4%BC%A41.png\" alt=\"\"></p>\n<p>这也导致了一些依赖关键点的算法无法实现。</p>\n<h3 id=\"5-_坐标系\">5. 坐标系</h3><p>UIKit 坐标系，原点在屏幕左上，x轴向右，y轴向下。</p>\n<p>Core Image 和 OpenGL 坐标系原点在屏幕的左下，x轴向右，y轴向上。</p>\n<p>所以位置的处理上要注意。</p>\n<h3 id=\"6-_局限\">6. 局限</h3><p>kernel 的输入和输出像素可以相互映射。大多数像素处理都可以用这种方式表达，但是有的图像处理操作很困难，甚至不可能。</p>\n<p>kernel 的使用上还是有一定的局限性。比如说通过输入图像映射计算直方图是很困难的。也不可以执行种子填充算法或者其他需要复杂条件语句的图像分析操作。</p>\n<h3 id=\"7-_性能优化\">7. 性能优化</h3><p>kernel 中的内容要尽可能简单，高效。</p>\n<ul>\n<li>展开循环操作会更快。</li>\n<li>外部能传入的变量，尽量不要在 kernel 中计算获取。</li>\n</ul>\n<h2 id=\"开发技巧\">开发技巧</h2><h3 id=\"1-_Log\">1. Log</h3><p><strong>+(id)kernelsWithString:(id)arg1 messageLog:(id)arg2 ;</strong></p>\n<p>这是  <a href=\"https://github.com/CPDigitalDarkroom/iOS9-SpringBoard-Headers/blob/a11be523d5644a178614585ff57f9638300c2cc0/System/Library/Frameworks/CoreImage.framework/CIKernel.h\">CIKernel.h</a> 里面的私有方法，在调试阶段可以利用它来打印 kernel 中的错误。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *messageLog = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *kernels = [[<span class=\"built_in\">CIKernel</span> class] \t\t performSelector:<span class=\"keyword\">@selector</span>(kernelsWithString:messageLog:) withObject:kernelCode withObject:messageLog];</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( messageLog.count &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">  \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error: %@\"</span>, messageLog.description);</span><br><span class=\"line\">customKernel = [kernels objectAtIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误 log</span></span><br><span class=\"line\">Error: (</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageLineNumber</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageType</span> = <span class=\"built_in\">CIKernelMessageTypeError</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageDescription</span> = <span class=\"string\">\"unkown type or function name 'destCoordE'; did you mean 'destCoord'?\"</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageOffset</span> = <span class=\"number\">142</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageLineNumber</span> = <span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CIKernelMessageType</span> = <span class=\"built_in\">CIKernelMessageTypeError</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageDescription</span> = <span class=\"string\">\"invalid operands to binary expression ('float' and 'int')\"</span>;</span><br><span class=\"line\">        k<span class=\"built_in\">CIKernelMessageOffset</span> = <span class=\"number\">281</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-_CI_PRINT_TREE\">2. CI_PRINT_TREE</h3><p>这里 Core Image 中非常实用的一个环境变量，通过设置它，可以很方便的查看 Core Image 工作过程中到底做了什么。比如：</p>\n<ul>\n<li>工作在 GPU 还是 CPU 上？</li>\n<li>各个 kernel 的参数值？</li>\n<li>Core Image 是如何链接 kernel？</li>\n<li>DOD，ROI 如何设置的？</li>\n<li>对于大图如何拆分处理？</li>\n<li>…</li>\n</ul>\n<blockquote>\n<p>PS ： 至于 CI_PRINT_TREE 具体应该如何使用，没有找到相关资料，只是在 Session 中提到过。</p>\n<p>包括 ObjC 中国 上的翻译：你可以通过在 Xcode 中设置计划配置（scheme configuration）里的 CI_PRINT_TREE 环境变量为 1 来决定用 CPU 还是 GPU 来渲染，也是很不准确的。</p>\n<p>这里的结论都是自己摸索后的总结，所以可能存在错误或者遗漏，欢迎补充交流～</p>\n</blockquote>\n<p>CI_PRINT_TREE 的设置大致是这样的：分成 A B 两部分，它们可以结合使用。</p>\n<p>其中 A 是主要分类，B 是辅助功能。</p>\n<p>A 包括：</p>\n<ul>\n<li>1  initial graph </li>\n<li>2  optimized graph </li>\n<li>4  tile graph </li>\n<li>8  programs graph </li>\n<li>16  timing graph </li>\n</ul>\n<p>B 包括：</p>\n<ul>\n<li>graphviz </li>\n<li>dump-inputs </li>\n<li>dump-intermediates </li>\n<li>skip-cpu </li>\n<li>skip-gpu  </li>\n<li>skip-small </li>\n<li>frame-<number> </li>\n</ul>\n<p>使用上，比如简单的查看 initial graph 做了什么，即我们添加这个 Filter 的时候，初始化过程执行了什么，传入了哪些参数。当然，这个过程它并没有真正得到渲染，只是一个操作流程列表。设置 CI_PRINT_TREE ＝ 1，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/ci_print_tree.png\" alt=\"2016101786999ci_print_tree.png\"></p>\n<p>它的结果如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initial graph render_to_display (opengles2 context <span class=\"number\">1</span> frame <span class=\"number\">1</span>) format=RGBA8 roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] = </span><br><span class=\"line\">  clamptoalpha roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] opaque</span><br><span class=\"line\">    colormatch workingspace-to-devicergb roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] opaque</span><br><span class=\"line\">      affine [<span class=\"number\">2</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">2</span> <span class=\"number\">0</span> <span class=\"number\">156</span>] roi=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">156</span> <span class=\"number\">750</span> <span class=\"number\">748</span>] opaque</span><br><span class=\"line\">        colorkernel </span><br><span class=\"line\">  roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br><span class=\"line\">          affine [<span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">-1</span> <span class=\"number\">0</span> <span class=\"number\">374</span>] roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br><span class=\"line\">            colormatch <span class=\"string\">\"sRGB IEC61966-2.1\"</span>-to-workingspace roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br><span class=\"line\">              <span class=\"built_in\">CGImageRef</span> <span class=\"number\">0x1701c4380</span> RGBX8 <span class=\"number\">375</span>x374  alpha_one roi=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br></pre></td></tr></table></figure>\n<p>这里有很多关键信息，十分详细。它的阅读顺序是从下往上，我们简单分析下：</p>\n<ul>\n<li><strong>CGImageRef</strong>： 指代我们传入的图片。</li>\n<li>每个阶段的 <strong>ROI，DOD</strong>。</li>\n<li><strong>colormatch “sRGB IEC61966-2.1”-to-workingspace</strong> ：传入的颜色空间</li>\n<li><strong>vignetteKernel(image,center=[187.5 187],radius=187.5,alpha=0.0537634)</strong> ：kernel 的每个参数</li>\n<li><strong>colormatch workingspace-to-devicergb</strong>：  输出的颜色空间</li>\n<li><strong>opengles2</strong> ：工作在 GPU 上</li>\n<li><strong>context 1 frame 1</strong> ：分别指代当前 context 以及第几帧。每次渲染 frame + 1</li>\n</ul>\n<p>当然，这只是 CI_PRINT_TREE 的一部分功能，如果你设置 CI_PRINT_TREE = 8 (programs graph )，你又会得到这样的信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">programs graph render_to_display (opengles2 context <span class=\"number\">1</span> frame <span class=\"number\">4</span> tile <span class=\"number\">1</span>) format=RGBA8 roi=[<span class=\"number\">0</span> <span class=\"number\">111</span> <span class=\"number\">640</span> <span class=\"number\">640</span>] = </span><br><span class=\"line\">  program affine(clamp_to_alpha(linear_to_srgb(vignetteKernel(affine(srgb_to_linear(swizzle_bgr1())))))) rois=[<span class=\"number\">0</span> <span class=\"number\">111</span> <span class=\"number\">640</span> <span class=\"number\">640</span>] extent=[<span class=\"number\">0</span> <span class=\"number\">111</span> <span class=\"number\">640</span> <span class=\"number\">640</span>]</span><br><span class=\"line\">    IOSurface <span class=\"number\">0x60000019ddc0</span> RGBA8 <span class=\"number\">375</span>x374 alpha_one edge_clamp rois=[<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] extent=[infinite][<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">375</span> <span class=\"number\">374</span>] opaque</span><br></pre></td></tr></table></figure>\n<p>这里描述了程序图表，即真正涉及到的操作。</p>\n<p>如果觉得这样看比较杂乱，可以试试添加 B 类辅助功能。 比如：<strong>CI_PRINT_TREE = 8 graphviz</strong> ，这样就可以导出 DOT 语言脚本。然后使用 <a href=\"http://www.graphviz.org/\">Graphviz</a> 工具，即可绘制这个 DOT 语言脚本描述的图形。</p>\n<p>比如上面 Log 对应绘制得到的图形如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/programs_graph.png\" alt=\"201610186930programs_graph.png\"></p>\n<p>同样是从下往上看，各个操作的层级关系就很明显了。除了我们提供的 vignetteKernel，Core Image 内部还做了其他的操作，比如 <strong>linear_to_srgb，clamp_to_alpha</strong> 等。它们的具体实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Filter DAG:</span><br><span class=\"line\">Node: <span class=\"number\">0</span></span><br><span class=\"line\">  original source: vec4 _ci_clamp_to_alpha(vec4 s) &#123; <span class=\"keyword\">return</span> clamp(s, <span class=\"number\">0.0</span>, s.a); &#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_clamp_to_alpha(vec4 s) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clamp(s, <span class=\"number\">0.000000e+00</span>, s.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">1</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">1</span></span><br><span class=\"line\">  original source: vec4 _ci_premultiply(vec4 s) &#123; <span class=\"keyword\">return</span> vec4(s.rgb*s.a, s.a); &#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_premultiply(vec4 s) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vec4(s.rgb * s.a, s.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">2</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">2</span></span><br><span class=\"line\">  original source: vec4 _ci_linear_to_srgb(vec4 s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  s.rgb = sign(s.rgb)*mix(s.rgb*<span class=\"number\">12.92</span>, pow(abs(s.rgb), vec3(<span class=\"number\">0.4166667</span>)) * <span class=\"number\">1.055</span> - <span class=\"number\">0.055</span>, step(<span class=\"number\">0.0031308</span>, abs(s.rgb)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_linear_to_srgb(vec4 s) &#123;</span><br><span class=\"line\">  s.rgb = sign(s.rgb) * mix(s.rgb * <span class=\"number\">1.292000e+01</span>, (pow(abs(s.rgb), vec3(<span class=\"number\">4.166667e-01</span>)) * <span class=\"number\">1.055000e+00</span>) - <span class=\"number\">5.500000e-02</span>, step(<span class=\"number\">3.130800e-03</span>, abs(s.rgb)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">3</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">3</span></span><br><span class=\"line\">  original source: vec4 _ci_unpremultiply(vec4 s) &#123; <span class=\"keyword\">return</span> vec4(s.rgb/max(s.a,<span class=\"number\">0.00001</span>), s.a); &#125;</span><br><span class=\"line\">  printed AST: vec4 _ci_unpremultiply(vec4 s) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vec4(s.rgb / max(s.a, <span class=\"number\">1.000000e-05</span>), s.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">6</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">6</span></span><br><span class=\"line\">  &lt;sample with transform&gt;</span><br><span class=\"line\">  original source: vec4 read_pixel(sampler2D image, vec2 c, mat3 m)&#123; <span class=\"keyword\">return</span> texture2D(image, (vec3(c, <span class=\"number\">1.0</span>) * m).xy);&#125;</span><br><span class=\"line\">  printed AST: vec4 read_pixel_6(sampler2D image, vec2 c, mat3 m) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> texture2D(image, (vec3(c, <span class=\"number\">1.000000e+00</span>) * m).xy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  children: <span class=\"number\">4</span> <span class=\"number\">7</span> <span class=\"number\">5</span></span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">4</span></span><br><span class=\"line\">  image: <span class=\"number\">6</span></span><br><span class=\"line\">  printed: uniform lowp sampler2D image6_0</span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">7</span></span><br><span class=\"line\">  position use &lt;_dc&gt;</span><br><span class=\"line\">End Filter Node</span><br><span class=\"line\"></span><br><span class=\"line\">Node: <span class=\"number\">5</span></span><br><span class=\"line\">  &lt;transform&gt;</span><br><span class=\"line\">  uniform: <span class=\"number\">6</span></span><br><span class=\"line\">End Filter Node</span><br></pre></td></tr></table></figure>\n<p>这个 DAG（有向无环图），具体描述了相关操作的实现过程，比较简单，可以自己看看，这里不累述。</p>\n<h2 id=\"工具介绍\">工具介绍</h2><p>Quartz Composer 是一款图形化的编程工具，专门用来生成各种动态视觉效果，包括可交互的界面原型。当然，它也支持 Core Image 滤镜图表的原型。</p>\n<p><img src=\"http://7xkc7a.com1.z0.glb.clouddn.com/2016092073920quartz_1.png\" alt=\"2016092073920quartz_1.png\"></p>\n<p>另外，在 QC 上编写 Kernel，除了代码高亮，实时调整效果也很棒。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/quartz_2.png\" alt=\"2016101158579quartz_2.png\"></p>\n<blockquote>\n<p>PS ：<a href=\"https://developer.apple.com/downloads/\">Quartz Composer 下载地址</a> </p>\n<p>有精力的话建议把 QC 内自带的所有 example 找出来仔细研究，苹果自己的例子是最好的。它们藏在 /Applications/Quartz Composer.app/Contents/Resources/Examples/Patches（找到 Quartz Composer.app 点右键，选择「Show Package Content」）</p>\n<p> 简单了解 Quartz Composer。QCDesigners 上有比较简要的介绍：<a href=\"https://link.zhihu.com/?target=http%3A//qcdesigners.com/index.php/forums/topic/2/new-to-quartz-composer-start-he\">QC Designers</a></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/download_Graphic_Tools_for_XCode.png\" alt=\"2016092059430download_Graphic_Tools_for_XCode.png\"></p>\n<p>QC 已经内置了适合 Core Image 的模板，并且实现了动态模糊滤镜效果。不过这里为了了解 QC 的使用方式，不使用内置的模板，从头开始。<strong>File —&gt; New Blank</strong>，创建一个空白的 QC 工程。</p>\n<blockquote>\n<p>PS： QC 的功能很强大，这里只介绍 Core Image Filter 编辑过程中会用到的，以及我所掌握的…</p>\n</blockquote>\n<h3 id=\"0-_概念介绍\">0. 概念介绍</h3><p>在讲解使用方式之前，介绍几个基本概念。</p>\n<p>一次滤镜操作，可以简单理解成： <strong>输入—&gt;(Patch)—&gt;输出</strong>。</p>\n<p>Patch 可以理解成 Kernel。</p>\n<p>输入则与 Kernel 的参数相对应，可以是 image，color，float…</p>\n<p>输入这里一般就是处理后的图像。</p>\n<p>还有一个比较特殊的 Patch，Layer。相当于画布，可以把结果图显示在上面，它也有层的概念。</p>\n<h3 id=\"1-_工作区介绍\">1.  工作区介绍</h3><p><strong>编辑区：</strong> 这是主面板，主要衔接各个 Patch，以及它们的输入，输出。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_1.png\" alt=\"2016101175676panel_1.png\"></p>\n<p><strong>Library：</strong> 这里陈列了 QC 内置的所有 Patch（也可以添加自定义的 Patch 进来），以及它们的详细使用介绍。(通过点击主面板左上角的 Patch Library 打开)</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_2.png\" alt=\"2016101159731panel_2.png\"></p>\n<p><strong>参数区：</strong> 这里设置各个 Patch 需要的输入参数。(通过点击主面板工具栏上的 Parameters 打开)</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_3.png\" alt=\"2016101163517panel_3.png\"></p>\n<p><strong>Viewer：</strong> 显示窗口，这里可以对 Layer 做处理，也可以响应用户操作。比如鼠标点击，移动，滑动等。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/panel_4.png\" alt=\"2016101121147panel_4.png\"></p>\n<h3 id=\"2-_Filter_编辑_&amp;_放大眼睛实战\">2. Filter 编辑 &amp; 放大眼睛实战</h3><p>首先，点击 Patch Library，添加一个 Core Image Filter。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_1.png\" alt=\"2016101898471qc_demo_1.png\"></p>\n<p>选中这个 Filter，点击 Patch Inspector，选择 Settings，进入编辑页面。</p>\n<p>改成如下放大眼睛核心代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 coreImageKernel(sampler image, vec2 centerPostion, <span class=\"keyword\">float</span> radius, <span class=\"keyword\">float</span> scaleRatio, <span class=\"keyword\">float</span> aspectRatio)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvec2 currentPosition = destCoord();</span><br><span class=\"line\">\tvec2 positionToUse = currentPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">     vec2 currentPositionToUse = vec2(currentPosition.x, currentPosition.y * aspectRatio + <span class=\"number\">0.5</span> - <span class=\"number\">0.5</span> * aspectRatio);</span><br><span class=\"line\">     vec2 centerPostionToUse = vec2(centerPostion.x, centerPostion.y * aspectRatio + <span class=\"number\">0.5</span> - <span class=\"number\">0.5</span> * aspectRatio);</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">float</span> r = distance(currentPositionToUse, centerPostionToUse);</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">if</span>(r &lt; radius)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">float</span> alpha = <span class=\"number\">1.0</span> - scaleRatio * (r / radius - <span class=\"number\">1.0</span>)*( r / radius - <span class=\"number\">1.0</span>);</span><br><span class=\"line\">         positionToUse = centerPostion + alpha * (currentPosition - centerPostion);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> sample(image, samplerTransform(image, positionToUse));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">     \t<span class=\"keyword\">return</span> sample(image, samplerTransform(image, positionToUse));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_2.png\" alt=\"201610185070qc_demo_2.png\"></p>\n<blockquote>\n<p>PS：这里不再讲解这个眼睛放大 kernel 的实现原理。</p>\n<p>我强烈建议你在了解了前面的内容后，自己试着解读这个 kernel。</p>\n</blockquote>\n<p>另外，这里还有几个需要说明的地方。</p>\n<ul>\n<li>Define Outp Image Domain of Definition as Union of Input Sampler DODs：输入输出图片的 DOD 一致。</li>\n<li>Show Advanced Input Sampler Options：显示更多选项。</li>\n<li>Edit Filter Function：编辑 Filter 函数。</li>\n</ul>\n<p>一般选中第一项就好。 如果有特殊需求，需要自定义 DOD，ROI，则选择 <strong>Edit Filter Function</strong>，进入编辑模式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function __image main(__image image, __vec2 centerPostion, __number radius, __number scaleRatio, __number aspectRatio) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> coreImageKernel.apply(image.definition, null, image, centerPostion, radius, scaleRatio, aspectRatio);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以对默认的 function 进行编辑。在这个 Demo 里面我们不需要，感兴趣可以自己实践下，很简单。</p>\n<p>这个时候，主面板应该长这样：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_3.png\" alt=\"201610184625qc_demo_3.png\"></p>\n<p>然后拖拽一张图片到主面板中，把图片的 Output Image 与 Filter 的 Input Image 想连接。</p>\n<p>再从 Patch Library 中选择 Billboard。把 Filter 的 Output Image 与 Billboard 的 Input Image 相连接。</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/qc_demo_4.png\" alt=\"2016101846779qc_demo_4.png\"></p>\n<p>然后选中 Filter，打开 Parameters 面板，输入参数值，即可。</p>\n<p>当然，放大眼睛这里需要定位到眼睛的位置，是否可以通过鼠标操作来获取点呢？再或者，眼睛放大效果不够直观，有没有办法鼠标按下显示效果图，松开显示原图呢？在 QC 里头，这些都不是问题~不过工具类的使用，更多的还是得靠自己去摸索，这里不再累述。可以参考 EnlargeEyes.qtz 文件，了解更多的操作。</p>\n<p>最终的效果应该是这样的：</p>\n<p><img src=\"https://raw.githubusercontent.com/colin1994/colin1994.github.io/feature/hexo/BlogResources/CoreImage/enlargeEyes_demo.gif\" alt=\"201610184575enlargeEyes_demo.gif\"></p>\n<h2 id=\"总结\">总结</h2><p>至此，关于 Core Image 自定义 Filter 相关的内容，就已经都讲完了。这篇近万字的文章，花了很多功夫总结出来，希望，对你有所帮助！</p>\n<p>那么，打开脑洞，创造更有趣的 Filter 吧~</p>\n<p>Have fun~   </p>\n<p><strong>PS：源码下载地址：</strong> <a href=\"https://github.com/colin1994/CoreImageDemo\">CoreImageDemo</a></p>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397-CH1-SW1\">Core Image Kernel Language Reference</a></p>\n<p>Core Image Kernel Language 官方概述。</p>\n<p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingKernels/WritingKernels.html\">Writing Kernels</a></p>\n<p>官方教程。</p>\n<p><a href=\"http://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW4\">Kernel Routine Rules</a></p>\n<p>官方准则。</p>\n<p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW2\">Region-of-Interest Methods</a> </p>\n<p>ROI 教程。</p>\n<p><a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/QuartzComposerUserGuide/qc_intro/qc_intro.html#//apple_ref/doc/uid/TP40005381-CH201-TPXREF101\">Quartz Composer User Guide</a></p>\n<p>QC 官方指南。</p>"},{"title":"Core Image【3】—— 2017 新特性","date":"2019-12-22T14:31:29.000Z","_content":"\nCore Image 系列，目前的文章如下：\n\n- [Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)\n- [Core Image 之自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)\n- [Core Image【3】—— 2017 新特性](http://colin1994.github.io/2019/12/22/Core-Image-2017/)\n- [Core Image【4】—— 2018 新特性](http://colin1994.github.io/2019/12/22/Core-Image-2018/)\n\n\n\n> 如果想了解 Core Image 相关，建议按序阅读，前后有依赖。\n>\n> 对应源码，见最末链接。\n\n\n\n-----\n\n\n\n## 概述\n\n先回顾一下 Core Image 目前强大的功能。\n\n* A simple, high-performance API to apply filters to images，提供简单使用，性能优秀的 API，以及内置各种 CIFiter，方便处理图片\n* Automatically tiles if images are large or graph is complex，大图处理优化\n* Automatically tiles if only a region of the output is rendered，只处理部分区域\n* Each CIFilter has one or more CIKernel functions，自定义 CIFliter\n* Multiple CIKernels are concatenated to improve performance，滤镜链延迟处理，合并成一个\n\n<!--more-->\n\n\n\n这几点之前的文章都详细描述过了，这里不再说明。\n\n2017 年，额外引入了一些新的东西，具体如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/547604b69f745205bdbb6fac9b69d9b5.png)\n\n从三个方面讨论，**性能，调试信息，新功能。**\n\n**性能：**\n\n* 支持使用 **Metal** 直接自定义 CIKernel，提高效率\n* 引入 **CIRenderDestination**，更方便，性能更好的渲染到指定目的地\n\n\n\n**信息：**\n\n* **CIRenderInfo**，包含更多的信息\n* **Quick Looks**，支持 Core Image 多个对象直观调试\n\n\n\n**新功能：**\n\n* 更多内置滤镜\n* 条码扫描支持\n* 与不同框架的协同处理\n\n\n\n下面逐一展开说明。\n\n\n\n## 性能\n\n### Metal\n\n先回顾旧的 CIKernel 编写方式，之前的文章也提到过，Core Image 支持自定义 CIFilter，它们的脚本是通过  CIKernel Language 编写的， CIKernel Language 又基于 GLSL。\n\n所以，当我们运行 App 时候，要用到这个 Filter，那么**系统会自动帮我们把对应的 kernel，翻译成 GLSL 或者 Metal 规范的 kernel。然后再编译得到的 kernel。**\n\n所以之前的方式，存在两个问题：\n\n* 编写 kernel 的时候，没有报错提示，哪怕是参数名错误都无法检查处理。效率极低。\n* 翻译转换，编译，都是发生到运行时，导致第一次使用滤镜的时候，耗时较久。\n\n关于耗时这点，具体如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4c9049f837033a13d1c19d1c0ec46b9d.png)\n\n这里的各个阶段分别指：\n\n* Translate CIKernels，转换 kernel，转成其他格式的。\n* Concatenate CIKernels，按序连接 kernel，滤镜链里头提到过\n* Compile CIKernels to Intermediate Representation，编译 CIKernel，这里的 IR（中间代码）我们无需关心，也干预不到\n* Compile to GPU Code，将 IR 转成 GPU 识别的代码\n* Render，在 GPU 上渲染\n\n在旧的模式里面，这五步都是**发生在运行时，且无法避免。**\n\nCIKernel 编译后会有缓存机制，所以耗时**第一次**较为明显。\n\n这就导致了一个问题，你可能只需要渲染一次，显示带效果的图片。但是哪怕你的图片很小，也需要相当久的等待，因为需要对 CIKernel 进行转换编译。\n\n进一步拆分，必须发生在运行时的，包含 Concatenate CIKernels，Compile to GPU Code 以及 Render，因为拼接滤镜可能是动态的，没法一开始就确定下来。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/61bece6e8c6e2ff8abde6b918bcab3de.png)\n\n而占大头的前两部，并不是一定需要在运行时才能处理的。Metal 恰恰能解决。\n\n**将 Kernel 的编译时间，提前到 App 编译阶段，并且有语法错误检查，大大提高效率。**\n\n![](https://diycode.b0.upaiyun.com/photo/2018/64e16a386430674c36282b962f4f84d9.png)\n\n\n\n那么，具体怎么用 Metal 编写 CIKernel 呢，对比旧的流程，有什么差异呢？下面举个实际例子。将上一篇文章里面实现的 Vignette， 改用 Metal 处理，便于参照。\n\n#### Write CIKernel in Metal shader file\n\nCIKL（CIKernel Language） 和 Metal 本质上是很相似的，基础语法都是一样的。\n\n>  关于语法类的东西，这里不细说，具体可以参照官方说明来。[MetalCIKLReference](https://developer.apple.com/metal/MetalCIKLReference6.pdf)\n\n这里提一点。CIKL 之前为了特性，扩展的那些支持， Metal 也同样支持。具体的转换规则如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/b14ddca70a1f0d21599d446b3cc2cb66.png)\n\n所以不同类型的 CIKernel，它们的简单转换应该是这样：\n\n**CIWarpKernel**：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/219136a92e6178a42efee4f5ed1540db.png)\n\n**CIColorKernel**：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ad595836500bc951221950c96eac6658.png)\n\n**CIKernel**:\n![](https://diycode.b0.upaiyun.com/photo/2018/428c5a2dd1e6b0e339d1f5d4bab81f2b.png)\n\n\n\n基本上，差异都体现在额外扩展的这些内容。实际的算法编写，基本不变。\n\n我们以之前实现的 **vignetteKernel** 为例，**Vignette.cikernel** 白板代码如下：\n\n\n```\nkernel vec4 vignetteKernel(__sample image, vec2 center, float radius, float alpha)\n{\n\t// 计算出当前点与中心的距离\n\tfloat distance = distance(destCoord(), center) ;\n\t// 根据距离计算出暗淡程度\n\tfloat darken = 1.0 - (distance / radius * alpha);\n\t// 返回该像素点最终的色值\n\timage.rgb *= darken;\n\treturn image.rgba;\n}\n```\n\n转换成 **Metal** 应该是：**Vignette.metal** ：\n\n\n```c++\n#include <metal_stdlib>\nusing namespace metal;\n\n#include <CoreImage/CoreImage.h> // includes CIKernelMetalLib.h\n\nextern \"C\" { namespace coreimage {\n    float4 vignetteMetal(sample_t image, float2 center, float radius, float alpha, destination dest) {\n        // 计算出当前点与中心的距离\n        float distance2 = distance(dest.coord(), center);\n        \n        // 根据距离计算出暗淡程度\n        float darken = 1.0 - (distance2 / radius * alpha);\n        // 返回该像素点最终的色值\n        image.rgb *= darken;\n        \n        return image.rgba;\n    }\n}}\n```\n\n这里有几个改变点逐一说下：\n\n```c++\n#include <metal_stdlib>\nusing namespace metal;\n\n#include <CoreImage/CoreImage.h> // includes CIKernelMetalLib.h\n\nextern \"C\" { namespace coreimage {\n}}\n```\n\n这里需要引入对应的库，以及命名空间。因为系统内部的实现大致是这样的：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/bb35482a6bbb737966125cc5954a1274.png)\n\n这基本是固定的格式，保持就好。\n\n然后就是特定的修改：\n\n* __sample —> sample_t\n* vec2 — > float2\n* destCoord() —> dest.coord()\n* vec4 —> float4\n\n这里注意，Metal 不支持 vec 类型，参数类型都需要转成浮点值类型。\n\n\n\n另外，入参这里，多了一个 **destination dest**，这个对应 CIColorKernel 是可选的，因为并不一定要获取当前的坐标，正常像素值就够了。\n\n如果要带的话，**它是隐式的，必须放在参数列表最后一个**，无须我们传参，系统自动赋值。这点需要额外注意！\n\n\n\n至此，shader 的编写就结束了，也是很好理解。\n\n\n\n#### Compile and link Metal shader file\n\n至于编译，Xcode 默认是不会帮我们编译 CIKernel 对应的 Metal 文件，需要我们显示的去设置。\n\n具体步骤如下：\n\nBuild Settings 里头找到 **Other Metal Compiler Flags**，添加值：**-fcikernel**\n\n![](https://diycode.b0.upaiyun.com/photo/2018/108c5682c22cd84683182397b8b1220f.png)\n\n然后新增一个自定义配置\n\n![](https://diycode.b0.upaiyun.com/photo/2018/e1f7404335c1db1336c95ae8851ab108.png)\n\n\n对应的 Key 为： **MTLLINKER_FLAGS**，value 为：**-cikernel**\n\n![](https://diycode.b0.upaiyun.com/photo/2018/aa1398fedeb1cb4c3d1953e92bc18a7c.png)\n\n\n\n> PS：\n>\n> 如果没添加对应的编译选项，下一步初始化 CIKernel 的时候，会失败。\n\n\n\n#### Initialize CIKernel\n\n这里同样对比旧的创建方式，\n\n```objc\nNSBundle *bundle = [NSBundle bundleForClass: [self class]];\nNSURL *kernelURL = [bundle URLForResource:@\"Vignette\" withExtension:@\"cikernel\"];\n\nNSError *error;\nNSString *kernelCode = [NSString stringWithContentsOfURL:kernelURL\n                                                encoding:NSUTF8StringEncoding\n                                                   error:&error];\nNSArray *kernels = [CIColorKernel kernelsWithString:kernelCode];\ncustomKernel = [kernels objectAtIndex:0];\n```\n\n只需要改为：\n\n```objc\nNSURL *kernelURL = [[NSBundle mainBundle] URLForResource:@\"default\" withExtension:@\"metallib\"];\nNSError *error;\nNSData *data = [NSData dataWithContentsOfURL:kernelURL];\ncustomKernel = [CIColorKernel kernelWithFunctionName:@\"vignetteMetal\"\n                                fromMetalLibraryData:data\n                                               error:&error];\n```\n\n初始化方法不一样，在使用上是一致的。\n\n\n至此，通过 Metal 自定义 CIFilter 的流程，已经全部走通了。对旧有的修改很小。\n这里额外提一点，UIImageView 针对 CIImage 有做优化，如果一个 UIImage 是通过 UIImage.init(ciImage:) 这种方式创建的，\n\n**设置到 UIImageView 上的时候，UIImageView 会在 GPU 上执行 Core Image 相关操作。GPU 处理很高效，并且能释放 CPU 压力。**\n\n所以，实时调整 Filter 的时候，也可以借助 UIImageView 来直接显示，效率很高：\n\n```objc\n@interface MetalKernelViewController ()\n\n@property (strong, nonatomic) MetalKernelFilter *vignetteFilter;\n@property (strong, nonatomic) CIImage *inputImage;\n@property (strong, nonatomic) IBOutlet UIImageView *imageView;\n\n@end\n\n@implementation MetalKernelViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    \n    // 初始化 Filter\n    self.vignetteFilter = [[MetalKernelFilter alloc] init];\n    NSURL *imageURL = [[NSBundle mainBundle] URLForResource:@\"vignetteImage\" withExtension:@\"jpg\"];\n    self.inputImage = [CIImage imageWithContentsOfURL:imageURL];\n    [self.vignetteFilter setValue:_inputImage forKey:@\"inputImage\"];\n    \n    self.imageView.image = [UIImage imageWithCIImage:self.inputImage];\n    \n}\n\n#pragma mark - Action\n- (IBAction)alphaChanged:(UISlider *)sender {\n    [self.vignetteFilter setValue:@(sender.value) forKey:@\"inputAlpha\"];\n    CIImage *result = _vignetteFilter.outputImage;\n    self.imageView.image = [UIImage imageWithCIImage:result];\n}\n\n@end\n```\n\n\n\n### CIRenderDestination\n\n这是一个新增的 API，iOS 11 之后支持，方便渲染到指定的目的地。\n\n目前支持：\n\n* IOSurface\n* CVPixelBuffer\n* Metal Texture\n* OpenGL Texture\n* Memory buffer\n\n基本涵盖了所有我们需要用来显示的对象。\n\n比如：\n\n```objc\n- (instancetype) initWithMTLTexture:(id<MTLTexture>)texture\n                      commandBuffer:(nullable id<MTLCommandBuffer>)commandBuffer;\n```\n\n当我们需要执行渲染的时候，就可以使用：\n\n```objc\n- (nullable CIRenderTask*) startTaskToRender:(CIImage*)image\n                               toDestination:(CIRenderDestination*)destination\n                                       error:(NSError**)error NS_AVAILABLE(10_13, 11_0);\n```\n\n\n\n当然，你可能有发现，旧的 API 也是支持渲染到指定目的地的，比如：\n\n```objc\n- (void)render:(CIImage *)image \ntoCVPixelBuffer:(CVPixelBufferRef)buffer NS_AVAILABLE(10_11,5_0);\n```\n\n那么，新的 API 有什么优势呢？我具体罗列了以下几点：\n\n* 如果渲染失败，会立即返回错误信息，便于排查问题，旧的是不支持。\n* 另外，渲染时，可以额外指定结果的一些属性，比如是否翻转，颜色空间，alpha 混合模式等。不需要额外的操作，性能高。\n* 另外，支持这些属性后，不需要额外创建多个 CIContext。之前处理的话，有的属性和具体的 CIContext 关联，导致配置不同参数的时候，需要依赖多个。现在只要一个就可以了。\n* 性能更好，速度快。旧的 API，需要等到所有提交到 GPU 的渲染命令，执行完毕后，才执行新的渲染操作。新的 API，当 CPU 提交完所有命令到 GPU 后，就可以开始执行新的，不需要等到 GPU 处理完。CPU 和 GPU 之间的协同工作更加高效。\n\n\n\n> They used to return after all the render on the GPU is completed.\n>\n> But now with this new API, it will return as soon as the CPU has finished issuing all the work for the GPU.\n>\n> And without having to wait for the GPU work to finish.\n>\n> So we think this new flexibility will now allow you to pipeline all your CPU and GPU work much more efficiently.\n\n\n\n额外支持的属性：\n\n```objc\n@property CIRenderDestinationAlphaMode alphaMode;\n@property (getter=isFlipped) BOOL flipped;\n@property (getter=isDithered) BOOL dithered;\n@property (getter=isClamped) BOOL clamped;\n@property (nullable, nonatomic) CGColorSpaceRef colorSpace;\n@property (nullable, nonatomic, retain) CIBlendKernel* blendKernel;\n@property BOOL blendsInDestinationColorSpace;\n```\n\n\n\n## 调试信息\n\n这里主要包含两点：\n\n* CIRenderInfo\n* Quick Look\n\n\n\n### CIRenderInfo\n\nCIRenderInfo 是新增的对象，它里面包含了一些有用的信息，比如 kernel 执行耗时，当前有多少数量的像素参与处理等。\n\n```objc\n// An Xcode quicklook of this object will show a graph visualization of the render\n// with detailed timing information.\nNS_CLASS_AVAILABLE(10_13, 11_0)\n@interface CIRenderInfo : NSObject\n{\n    void *_priv;\n}\n\n// This property will return how much time a render spent executing kernels.\n@property (readonly) NSTimeInterval kernelExecutionTime;\n\n// This property will return how many passes the render requires.\n// If passCount is 1 than the render can be fully concatinated and no\n// intermediate buffers will be required.\n@property (readonly) NSInteger passCount;\n\n// This property will return how many pixels a render produced executing kernels.\n@property (readonly) NSInteger pixelsProcessed;\n\n@end\n```\n\n\n\n### Quick Look\n\nCore Image 对很对对象新增了 Quick Look 支持，方便调试查看效果。\n\n关于调试信息这点，前两篇文章其实有提到其他方式，只是都没有 Quick Look 来得方便。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/499151a6af87609acc2b3c0e0dcc4cc7.png)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ad284913cfc4298cef07170e06696f27.png)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/c64ba6e368ae6dd96cf8d80d7bb44dd2.png)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/0cb9e4a8b7547a643a9733b8ecd78b07.png)\n\n图表都支持放大查阅，具体的大家可以实际查阅。信息还是很有用的，包含多个滤镜是怎么组合的等等细节。\n\n\n## 新功能\n\n\n\n### New Filter\n\n现在内置了 196 个 filters\n\n![](https://diycode.b0.upaiyun.com/photo/2018/1af5a34340e9d232a99d2683bc395228.png)\n\n内置的滤镜，有新增，也有性能优化。这里不展开讲。\n\n一般都是用到的时候，去查找是否有合适的内置滤镜，而不是一开始就把这近 200 个滤镜都掌握下来。\n\n具体的可以查阅： [Core Image Filter Reference](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346) \n\n\n\n\n\n### CIBarcodeDescriptor\n\nApp 现在支持各种各样的条码扫描，识别。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/84253106453689f22287df902bd16c1a.png)\n\n并且，各个不同的框架，通过新引入的 CIBarcodeDescriptor，能够协调工作。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ac17593c23d689cebb269dfb217f171b.png)\n\n这里，可以通过 AVFoundation 框架，实时获取图像，并检测识别得到 CIBarcodeDescriptor 对象。\n\n```swift\n// Get a CIBarcodeDescriptor from AVFoundation.framework\nclass MyMetadataOutputObjectsDelegate: NSObject, AVCaptureMetadataOutputObjectsDelegate\n{\n    func metadataOutput(_ output: AVCaptureMetadataOutput,\n                        didOutput metadataObjects: [AVMetadataObject],\n                        from connection: AVCaptureConnection) {\n        if let mrc = metadataObjects.first as? AVMetadataMachineReadableCodeObject,\n          let descriptor = mrc.descriptor {\n              print(descriptor)\n        }\n    }\n}\n```\n\n\n\n当然，对于静态图片，或者录制好的视频文件，也可以通过 Vision 框架检测识别得到 CIBarcodeDescriptor 对象。\n\n```swift\n// Detect a CIBarcodeDescriptor using Vision.framework\nfunc descriptorFromImage(_ image: CIImage) -> CIBarcodeDescriptor?\n{\n    // Create the request and request handler\n    let requestHandler = VNImageRequestHandler(ciImage: image, options: [:])\n    let request = VNDetectBarcodesRequest();\n\n    // Send the request to the handler\n    try? requestHandler.perform([request])\n\n    // Get the observation\n    let firstResult = request.results?.first \n    return firstResult?.barcodeDescriptor\n}\n```\n\n\n\n而获取到的 CIBarcodeDescriptor，则可以通过 Core Image 进行渲染，得到对应的条码图像。\n\n```swift\n// Create an image for a CIBarcodeDescriptor using CoreImage.framework\nfunc imageFromBarcodeCodeDescriptor(_ descriptor: CIBarcodeDescriptor) -> CIImage? \n{\n    return CIFilter(name: \"CIBarcodeGenerator\", \n                    withInputParameters: [\"inputBarcodeDescriptor\" : descriptor])\n                      ?.outputImage \n}\n```\n\n> PS：\n>\n> 另外，CIBarcodeDescriptor 提供了许多有用的属性，比如 errorCorrectedPayload，maskPattern 等，便于获取条码的各种信息。\n\n\n\n通过这几个框架的无缝结合，可以做一些有趣的事情。\n\n官方展示了这么一个 Demo，它可以从视频帧中，提取出条码，然后重新渲染到条码上，加上红色遮罩，突出效果。这里有两点很惊艳。\n\n* 识别到的条码已经重新渲染的位置都很准确。\n* 注意看手指遮挡的部分，也能渲染出来。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4f367603d32d8707f1f2e2a84a92c5fe.png)\n\n\n\n### Using Core Image with Vision\n\n这个部分，有种捆绑销售的感觉～强行推一波新加入的 Vision。\n\n我们知道 Core Image 可以对图像进行处理，比如裁剪，旋转，灰度等等。\n\n而 Apple 新推出的 Vision 框架，在分析图像方面十分擅长，能提取出很多有用的信息。\n\n所以它们配合在一起能做一些很棒的事情，比如这里介绍了一个，从一组图片中，生成一张不包含某个对象的图片。\n\n> Photo from Video with Removal of Unwanted Objects\n\n具体如下图所示：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/97e8a5bdbe9caac2c1c6b7230e463ccc.png)\n\n\n\n从五张同个场景的图片，通过 Vision 和 Core Image 结合，实现去除图片上移动的人物。\n\n实现这个功能的具体步骤如下：\n\n从视频中提取序列帧。这里简单的使用 AVFoundation 就能实现，我们可以得到几个对应的 CIImage。\n\n图像对齐校正。提取出来的几张图片，可能因为拍摄设备的抖动，导致画面并不是完全一致，这时候就需要后期的调整。Vision 为我们提供了一个类 VNHomographicImageRegistrationRequest，专门用来做图像配准的。通过对比两张图片，能得到一个“对齐矩阵”，这样一张图片就能向另一张图片对齐。\n\n> An image analysis request that determines the perspective warp matrix needed to align the content of two images.\n>\n> Create and perform a homographic image registration request to align content in two images through a homography. A homography is an isomorphism of projected spaces, a bijection that maps lines to lines.\n\n具体代码如下：\n\n```swift\nfunc homographicTransform(from image: CIImage, to reference: CIImage) -> matrix_float3x3? {\n  // Create the request and request handler\n  let request = VNHomographicImageRegistrationRequest(targetedCIImage: image); \n  let requestHandler = VNImageRequestHandler(ciImage: reference, options: [:]);\n\n  // Send the request to the handler\n  try? requestHandler.perform([request]);\n\n  // Get the observation\n  guard let results = request.results,\n        let observation = results.first as? VNImageHomographicAlignmentObservation\n  else {\n      return nil\n  } \n  return observation.warpTransform\n}\n```\n\n得到的矩阵，再传入 CIFilter 中，做对齐，对应的 kernel 脚本如下 ：\n\n```c++\n// Core Image Metal kernel to apply a homography matrix\nfloat2 warpHomography(float3x3 h, destination dest) \n{\n  \tfloat3 homogeneousDestCoord = float3(dest.coord(), 1.0);\n  \tfloat3 homogeneousSrcCoord = h * homogeneousDestCoord;\n  \tfloat2 srcCoord = homogeneousSrcCoord.xy / max(homogeneousSrcCoord.z, 0.000001);\n  \treturn srcCoord; \n}\n```\n\n经过这个操作后，得到的 5 张图片，都是对齐过的，场景都是一致的。\n\n但是画面上，人物的位置是不均匀分布的，所以要使用中位算法，取出最终的画面。\n\n也就是每个像素点，都是5个图片一起分析，取出相同占比最高的那个像素值，结合成一个新的画面，就能剔除额外的人物。具体脚本如下：\n\n```swift\n// Core Image Metal kernel to return the median of 5 images\ninline void swap(thread float4 &a, thread float4 &b) \n{\n\tfloat4 tmp = a; a = min(a,b); b = max(tmp, b); // swap sort of two elements \n}\n\nfloat4 medianReduction5(sample_t v0, sample_t v1, sample_t v2, sample_t v3, sample_t v4) \n{\n\t// using a Bose-Nelson sorting network\n\tswap(v0, v1); swap(v3, v4); swap(v2, v4); swap(v2, v3); swap(v0, v3); swap(v0, v2); \tswap(v1, v4); swap(v1, v3); swap(v1, v2); \n\treturn v2;\n}\n```\n\n\n\n## 延伸阅读\n\n\n\n[Advances in Core Image: Filters, Metal, Vision, and More](https://developer.apple.com/videos/play/wwdc2017/510/)\n\n","source":"_posts/Core-Image-2017.md","raw":"title: Core Image【3】—— 2017 新特性\ndate: 2019-12-22 22:31:29\n\ntags:\n\n- Core Image\n\n------\n\nCore Image 系列，目前的文章如下：\n\n- [Core Image 你需要了解的那些事~](http://colin1994.github.io/2016/10/21/Core-Image-OverView/)\n- [Core Image 之自定义 Filter~](http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/)\n- [Core Image【3】—— 2017 新特性](http://colin1994.github.io/2019/12/22/Core-Image-2017/)\n- [Core Image【4】—— 2018 新特性](http://colin1994.github.io/2019/12/22/Core-Image-2018/)\n\n\n\n> 如果想了解 Core Image 相关，建议按序阅读，前后有依赖。\n>\n> 对应源码，见最末链接。\n\n\n\n-----\n\n\n\n## 概述\n\n先回顾一下 Core Image 目前强大的功能。\n\n* A simple, high-performance API to apply filters to images，提供简单使用，性能优秀的 API，以及内置各种 CIFiter，方便处理图片\n* Automatically tiles if images are large or graph is complex，大图处理优化\n* Automatically tiles if only a region of the output is rendered，只处理部分区域\n* Each CIFilter has one or more CIKernel functions，自定义 CIFliter\n* Multiple CIKernels are concatenated to improve performance，滤镜链延迟处理，合并成一个\n\n<!--more-->\n\n\n\n这几点之前的文章都详细描述过了，这里不再说明。\n\n2017 年，额外引入了一些新的东西，具体如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/547604b69f745205bdbb6fac9b69d9b5.png)\n\n从三个方面讨论，**性能，调试信息，新功能。**\n\n**性能：**\n\n* 支持使用 **Metal** 直接自定义 CIKernel，提高效率\n* 引入 **CIRenderDestination**，更方便，性能更好的渲染到指定目的地\n\n\n\n**信息：**\n\n* **CIRenderInfo**，包含更多的信息\n* **Quick Looks**，支持 Core Image 多个对象直观调试\n\n\n\n**新功能：**\n\n* 更多内置滤镜\n* 条码扫描支持\n* 与不同框架的协同处理\n\n\n\n下面逐一展开说明。\n\n\n\n## 性能\n\n### Metal\n\n先回顾旧的 CIKernel 编写方式，之前的文章也提到过，Core Image 支持自定义 CIFilter，它们的脚本是通过  CIKernel Language 编写的， CIKernel Language 又基于 GLSL。\n\n所以，当我们运行 App 时候，要用到这个 Filter，那么**系统会自动帮我们把对应的 kernel，翻译成 GLSL 或者 Metal 规范的 kernel。然后再编译得到的 kernel。**\n\n所以之前的方式，存在两个问题：\n\n* 编写 kernel 的时候，没有报错提示，哪怕是参数名错误都无法检查处理。效率极低。\n* 翻译转换，编译，都是发生到运行时，导致第一次使用滤镜的时候，耗时较久。\n\n关于耗时这点，具体如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4c9049f837033a13d1c19d1c0ec46b9d.png)\n\n这里的各个阶段分别指：\n\n* Translate CIKernels，转换 kernel，转成其他格式的。\n* Concatenate CIKernels，按序连接 kernel，滤镜链里头提到过\n* Compile CIKernels to Intermediate Representation，编译 CIKernel，这里的 IR（中间代码）我们无需关心，也干预不到\n* Compile to GPU Code，将 IR 转成 GPU 识别的代码\n* Render，在 GPU 上渲染\n\n在旧的模式里面，这五步都是**发生在运行时，且无法避免。**\n\nCIKernel 编译后会有缓存机制，所以耗时**第一次**较为明显。\n\n这就导致了一个问题，你可能只需要渲染一次，显示带效果的图片。但是哪怕你的图片很小，也需要相当久的等待，因为需要对 CIKernel 进行转换编译。\n\n进一步拆分，必须发生在运行时的，包含 Concatenate CIKernels，Compile to GPU Code 以及 Render，因为拼接滤镜可能是动态的，没法一开始就确定下来。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/61bece6e8c6e2ff8abde6b918bcab3de.png)\n\n而占大头的前两部，并不是一定需要在运行时才能处理的。Metal 恰恰能解决。\n\n**将 Kernel 的编译时间，提前到 App 编译阶段，并且有语法错误检查，大大提高效率。**\n\n![](https://diycode.b0.upaiyun.com/photo/2018/64e16a386430674c36282b962f4f84d9.png)\n\n\n\n那么，具体怎么用 Metal 编写 CIKernel 呢，对比旧的流程，有什么差异呢？下面举个实际例子。将上一篇文章里面实现的 Vignette， 改用 Metal 处理，便于参照。\n\n#### Write CIKernel in Metal shader file\n\nCIKL（CIKernel Language） 和 Metal 本质上是很相似的，基础语法都是一样的。\n\n>  关于语法类的东西，这里不细说，具体可以参照官方说明来。[MetalCIKLReference](https://developer.apple.com/metal/MetalCIKLReference6.pdf)\n\n这里提一点。CIKL 之前为了特性，扩展的那些支持， Metal 也同样支持。具体的转换规则如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/b14ddca70a1f0d21599d446b3cc2cb66.png)\n\n所以不同类型的 CIKernel，它们的简单转换应该是这样：\n\n**CIWarpKernel**：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/219136a92e6178a42efee4f5ed1540db.png)\n\n**CIColorKernel**：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ad595836500bc951221950c96eac6658.png)\n\n**CIKernel**:\n![](https://diycode.b0.upaiyun.com/photo/2018/428c5a2dd1e6b0e339d1f5d4bab81f2b.png)\n\n\n\n基本上，差异都体现在额外扩展的这些内容。实际的算法编写，基本不变。\n\n我们以之前实现的 **vignetteKernel** 为例，**Vignette.cikernel** 白板代码如下：\n\n\n```\nkernel vec4 vignetteKernel(__sample image, vec2 center, float radius, float alpha)\n{\n\t// 计算出当前点与中心的距离\n\tfloat distance = distance(destCoord(), center) ;\n\t// 根据距离计算出暗淡程度\n\tfloat darken = 1.0 - (distance / radius * alpha);\n\t// 返回该像素点最终的色值\n\timage.rgb *= darken;\n\treturn image.rgba;\n}\n```\n\n转换成 **Metal** 应该是：**Vignette.metal** ：\n\n\n```c++\n#include <metal_stdlib>\nusing namespace metal;\n\n#include <CoreImage/CoreImage.h> // includes CIKernelMetalLib.h\n\nextern \"C\" { namespace coreimage {\n    float4 vignetteMetal(sample_t image, float2 center, float radius, float alpha, destination dest) {\n        // 计算出当前点与中心的距离\n        float distance2 = distance(dest.coord(), center);\n        \n        // 根据距离计算出暗淡程度\n        float darken = 1.0 - (distance2 / radius * alpha);\n        // 返回该像素点最终的色值\n        image.rgb *= darken;\n        \n        return image.rgba;\n    }\n}}\n```\n\n这里有几个改变点逐一说下：\n\n```c++\n#include <metal_stdlib>\nusing namespace metal;\n\n#include <CoreImage/CoreImage.h> // includes CIKernelMetalLib.h\n\nextern \"C\" { namespace coreimage {\n}}\n```\n\n这里需要引入对应的库，以及命名空间。因为系统内部的实现大致是这样的：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/bb35482a6bbb737966125cc5954a1274.png)\n\n这基本是固定的格式，保持就好。\n\n然后就是特定的修改：\n\n* __sample —> sample_t\n* vec2 — > float2\n* destCoord() —> dest.coord()\n* vec4 —> float4\n\n这里注意，Metal 不支持 vec 类型，参数类型都需要转成浮点值类型。\n\n\n\n另外，入参这里，多了一个 **destination dest**，这个对应 CIColorKernel 是可选的，因为并不一定要获取当前的坐标，正常像素值就够了。\n\n如果要带的话，**它是隐式的，必须放在参数列表最后一个**，无须我们传参，系统自动赋值。这点需要额外注意！\n\n\n\n至此，shader 的编写就结束了，也是很好理解。\n\n\n\n#### Compile and link Metal shader file\n\n至于编译，Xcode 默认是不会帮我们编译 CIKernel 对应的 Metal 文件，需要我们显示的去设置。\n\n具体步骤如下：\n\nBuild Settings 里头找到 **Other Metal Compiler Flags**，添加值：**-fcikernel**\n\n![](https://diycode.b0.upaiyun.com/photo/2018/108c5682c22cd84683182397b8b1220f.png)\n\n然后新增一个自定义配置\n\n![](https://diycode.b0.upaiyun.com/photo/2018/e1f7404335c1db1336c95ae8851ab108.png)\n\n\n对应的 Key 为： **MTLLINKER_FLAGS**，value 为：**-cikernel**\n\n![](https://diycode.b0.upaiyun.com/photo/2018/aa1398fedeb1cb4c3d1953e92bc18a7c.png)\n\n\n\n> PS：\n>\n> 如果没添加对应的编译选项，下一步初始化 CIKernel 的时候，会失败。\n\n\n\n#### Initialize CIKernel\n\n这里同样对比旧的创建方式，\n\n```objc\nNSBundle *bundle = [NSBundle bundleForClass: [self class]];\nNSURL *kernelURL = [bundle URLForResource:@\"Vignette\" withExtension:@\"cikernel\"];\n\nNSError *error;\nNSString *kernelCode = [NSString stringWithContentsOfURL:kernelURL\n                                                encoding:NSUTF8StringEncoding\n                                                   error:&error];\nNSArray *kernels = [CIColorKernel kernelsWithString:kernelCode];\ncustomKernel = [kernels objectAtIndex:0];\n```\n\n只需要改为：\n\n```objc\nNSURL *kernelURL = [[NSBundle mainBundle] URLForResource:@\"default\" withExtension:@\"metallib\"];\nNSError *error;\nNSData *data = [NSData dataWithContentsOfURL:kernelURL];\ncustomKernel = [CIColorKernel kernelWithFunctionName:@\"vignetteMetal\"\n                                fromMetalLibraryData:data\n                                               error:&error];\n```\n\n初始化方法不一样，在使用上是一致的。\n\n\n至此，通过 Metal 自定义 CIFilter 的流程，已经全部走通了。对旧有的修改很小。\n这里额外提一点，UIImageView 针对 CIImage 有做优化，如果一个 UIImage 是通过 UIImage.init(ciImage:) 这种方式创建的，\n\n**设置到 UIImageView 上的时候，UIImageView 会在 GPU 上执行 Core Image 相关操作。GPU 处理很高效，并且能释放 CPU 压力。**\n\n所以，实时调整 Filter 的时候，也可以借助 UIImageView 来直接显示，效率很高：\n\n```objc\n@interface MetalKernelViewController ()\n\n@property (strong, nonatomic) MetalKernelFilter *vignetteFilter;\n@property (strong, nonatomic) CIImage *inputImage;\n@property (strong, nonatomic) IBOutlet UIImageView *imageView;\n\n@end\n\n@implementation MetalKernelViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    \n    // 初始化 Filter\n    self.vignetteFilter = [[MetalKernelFilter alloc] init];\n    NSURL *imageURL = [[NSBundle mainBundle] URLForResource:@\"vignetteImage\" withExtension:@\"jpg\"];\n    self.inputImage = [CIImage imageWithContentsOfURL:imageURL];\n    [self.vignetteFilter setValue:_inputImage forKey:@\"inputImage\"];\n    \n    self.imageView.image = [UIImage imageWithCIImage:self.inputImage];\n    \n}\n\n#pragma mark - Action\n- (IBAction)alphaChanged:(UISlider *)sender {\n    [self.vignetteFilter setValue:@(sender.value) forKey:@\"inputAlpha\"];\n    CIImage *result = _vignetteFilter.outputImage;\n    self.imageView.image = [UIImage imageWithCIImage:result];\n}\n\n@end\n```\n\n\n\n### CIRenderDestination\n\n这是一个新增的 API，iOS 11 之后支持，方便渲染到指定的目的地。\n\n目前支持：\n\n* IOSurface\n* CVPixelBuffer\n* Metal Texture\n* OpenGL Texture\n* Memory buffer\n\n基本涵盖了所有我们需要用来显示的对象。\n\n比如：\n\n```objc\n- (instancetype) initWithMTLTexture:(id<MTLTexture>)texture\n                      commandBuffer:(nullable id<MTLCommandBuffer>)commandBuffer;\n```\n\n当我们需要执行渲染的时候，就可以使用：\n\n```objc\n- (nullable CIRenderTask*) startTaskToRender:(CIImage*)image\n                               toDestination:(CIRenderDestination*)destination\n                                       error:(NSError**)error NS_AVAILABLE(10_13, 11_0);\n```\n\n\n\n当然，你可能有发现，旧的 API 也是支持渲染到指定目的地的，比如：\n\n```objc\n- (void)render:(CIImage *)image \ntoCVPixelBuffer:(CVPixelBufferRef)buffer NS_AVAILABLE(10_11,5_0);\n```\n\n那么，新的 API 有什么优势呢？我具体罗列了以下几点：\n\n* 如果渲染失败，会立即返回错误信息，便于排查问题，旧的是不支持。\n* 另外，渲染时，可以额外指定结果的一些属性，比如是否翻转，颜色空间，alpha 混合模式等。不需要额外的操作，性能高。\n* 另外，支持这些属性后，不需要额外创建多个 CIContext。之前处理的话，有的属性和具体的 CIContext 关联，导致配置不同参数的时候，需要依赖多个。现在只要一个就可以了。\n* 性能更好，速度快。旧的 API，需要等到所有提交到 GPU 的渲染命令，执行完毕后，才执行新的渲染操作。新的 API，当 CPU 提交完所有命令到 GPU 后，就可以开始执行新的，不需要等到 GPU 处理完。CPU 和 GPU 之间的协同工作更加高效。\n\n\n\n> They used to return after all the render on the GPU is completed.\n>\n> But now with this new API, it will return as soon as the CPU has finished issuing all the work for the GPU.\n>\n> And without having to wait for the GPU work to finish.\n>\n> So we think this new flexibility will now allow you to pipeline all your CPU and GPU work much more efficiently.\n\n\n\n额外支持的属性：\n\n```objc\n@property CIRenderDestinationAlphaMode alphaMode;\n@property (getter=isFlipped) BOOL flipped;\n@property (getter=isDithered) BOOL dithered;\n@property (getter=isClamped) BOOL clamped;\n@property (nullable, nonatomic) CGColorSpaceRef colorSpace;\n@property (nullable, nonatomic, retain) CIBlendKernel* blendKernel;\n@property BOOL blendsInDestinationColorSpace;\n```\n\n\n\n## 调试信息\n\n这里主要包含两点：\n\n* CIRenderInfo\n* Quick Look\n\n\n\n### CIRenderInfo\n\nCIRenderInfo 是新增的对象，它里面包含了一些有用的信息，比如 kernel 执行耗时，当前有多少数量的像素参与处理等。\n\n```objc\n// An Xcode quicklook of this object will show a graph visualization of the render\n// with detailed timing information.\nNS_CLASS_AVAILABLE(10_13, 11_0)\n@interface CIRenderInfo : NSObject\n{\n    void *_priv;\n}\n\n// This property will return how much time a render spent executing kernels.\n@property (readonly) NSTimeInterval kernelExecutionTime;\n\n// This property will return how many passes the render requires.\n// If passCount is 1 than the render can be fully concatinated and no\n// intermediate buffers will be required.\n@property (readonly) NSInteger passCount;\n\n// This property will return how many pixels a render produced executing kernels.\n@property (readonly) NSInteger pixelsProcessed;\n\n@end\n```\n\n\n\n### Quick Look\n\nCore Image 对很对对象新增了 Quick Look 支持，方便调试查看效果。\n\n关于调试信息这点，前两篇文章其实有提到其他方式，只是都没有 Quick Look 来得方便。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/499151a6af87609acc2b3c0e0dcc4cc7.png)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ad284913cfc4298cef07170e06696f27.png)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/c64ba6e368ae6dd96cf8d80d7bb44dd2.png)\n\n![](https://diycode.b0.upaiyun.com/photo/2018/0cb9e4a8b7547a643a9733b8ecd78b07.png)\n\n图表都支持放大查阅，具体的大家可以实际查阅。信息还是很有用的，包含多个滤镜是怎么组合的等等细节。\n\n\n## 新功能\n\n\n\n### New Filter\n\n现在内置了 196 个 filters\n\n![](https://diycode.b0.upaiyun.com/photo/2018/1af5a34340e9d232a99d2683bc395228.png)\n\n内置的滤镜，有新增，也有性能优化。这里不展开讲。\n\n一般都是用到的时候，去查找是否有合适的内置滤镜，而不是一开始就把这近 200 个滤镜都掌握下来。\n\n具体的可以查阅： [Core Image Filter Reference](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346) \n\n\n\n\n\n### CIBarcodeDescriptor\n\nApp 现在支持各种各样的条码扫描，识别。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/84253106453689f22287df902bd16c1a.png)\n\n并且，各个不同的框架，通过新引入的 CIBarcodeDescriptor，能够协调工作。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ac17593c23d689cebb269dfb217f171b.png)\n\n这里，可以通过 AVFoundation 框架，实时获取图像，并检测识别得到 CIBarcodeDescriptor 对象。\n\n```swift\n// Get a CIBarcodeDescriptor from AVFoundation.framework\nclass MyMetadataOutputObjectsDelegate: NSObject, AVCaptureMetadataOutputObjectsDelegate\n{\n    func metadataOutput(_ output: AVCaptureMetadataOutput,\n                        didOutput metadataObjects: [AVMetadataObject],\n                        from connection: AVCaptureConnection) {\n        if let mrc = metadataObjects.first as? AVMetadataMachineReadableCodeObject,\n          let descriptor = mrc.descriptor {\n              print(descriptor)\n        }\n    }\n}\n```\n\n\n\n当然，对于静态图片，或者录制好的视频文件，也可以通过 Vision 框架检测识别得到 CIBarcodeDescriptor 对象。\n\n```swift\n// Detect a CIBarcodeDescriptor using Vision.framework\nfunc descriptorFromImage(_ image: CIImage) -> CIBarcodeDescriptor?\n{\n    // Create the request and request handler\n    let requestHandler = VNImageRequestHandler(ciImage: image, options: [:])\n    let request = VNDetectBarcodesRequest();\n\n    // Send the request to the handler\n    try? requestHandler.perform([request])\n\n    // Get the observation\n    let firstResult = request.results?.first \n    return firstResult?.barcodeDescriptor\n}\n```\n\n\n\n而获取到的 CIBarcodeDescriptor，则可以通过 Core Image 进行渲染，得到对应的条码图像。\n\n```swift\n// Create an image for a CIBarcodeDescriptor using CoreImage.framework\nfunc imageFromBarcodeCodeDescriptor(_ descriptor: CIBarcodeDescriptor) -> CIImage? \n{\n    return CIFilter(name: \"CIBarcodeGenerator\", \n                    withInputParameters: [\"inputBarcodeDescriptor\" : descriptor])\n                      ?.outputImage \n}\n```\n\n> PS：\n>\n> 另外，CIBarcodeDescriptor 提供了许多有用的属性，比如 errorCorrectedPayload，maskPattern 等，便于获取条码的各种信息。\n\n\n\n通过这几个框架的无缝结合，可以做一些有趣的事情。\n\n官方展示了这么一个 Demo，它可以从视频帧中，提取出条码，然后重新渲染到条码上，加上红色遮罩，突出效果。这里有两点很惊艳。\n\n* 识别到的条码已经重新渲染的位置都很准确。\n* 注意看手指遮挡的部分，也能渲染出来。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4f367603d32d8707f1f2e2a84a92c5fe.png)\n\n\n\n### Using Core Image with Vision\n\n这个部分，有种捆绑销售的感觉～强行推一波新加入的 Vision。\n\n我们知道 Core Image 可以对图像进行处理，比如裁剪，旋转，灰度等等。\n\n而 Apple 新推出的 Vision 框架，在分析图像方面十分擅长，能提取出很多有用的信息。\n\n所以它们配合在一起能做一些很棒的事情，比如这里介绍了一个，从一组图片中，生成一张不包含某个对象的图片。\n\n> Photo from Video with Removal of Unwanted Objects\n\n具体如下图所示：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/97e8a5bdbe9caac2c1c6b7230e463ccc.png)\n\n\n\n从五张同个场景的图片，通过 Vision 和 Core Image 结合，实现去除图片上移动的人物。\n\n实现这个功能的具体步骤如下：\n\n从视频中提取序列帧。这里简单的使用 AVFoundation 就能实现，我们可以得到几个对应的 CIImage。\n\n图像对齐校正。提取出来的几张图片，可能因为拍摄设备的抖动，导致画面并不是完全一致，这时候就需要后期的调整。Vision 为我们提供了一个类 VNHomographicImageRegistrationRequest，专门用来做图像配准的。通过对比两张图片，能得到一个“对齐矩阵”，这样一张图片就能向另一张图片对齐。\n\n> An image analysis request that determines the perspective warp matrix needed to align the content of two images.\n>\n> Create and perform a homographic image registration request to align content in two images through a homography. A homography is an isomorphism of projected spaces, a bijection that maps lines to lines.\n\n具体代码如下：\n\n```swift\nfunc homographicTransform(from image: CIImage, to reference: CIImage) -> matrix_float3x3? {\n  // Create the request and request handler\n  let request = VNHomographicImageRegistrationRequest(targetedCIImage: image); \n  let requestHandler = VNImageRequestHandler(ciImage: reference, options: [:]);\n\n  // Send the request to the handler\n  try? requestHandler.perform([request]);\n\n  // Get the observation\n  guard let results = request.results,\n        let observation = results.first as? VNImageHomographicAlignmentObservation\n  else {\n      return nil\n  } \n  return observation.warpTransform\n}\n```\n\n得到的矩阵，再传入 CIFilter 中，做对齐，对应的 kernel 脚本如下 ：\n\n```c++\n// Core Image Metal kernel to apply a homography matrix\nfloat2 warpHomography(float3x3 h, destination dest) \n{\n  \tfloat3 homogeneousDestCoord = float3(dest.coord(), 1.0);\n  \tfloat3 homogeneousSrcCoord = h * homogeneousDestCoord;\n  \tfloat2 srcCoord = homogeneousSrcCoord.xy / max(homogeneousSrcCoord.z, 0.000001);\n  \treturn srcCoord; \n}\n```\n\n经过这个操作后，得到的 5 张图片，都是对齐过的，场景都是一致的。\n\n但是画面上，人物的位置是不均匀分布的，所以要使用中位算法，取出最终的画面。\n\n也就是每个像素点，都是5个图片一起分析，取出相同占比最高的那个像素值，结合成一个新的画面，就能剔除额外的人物。具体脚本如下：\n\n```swift\n// Core Image Metal kernel to return the median of 5 images\ninline void swap(thread float4 &a, thread float4 &b) \n{\n\tfloat4 tmp = a; a = min(a,b); b = max(tmp, b); // swap sort of two elements \n}\n\nfloat4 medianReduction5(sample_t v0, sample_t v1, sample_t v2, sample_t v3, sample_t v4) \n{\n\t// using a Bose-Nelson sorting network\n\tswap(v0, v1); swap(v3, v4); swap(v2, v4); swap(v2, v3); swap(v0, v3); swap(v0, v2); \tswap(v1, v4); swap(v1, v3); swap(v1, v2); \n\treturn v2;\n}\n```\n\n\n\n## 延伸阅读\n\n\n\n[Advances in Core Image: Filters, Metal, Vision, and More](https://developer.apple.com/videos/play/wwdc2017/510/)\n\n","slug":"Core-Image-2017","published":1,"updated":"2019-12-23T01:17:50.449Z","_id":"ck4hqrjok000200ln3u7pj5eu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\" target=\"_blank\" rel=\"external\">Core Image 你需要了解的那些事~</a></li>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\" target=\"_blank\" rel=\"external\">Core Image 之自定义 Filter~</a></li>\n<li><a href=\"http://colin1994.github.io/2019/12/22/Core-Image-2017/\" target=\"_blank\" rel=\"external\">Core Image【3】—— 2017 新特性</a></li>\n<li><a href=\"http://colin1994.github.io/2019/12/22/Core-Image-2018/\" target=\"_blank\" rel=\"external\">Core Image【4】—— 2018 新特性</a></li>\n</ul>\n<blockquote>\n<p>如果想了解 Core Image 相关，建议按序阅读，前后有依赖。</p>\n<p>对应源码，见最末链接。</p>\n</blockquote>\n<hr>\n<h2 id=\"概述\">概述</h2><p>先回顾一下 Core Image 目前强大的功能。</p>\n<ul>\n<li>A simple, high-performance API to apply filters to images，提供简单使用，性能优秀的 API，以及内置各种 CIFiter，方便处理图片</li>\n<li>Automatically tiles if images are large or graph is complex，大图处理优化</li>\n<li>Automatically tiles if only a region of the output is rendered，只处理部分区域</li>\n<li>Each CIFilter has one or more CIKernel functions，自定义 CIFliter</li>\n<li>Multiple CIKernels are concatenated to improve performance，滤镜链延迟处理，合并成一个</li>\n</ul>\n<a id=\"more\"></a>\n<p>这几点之前的文章都详细描述过了，这里不再说明。</p>\n<p>2017 年，额外引入了一些新的东西，具体如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/547604b69f745205bdbb6fac9b69d9b5.png\" alt=\"\"></p>\n<p>从三个方面讨论，<strong>性能，调试信息，新功能。</strong></p>\n<p><strong>性能：</strong></p>\n<ul>\n<li>支持使用 <strong>Metal</strong> 直接自定义 CIKernel，提高效率</li>\n<li>引入 <strong>CIRenderDestination</strong>，更方便，性能更好的渲染到指定目的地</li>\n</ul>\n<p><strong>信息：</strong></p>\n<ul>\n<li><strong>CIRenderInfo</strong>，包含更多的信息</li>\n<li><strong>Quick Looks</strong>，支持 Core Image 多个对象直观调试</li>\n</ul>\n<p><strong>新功能：</strong></p>\n<ul>\n<li>更多内置滤镜</li>\n<li>条码扫描支持</li>\n<li>与不同框架的协同处理</li>\n</ul>\n<p>下面逐一展开说明。</p>\n<h2 id=\"性能\">性能</h2><h3 id=\"Metal\">Metal</h3><p>先回顾旧的 CIKernel 编写方式，之前的文章也提到过，Core Image 支持自定义 CIFilter，它们的脚本是通过  CIKernel Language 编写的， CIKernel Language 又基于 GLSL。</p>\n<p>所以，当我们运行 App 时候，要用到这个 Filter，那么<strong>系统会自动帮我们把对应的 kernel，翻译成 GLSL 或者 Metal 规范的 kernel。然后再编译得到的 kernel。</strong></p>\n<p>所以之前的方式，存在两个问题：</p>\n<ul>\n<li>编写 kernel 的时候，没有报错提示，哪怕是参数名错误都无法检查处理。效率极低。</li>\n<li>翻译转换，编译，都是发生到运行时，导致第一次使用滤镜的时候，耗时较久。</li>\n</ul>\n<p>关于耗时这点，具体如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4c9049f837033a13d1c19d1c0ec46b9d.png\" alt=\"\"></p>\n<p>这里的各个阶段分别指：</p>\n<ul>\n<li>Translate CIKernels，转换 kernel，转成其他格式的。</li>\n<li>Concatenate CIKernels，按序连接 kernel，滤镜链里头提到过</li>\n<li>Compile CIKernels to Intermediate Representation，编译 CIKernel，这里的 IR（中间代码）我们无需关心，也干预不到</li>\n<li>Compile to GPU Code，将 IR 转成 GPU 识别的代码</li>\n<li>Render，在 GPU 上渲染</li>\n</ul>\n<p>在旧的模式里面，这五步都是<strong>发生在运行时，且无法避免。</strong></p>\n<p>CIKernel 编译后会有缓存机制，所以耗时<strong>第一次</strong>较为明显。</p>\n<p>这就导致了一个问题，你可能只需要渲染一次，显示带效果的图片。但是哪怕你的图片很小，也需要相当久的等待，因为需要对 CIKernel 进行转换编译。</p>\n<p>进一步拆分，必须发生在运行时的，包含 Concatenate CIKernels，Compile to GPU Code 以及 Render，因为拼接滤镜可能是动态的，没法一开始就确定下来。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/61bece6e8c6e2ff8abde6b918bcab3de.png\" alt=\"\"></p>\n<p>而占大头的前两部，并不是一定需要在运行时才能处理的。Metal 恰恰能解决。</p>\n<p><strong>将 Kernel 的编译时间，提前到 App 编译阶段，并且有语法错误检查，大大提高效率。</strong></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/64e16a386430674c36282b962f4f84d9.png\" alt=\"\"></p>\n<p>那么，具体怎么用 Metal 编写 CIKernel 呢，对比旧的流程，有什么差异呢？下面举个实际例子。将上一篇文章里面实现的 Vignette， 改用 Metal 处理，便于参照。</p>\n<h4 id=\"Write_CIKernel_in_Metal_shader_file\">Write CIKernel in Metal shader file</h4><p>CIKL（CIKernel Language） 和 Metal 本质上是很相似的，基础语法都是一样的。</p>\n<blockquote>\n<p> 关于语法类的东西，这里不细说，具体可以参照官方说明来。<a href=\"https://developer.apple.com/metal/MetalCIKLReference6.pdf\" target=\"_blank\" rel=\"external\">MetalCIKLReference</a></p>\n</blockquote>\n<p>这里提一点。CIKL 之前为了特性，扩展的那些支持， Metal 也同样支持。具体的转换规则如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/b14ddca70a1f0d21599d446b3cc2cb66.png\" alt=\"\"></p>\n<p>所以不同类型的 CIKernel，它们的简单转换应该是这样：</p>\n<p><strong>CIWarpKernel</strong>：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/219136a92e6178a42efee4f5ed1540db.png\" alt=\"\"></p>\n<p><strong>CIColorKernel</strong>：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ad595836500bc951221950c96eac6658.png\" alt=\"\"></p>\n<p><strong>CIKernel</strong>:<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/428c5a2dd1e6b0e339d1f5d4bab81f2b.png\" alt=\"\"></p>\n<p>基本上，差异都体现在额外扩展的这些内容。实际的算法编写，基本不变。</p>\n<p>我们以之前实现的 <strong>vignetteKernel</strong> 为例，<strong>Vignette.cikernel</strong> 白板代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 vignetteKernel(__sample image, vec2 center, float radius, float alpha)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 计算出当前点与中心的距离</span><br><span class=\"line\">\tfloat distance = distance(destCoord(), center) ;</span><br><span class=\"line\">\t// 根据距离计算出暗淡程度</span><br><span class=\"line\">\tfloat darken = 1.0 - (distance / radius * alpha);</span><br><span class=\"line\">\t// 返回该像素点最终的色值</span><br><span class=\"line\">\timage.rgb *= darken;</span><br><span class=\"line\">\treturn image.rgba;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>转换成 <strong>Metal</strong> 应该是：<strong>Vignette.metal</strong> ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;metal_stdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> metal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;CoreImage/CoreImage.h&gt;</span> // includes CIKernelMetalLib.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123; <span class=\"keyword\">namespace</span> coreimage &#123;</span><br><span class=\"line\">    <span class=\"function\">float4 <span class=\"title\">vignetteMetal</span><span class=\"params\">(sample_t image, float2 center, <span class=\"keyword\">float</span> radius, <span class=\"keyword\">float</span> alpha, destination dest)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算出当前点与中心的距离</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> distance2 = distance(dest.coord(), center);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 根据距离计算出暗淡程度</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> darken = <span class=\"number\">1.0</span> - (distance2 / radius * alpha);</span><br><span class=\"line\">        <span class=\"comment\">// 返回该像素点最终的色值</span></span><br><span class=\"line\">        image.rgb *= darken;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> image.rgba;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有几个改变点逐一说下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;metal_stdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> metal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;CoreImage/CoreImage.h&gt;</span> // includes CIKernelMetalLib.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123; <span class=\"keyword\">namespace</span> coreimage &#123;</span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要引入对应的库，以及命名空间。因为系统内部的实现大致是这样的：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/bb35482a6bbb737966125cc5954a1274.png\" alt=\"\"></p>\n<p>这基本是固定的格式，保持就好。</p>\n<p>然后就是特定的修改：</p>\n<ul>\n<li>__sample —&gt; sample_t</li>\n<li>vec2 — &gt; float2</li>\n<li>destCoord() —&gt; dest.coord()</li>\n<li>vec4 —&gt; float4</li>\n</ul>\n<p>这里注意，Metal 不支持 vec 类型，参数类型都需要转成浮点值类型。</p>\n<p>另外，入参这里，多了一个 <strong>destination dest</strong>，这个对应 CIColorKernel 是可选的，因为并不一定要获取当前的坐标，正常像素值就够了。</p>\n<p>如果要带的话，<strong>它是隐式的，必须放在参数列表最后一个</strong>，无须我们传参，系统自动赋值。这点需要额外注意！</p>\n<p>至此，shader 的编写就结束了，也是很好理解。</p>\n<h4 id=\"Compile_and_link_Metal_shader_file\">Compile and link Metal shader file</h4><p>至于编译，Xcode 默认是不会帮我们编译 CIKernel 对应的 Metal 文件，需要我们显示的去设置。</p>\n<p>具体步骤如下：</p>\n<p>Build Settings 里头找到 <strong>Other Metal Compiler Flags</strong>，添加值：<strong>-fcikernel</strong></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/108c5682c22cd84683182397b8b1220f.png\" alt=\"\"></p>\n<p>然后新增一个自定义配置</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e1f7404335c1db1336c95ae8851ab108.png\" alt=\"\"></p>\n<p>对应的 Key 为： <strong>MTLLINKER_FLAGS</strong>，value 为：<strong>-cikernel</strong></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/aa1398fedeb1cb4c3d1953e92bc18a7c.png\" alt=\"\"></p>\n<blockquote>\n<p>PS：</p>\n<p>如果没添加对应的编译选项，下一步初始化 CIKernel 的时候，会失败。</p>\n</blockquote>\n<h4 id=\"Initialize_CIKernel\">Initialize CIKernel</h4><p>这里同样对比旧的创建方式，</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSBundle</span> *bundle = [<span class=\"built_in\">NSBundle</span> bundleForClass: [<span class=\"keyword\">self</span> class]];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *kernelURL = [bundle URLForResource:<span class=\"string\">@\"Vignette\"</span> withExtension:<span class=\"string\">@\"cikernel\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *kernelCode = [<span class=\"built_in\">NSString</span> stringWithContentsOfURL:kernelURL</span><br><span class=\"line\">                                                encoding:<span class=\"built_in\">NSUTF8StringEncoding</span></span><br><span class=\"line\">                                                   error:&amp;error];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *kernels = [<span class=\"built_in\">CIColorKernel</span> kernelsWithString:kernelCode];</span><br><span class=\"line\">customKernel = [kernels objectAtIndex:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>只需要改为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *kernelURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"default\"</span> withExtension:<span class=\"string\">@\"metallib\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:kernelURL];</span><br><span class=\"line\">customKernel = [<span class=\"built_in\">CIColorKernel</span> kernelWithFunctionName:<span class=\"string\">@\"vignetteMetal\"</span></span><br><span class=\"line\">                                fromMetalLibraryData:data</span><br><span class=\"line\">                                               error:&amp;error];</span><br></pre></td></tr></table></figure>\n<p>初始化方法不一样，在使用上是一致的。</p>\n<p>至此，通过 Metal 自定义 CIFilter 的流程，已经全部走通了。对旧有的修改很小。<br>这里额外提一点，UIImageView 针对 CIImage 有做优化，如果一个 UIImage 是通过 UIImage.init(ciImage:) 这种方式创建的，</p>\n<p><strong>设置到 UIImageView 上的时候，UIImageView 会在 GPU 上执行 Core Image 相关操作。GPU 处理很高效，并且能释放 CPU 压力。</strong></p>\n<p>所以，实时调整 Filter 的时候，也可以借助 UIImageView 来直接显示，效率很高：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MetalKernelViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) MetalKernelFilter *vignetteFilter;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CIImage</span> *inputImage;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *imageView;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MetalKernelViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化 Filter</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.vignetteFilter = [[MetalKernelFilter alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *imageURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"vignetteImage\"</span> withExtension:<span class=\"string\">@\"jpg\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.inputImage = [<span class=\"built_in\">CIImage</span> imageWithContentsOfURL:imageURL];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.vignetteFilter setValue:_inputImage forKey:<span class=\"string\">@\"inputImage\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.imageView.image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CIImage</span>:<span class=\"keyword\">self</span>.inputImage];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Action</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)alphaChanged:(<span class=\"built_in\">UISlider</span> *)sender &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.vignetteFilter setValue:@(sender.value) forKey:<span class=\"string\">@\"inputAlpha\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *result = _vignetteFilter.outputImage;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.imageView.image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CIImage</span>:result];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"CIRenderDestination\">CIRenderDestination</h3><p>这是一个新增的 API，iOS 11 之后支持，方便渲染到指定的目的地。</p>\n<p>目前支持：</p>\n<ul>\n<li>IOSurface</li>\n<li>CVPixelBuffer</li>\n<li>Metal Texture</li>\n<li>OpenGL Texture</li>\n<li>Memory buffer</li>\n</ul>\n<p>基本涵盖了所有我们需要用来显示的对象。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype) initWithMTLTexture:(<span class=\"keyword\">id</span>&lt;MTLTexture&gt;)texture</span><br><span class=\"line\">                      commandBuffer:(nullable <span class=\"keyword\">id</span>&lt;MTLCommandBuffer&gt;)commandBuffer;</span><br></pre></td></tr></table></figure>\n<p>当我们需要执行渲染的时候，就可以使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">CIRenderTask</span>*) startTaskToRender:(<span class=\"built_in\">CIImage</span>*)image</span><br><span class=\"line\">                               toDestination:(<span class=\"built_in\">CIRenderDestination</span>*)destination</span><br><span class=\"line\">                                       error:(<span class=\"built_in\">NSError</span>**)error <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_13, <span class=\"number\">11</span>_0);</span><br></pre></td></tr></table></figure>\n<p>当然，你可能有发现，旧的 API 也是支持渲染到指定目的地的，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)render:(<span class=\"built_in\">CIImage</span> *)image </span><br><span class=\"line\">toCVPixelBuffer:(CVPixelBufferRef)buffer <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_11,<span class=\"number\">5</span>_0);</span><br></pre></td></tr></table></figure>\n<p>那么，新的 API 有什么优势呢？我具体罗列了以下几点：</p>\n<ul>\n<li>如果渲染失败，会立即返回错误信息，便于排查问题，旧的是不支持。</li>\n<li>另外，渲染时，可以额外指定结果的一些属性，比如是否翻转，颜色空间，alpha 混合模式等。不需要额外的操作，性能高。</li>\n<li>另外，支持这些属性后，不需要额外创建多个 CIContext。之前处理的话，有的属性和具体的 CIContext 关联，导致配置不同参数的时候，需要依赖多个。现在只要一个就可以了。</li>\n<li>性能更好，速度快。旧的 API，需要等到所有提交到 GPU 的渲染命令，执行完毕后，才执行新的渲染操作。新的 API，当 CPU 提交完所有命令到 GPU 后，就可以开始执行新的，不需要等到 GPU 处理完。CPU 和 GPU 之间的协同工作更加高效。</li>\n</ul>\n<blockquote>\n<p>They used to return after all the render on the GPU is completed.</p>\n<p>But now with this new API, it will return as soon as the CPU has finished issuing all the work for the GPU.</p>\n<p>And without having to wait for the GPU work to finish.</p>\n<p>So we think this new flexibility will now allow you to pipeline all your CPU and GPU work much more efficiently.</p>\n</blockquote>\n<p>额外支持的属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">CIRenderDestinationAlphaMode</span> alphaMode;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (getter=isFlipped) <span class=\"built_in\">BOOL</span> flipped;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (getter=isDithered) <span class=\"built_in\">BOOL</span> dithered;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (getter=isClamped) <span class=\"built_in\">BOOL</span> clamped;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (nullable, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CGColorSpaceRef</span> colorSpace;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (nullable, <span class=\"keyword\">nonatomic</span>, retain) <span class=\"built_in\">CIBlendKernel</span>* blendKernel;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> blendsInDestinationColorSpace;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调试信息\">调试信息</h2><p>这里主要包含两点：</p>\n<ul>\n<li>CIRenderInfo</li>\n<li>Quick Look</li>\n</ul>\n<h3 id=\"CIRenderInfo\">CIRenderInfo</h3><p>CIRenderInfo 是新增的对象，它里面包含了一些有用的信息，比如 kernel 执行耗时，当前有多少数量的像素参与处理等。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// An Xcode quicklook of this object will show a graph visualization of the render</span></span><br><span class=\"line\"><span class=\"comment\">// with detailed timing information.</span></span><br><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE</span>(<span class=\"number\">10</span>_13, <span class=\"number\">11</span>_0)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CIRenderInfo</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *_priv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This property will return how much time a render spent executing kernels.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSTimeInterval</span> kernelExecutionTime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This property will return how many passes the render requires.</span></span><br><span class=\"line\"><span class=\"comment\">// If passCount is 1 than the render can be fully concatinated and no</span></span><br><span class=\"line\"><span class=\"comment\">// intermediate buffers will be required.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSInteger</span> passCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This property will return how many pixels a render produced executing kernels.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSInteger</span> pixelsProcessed;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Quick_Look\">Quick Look</h3><p>Core Image 对很对对象新增了 Quick Look 支持，方便调试查看效果。</p>\n<p>关于调试信息这点，前两篇文章其实有提到其他方式，只是都没有 Quick Look 来得方便。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/499151a6af87609acc2b3c0e0dcc4cc7.png\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ad284913cfc4298cef07170e06696f27.png\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/c64ba6e368ae6dd96cf8d80d7bb44dd2.png\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/0cb9e4a8b7547a643a9733b8ecd78b07.png\" alt=\"\"></p>\n<p>图表都支持放大查阅，具体的大家可以实际查阅。信息还是很有用的，包含多个滤镜是怎么组合的等等细节。</p>\n<h2 id=\"新功能\">新功能</h2><h3 id=\"New_Filter\">New Filter</h3><p>现在内置了 196 个 filters</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/1af5a34340e9d232a99d2683bc395228.png\" alt=\"\"></p>\n<p>内置的滤镜，有新增，也有性能优化。这里不展开讲。</p>\n<p>一般都是用到的时候，去查找是否有合适的内置滤镜，而不是一开始就把这近 200 个滤镜都掌握下来。</p>\n<p>具体的可以查阅： <a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346\" target=\"_blank\" rel=\"external\">Core Image Filter Reference</a> </p>\n<h3 id=\"CIBarcodeDescriptor\">CIBarcodeDescriptor</h3><p>App 现在支持各种各样的条码扫描，识别。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/84253106453689f22287df902bd16c1a.png\" alt=\"\"></p>\n<p>并且，各个不同的框架，通过新引入的 CIBarcodeDescriptor，能够协调工作。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ac17593c23d689cebb269dfb217f171b.png\" alt=\"\"></p>\n<p>这里，可以通过 AVFoundation 框架，实时获取图像，并检测识别得到 CIBarcodeDescriptor 对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get a CIBarcodeDescriptor from AVFoundation.framework</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMetadataOutputObjectsDelegate</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">AVCaptureMetadataOutputObjectsDelegate</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">metadataOutput</span><span class=\"params\">(<span class=\"number\">_</span> output: AVCaptureMetadataOutput,</span><br><span class=\"line\">                        didOutput metadataObjects: [AVMetadataObject],</span><br><span class=\"line\">                        from connection: AVCaptureConnection)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mrc = metadataObjects.first <span class=\"keyword\">as</span>? <span class=\"type\">AVMetadataMachineReadableCodeObject</span>,</span><br><span class=\"line\">          <span class=\"keyword\">let</span> descriptor = mrc.descriptor &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(descriptor)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，对于静态图片，或者录制好的视频文件，也可以通过 Vision 框架检测识别得到 CIBarcodeDescriptor 对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Detect a CIBarcodeDescriptor using Vision.framework</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">descriptorFromImage</span><span class=\"params\">(<span class=\"number\">_</span> image: CIImage)</span></span> -&gt; <span class=\"type\">CIBarcodeDescriptor</span>?</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the request and request handler</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> requestHandler = <span class=\"type\">VNImageRequestHandler</span>(ciImage: image, options: [:])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"type\">VNDetectBarcodesRequest</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Send the request to the handler</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>? requestHandler.perform([request])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Get the observation</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> firstResult = request.results?.first </span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstResult?.barcodeDescriptor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而获取到的 CIBarcodeDescriptor，则可以通过 Core Image 进行渲染，得到对应的条码图像。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create an image for a CIBarcodeDescriptor using CoreImage.framework</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">imageFromBarcodeCodeDescriptor</span><span class=\"params\">(<span class=\"number\">_</span> descriptor: CIBarcodeDescriptor)</span></span> -&gt; <span class=\"type\">CIImage</span>? </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIBarcodeGenerator\"</span>, </span><br><span class=\"line\">                    withInputParameters: [<span class=\"string\">\"inputBarcodeDescriptor\"</span> : descriptor])</span><br><span class=\"line\">                      ?.outputImage </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>另外，CIBarcodeDescriptor 提供了许多有用的属性，比如 errorCorrectedPayload，maskPattern 等，便于获取条码的各种信息。</p>\n</blockquote>\n<p>通过这几个框架的无缝结合，可以做一些有趣的事情。</p>\n<p>官方展示了这么一个 Demo，它可以从视频帧中，提取出条码，然后重新渲染到条码上，加上红色遮罩，突出效果。这里有两点很惊艳。</p>\n<ul>\n<li>识别到的条码已经重新渲染的位置都很准确。</li>\n<li>注意看手指遮挡的部分，也能渲染出来。</li>\n</ul>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4f367603d32d8707f1f2e2a84a92c5fe.png\" alt=\"\"></p>\n<h3 id=\"Using_Core_Image_with_Vision\">Using Core Image with Vision</h3><p>这个部分，有种捆绑销售的感觉～强行推一波新加入的 Vision。</p>\n<p>我们知道 Core Image 可以对图像进行处理，比如裁剪，旋转，灰度等等。</p>\n<p>而 Apple 新推出的 Vision 框架，在分析图像方面十分擅长，能提取出很多有用的信息。</p>\n<p>所以它们配合在一起能做一些很棒的事情，比如这里介绍了一个，从一组图片中，生成一张不包含某个对象的图片。</p>\n<blockquote>\n<p>Photo from Video with Removal of Unwanted Objects</p>\n</blockquote>\n<p>具体如下图所示：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/97e8a5bdbe9caac2c1c6b7230e463ccc.png\" alt=\"\"></p>\n<p>从五张同个场景的图片，通过 Vision 和 Core Image 结合，实现去除图片上移动的人物。</p>\n<p>实现这个功能的具体步骤如下：</p>\n<p>从视频中提取序列帧。这里简单的使用 AVFoundation 就能实现，我们可以得到几个对应的 CIImage。</p>\n<p>图像对齐校正。提取出来的几张图片，可能因为拍摄设备的抖动，导致画面并不是完全一致，这时候就需要后期的调整。Vision 为我们提供了一个类 VNHomographicImageRegistrationRequest，专门用来做图像配准的。通过对比两张图片，能得到一个“对齐矩阵”，这样一张图片就能向另一张图片对齐。</p>\n<blockquote>\n<p>An image analysis request that determines the perspective warp matrix needed to align the content of two images.</p>\n<p>Create and perform a homographic image registration request to align content in two images through a homography. A homography is an isomorphism of projected spaces, a bijection that maps lines to lines.</p>\n</blockquote>\n<p>具体代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">homographicTransform</span><span class=\"params\">(from image: CIImage, to reference: CIImage)</span></span> -&gt; matrix_float3x3? &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create the request and request handler</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> request = <span class=\"type\">VNHomographicImageRegistrationRequest</span>(targetedCIImage: image); </span><br><span class=\"line\">  <span class=\"keyword\">let</span> requestHandler = <span class=\"type\">VNImageRequestHandler</span>(ciImage: reference, options: [:]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send the request to the handler</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span>? requestHandler.perform([request]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Get the observation</span></span><br><span class=\"line\">  <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> results = request.results,</span><br><span class=\"line\">        <span class=\"keyword\">let</span> observation = results.first <span class=\"keyword\">as</span>? <span class=\"type\">VNImageHomographicAlignmentObservation</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> observation.warpTransform</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到的矩阵，再传入 CIFilter 中，做对齐，对应的 kernel 脚本如下 ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Core Image Metal kernel to apply a homography matrix</span></span><br><span class=\"line\"><span class=\"function\">float2 <span class=\"title\">warpHomography</span><span class=\"params\">(float3x3 h, destination dest)</span> </span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">  \tfloat3 homogeneousDestCoord = float3(dest.coord(), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">  \tfloat3 homogeneousSrcCoord = h * homogeneousDestCoord;</span><br><span class=\"line\">  \tfloat2 srcCoord = homogeneousSrcCoord.xy / max(homogeneousSrcCoord.z, <span class=\"number\">0.000001</span>);</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> srcCoord; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过这个操作后，得到的 5 张图片，都是对齐过的，场景都是一致的。</p>\n<p>但是画面上，人物的位置是不均匀分布的，所以要使用中位算法，取出最终的画面。</p>\n<p>也就是每个像素点，都是5个图片一起分析，取出相同占比最高的那个像素值，结合成一个新的画面，就能剔除额外的人物。具体脚本如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Core Image Metal kernel to return the median of 5 images</span></span><br><span class=\"line\">inline void <span class=\"built_in\">swap</span>(thread float4 &amp;a, thread float4 &amp;b) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat4 tmp = a; a = <span class=\"built_in\">min</span>(a,b); b = <span class=\"built_in\">max</span>(tmp, b); <span class=\"comment\">// swap sort of two elements </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float4 medianReduction5(sample_t v0, sample_t v1, sample_t v2, sample_t v3, sample_t v4) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// using a Bose-Nelson sorting network</span></span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(v0, v1); <span class=\"built_in\">swap</span>(v3, v4); <span class=\"built_in\">swap</span>(v2, v4); <span class=\"built_in\">swap</span>(v2, v3); <span class=\"built_in\">swap</span>(v0, v3); <span class=\"built_in\">swap</span>(v0, v2); \t<span class=\"built_in\">swap</span>(v1, v4); <span class=\"built_in\">swap</span>(v1, v3); <span class=\"built_in\">swap</span>(v1, v2); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/videos/play/wwdc2017/510/\" target=\"_blank\" rel=\"external\">Advances in Core Image: Filters, Metal, Vision, and More</a></p>\n","excerpt":"<p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-OverView/\">Core Image 你需要了解的那些事~</a></li>\n<li><a href=\"http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/\">Core Image 之自定义 Filter~</a></li>\n<li><a href=\"http://colin1994.github.io/2019/12/22/Core-Image-2017/\">Core Image【3】—— 2017 新特性</a></li>\n<li><a href=\"http://colin1994.github.io/2019/12/22/Core-Image-2018/\">Core Image【4】—— 2018 新特性</a></li>\n</ul>\n<blockquote>\n<p>如果想了解 Core Image 相关，建议按序阅读，前后有依赖。</p>\n<p>对应源码，见最末链接。</p>\n</blockquote>\n<hr>\n<h2 id=\"概述\">概述</h2><p>先回顾一下 Core Image 目前强大的功能。</p>\n<ul>\n<li>A simple, high-performance API to apply filters to images，提供简单使用，性能优秀的 API，以及内置各种 CIFiter，方便处理图片</li>\n<li>Automatically tiles if images are large or graph is complex，大图处理优化</li>\n<li>Automatically tiles if only a region of the output is rendered，只处理部分区域</li>\n<li>Each CIFilter has one or more CIKernel functions，自定义 CIFliter</li>\n<li>Multiple CIKernels are concatenated to improve performance，滤镜链延迟处理，合并成一个</li>\n</ul>","more":"<p>这几点之前的文章都详细描述过了，这里不再说明。</p>\n<p>2017 年，额外引入了一些新的东西，具体如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/547604b69f745205bdbb6fac9b69d9b5.png\" alt=\"\"></p>\n<p>从三个方面讨论，<strong>性能，调试信息，新功能。</strong></p>\n<p><strong>性能：</strong></p>\n<ul>\n<li>支持使用 <strong>Metal</strong> 直接自定义 CIKernel，提高效率</li>\n<li>引入 <strong>CIRenderDestination</strong>，更方便，性能更好的渲染到指定目的地</li>\n</ul>\n<p><strong>信息：</strong></p>\n<ul>\n<li><strong>CIRenderInfo</strong>，包含更多的信息</li>\n<li><strong>Quick Looks</strong>，支持 Core Image 多个对象直观调试</li>\n</ul>\n<p><strong>新功能：</strong></p>\n<ul>\n<li>更多内置滤镜</li>\n<li>条码扫描支持</li>\n<li>与不同框架的协同处理</li>\n</ul>\n<p>下面逐一展开说明。</p>\n<h2 id=\"性能\">性能</h2><h3 id=\"Metal\">Metal</h3><p>先回顾旧的 CIKernel 编写方式，之前的文章也提到过，Core Image 支持自定义 CIFilter，它们的脚本是通过  CIKernel Language 编写的， CIKernel Language 又基于 GLSL。</p>\n<p>所以，当我们运行 App 时候，要用到这个 Filter，那么<strong>系统会自动帮我们把对应的 kernel，翻译成 GLSL 或者 Metal 规范的 kernel。然后再编译得到的 kernel。</strong></p>\n<p>所以之前的方式，存在两个问题：</p>\n<ul>\n<li>编写 kernel 的时候，没有报错提示，哪怕是参数名错误都无法检查处理。效率极低。</li>\n<li>翻译转换，编译，都是发生到运行时，导致第一次使用滤镜的时候，耗时较久。</li>\n</ul>\n<p>关于耗时这点，具体如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4c9049f837033a13d1c19d1c0ec46b9d.png\" alt=\"\"></p>\n<p>这里的各个阶段分别指：</p>\n<ul>\n<li>Translate CIKernels，转换 kernel，转成其他格式的。</li>\n<li>Concatenate CIKernels，按序连接 kernel，滤镜链里头提到过</li>\n<li>Compile CIKernels to Intermediate Representation，编译 CIKernel，这里的 IR（中间代码）我们无需关心，也干预不到</li>\n<li>Compile to GPU Code，将 IR 转成 GPU 识别的代码</li>\n<li>Render，在 GPU 上渲染</li>\n</ul>\n<p>在旧的模式里面，这五步都是<strong>发生在运行时，且无法避免。</strong></p>\n<p>CIKernel 编译后会有缓存机制，所以耗时<strong>第一次</strong>较为明显。</p>\n<p>这就导致了一个问题，你可能只需要渲染一次，显示带效果的图片。但是哪怕你的图片很小，也需要相当久的等待，因为需要对 CIKernel 进行转换编译。</p>\n<p>进一步拆分，必须发生在运行时的，包含 Concatenate CIKernels，Compile to GPU Code 以及 Render，因为拼接滤镜可能是动态的，没法一开始就确定下来。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/61bece6e8c6e2ff8abde6b918bcab3de.png\" alt=\"\"></p>\n<p>而占大头的前两部，并不是一定需要在运行时才能处理的。Metal 恰恰能解决。</p>\n<p><strong>将 Kernel 的编译时间，提前到 App 编译阶段，并且有语法错误检查，大大提高效率。</strong></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/64e16a386430674c36282b962f4f84d9.png\" alt=\"\"></p>\n<p>那么，具体怎么用 Metal 编写 CIKernel 呢，对比旧的流程，有什么差异呢？下面举个实际例子。将上一篇文章里面实现的 Vignette， 改用 Metal 处理，便于参照。</p>\n<h4 id=\"Write_CIKernel_in_Metal_shader_file\">Write CIKernel in Metal shader file</h4><p>CIKL（CIKernel Language） 和 Metal 本质上是很相似的，基础语法都是一样的。</p>\n<blockquote>\n<p> 关于语法类的东西，这里不细说，具体可以参照官方说明来。<a href=\"https://developer.apple.com/metal/MetalCIKLReference6.pdf\">MetalCIKLReference</a></p>\n</blockquote>\n<p>这里提一点。CIKL 之前为了特性，扩展的那些支持， Metal 也同样支持。具体的转换规则如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/b14ddca70a1f0d21599d446b3cc2cb66.png\" alt=\"\"></p>\n<p>所以不同类型的 CIKernel，它们的简单转换应该是这样：</p>\n<p><strong>CIWarpKernel</strong>：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/219136a92e6178a42efee4f5ed1540db.png\" alt=\"\"></p>\n<p><strong>CIColorKernel</strong>：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ad595836500bc951221950c96eac6658.png\" alt=\"\"></p>\n<p><strong>CIKernel</strong>:<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/428c5a2dd1e6b0e339d1f5d4bab81f2b.png\" alt=\"\"></p>\n<p>基本上，差异都体现在额外扩展的这些内容。实际的算法编写，基本不变。</p>\n<p>我们以之前实现的 <strong>vignetteKernel</strong> 为例，<strong>Vignette.cikernel</strong> 白板代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel vec4 vignetteKernel(__sample image, vec2 center, float radius, float alpha)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 计算出当前点与中心的距离</span><br><span class=\"line\">\tfloat distance = distance(destCoord(), center) ;</span><br><span class=\"line\">\t// 根据距离计算出暗淡程度</span><br><span class=\"line\">\tfloat darken = 1.0 - (distance / radius * alpha);</span><br><span class=\"line\">\t// 返回该像素点最终的色值</span><br><span class=\"line\">\timage.rgb *= darken;</span><br><span class=\"line\">\treturn image.rgba;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>转换成 <strong>Metal</strong> 应该是：<strong>Vignette.metal</strong> ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;metal_stdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> metal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;CoreImage/CoreImage.h&gt;</span> // includes CIKernelMetalLib.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123; <span class=\"keyword\">namespace</span> coreimage &#123;</span><br><span class=\"line\">    <span class=\"function\">float4 <span class=\"title\">vignetteMetal</span><span class=\"params\">(sample_t image, float2 center, <span class=\"keyword\">float</span> radius, <span class=\"keyword\">float</span> alpha, destination dest)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算出当前点与中心的距离</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> distance2 = distance(dest.coord(), center);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 根据距离计算出暗淡程度</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> darken = <span class=\"number\">1.0</span> - (distance2 / radius * alpha);</span><br><span class=\"line\">        <span class=\"comment\">// 返回该像素点最终的色值</span></span><br><span class=\"line\">        image.rgb *= darken;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> image.rgba;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有几个改变点逐一说下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;metal_stdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> metal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;CoreImage/CoreImage.h&gt;</span> // includes CIKernelMetalLib.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123; <span class=\"keyword\">namespace</span> coreimage &#123;</span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要引入对应的库，以及命名空间。因为系统内部的实现大致是这样的：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/bb35482a6bbb737966125cc5954a1274.png\" alt=\"\"></p>\n<p>这基本是固定的格式，保持就好。</p>\n<p>然后就是特定的修改：</p>\n<ul>\n<li>__sample —&gt; sample_t</li>\n<li>vec2 — &gt; float2</li>\n<li>destCoord() —&gt; dest.coord()</li>\n<li>vec4 —&gt; float4</li>\n</ul>\n<p>这里注意，Metal 不支持 vec 类型，参数类型都需要转成浮点值类型。</p>\n<p>另外，入参这里，多了一个 <strong>destination dest</strong>，这个对应 CIColorKernel 是可选的，因为并不一定要获取当前的坐标，正常像素值就够了。</p>\n<p>如果要带的话，<strong>它是隐式的，必须放在参数列表最后一个</strong>，无须我们传参，系统自动赋值。这点需要额外注意！</p>\n<p>至此，shader 的编写就结束了，也是很好理解。</p>\n<h4 id=\"Compile_and_link_Metal_shader_file\">Compile and link Metal shader file</h4><p>至于编译，Xcode 默认是不会帮我们编译 CIKernel 对应的 Metal 文件，需要我们显示的去设置。</p>\n<p>具体步骤如下：</p>\n<p>Build Settings 里头找到 <strong>Other Metal Compiler Flags</strong>，添加值：<strong>-fcikernel</strong></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/108c5682c22cd84683182397b8b1220f.png\" alt=\"\"></p>\n<p>然后新增一个自定义配置</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e1f7404335c1db1336c95ae8851ab108.png\" alt=\"\"></p>\n<p>对应的 Key 为： <strong>MTLLINKER_FLAGS</strong>，value 为：<strong>-cikernel</strong></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/aa1398fedeb1cb4c3d1953e92bc18a7c.png\" alt=\"\"></p>\n<blockquote>\n<p>PS：</p>\n<p>如果没添加对应的编译选项，下一步初始化 CIKernel 的时候，会失败。</p>\n</blockquote>\n<h4 id=\"Initialize_CIKernel\">Initialize CIKernel</h4><p>这里同样对比旧的创建方式，</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSBundle</span> *bundle = [<span class=\"built_in\">NSBundle</span> bundleForClass: [<span class=\"keyword\">self</span> class]];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *kernelURL = [bundle URLForResource:<span class=\"string\">@\"Vignette\"</span> withExtension:<span class=\"string\">@\"cikernel\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *kernelCode = [<span class=\"built_in\">NSString</span> stringWithContentsOfURL:kernelURL</span><br><span class=\"line\">                                                encoding:<span class=\"built_in\">NSUTF8StringEncoding</span></span><br><span class=\"line\">                                                   error:&amp;error];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *kernels = [<span class=\"built_in\">CIColorKernel</span> kernelsWithString:kernelCode];</span><br><span class=\"line\">customKernel = [kernels objectAtIndex:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>只需要改为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *kernelURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"default\"</span> withExtension:<span class=\"string\">@\"metallib\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:kernelURL];</span><br><span class=\"line\">customKernel = [<span class=\"built_in\">CIColorKernel</span> kernelWithFunctionName:<span class=\"string\">@\"vignetteMetal\"</span></span><br><span class=\"line\">                                fromMetalLibraryData:data</span><br><span class=\"line\">                                               error:&amp;error];</span><br></pre></td></tr></table></figure>\n<p>初始化方法不一样，在使用上是一致的。</p>\n<p>至此，通过 Metal 自定义 CIFilter 的流程，已经全部走通了。对旧有的修改很小。<br>这里额外提一点，UIImageView 针对 CIImage 有做优化，如果一个 UIImage 是通过 UIImage.init(ciImage:) 这种方式创建的，</p>\n<p><strong>设置到 UIImageView 上的时候，UIImageView 会在 GPU 上执行 Core Image 相关操作。GPU 处理很高效，并且能释放 CPU 压力。</strong></p>\n<p>所以，实时调整 Filter 的时候，也可以借助 UIImageView 来直接显示，效率很高：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MetalKernelViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) MetalKernelFilter *vignetteFilter;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CIImage</span> *inputImage;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *imageView;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MetalKernelViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化 Filter</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.vignetteFilter = [[MetalKernelFilter alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *imageURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"vignetteImage\"</span> withExtension:<span class=\"string\">@\"jpg\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.inputImage = [<span class=\"built_in\">CIImage</span> imageWithContentsOfURL:imageURL];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.vignetteFilter setValue:_inputImage forKey:<span class=\"string\">@\"inputImage\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.imageView.image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CIImage</span>:<span class=\"keyword\">self</span>.inputImage];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Action</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)alphaChanged:(<span class=\"built_in\">UISlider</span> *)sender &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.vignetteFilter setValue:@(sender.value) forKey:<span class=\"string\">@\"inputAlpha\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">CIImage</span> *result = _vignetteFilter.outputImage;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.imageView.image = [<span class=\"built_in\">UIImage</span> imageWith<span class=\"built_in\">CIImage</span>:result];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"CIRenderDestination\">CIRenderDestination</h3><p>这是一个新增的 API，iOS 11 之后支持，方便渲染到指定的目的地。</p>\n<p>目前支持：</p>\n<ul>\n<li>IOSurface</li>\n<li>CVPixelBuffer</li>\n<li>Metal Texture</li>\n<li>OpenGL Texture</li>\n<li>Memory buffer</li>\n</ul>\n<p>基本涵盖了所有我们需要用来显示的对象。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype) initWithMTLTexture:(<span class=\"keyword\">id</span>&lt;MTLTexture&gt;)texture</span><br><span class=\"line\">                      commandBuffer:(nullable <span class=\"keyword\">id</span>&lt;MTLCommandBuffer&gt;)commandBuffer;</span><br></pre></td></tr></table></figure>\n<p>当我们需要执行渲染的时候，就可以使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">CIRenderTask</span>*) startTaskToRender:(<span class=\"built_in\">CIImage</span>*)image</span><br><span class=\"line\">                               toDestination:(<span class=\"built_in\">CIRenderDestination</span>*)destination</span><br><span class=\"line\">                                       error:(<span class=\"built_in\">NSError</span>**)error <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_13, <span class=\"number\">11</span>_0);</span><br></pre></td></tr></table></figure>\n<p>当然，你可能有发现，旧的 API 也是支持渲染到指定目的地的，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)render:(<span class=\"built_in\">CIImage</span> *)image </span><br><span class=\"line\">toCVPixelBuffer:(CVPixelBufferRef)buffer <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_11,<span class=\"number\">5</span>_0);</span><br></pre></td></tr></table></figure>\n<p>那么，新的 API 有什么优势呢？我具体罗列了以下几点：</p>\n<ul>\n<li>如果渲染失败，会立即返回错误信息，便于排查问题，旧的是不支持。</li>\n<li>另外，渲染时，可以额外指定结果的一些属性，比如是否翻转，颜色空间，alpha 混合模式等。不需要额外的操作，性能高。</li>\n<li>另外，支持这些属性后，不需要额外创建多个 CIContext。之前处理的话，有的属性和具体的 CIContext 关联，导致配置不同参数的时候，需要依赖多个。现在只要一个就可以了。</li>\n<li>性能更好，速度快。旧的 API，需要等到所有提交到 GPU 的渲染命令，执行完毕后，才执行新的渲染操作。新的 API，当 CPU 提交完所有命令到 GPU 后，就可以开始执行新的，不需要等到 GPU 处理完。CPU 和 GPU 之间的协同工作更加高效。</li>\n</ul>\n<blockquote>\n<p>They used to return after all the render on the GPU is completed.</p>\n<p>But now with this new API, it will return as soon as the CPU has finished issuing all the work for the GPU.</p>\n<p>And without having to wait for the GPU work to finish.</p>\n<p>So we think this new flexibility will now allow you to pipeline all your CPU and GPU work much more efficiently.</p>\n</blockquote>\n<p>额外支持的属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">CIRenderDestinationAlphaMode</span> alphaMode;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (getter=isFlipped) <span class=\"built_in\">BOOL</span> flipped;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (getter=isDithered) <span class=\"built_in\">BOOL</span> dithered;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (getter=isClamped) <span class=\"built_in\">BOOL</span> clamped;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (nullable, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CGColorSpaceRef</span> colorSpace;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (nullable, <span class=\"keyword\">nonatomic</span>, retain) <span class=\"built_in\">CIBlendKernel</span>* blendKernel;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> blendsInDestinationColorSpace;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调试信息\">调试信息</h2><p>这里主要包含两点：</p>\n<ul>\n<li>CIRenderInfo</li>\n<li>Quick Look</li>\n</ul>\n<h3 id=\"CIRenderInfo\">CIRenderInfo</h3><p>CIRenderInfo 是新增的对象，它里面包含了一些有用的信息，比如 kernel 执行耗时，当前有多少数量的像素参与处理等。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// An Xcode quicklook of this object will show a graph visualization of the render</span></span><br><span class=\"line\"><span class=\"comment\">// with detailed timing information.</span></span><br><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE</span>(<span class=\"number\">10</span>_13, <span class=\"number\">11</span>_0)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CIRenderInfo</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *_priv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This property will return how much time a render spent executing kernels.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSTimeInterval</span> kernelExecutionTime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This property will return how many passes the render requires.</span></span><br><span class=\"line\"><span class=\"comment\">// If passCount is 1 than the render can be fully concatinated and no</span></span><br><span class=\"line\"><span class=\"comment\">// intermediate buffers will be required.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSInteger</span> passCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This property will return how many pixels a render produced executing kernels.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSInteger</span> pixelsProcessed;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Quick_Look\">Quick Look</h3><p>Core Image 对很对对象新增了 Quick Look 支持，方便调试查看效果。</p>\n<p>关于调试信息这点，前两篇文章其实有提到其他方式，只是都没有 Quick Look 来得方便。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/499151a6af87609acc2b3c0e0dcc4cc7.png\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ad284913cfc4298cef07170e06696f27.png\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/c64ba6e368ae6dd96cf8d80d7bb44dd2.png\" alt=\"\"></p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/0cb9e4a8b7547a643a9733b8ecd78b07.png\" alt=\"\"></p>\n<p>图表都支持放大查阅，具体的大家可以实际查阅。信息还是很有用的，包含多个滤镜是怎么组合的等等细节。</p>\n<h2 id=\"新功能\">新功能</h2><h3 id=\"New_Filter\">New Filter</h3><p>现在内置了 196 个 filters</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/1af5a34340e9d232a99d2683bc395228.png\" alt=\"\"></p>\n<p>内置的滤镜，有新增，也有性能优化。这里不展开讲。</p>\n<p>一般都是用到的时候，去查找是否有合适的内置滤镜，而不是一开始就把这近 200 个滤镜都掌握下来。</p>\n<p>具体的可以查阅： <a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346\">Core Image Filter Reference</a> </p>\n<h3 id=\"CIBarcodeDescriptor\">CIBarcodeDescriptor</h3><p>App 现在支持各种各样的条码扫描，识别。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/84253106453689f22287df902bd16c1a.png\" alt=\"\"></p>\n<p>并且，各个不同的框架，通过新引入的 CIBarcodeDescriptor，能够协调工作。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ac17593c23d689cebb269dfb217f171b.png\" alt=\"\"></p>\n<p>这里，可以通过 AVFoundation 框架，实时获取图像，并检测识别得到 CIBarcodeDescriptor 对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get a CIBarcodeDescriptor from AVFoundation.framework</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMetadataOutputObjectsDelegate</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">AVCaptureMetadataOutputObjectsDelegate</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">metadataOutput</span><span class=\"params\">(<span class=\"number\">_</span> output: AVCaptureMetadataOutput,</span><br><span class=\"line\">                        didOutput metadataObjects: [AVMetadataObject],</span><br><span class=\"line\">                        from connection: AVCaptureConnection)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mrc = metadataObjects.first <span class=\"keyword\">as</span>? <span class=\"type\">AVMetadataMachineReadableCodeObject</span>,</span><br><span class=\"line\">          <span class=\"keyword\">let</span> descriptor = mrc.descriptor &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(descriptor)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，对于静态图片，或者录制好的视频文件，也可以通过 Vision 框架检测识别得到 CIBarcodeDescriptor 对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Detect a CIBarcodeDescriptor using Vision.framework</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">descriptorFromImage</span><span class=\"params\">(<span class=\"number\">_</span> image: CIImage)</span></span> -&gt; <span class=\"type\">CIBarcodeDescriptor</span>?</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the request and request handler</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> requestHandler = <span class=\"type\">VNImageRequestHandler</span>(ciImage: image, options: [:])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"type\">VNDetectBarcodesRequest</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Send the request to the handler</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>? requestHandler.perform([request])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Get the observation</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> firstResult = request.results?.first </span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstResult?.barcodeDescriptor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而获取到的 CIBarcodeDescriptor，则可以通过 Core Image 进行渲染，得到对应的条码图像。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create an image for a CIBarcodeDescriptor using CoreImage.framework</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">imageFromBarcodeCodeDescriptor</span><span class=\"params\">(<span class=\"number\">_</span> descriptor: CIBarcodeDescriptor)</span></span> -&gt; <span class=\"type\">CIImage</span>? </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIBarcodeGenerator\"</span>, </span><br><span class=\"line\">                    withInputParameters: [<span class=\"string\">\"inputBarcodeDescriptor\"</span> : descriptor])</span><br><span class=\"line\">                      ?.outputImage </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>另外，CIBarcodeDescriptor 提供了许多有用的属性，比如 errorCorrectedPayload，maskPattern 等，便于获取条码的各种信息。</p>\n</blockquote>\n<p>通过这几个框架的无缝结合，可以做一些有趣的事情。</p>\n<p>官方展示了这么一个 Demo，它可以从视频帧中，提取出条码，然后重新渲染到条码上，加上红色遮罩，突出效果。这里有两点很惊艳。</p>\n<ul>\n<li>识别到的条码已经重新渲染的位置都很准确。</li>\n<li>注意看手指遮挡的部分，也能渲染出来。</li>\n</ul>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4f367603d32d8707f1f2e2a84a92c5fe.png\" alt=\"\"></p>\n<h3 id=\"Using_Core_Image_with_Vision\">Using Core Image with Vision</h3><p>这个部分，有种捆绑销售的感觉～强行推一波新加入的 Vision。</p>\n<p>我们知道 Core Image 可以对图像进行处理，比如裁剪，旋转，灰度等等。</p>\n<p>而 Apple 新推出的 Vision 框架，在分析图像方面十分擅长，能提取出很多有用的信息。</p>\n<p>所以它们配合在一起能做一些很棒的事情，比如这里介绍了一个，从一组图片中，生成一张不包含某个对象的图片。</p>\n<blockquote>\n<p>Photo from Video with Removal of Unwanted Objects</p>\n</blockquote>\n<p>具体如下图所示：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/97e8a5bdbe9caac2c1c6b7230e463ccc.png\" alt=\"\"></p>\n<p>从五张同个场景的图片，通过 Vision 和 Core Image 结合，实现去除图片上移动的人物。</p>\n<p>实现这个功能的具体步骤如下：</p>\n<p>从视频中提取序列帧。这里简单的使用 AVFoundation 就能实现，我们可以得到几个对应的 CIImage。</p>\n<p>图像对齐校正。提取出来的几张图片，可能因为拍摄设备的抖动，导致画面并不是完全一致，这时候就需要后期的调整。Vision 为我们提供了一个类 VNHomographicImageRegistrationRequest，专门用来做图像配准的。通过对比两张图片，能得到一个“对齐矩阵”，这样一张图片就能向另一张图片对齐。</p>\n<blockquote>\n<p>An image analysis request that determines the perspective warp matrix needed to align the content of two images.</p>\n<p>Create and perform a homographic image registration request to align content in two images through a homography. A homography is an isomorphism of projected spaces, a bijection that maps lines to lines.</p>\n</blockquote>\n<p>具体代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">homographicTransform</span><span class=\"params\">(from image: CIImage, to reference: CIImage)</span></span> -&gt; matrix_float3x3? &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create the request and request handler</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> request = <span class=\"type\">VNHomographicImageRegistrationRequest</span>(targetedCIImage: image); </span><br><span class=\"line\">  <span class=\"keyword\">let</span> requestHandler = <span class=\"type\">VNImageRequestHandler</span>(ciImage: reference, options: [:]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send the request to the handler</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span>? requestHandler.perform([request]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Get the observation</span></span><br><span class=\"line\">  <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> results = request.results,</span><br><span class=\"line\">        <span class=\"keyword\">let</span> observation = results.first <span class=\"keyword\">as</span>? <span class=\"type\">VNImageHomographicAlignmentObservation</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> observation.warpTransform</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到的矩阵，再传入 CIFilter 中，做对齐，对应的 kernel 脚本如下 ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Core Image Metal kernel to apply a homography matrix</span></span><br><span class=\"line\"><span class=\"function\">float2 <span class=\"title\">warpHomography</span><span class=\"params\">(float3x3 h, destination dest)</span> </span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">  \tfloat3 homogeneousDestCoord = float3(dest.coord(), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">  \tfloat3 homogeneousSrcCoord = h * homogeneousDestCoord;</span><br><span class=\"line\">  \tfloat2 srcCoord = homogeneousSrcCoord.xy / max(homogeneousSrcCoord.z, <span class=\"number\">0.000001</span>);</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> srcCoord; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过这个操作后，得到的 5 张图片，都是对齐过的，场景都是一致的。</p>\n<p>但是画面上，人物的位置是不均匀分布的，所以要使用中位算法，取出最终的画面。</p>\n<p>也就是每个像素点，都是5个图片一起分析，取出相同占比最高的那个像素值，结合成一个新的画面，就能剔除额外的人物。具体脚本如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Core Image Metal kernel to return the median of 5 images</span></span><br><span class=\"line\">inline void <span class=\"built_in\">swap</span>(thread float4 &amp;a, thread float4 &amp;b) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat4 tmp = a; a = <span class=\"built_in\">min</span>(a,b); b = <span class=\"built_in\">max</span>(tmp, b); <span class=\"comment\">// swap sort of two elements </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float4 medianReduction5(sample_t v0, sample_t v1, sample_t v2, sample_t v3, sample_t v4) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// using a Bose-Nelson sorting network</span></span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(v0, v1); <span class=\"built_in\">swap</span>(v3, v4); <span class=\"built_in\">swap</span>(v2, v4); <span class=\"built_in\">swap</span>(v2, v3); <span class=\"built_in\">swap</span>(v0, v3); <span class=\"built_in\">swap</span>(v0, v2); \t<span class=\"built_in\">swap</span>(v1, v4); <span class=\"built_in\">swap</span>(v1, v3); <span class=\"built_in\">swap</span>(v1, v2); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/videos/play/wwdc2017/510/\">Advances in Core Image: Filters, Metal, Vision, and More</a></p>"},{"_content":"# Core Image【4】—— 2018 新特性\n\nCore Image 系列，目前的文章如下：\n\n* Core Image【1】—— 概述\n* Core Image【2】—— 自定义 Filter\n* Core Image【3】—— 2017 新特性\n* Core Image【4】—— 2018 新特性\n\n> 如果想了解 Core Image 相关，建议按序阅读，前后有依赖。\n>\n\n-----\n\n\n\n## 概述\n\n\n\n2018，Core Image 主要更新了三个点：**性能优化**，**原型开发**，**以及与 CoreML 的结合**。\n\n整体更新的不多，但都比较有意思。下面逐一详细阐述。\n\n\n\n## Performance\n\n 性能方面，2018 主要更新了两点：\n\n* intermediate buffers，中间缓存\n* new CIKernel Language features，CIKernel 新特性，按组读写\n\n\n\n\n\n### intermediate buffers\n\n首先，回顾下 Core Image 滤镜链现有的工作方式：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ad4e8443efe38ee5a38d5603c4e6d9b9.png)\n\n我们可以通过这样首尾相连的方式，组合不同的 Filter，达到我们想要的效果，各个 Filter 又对应着各自的 Kernel，我们也可以自定义 Kernel。\n\n> PS：\n>\n> 关于如何使用滤镜链，以及如何自定义 Filter，如果有不了解的，可以翻看前两篇文章。\n>\n> 这里不再阐述。\n\nCore Image 为了性能，包括处理速度，以及降低内存，会自动把整个滤镜链，优化成一个 Filter 处理，如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/8174b09eb717d3a6e27c836268621af0.png)\n\n这可以说是 Core Image 很厉害的地方，也正因为这个特性，Core Image 在处理滤镜链上，性能比 GPUImage 要好得多。\n\n> PS：\n>\n> GPUImage 的做法，和我们平时的处理方式一致，是按序处理的，没有优化，即 **原图— Filter1 —> 结果图1 — Filter2 —> 结果图2 —> Filter3 —> 结果图** 这样的一个过程。这期间产生了两个中间缓存，即 **结果图1** 和 **结果图2**。\n\n当然，Core Image 减少中间缓存，提高性能，绝大多数情况下，都是非常棒的，但也有一些情况下，需要额外去修改，扩展。\n\n比如这样一个场景：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/d747924125e7bb677ab67dc2b964aca7.png)\n\n滤镜链里面的三个滤镜，Sharpen，Hue，Contrast。\n\n其中，**Sharpen 操作是比较耗时的，并且，用户能动态修改的，只有 Contrast。**\n\n所以如果按照常规的做法，每次修改 Contrast 程度值的时候，都重新跑一遍滤镜链，毫无疑问，会造成不必要的性能损耗。因为 Sharpen + Hue 这两个效果，任何情况下，出来的结果图都是一样的（因为没改变这两个 Filter 的程度值），并且它们本身也是比较耗时的。\n\n当然，在介绍 Core Image 新功能之前，我们之前遇到类似的问题，是怎么解决的呢？\n\n很明显，要引入一个临时的 CIImage，接收 Sharpen + Hue 处理出来的 outputImage。然后作为 inputImage，输入给 Contrast Filter。接下去的操作，都只处理 Contrast，它的 inputImage 暂存，固定不变。也就是将原有的一个滤镜链，拆分成两个。\n\n当然，这种做法是可行的，也是目前的通用方式。只是在代码逻辑维护上，需要额外的成本。\n\n那么，Core Image 会如何优化这个问题呢？\n\n![](https://diycode.b0.upaiyun.com/photo/2018/24617819ec01e5faa2d859d6b973201f.png)\n\n它的做法，其实和我们之前提到的一样，iOS 12 之后，CIImage 新增了一个方法，**insertingIntermediate**。\n\n```swift\nfunc insertingIntermediate() -> CIImage\n// Returns a new image created by inserting an intermediate.\n```\n\nHue 得到的 outputImage，调用 insertingIntermediate() 方法，再作为 inputImage 传入 Contrast，优化后的流程如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/8315f8c92ed68db55e7c8f626914cccf.png)\n\n自动组合的逻辑，会根据 insertingIntermediate 做调整。这里，前两个 Filter 自动组合了。\n\n对比我们自己维护多个滤镜链和系统提供的 insertingIntermediate，效率上应该是没什么差异，只是系统的使用起来更加方便罢了。\n\n另外，使用上还要注意什么时候需要缓存，什么时候不需要缓存。Core Image 给我们提供了相关的属性，方便我们控制。\n\n```swift\nstatic let cacheIntermediates: CIContextOption\n// The value for this key is an NSNumber object containing a Boolean value. If this value is false, the context empties such buffers during and after renders. The default value is true.\n\nfunc insertingIntermediate(cache: Bool) -> CIImage\n// Intermediate buffers created through setting cache to true have a higher priority than others. This setting is independent of of CIContext's cacheIntermediates option.\n```\n\n默认是缓存所有的 Intermediates，如果不需要，可以强制关闭。\n\n```swift\nlet context = CIContext(options: [.cacheIntermediates: false] );\n```\n\n当然，CIContext 整体设置不缓存后，也可以针对个别 Intermediates 单独开启，下面的优先级更高\n\n```swift\nimage.insertingIntermediate(cache: true);\n```\n\n总之，决定权在你自己。\n\n\n\n### new CIKernel Language features\n\n在 2017 新特性中，我们提到过，CIKernel 支持 Metal 直接编写。所以目前自定义 Filter 有这么两种方式：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/7417769c610a8b77aec8c523ab21333c.png)\n\n> PS：\n> 这两种之前的文章中都已经详细阐述了，这里不再说明，有疑惑的可以翻看之前的。\n\n但是 iOS 12 之后，主推 Metal，不仅 OpenGL ES 被弃用，这里的 CIKernel Language 编写方式，也被弃用。当然，Metal 的性能优势还是很明显的，所以尽可能的使用 Metal，也是合理的。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/8fba62d2ddfc97a040be3856fab51d2f.png)\n\n\n\n另外，CIKernel 还有两点比较重要的性能优化：\n\n* Half float support\n* Group reads\n\n\n\n**Half float support，支持半精度浮点数。**\n\n很多时候，half float 精度处理出来的效果，是足够好的，比如处理 RGB 的时候。\n\n通过降低精度，使得运行速度变得更快，尤其是在 A11 芯片上。\n另外，half float 的另一个优点是它可以使用更小的寄存器，从而能更充分的利用 GPU，进而提升效率。\n\n\n\n接下去，重点分析下按组读写。\n\n给 shader 提供了新的接口，实现单通道每次读取 4 个像素点，已经每次写入 4 个目标像素值。\n\n这里举了一个卷积操作为例说明。\n\n> PS：\n>\n> 在图像处理中，卷积操作指的是使用一个卷积核对图像中的每个像素进行一系列操作。 \n>\n> 卷积核（算子）是用来做图像处理时的矩阵,图像处理时也称为掩膜，是与原图像做运算的参数。\n>\n> 卷积核通常是一个四方形的网格结构（例如3x3的矩阵或像素区域），该区域上每个方格都有一个权重值。 \n>\n> 使用卷积进行计算时，需要将卷积核的中心放置在要计算的像素上，一次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结构就是该位置的新像素值。 \n>\n> 这里不细说，感兴趣的可以了解下 Convolutional Neural Networks。\n>\n> 如下图所示，展示了一个 3x3 的卷积核在 5x5 的图像上做卷积的过程。每个卷积都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。![卷积神经网络](http://dataunion.org/wp-content/uploads/2015/03/6.gif)\n>\n> 卷积在图像处理中最常见的应用为锐化和边缘提取。 感兴趣可以查阅下 kGPUImageSharpenFragmentShaderString，锐化算法就是根据周围区域像素值，计算得到中心区域最终像素值。\n\n\n\n想象一下，我们有一个 3x3 的单通道卷积运算。按照上图的描述，我们每计算一次目标位置的像素值，就需要 9 次读操作，和 1 次写操作，如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/956d80d5c7b2cd60af05100db38bf59f.png)\n\n\n\n\n再复杂点，如果需要获取 4 个位置的像素值，按照之前逐个读写的方式，那么就需要 36 次的读操作，和 4 次的写操作。但是仔细观察最终读的区域，其实是有很大一部分重复的。如果能一次写入 4 个像素值，那么实际上只有 16 个位置的像素值需要读取。\n![](https://diycode.b0.upaiyun.com/photo/2018/e5091894c8d8cd79f6e9e513f52a263f.png)\n\n而 CIkernel 的一个新特性就是，支持按组写，优化这部分性能，所以上述操作，可以同时进行 16 次读操作，4 次写操作。\n\n再进一步，CIKernel 还支持按组读，所以 16 次读操作，可以细分成 4 组来完成。最终，一次操作会完成：4 组 读，4 次写。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/986c910b79d01b16243733aa509d0da1.png)\n\n具体实践起来，kernel 代码如下：（这里是 r 通道的处理）\n\n先把 float 换成 half，这是之前提到的一个优化点，如下是常规的读 9 次，写 1次。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/35de101cc86080eeb705fe86dffba2fb.png)\n\n\n\n按组读写优化后，代码如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/9cdc0d32222f99e64e8f4dc5e9483a78.png)\n\n这里说明下。\n\n如果需要按照写，那么需要对 dest 添加 group 修饰符。**group::destination_h dest**\n\n蓝色区域，是当前处理的位置，即 dest.coord()。每个格子代表一个像素点。\n\ndc + float2(-0.5, -0.5) 即 g1 的中心。同理可得 g1，g2，g3，g4。这里通过 `s.gatherX`  来实现分组。\n\n然后 r1，即蓝色区域 r 通道值，则是通过周围 9 个像素点计算出来的，即\n\n```c++\nhalf r1 = (g1.x + g1.y + g1.z + g1.w + g2.x + g2.w + g3.x + g3.y + g4.x) / 9.0h;\n```\n\n同理可得，r1，r2，r3，r4。\n最后，按照写入即可。\n```C++\ndest.write(half4(r1, 0,0,1), half4(r2, 0,0,1), half4(r3, 0,0,1), half4(r4, 0,0,1));\n```\n\n在这个简单的例子里，可以得到 2倍的性能提升。\n\n所以其他类似的操作，尤其是卷积运算上，按组读写是一个提高性能的好办法。\n\n\n\n\n## Prototyping\n\n回顾我们平时实现自研效果的流程：\n\n特效同学，在电脑上模拟出最终的效果，然后我们（客户端开发）依照算法规则，在 iOS 平台上实现。\n\n在这个过程中，经常会因为平台差异，或者工具差异，导致最终的效果不一致。比如颜色空间，技术可行性等等。\n\n比如，我们想得到一个 人形区域 mask，可以通过 NumPy，OpenCV，TensorFlow，Python 等进行原型开发。但是在 iOS 平台上具体实现的时候，可以使用的只有 Core Image，Metal，MPS 等完全不同的东西。\n\n这就可能出现因为工具的不完全一致，导致效果错误。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/6f75ea97bce31c1f3583f53236a0edba.png)\n\n还有一个问题，就是性能。\n\n在进行原型开发的时候，平台和工具不同，对内存和CPU／GPU 占用等，都没有具体的参考价值，这导致很多性能问题，会在最终实际开发过程中，才暴露出来。\n\n为了解决上述提到的问题，Apple 引入了 **PyCoreImage**。\n\n> **Python bindings for Core Image.**\n>\n> 把 Core Image 强大的图像处理能力，和 Python 语言的灵活结合起来。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/6d31d0cde0cc10f6ae6904c8cf808374.png)\n\n\n\n使用 PyCoreImage，可以最大程度的模拟真实环境，并且无需额外的学习成本。如果习惯用 Swift 的话，可以直接在 Playground 中模拟效果。\n\n要使用 PyCoreImage，需要借助 Mac OS X 10.5 就引入的 PyObjC，它实现了在 Python 中调用 Objective-C 代码。\n\n下面是一个简单的转换示例：\n\n```objc\n// Objc\n#import <CoreImage/CoreImage.h>\nCIVector *v = [CIVector vectorWithX:0 Y:1 Z:2 W:3];\n// Python\nfrom Quartz import CIVector\nv = CIVector.vectorWithX_Y_Z_W_(0, 1, 2, 3)\n```\n\n![](https://diycode.b0.upaiyun.com/photo/2018/1f60d7db46d202a75a7c565de98b3a91.png)\n\n至于 PyCoreImage 的整体架构，如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/a6c5ee7aca6b0128da518cf2273a4e2e.png)\n\n\n\n**可以通过 NumPy 加载图片，获取二维图像数据数组，转为 CIImage 传入 PyCoreImage 中使用，PyCoreImage 通过 PyObjC，与 Core Image 进行交互，下发指令进行处理。**\n\n> PS：\n>\n> NumPy 是一个为 Python 提供高性能向量、矩阵和高维数据结构的科学计算库。它通过 C 和 Fortran 实现，因此用向量和矩阵建立方程并实现数值计算有非常好的性能。NumPy 基本上是所有使用 Python 进行数值计算的框架和包的基础，例如 TensorFlow 和 PyTorch，构建机器学习模型最基础的内容就是学会使用 NumPy 搭建计算过程。\n>\n> NumPy 主要的运算对象为同质的多维数组，即由同一类型元素（一般是数字）组成的表格，且所有元素通过正整数元组进行索引。\n>\n\n\n\n下面是一个高斯模糊的具体例子：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/520e9259123a89b57904efa8225be7a0.png)\n\n代码很简单，这里不具体说明。\n\n另外，为了降低学习成本，PyCoreImage 对比 Core Image 做了一些简化，比如颜色空间统一为 sRGB 等。绿色标注即差异项：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/c0b518b8dc68e00b780994c71262c308.png)\n\n\n\n下面是一个备忘录，列举了常用的一些操作：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/bb6efbe96c4b43c89ff4201d85f2ccc8.png)\n\n这里额外提一个，Kernel 的加载方式。\n\n自定义 Filter，可以通过如下方式加载并应用效果。这里可以留意到，kernel 和我们在 iOS 上用的完全一致，真正的减少了移植的成本。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4bb2a0a17af53277611da8ada541dc05.png)\n\n\n\n如果想了解这部分的更多知识，包括安装方式，其他 API 等，可以查阅官方文档：\n\n[Prototyping Your App’s Core Image Pipeline with Python](https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python)\n\n\n\n\n\n## Machine Learning\n\n新加入了一个内置 Filter，CICoreMLModelFilter，可以和方便的与 CoreML 结合起来，实现效果。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/9aa47e880bd8c47618449e1d00d28de2.png)\n\n参数十分简洁，就两个，inputImage 和 inputModel。如下：\n\n```swift\nlet result = image.applyingFilter(\"CICoreMLModelFilter\", parameters: [\"inputModel\": model])!\n```\n\n\n\n> PS：\n>\n> 不过目前在官方文档上，还搜不到 CICoreMLModelFilter 的任何内容，内置的 CIFilter 也找不到，估计还没开放。\n\n\n\n关于与 CoreML 的配合，这里还提了一点。\n\n当我们在训练模型的时候，其实就是我们调参的过程，这样模型能将具体的输入（比如说图像）映射为输出（标签）。我们的优化目标就是尽力让模型的损失调低，当然需要往正确的方向调整模型参数才行。成功的神经网络拥有数以百万计的参数！自然而然，如果你有很多参数，就需要为模型展示大量的样本，才能让模型获得良好的性能。\n\n所以说，训练集和模型的准确性成正比。不同类型的大量数据，对神经网络的鲁棒性起着至关重要的作用。\n\n但不得不提到，真实数据的采集是十分困难的。这种情况下，我们一般会借助  **Data Augmentation** 来模拟，填充数据。\n\n> PS：\n>\n> 在深度学习中，有的时候训练集不够多，或者某一类数据较少，或者为了防止过拟合，让模型更加鲁棒性， Data Augmentation 是一个不错的选择。\n>\n> 普通的图像增强方法包括：**翻转、旋转、平移、裁剪、缩放和高斯噪声**；高级版图像增强方法还有**常数填充、反射、边缘延伸、对称和包裹模式**等。\n>\n> 更多的，可以查阅：[使用深度学习(CNN)算法进行图像识别工作时，有哪些data augmentation 的奇技淫巧？](https://www.zhihu.com/question/35339639)\n\n借助 Core Image 内置滤镜，可以十分方便实现图像增强。\n\n如下是几个具体例子：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/41b67e67f039708afa127dffb5fee528.png)\n\n另外，结合 PyCoreImage，在电脑上可以快速生成样本数据。如下是具体的实践代码：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/45d9cb192ff6c84f40ae25c1d2bacaed.png)\n\n运行后，就可以得到大量样本啦～\n\n![](https://diycode.b0.upaiyun.com/photo/2018/5444a7aa0d60df9eabe6a3135943fb44.png)\n\n\n\n\n\n## 延伸阅读\n\n\n\n[Core Image: Performance, Prototyping, and Python](https://developer.apple.com/videos/play/wwdc2018/719/)\n\n[Prototyping Your App’s Core Image Pipeline with Python](https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python)\n\n","source":"_posts/Core-Image-2018.md","raw":"# Core Image【4】—— 2018 新特性\n\nCore Image 系列，目前的文章如下：\n\n* Core Image【1】—— 概述\n* Core Image【2】—— 自定义 Filter\n* Core Image【3】—— 2017 新特性\n* Core Image【4】—— 2018 新特性\n\n> 如果想了解 Core Image 相关，建议按序阅读，前后有依赖。\n>\n\n-----\n\n\n\n## 概述\n\n\n\n2018，Core Image 主要更新了三个点：**性能优化**，**原型开发**，**以及与 CoreML 的结合**。\n\n整体更新的不多，但都比较有意思。下面逐一详细阐述。\n\n\n\n## Performance\n\n 性能方面，2018 主要更新了两点：\n\n* intermediate buffers，中间缓存\n* new CIKernel Language features，CIKernel 新特性，按组读写\n\n\n\n\n\n### intermediate buffers\n\n首先，回顾下 Core Image 滤镜链现有的工作方式：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/ad4e8443efe38ee5a38d5603c4e6d9b9.png)\n\n我们可以通过这样首尾相连的方式，组合不同的 Filter，达到我们想要的效果，各个 Filter 又对应着各自的 Kernel，我们也可以自定义 Kernel。\n\n> PS：\n>\n> 关于如何使用滤镜链，以及如何自定义 Filter，如果有不了解的，可以翻看前两篇文章。\n>\n> 这里不再阐述。\n\nCore Image 为了性能，包括处理速度，以及降低内存，会自动把整个滤镜链，优化成一个 Filter 处理，如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/8174b09eb717d3a6e27c836268621af0.png)\n\n这可以说是 Core Image 很厉害的地方，也正因为这个特性，Core Image 在处理滤镜链上，性能比 GPUImage 要好得多。\n\n> PS：\n>\n> GPUImage 的做法，和我们平时的处理方式一致，是按序处理的，没有优化，即 **原图— Filter1 —> 结果图1 — Filter2 —> 结果图2 —> Filter3 —> 结果图** 这样的一个过程。这期间产生了两个中间缓存，即 **结果图1** 和 **结果图2**。\n\n当然，Core Image 减少中间缓存，提高性能，绝大多数情况下，都是非常棒的，但也有一些情况下，需要额外去修改，扩展。\n\n比如这样一个场景：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/d747924125e7bb677ab67dc2b964aca7.png)\n\n滤镜链里面的三个滤镜，Sharpen，Hue，Contrast。\n\n其中，**Sharpen 操作是比较耗时的，并且，用户能动态修改的，只有 Contrast。**\n\n所以如果按照常规的做法，每次修改 Contrast 程度值的时候，都重新跑一遍滤镜链，毫无疑问，会造成不必要的性能损耗。因为 Sharpen + Hue 这两个效果，任何情况下，出来的结果图都是一样的（因为没改变这两个 Filter 的程度值），并且它们本身也是比较耗时的。\n\n当然，在介绍 Core Image 新功能之前，我们之前遇到类似的问题，是怎么解决的呢？\n\n很明显，要引入一个临时的 CIImage，接收 Sharpen + Hue 处理出来的 outputImage。然后作为 inputImage，输入给 Contrast Filter。接下去的操作，都只处理 Contrast，它的 inputImage 暂存，固定不变。也就是将原有的一个滤镜链，拆分成两个。\n\n当然，这种做法是可行的，也是目前的通用方式。只是在代码逻辑维护上，需要额外的成本。\n\n那么，Core Image 会如何优化这个问题呢？\n\n![](https://diycode.b0.upaiyun.com/photo/2018/24617819ec01e5faa2d859d6b973201f.png)\n\n它的做法，其实和我们之前提到的一样，iOS 12 之后，CIImage 新增了一个方法，**insertingIntermediate**。\n\n```swift\nfunc insertingIntermediate() -> CIImage\n// Returns a new image created by inserting an intermediate.\n```\n\nHue 得到的 outputImage，调用 insertingIntermediate() 方法，再作为 inputImage 传入 Contrast，优化后的流程如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/8315f8c92ed68db55e7c8f626914cccf.png)\n\n自动组合的逻辑，会根据 insertingIntermediate 做调整。这里，前两个 Filter 自动组合了。\n\n对比我们自己维护多个滤镜链和系统提供的 insertingIntermediate，效率上应该是没什么差异，只是系统的使用起来更加方便罢了。\n\n另外，使用上还要注意什么时候需要缓存，什么时候不需要缓存。Core Image 给我们提供了相关的属性，方便我们控制。\n\n```swift\nstatic let cacheIntermediates: CIContextOption\n// The value for this key is an NSNumber object containing a Boolean value. If this value is false, the context empties such buffers during and after renders. The default value is true.\n\nfunc insertingIntermediate(cache: Bool) -> CIImage\n// Intermediate buffers created through setting cache to true have a higher priority than others. This setting is independent of of CIContext's cacheIntermediates option.\n```\n\n默认是缓存所有的 Intermediates，如果不需要，可以强制关闭。\n\n```swift\nlet context = CIContext(options: [.cacheIntermediates: false] );\n```\n\n当然，CIContext 整体设置不缓存后，也可以针对个别 Intermediates 单独开启，下面的优先级更高\n\n```swift\nimage.insertingIntermediate(cache: true);\n```\n\n总之，决定权在你自己。\n\n\n\n### new CIKernel Language features\n\n在 2017 新特性中，我们提到过，CIKernel 支持 Metal 直接编写。所以目前自定义 Filter 有这么两种方式：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/7417769c610a8b77aec8c523ab21333c.png)\n\n> PS：\n> 这两种之前的文章中都已经详细阐述了，这里不再说明，有疑惑的可以翻看之前的。\n\n但是 iOS 12 之后，主推 Metal，不仅 OpenGL ES 被弃用，这里的 CIKernel Language 编写方式，也被弃用。当然，Metal 的性能优势还是很明显的，所以尽可能的使用 Metal，也是合理的。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/8fba62d2ddfc97a040be3856fab51d2f.png)\n\n\n\n另外，CIKernel 还有两点比较重要的性能优化：\n\n* Half float support\n* Group reads\n\n\n\n**Half float support，支持半精度浮点数。**\n\n很多时候，half float 精度处理出来的效果，是足够好的，比如处理 RGB 的时候。\n\n通过降低精度，使得运行速度变得更快，尤其是在 A11 芯片上。\n另外，half float 的另一个优点是它可以使用更小的寄存器，从而能更充分的利用 GPU，进而提升效率。\n\n\n\n接下去，重点分析下按组读写。\n\n给 shader 提供了新的接口，实现单通道每次读取 4 个像素点，已经每次写入 4 个目标像素值。\n\n这里举了一个卷积操作为例说明。\n\n> PS：\n>\n> 在图像处理中，卷积操作指的是使用一个卷积核对图像中的每个像素进行一系列操作。 \n>\n> 卷积核（算子）是用来做图像处理时的矩阵,图像处理时也称为掩膜，是与原图像做运算的参数。\n>\n> 卷积核通常是一个四方形的网格结构（例如3x3的矩阵或像素区域），该区域上每个方格都有一个权重值。 \n>\n> 使用卷积进行计算时，需要将卷积核的中心放置在要计算的像素上，一次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结构就是该位置的新像素值。 \n>\n> 这里不细说，感兴趣的可以了解下 Convolutional Neural Networks。\n>\n> 如下图所示，展示了一个 3x3 的卷积核在 5x5 的图像上做卷积的过程。每个卷积都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。![卷积神经网络](http://dataunion.org/wp-content/uploads/2015/03/6.gif)\n>\n> 卷积在图像处理中最常见的应用为锐化和边缘提取。 感兴趣可以查阅下 kGPUImageSharpenFragmentShaderString，锐化算法就是根据周围区域像素值，计算得到中心区域最终像素值。\n\n\n\n想象一下，我们有一个 3x3 的单通道卷积运算。按照上图的描述，我们每计算一次目标位置的像素值，就需要 9 次读操作，和 1 次写操作，如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/956d80d5c7b2cd60af05100db38bf59f.png)\n\n\n\n\n再复杂点，如果需要获取 4 个位置的像素值，按照之前逐个读写的方式，那么就需要 36 次的读操作，和 4 次的写操作。但是仔细观察最终读的区域，其实是有很大一部分重复的。如果能一次写入 4 个像素值，那么实际上只有 16 个位置的像素值需要读取。\n![](https://diycode.b0.upaiyun.com/photo/2018/e5091894c8d8cd79f6e9e513f52a263f.png)\n\n而 CIkernel 的一个新特性就是，支持按组写，优化这部分性能，所以上述操作，可以同时进行 16 次读操作，4 次写操作。\n\n再进一步，CIKernel 还支持按组读，所以 16 次读操作，可以细分成 4 组来完成。最终，一次操作会完成：4 组 读，4 次写。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/986c910b79d01b16243733aa509d0da1.png)\n\n具体实践起来，kernel 代码如下：（这里是 r 通道的处理）\n\n先把 float 换成 half，这是之前提到的一个优化点，如下是常规的读 9 次，写 1次。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/35de101cc86080eeb705fe86dffba2fb.png)\n\n\n\n按组读写优化后，代码如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/9cdc0d32222f99e64e8f4dc5e9483a78.png)\n\n这里说明下。\n\n如果需要按照写，那么需要对 dest 添加 group 修饰符。**group::destination_h dest**\n\n蓝色区域，是当前处理的位置，即 dest.coord()。每个格子代表一个像素点。\n\ndc + float2(-0.5, -0.5) 即 g1 的中心。同理可得 g1，g2，g3，g4。这里通过 `s.gatherX`  来实现分组。\n\n然后 r1，即蓝色区域 r 通道值，则是通过周围 9 个像素点计算出来的，即\n\n```c++\nhalf r1 = (g1.x + g1.y + g1.z + g1.w + g2.x + g2.w + g3.x + g3.y + g4.x) / 9.0h;\n```\n\n同理可得，r1，r2，r3，r4。\n最后，按照写入即可。\n```C++\ndest.write(half4(r1, 0,0,1), half4(r2, 0,0,1), half4(r3, 0,0,1), half4(r4, 0,0,1));\n```\n\n在这个简单的例子里，可以得到 2倍的性能提升。\n\n所以其他类似的操作，尤其是卷积运算上，按组读写是一个提高性能的好办法。\n\n\n\n\n## Prototyping\n\n回顾我们平时实现自研效果的流程：\n\n特效同学，在电脑上模拟出最终的效果，然后我们（客户端开发）依照算法规则，在 iOS 平台上实现。\n\n在这个过程中，经常会因为平台差异，或者工具差异，导致最终的效果不一致。比如颜色空间，技术可行性等等。\n\n比如，我们想得到一个 人形区域 mask，可以通过 NumPy，OpenCV，TensorFlow，Python 等进行原型开发。但是在 iOS 平台上具体实现的时候，可以使用的只有 Core Image，Metal，MPS 等完全不同的东西。\n\n这就可能出现因为工具的不完全一致，导致效果错误。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/6f75ea97bce31c1f3583f53236a0edba.png)\n\n还有一个问题，就是性能。\n\n在进行原型开发的时候，平台和工具不同，对内存和CPU／GPU 占用等，都没有具体的参考价值，这导致很多性能问题，会在最终实际开发过程中，才暴露出来。\n\n为了解决上述提到的问题，Apple 引入了 **PyCoreImage**。\n\n> **Python bindings for Core Image.**\n>\n> 把 Core Image 强大的图像处理能力，和 Python 语言的灵活结合起来。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/6d31d0cde0cc10f6ae6904c8cf808374.png)\n\n\n\n使用 PyCoreImage，可以最大程度的模拟真实环境，并且无需额外的学习成本。如果习惯用 Swift 的话，可以直接在 Playground 中模拟效果。\n\n要使用 PyCoreImage，需要借助 Mac OS X 10.5 就引入的 PyObjC，它实现了在 Python 中调用 Objective-C 代码。\n\n下面是一个简单的转换示例：\n\n```objc\n// Objc\n#import <CoreImage/CoreImage.h>\nCIVector *v = [CIVector vectorWithX:0 Y:1 Z:2 W:3];\n// Python\nfrom Quartz import CIVector\nv = CIVector.vectorWithX_Y_Z_W_(0, 1, 2, 3)\n```\n\n![](https://diycode.b0.upaiyun.com/photo/2018/1f60d7db46d202a75a7c565de98b3a91.png)\n\n至于 PyCoreImage 的整体架构，如下：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/a6c5ee7aca6b0128da518cf2273a4e2e.png)\n\n\n\n**可以通过 NumPy 加载图片，获取二维图像数据数组，转为 CIImage 传入 PyCoreImage 中使用，PyCoreImage 通过 PyObjC，与 Core Image 进行交互，下发指令进行处理。**\n\n> PS：\n>\n> NumPy 是一个为 Python 提供高性能向量、矩阵和高维数据结构的科学计算库。它通过 C 和 Fortran 实现，因此用向量和矩阵建立方程并实现数值计算有非常好的性能。NumPy 基本上是所有使用 Python 进行数值计算的框架和包的基础，例如 TensorFlow 和 PyTorch，构建机器学习模型最基础的内容就是学会使用 NumPy 搭建计算过程。\n>\n> NumPy 主要的运算对象为同质的多维数组，即由同一类型元素（一般是数字）组成的表格，且所有元素通过正整数元组进行索引。\n>\n\n\n\n下面是一个高斯模糊的具体例子：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/520e9259123a89b57904efa8225be7a0.png)\n\n代码很简单，这里不具体说明。\n\n另外，为了降低学习成本，PyCoreImage 对比 Core Image 做了一些简化，比如颜色空间统一为 sRGB 等。绿色标注即差异项：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/c0b518b8dc68e00b780994c71262c308.png)\n\n\n\n下面是一个备忘录，列举了常用的一些操作：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/bb6efbe96c4b43c89ff4201d85f2ccc8.png)\n\n这里额外提一个，Kernel 的加载方式。\n\n自定义 Filter，可以通过如下方式加载并应用效果。这里可以留意到，kernel 和我们在 iOS 上用的完全一致，真正的减少了移植的成本。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/4bb2a0a17af53277611da8ada541dc05.png)\n\n\n\n如果想了解这部分的更多知识，包括安装方式，其他 API 等，可以查阅官方文档：\n\n[Prototyping Your App’s Core Image Pipeline with Python](https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python)\n\n\n\n\n\n## Machine Learning\n\n新加入了一个内置 Filter，CICoreMLModelFilter，可以和方便的与 CoreML 结合起来，实现效果。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/9aa47e880bd8c47618449e1d00d28de2.png)\n\n参数十分简洁，就两个，inputImage 和 inputModel。如下：\n\n```swift\nlet result = image.applyingFilter(\"CICoreMLModelFilter\", parameters: [\"inputModel\": model])!\n```\n\n\n\n> PS：\n>\n> 不过目前在官方文档上，还搜不到 CICoreMLModelFilter 的任何内容，内置的 CIFilter 也找不到，估计还没开放。\n\n\n\n关于与 CoreML 的配合，这里还提了一点。\n\n当我们在训练模型的时候，其实就是我们调参的过程，这样模型能将具体的输入（比如说图像）映射为输出（标签）。我们的优化目标就是尽力让模型的损失调低，当然需要往正确的方向调整模型参数才行。成功的神经网络拥有数以百万计的参数！自然而然，如果你有很多参数，就需要为模型展示大量的样本，才能让模型获得良好的性能。\n\n所以说，训练集和模型的准确性成正比。不同类型的大量数据，对神经网络的鲁棒性起着至关重要的作用。\n\n但不得不提到，真实数据的采集是十分困难的。这种情况下，我们一般会借助  **Data Augmentation** 来模拟，填充数据。\n\n> PS：\n>\n> 在深度学习中，有的时候训练集不够多，或者某一类数据较少，或者为了防止过拟合，让模型更加鲁棒性， Data Augmentation 是一个不错的选择。\n>\n> 普通的图像增强方法包括：**翻转、旋转、平移、裁剪、缩放和高斯噪声**；高级版图像增强方法还有**常数填充、反射、边缘延伸、对称和包裹模式**等。\n>\n> 更多的，可以查阅：[使用深度学习(CNN)算法进行图像识别工作时，有哪些data augmentation 的奇技淫巧？](https://www.zhihu.com/question/35339639)\n\n借助 Core Image 内置滤镜，可以十分方便实现图像增强。\n\n如下是几个具体例子：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/41b67e67f039708afa127dffb5fee528.png)\n\n另外，结合 PyCoreImage，在电脑上可以快速生成样本数据。如下是具体的实践代码：\n\n![](https://diycode.b0.upaiyun.com/photo/2018/45d9cb192ff6c84f40ae25c1d2bacaed.png)\n\n运行后，就可以得到大量样本啦～\n\n![](https://diycode.b0.upaiyun.com/photo/2018/5444a7aa0d60df9eabe6a3135943fb44.png)\n\n\n\n\n\n## 延伸阅读\n\n\n\n[Core Image: Performance, Prototyping, and Python](https://developer.apple.com/videos/play/wwdc2018/719/)\n\n[Prototyping Your App’s Core Image Pipeline with Python](https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python)\n\n","slug":"Core-Image-2018","published":1,"date":"2019-04-16T06:11:29.937Z","updated":"2019-04-16T06:11:29.937Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4hqrpqd000300lnb2bcypse","content":"<h1 id=\"Core_Image【4】——_2018_新特性\">Core Image【4】—— 2018 新特性</h1><p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li>Core Image【1】—— 概述</li>\n<li>Core Image【2】—— 自定义 Filter</li>\n<li>Core Image【3】—— 2017 新特性</li>\n<li>Core Image【4】—— 2018 新特性</li>\n</ul>\n<blockquote>\n<p>如果想了解 Core Image 相关，建议按序阅读，前后有依赖。</p>\n</blockquote>\n<hr>\n<h2 id=\"概述\">概述</h2><p>2018，Core Image 主要更新了三个点：<strong>性能优化</strong>，<strong>原型开发</strong>，<strong>以及与 CoreML 的结合</strong>。</p>\n<p>整体更新的不多，但都比较有意思。下面逐一详细阐述。</p>\n<h2 id=\"Performance\">Performance</h2><p> 性能方面，2018 主要更新了两点：</p>\n<ul>\n<li>intermediate buffers，中间缓存</li>\n<li>new CIKernel Language features，CIKernel 新特性，按组读写</li>\n</ul>\n<h3 id=\"intermediate_buffers\">intermediate buffers</h3><p>首先，回顾下 Core Image 滤镜链现有的工作方式：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ad4e8443efe38ee5a38d5603c4e6d9b9.png\" alt=\"\"></p>\n<p>我们可以通过这样首尾相连的方式，组合不同的 Filter，达到我们想要的效果，各个 Filter 又对应着各自的 Kernel，我们也可以自定义 Kernel。</p>\n<blockquote>\n<p>PS：</p>\n<p>关于如何使用滤镜链，以及如何自定义 Filter，如果有不了解的，可以翻看前两篇文章。</p>\n<p>这里不再阐述。</p>\n</blockquote>\n<p>Core Image 为了性能，包括处理速度，以及降低内存，会自动把整个滤镜链，优化成一个 Filter 处理，如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/8174b09eb717d3a6e27c836268621af0.png\" alt=\"\"></p>\n<p>这可以说是 Core Image 很厉害的地方，也正因为这个特性，Core Image 在处理滤镜链上，性能比 GPUImage 要好得多。</p>\n<blockquote>\n<p>PS：</p>\n<p>GPUImage 的做法，和我们平时的处理方式一致，是按序处理的，没有优化，即 <strong>原图— Filter1 —&gt; 结果图1 — Filter2 —&gt; 结果图2 —&gt; Filter3 —&gt; 结果图</strong> 这样的一个过程。这期间产生了两个中间缓存，即 <strong>结果图1</strong> 和 <strong>结果图2</strong>。</p>\n</blockquote>\n<p>当然，Core Image 减少中间缓存，提高性能，绝大多数情况下，都是非常棒的，但也有一些情况下，需要额外去修改，扩展。</p>\n<p>比如这样一个场景：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/d747924125e7bb677ab67dc2b964aca7.png\" alt=\"\"></p>\n<p>滤镜链里面的三个滤镜，Sharpen，Hue，Contrast。</p>\n<p>其中，<strong>Sharpen 操作是比较耗时的，并且，用户能动态修改的，只有 Contrast。</strong></p>\n<p>所以如果按照常规的做法，每次修改 Contrast 程度值的时候，都重新跑一遍滤镜链，毫无疑问，会造成不必要的性能损耗。因为 Sharpen + Hue 这两个效果，任何情况下，出来的结果图都是一样的（因为没改变这两个 Filter 的程度值），并且它们本身也是比较耗时的。</p>\n<p>当然，在介绍 Core Image 新功能之前，我们之前遇到类似的问题，是怎么解决的呢？</p>\n<p>很明显，要引入一个临时的 CIImage，接收 Sharpen + Hue 处理出来的 outputImage。然后作为 inputImage，输入给 Contrast Filter。接下去的操作，都只处理 Contrast，它的 inputImage 暂存，固定不变。也就是将原有的一个滤镜链，拆分成两个。</p>\n<p>当然，这种做法是可行的，也是目前的通用方式。只是在代码逻辑维护上，需要额外的成本。</p>\n<p>那么，Core Image 会如何优化这个问题呢？</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/24617819ec01e5faa2d859d6b973201f.png\" alt=\"\"></p>\n<p>它的做法，其实和我们之前提到的一样，iOS 12 之后，CIImage 新增了一个方法，<strong>insertingIntermediate</strong>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertingIntermediate</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">CIImage</span></span><br><span class=\"line\"><span class=\"comment\">// Returns a new image created by inserting an intermediate.</span></span><br></pre></td></tr></table></figure>\n<p>Hue 得到的 outputImage，调用 insertingIntermediate() 方法，再作为 inputImage 传入 Contrast，优化后的流程如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/8315f8c92ed68db55e7c8f626914cccf.png\" alt=\"\"></p>\n<p>自动组合的逻辑，会根据 insertingIntermediate 做调整。这里，前两个 Filter 自动组合了。</p>\n<p>对比我们自己维护多个滤镜链和系统提供的 insertingIntermediate，效率上应该是没什么差异，只是系统的使用起来更加方便罢了。</p>\n<p>另外，使用上还要注意什么时候需要缓存，什么时候不需要缓存。Core Image 给我们提供了相关的属性，方便我们控制。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">let</span> cacheIntermediates: <span class=\"type\">CIContextOption</span></span><br><span class=\"line\"><span class=\"comment\">// The value for this key is an NSNumber object containing a Boolean value. If this value is false, the context empties such buffers during and after renders. The default value is true.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertingIntermediate</span><span class=\"params\">(cache: Bool)</span></span> -&gt; <span class=\"type\">CIImage</span></span><br><span class=\"line\"><span class=\"comment\">// Intermediate buffers created through setting cache to true have a higher priority than others. This setting is independent of of CIContext's cacheIntermediates option.</span></span><br></pre></td></tr></table></figure>\n<p>默认是缓存所有的 Intermediates，如果不需要，可以强制关闭。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> context = <span class=\"type\">CIContext</span>(options: [.cacheIntermediates: <span class=\"literal\">false</span>] );</span><br></pre></td></tr></table></figure>\n<p>当然，CIContext 整体设置不缓存后，也可以针对个别 Intermediates 单独开启，下面的优先级更高</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image.insertingIntermediate(cache: <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>总之，决定权在你自己。</p>\n<h3 id=\"new_CIKernel_Language_features\">new CIKernel Language features</h3><p>在 2017 新特性中，我们提到过，CIKernel 支持 Metal 直接编写。所以目前自定义 Filter 有这么两种方式：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/7417769c610a8b77aec8c523ab21333c.png\" alt=\"\"></p>\n<blockquote>\n<p>PS：<br>这两种之前的文章中都已经详细阐述了，这里不再说明，有疑惑的可以翻看之前的。</p>\n</blockquote>\n<p>但是 iOS 12 之后，主推 Metal，不仅 OpenGL ES 被弃用，这里的 CIKernel Language 编写方式，也被弃用。当然，Metal 的性能优势还是很明显的，所以尽可能的使用 Metal，也是合理的。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/8fba62d2ddfc97a040be3856fab51d2f.png\" alt=\"\"></p>\n<p>另外，CIKernel 还有两点比较重要的性能优化：</p>\n<ul>\n<li>Half float support</li>\n<li>Group reads</li>\n</ul>\n<p><strong>Half float support，支持半精度浮点数。</strong></p>\n<p>很多时候，half float 精度处理出来的效果，是足够好的，比如处理 RGB 的时候。</p>\n<p>通过降低精度，使得运行速度变得更快，尤其是在 A11 芯片上。<br>另外，half float 的另一个优点是它可以使用更小的寄存器，从而能更充分的利用 GPU，进而提升效率。</p>\n<p>接下去，重点分析下按组读写。</p>\n<p>给 shader 提供了新的接口，实现单通道每次读取 4 个像素点，已经每次写入 4 个目标像素值。</p>\n<p>这里举了一个卷积操作为例说明。</p>\n<blockquote>\n<p>PS：</p>\n<p>在图像处理中，卷积操作指的是使用一个卷积核对图像中的每个像素进行一系列操作。 </p>\n<p>卷积核（算子）是用来做图像处理时的矩阵,图像处理时也称为掩膜，是与原图像做运算的参数。</p>\n<p>卷积核通常是一个四方形的网格结构（例如3x3的矩阵或像素区域），该区域上每个方格都有一个权重值。 </p>\n<p>使用卷积进行计算时，需要将卷积核的中心放置在要计算的像素上，一次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结构就是该位置的新像素值。 </p>\n<p>这里不细说，感兴趣的可以了解下 Convolutional Neural Networks。</p>\n<p>如下图所示，展示了一个 3x3 的卷积核在 5x5 的图像上做卷积的过程。每个卷积都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。<img src=\"http://dataunion.org/wp-content/uploads/2015/03/6.gif\" alt=\"卷积神经网络\"></p>\n<p>卷积在图像处理中最常见的应用为锐化和边缘提取。 感兴趣可以查阅下 kGPUImageSharpenFragmentShaderString，锐化算法就是根据周围区域像素值，计算得到中心区域最终像素值。</p>\n</blockquote>\n<p>想象一下，我们有一个 3x3 的单通道卷积运算。按照上图的描述，我们每计算一次目标位置的像素值，就需要 9 次读操作，和 1 次写操作，如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/956d80d5c7b2cd60af05100db38bf59f.png\" alt=\"\"></p>\n<p>再复杂点，如果需要获取 4 个位置的像素值，按照之前逐个读写的方式，那么就需要 36 次的读操作，和 4 次的写操作。但是仔细观察最终读的区域，其实是有很大一部分重复的。如果能一次写入 4 个像素值，那么实际上只有 16 个位置的像素值需要读取。<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e5091894c8d8cd79f6e9e513f52a263f.png\" alt=\"\"></p>\n<p>而 CIkernel 的一个新特性就是，支持按组写，优化这部分性能，所以上述操作，可以同时进行 16 次读操作，4 次写操作。</p>\n<p>再进一步，CIKernel 还支持按组读，所以 16 次读操作，可以细分成 4 组来完成。最终，一次操作会完成：4 组 读，4 次写。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/986c910b79d01b16243733aa509d0da1.png\" alt=\"\"></p>\n<p>具体实践起来，kernel 代码如下：（这里是 r 通道的处理）</p>\n<p>先把 float 换成 half，这是之前提到的一个优化点，如下是常规的读 9 次，写 1次。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/35de101cc86080eeb705fe86dffba2fb.png\" alt=\"\"></p>\n<p>按组读写优化后，代码如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/9cdc0d32222f99e64e8f4dc5e9483a78.png\" alt=\"\"></p>\n<p>这里说明下。</p>\n<p>如果需要按照写，那么需要对 dest 添加 group 修饰符。<strong>group::destination_h dest</strong></p>\n<p>蓝色区域，是当前处理的位置，即 dest.coord()。每个格子代表一个像素点。</p>\n<p>dc + float2(-0.5, -0.5) 即 g1 的中心。同理可得 g1，g2，g3，g4。这里通过 <code>s.gatherX</code>  来实现分组。</p>\n<p>然后 r1，即蓝色区域 r 通道值，则是通过周围 9 个像素点计算出来的，即</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">half r1 = (g1.x + g1.y + g1.z + g1.w + g2.x + g2.w + g3.x + g3.y + g4.x) / <span class=\"number\">9.0</span>h;</span><br></pre></td></tr></table></figure>\n<p>同理可得，r1，r2，r3，r4。<br>最后，按照写入即可。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest.write(half4(r1, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>), half4(r2, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>), half4(r3, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>), half4(r4, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure></p>\n<p>在这个简单的例子里，可以得到 2倍的性能提升。</p>\n<p>所以其他类似的操作，尤其是卷积运算上，按组读写是一个提高性能的好办法。</p>\n<h2 id=\"Prototyping\">Prototyping</h2><p>回顾我们平时实现自研效果的流程：</p>\n<p>特效同学，在电脑上模拟出最终的效果，然后我们（客户端开发）依照算法规则，在 iOS 平台上实现。</p>\n<p>在这个过程中，经常会因为平台差异，或者工具差异，导致最终的效果不一致。比如颜色空间，技术可行性等等。</p>\n<p>比如，我们想得到一个 人形区域 mask，可以通过 NumPy，OpenCV，TensorFlow，Python 等进行原型开发。但是在 iOS 平台上具体实现的时候，可以使用的只有 Core Image，Metal，MPS 等完全不同的东西。</p>\n<p>这就可能出现因为工具的不完全一致，导致效果错误。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/6f75ea97bce31c1f3583f53236a0edba.png\" alt=\"\"></p>\n<p>还有一个问题，就是性能。</p>\n<p>在进行原型开发的时候，平台和工具不同，对内存和CPU／GPU 占用等，都没有具体的参考价值，这导致很多性能问题，会在最终实际开发过程中，才暴露出来。</p>\n<p>为了解决上述提到的问题，Apple 引入了 <strong>PyCoreImage</strong>。</p>\n<blockquote>\n<p><strong>Python bindings for Core Image.</strong></p>\n<p>把 Core Image 强大的图像处理能力，和 Python 语言的灵活结合起来。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/6d31d0cde0cc10f6ae6904c8cf808374.png\" alt=\"\"></p>\n<p>使用 PyCoreImage，可以最大程度的模拟真实环境，并且无需额外的学习成本。如果习惯用 Swift 的话，可以直接在 Playground 中模拟效果。</p>\n<p>要使用 PyCoreImage，需要借助 Mac OS X 10.5 就引入的 PyObjC，它实现了在 Python 中调用 Objective-C 代码。</p>\n<p>下面是一个简单的转换示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Objc</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CoreImage/CoreImage.h&gt;</span></span></span><br><span class=\"line\"><span class=\"built_in\">CIVector</span> *v = [<span class=\"built_in\">CIVector</span> vectorWithX:<span class=\"number\">0</span> Y:<span class=\"number\">1</span> Z:<span class=\"number\">2</span> W:<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// Python</span></span><br><span class=\"line\">from Quartz import <span class=\"built_in\">CIVector</span></span><br><span class=\"line\">v = <span class=\"built_in\">CIVector</span>.vectorWithX_Y_Z_W_(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/1f60d7db46d202a75a7c565de98b3a91.png\" alt=\"\"></p>\n<p>至于 PyCoreImage 的整体架构，如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/a6c5ee7aca6b0128da518cf2273a4e2e.png\" alt=\"\"></p>\n<p><strong>可以通过 NumPy 加载图片，获取二维图像数据数组，转为 CIImage 传入 PyCoreImage 中使用，PyCoreImage 通过 PyObjC，与 Core Image 进行交互，下发指令进行处理。</strong></p>\n<blockquote>\n<p>PS：</p>\n<p>NumPy 是一个为 Python 提供高性能向量、矩阵和高维数据结构的科学计算库。它通过 C 和 Fortran 实现，因此用向量和矩阵建立方程并实现数值计算有非常好的性能。NumPy 基本上是所有使用 Python 进行数值计算的框架和包的基础，例如 TensorFlow 和 PyTorch，构建机器学习模型最基础的内容就是学会使用 NumPy 搭建计算过程。</p>\n<p>NumPy 主要的运算对象为同质的多维数组，即由同一类型元素（一般是数字）组成的表格，且所有元素通过正整数元组进行索引。</p>\n</blockquote>\n<p>下面是一个高斯模糊的具体例子：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/520e9259123a89b57904efa8225be7a0.png\" alt=\"\"></p>\n<p>代码很简单，这里不具体说明。</p>\n<p>另外，为了降低学习成本，PyCoreImage 对比 Core Image 做了一些简化，比如颜色空间统一为 sRGB 等。绿色标注即差异项：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/c0b518b8dc68e00b780994c71262c308.png\" alt=\"\"></p>\n<p>下面是一个备忘录，列举了常用的一些操作：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/bb6efbe96c4b43c89ff4201d85f2ccc8.png\" alt=\"\"></p>\n<p>这里额外提一个，Kernel 的加载方式。</p>\n<p>自定义 Filter，可以通过如下方式加载并应用效果。这里可以留意到，kernel 和我们在 iOS 上用的完全一致，真正的减少了移植的成本。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4bb2a0a17af53277611da8ada541dc05.png\" alt=\"\"></p>\n<p>如果想了解这部分的更多知识，包括安装方式，其他 API 等，可以查阅官方文档：</p>\n<p><a href=\"https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python\" target=\"_blank\" rel=\"external\">Prototyping Your App’s Core Image Pipeline with Python</a></p>\n<h2 id=\"Machine_Learning\">Machine Learning</h2><p>新加入了一个内置 Filter，CICoreMLModelFilter，可以和方便的与 CoreML 结合起来，实现效果。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/9aa47e880bd8c47618449e1d00d28de2.png\" alt=\"\"></p>\n<p>参数十分简洁，就两个，inputImage 和 inputModel。如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = image.applyingFilter(<span class=\"string\">\"CICoreMLModelFilter\"</span>, parameters: [<span class=\"string\">\"inputModel\"</span>: model])!</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>不过目前在官方文档上，还搜不到 CICoreMLModelFilter 的任何内容，内置的 CIFilter 也找不到，估计还没开放。</p>\n</blockquote>\n<p>关于与 CoreML 的配合，这里还提了一点。</p>\n<p>当我们在训练模型的时候，其实就是我们调参的过程，这样模型能将具体的输入（比如说图像）映射为输出（标签）。我们的优化目标就是尽力让模型的损失调低，当然需要往正确的方向调整模型参数才行。成功的神经网络拥有数以百万计的参数！自然而然，如果你有很多参数，就需要为模型展示大量的样本，才能让模型获得良好的性能。</p>\n<p>所以说，训练集和模型的准确性成正比。不同类型的大量数据，对神经网络的鲁棒性起着至关重要的作用。</p>\n<p>但不得不提到，真实数据的采集是十分困难的。这种情况下，我们一般会借助  <strong>Data Augmentation</strong> 来模拟，填充数据。</p>\n<blockquote>\n<p>PS：</p>\n<p>在深度学习中，有的时候训练集不够多，或者某一类数据较少，或者为了防止过拟合，让模型更加鲁棒性， Data Augmentation 是一个不错的选择。</p>\n<p>普通的图像增强方法包括：<strong>翻转、旋转、平移、裁剪、缩放和高斯噪声</strong>；高级版图像增强方法还有<strong>常数填充、反射、边缘延伸、对称和包裹模式</strong>等。</p>\n<p>更多的，可以查阅：<a href=\"https://www.zhihu.com/question/35339639\" target=\"_blank\" rel=\"external\">使用深度学习(CNN)算法进行图像识别工作时，有哪些data augmentation 的奇技淫巧？</a></p>\n</blockquote>\n<p>借助 Core Image 内置滤镜，可以十分方便实现图像增强。</p>\n<p>如下是几个具体例子：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/41b67e67f039708afa127dffb5fee528.png\" alt=\"\"></p>\n<p>另外，结合 PyCoreImage，在电脑上可以快速生成样本数据。如下是具体的实践代码：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/45d9cb192ff6c84f40ae25c1d2bacaed.png\" alt=\"\"></p>\n<p>运行后，就可以得到大量样本啦～</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5444a7aa0d60df9eabe6a3135943fb44.png\" alt=\"\"></p>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/videos/play/wwdc2018/719/\" target=\"_blank\" rel=\"external\">Core Image: Performance, Prototyping, and Python</a></p>\n<p><a href=\"https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python\" target=\"_blank\" rel=\"external\">Prototyping Your App’s Core Image Pipeline with Python</a></p>\n","excerpt":"","more":"<h1 id=\"Core_Image【4】——_2018_新特性\">Core Image【4】—— 2018 新特性</h1><p>Core Image 系列，目前的文章如下：</p>\n<ul>\n<li>Core Image【1】—— 概述</li>\n<li>Core Image【2】—— 自定义 Filter</li>\n<li>Core Image【3】—— 2017 新特性</li>\n<li>Core Image【4】—— 2018 新特性</li>\n</ul>\n<blockquote>\n<p>如果想了解 Core Image 相关，建议按序阅读，前后有依赖。</p>\n</blockquote>\n<hr>\n<h2 id=\"概述\">概述</h2><p>2018，Core Image 主要更新了三个点：<strong>性能优化</strong>，<strong>原型开发</strong>，<strong>以及与 CoreML 的结合</strong>。</p>\n<p>整体更新的不多，但都比较有意思。下面逐一详细阐述。</p>\n<h2 id=\"Performance\">Performance</h2><p> 性能方面，2018 主要更新了两点：</p>\n<ul>\n<li>intermediate buffers，中间缓存</li>\n<li>new CIKernel Language features，CIKernel 新特性，按组读写</li>\n</ul>\n<h3 id=\"intermediate_buffers\">intermediate buffers</h3><p>首先，回顾下 Core Image 滤镜链现有的工作方式：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/ad4e8443efe38ee5a38d5603c4e6d9b9.png\" alt=\"\"></p>\n<p>我们可以通过这样首尾相连的方式，组合不同的 Filter，达到我们想要的效果，各个 Filter 又对应着各自的 Kernel，我们也可以自定义 Kernel。</p>\n<blockquote>\n<p>PS：</p>\n<p>关于如何使用滤镜链，以及如何自定义 Filter，如果有不了解的，可以翻看前两篇文章。</p>\n<p>这里不再阐述。</p>\n</blockquote>\n<p>Core Image 为了性能，包括处理速度，以及降低内存，会自动把整个滤镜链，优化成一个 Filter 处理，如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/8174b09eb717d3a6e27c836268621af0.png\" alt=\"\"></p>\n<p>这可以说是 Core Image 很厉害的地方，也正因为这个特性，Core Image 在处理滤镜链上，性能比 GPUImage 要好得多。</p>\n<blockquote>\n<p>PS：</p>\n<p>GPUImage 的做法，和我们平时的处理方式一致，是按序处理的，没有优化，即 <strong>原图— Filter1 —&gt; 结果图1 — Filter2 —&gt; 结果图2 —&gt; Filter3 —&gt; 结果图</strong> 这样的一个过程。这期间产生了两个中间缓存，即 <strong>结果图1</strong> 和 <strong>结果图2</strong>。</p>\n</blockquote>\n<p>当然，Core Image 减少中间缓存，提高性能，绝大多数情况下，都是非常棒的，但也有一些情况下，需要额外去修改，扩展。</p>\n<p>比如这样一个场景：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/d747924125e7bb677ab67dc2b964aca7.png\" alt=\"\"></p>\n<p>滤镜链里面的三个滤镜，Sharpen，Hue，Contrast。</p>\n<p>其中，<strong>Sharpen 操作是比较耗时的，并且，用户能动态修改的，只有 Contrast。</strong></p>\n<p>所以如果按照常规的做法，每次修改 Contrast 程度值的时候，都重新跑一遍滤镜链，毫无疑问，会造成不必要的性能损耗。因为 Sharpen + Hue 这两个效果，任何情况下，出来的结果图都是一样的（因为没改变这两个 Filter 的程度值），并且它们本身也是比较耗时的。</p>\n<p>当然，在介绍 Core Image 新功能之前，我们之前遇到类似的问题，是怎么解决的呢？</p>\n<p>很明显，要引入一个临时的 CIImage，接收 Sharpen + Hue 处理出来的 outputImage。然后作为 inputImage，输入给 Contrast Filter。接下去的操作，都只处理 Contrast，它的 inputImage 暂存，固定不变。也就是将原有的一个滤镜链，拆分成两个。</p>\n<p>当然，这种做法是可行的，也是目前的通用方式。只是在代码逻辑维护上，需要额外的成本。</p>\n<p>那么，Core Image 会如何优化这个问题呢？</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/24617819ec01e5faa2d859d6b973201f.png\" alt=\"\"></p>\n<p>它的做法，其实和我们之前提到的一样，iOS 12 之后，CIImage 新增了一个方法，<strong>insertingIntermediate</strong>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertingIntermediate</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">CIImage</span></span><br><span class=\"line\"><span class=\"comment\">// Returns a new image created by inserting an intermediate.</span></span><br></pre></td></tr></table></figure>\n<p>Hue 得到的 outputImage，调用 insertingIntermediate() 方法，再作为 inputImage 传入 Contrast，优化后的流程如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/8315f8c92ed68db55e7c8f626914cccf.png\" alt=\"\"></p>\n<p>自动组合的逻辑，会根据 insertingIntermediate 做调整。这里，前两个 Filter 自动组合了。</p>\n<p>对比我们自己维护多个滤镜链和系统提供的 insertingIntermediate，效率上应该是没什么差异，只是系统的使用起来更加方便罢了。</p>\n<p>另外，使用上还要注意什么时候需要缓存，什么时候不需要缓存。Core Image 给我们提供了相关的属性，方便我们控制。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">let</span> cacheIntermediates: <span class=\"type\">CIContextOption</span></span><br><span class=\"line\"><span class=\"comment\">// The value for this key is an NSNumber object containing a Boolean value. If this value is false, the context empties such buffers during and after renders. The default value is true.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertingIntermediate</span><span class=\"params\">(cache: Bool)</span></span> -&gt; <span class=\"type\">CIImage</span></span><br><span class=\"line\"><span class=\"comment\">// Intermediate buffers created through setting cache to true have a higher priority than others. This setting is independent of of CIContext's cacheIntermediates option.</span></span><br></pre></td></tr></table></figure>\n<p>默认是缓存所有的 Intermediates，如果不需要，可以强制关闭。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> context = <span class=\"type\">CIContext</span>(options: [.cacheIntermediates: <span class=\"literal\">false</span>] );</span><br></pre></td></tr></table></figure>\n<p>当然，CIContext 整体设置不缓存后，也可以针对个别 Intermediates 单独开启，下面的优先级更高</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image.insertingIntermediate(cache: <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>总之，决定权在你自己。</p>\n<h3 id=\"new_CIKernel_Language_features\">new CIKernel Language features</h3><p>在 2017 新特性中，我们提到过，CIKernel 支持 Metal 直接编写。所以目前自定义 Filter 有这么两种方式：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/7417769c610a8b77aec8c523ab21333c.png\" alt=\"\"></p>\n<blockquote>\n<p>PS：<br>这两种之前的文章中都已经详细阐述了，这里不再说明，有疑惑的可以翻看之前的。</p>\n</blockquote>\n<p>但是 iOS 12 之后，主推 Metal，不仅 OpenGL ES 被弃用，这里的 CIKernel Language 编写方式，也被弃用。当然，Metal 的性能优势还是很明显的，所以尽可能的使用 Metal，也是合理的。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/8fba62d2ddfc97a040be3856fab51d2f.png\" alt=\"\"></p>\n<p>另外，CIKernel 还有两点比较重要的性能优化：</p>\n<ul>\n<li>Half float support</li>\n<li>Group reads</li>\n</ul>\n<p><strong>Half float support，支持半精度浮点数。</strong></p>\n<p>很多时候，half float 精度处理出来的效果，是足够好的，比如处理 RGB 的时候。</p>\n<p>通过降低精度，使得运行速度变得更快，尤其是在 A11 芯片上。<br>另外，half float 的另一个优点是它可以使用更小的寄存器，从而能更充分的利用 GPU，进而提升效率。</p>\n<p>接下去，重点分析下按组读写。</p>\n<p>给 shader 提供了新的接口，实现单通道每次读取 4 个像素点，已经每次写入 4 个目标像素值。</p>\n<p>这里举了一个卷积操作为例说明。</p>\n<blockquote>\n<p>PS：</p>\n<p>在图像处理中，卷积操作指的是使用一个卷积核对图像中的每个像素进行一系列操作。 </p>\n<p>卷积核（算子）是用来做图像处理时的矩阵,图像处理时也称为掩膜，是与原图像做运算的参数。</p>\n<p>卷积核通常是一个四方形的网格结构（例如3x3的矩阵或像素区域），该区域上每个方格都有一个权重值。 </p>\n<p>使用卷积进行计算时，需要将卷积核的中心放置在要计算的像素上，一次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结构就是该位置的新像素值。 </p>\n<p>这里不细说，感兴趣的可以了解下 Convolutional Neural Networks。</p>\n<p>如下图所示，展示了一个 3x3 的卷积核在 5x5 的图像上做卷积的过程。每个卷积都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。<img src=\"http://dataunion.org/wp-content/uploads/2015/03/6.gif\" alt=\"卷积神经网络\"></p>\n<p>卷积在图像处理中最常见的应用为锐化和边缘提取。 感兴趣可以查阅下 kGPUImageSharpenFragmentShaderString，锐化算法就是根据周围区域像素值，计算得到中心区域最终像素值。</p>\n</blockquote>\n<p>想象一下，我们有一个 3x3 的单通道卷积运算。按照上图的描述，我们每计算一次目标位置的像素值，就需要 9 次读操作，和 1 次写操作，如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/956d80d5c7b2cd60af05100db38bf59f.png\" alt=\"\"></p>\n<p>再复杂点，如果需要获取 4 个位置的像素值，按照之前逐个读写的方式，那么就需要 36 次的读操作，和 4 次的写操作。但是仔细观察最终读的区域，其实是有很大一部分重复的。如果能一次写入 4 个像素值，那么实际上只有 16 个位置的像素值需要读取。<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e5091894c8d8cd79f6e9e513f52a263f.png\" alt=\"\"></p>\n<p>而 CIkernel 的一个新特性就是，支持按组写，优化这部分性能，所以上述操作，可以同时进行 16 次读操作，4 次写操作。</p>\n<p>再进一步，CIKernel 还支持按组读，所以 16 次读操作，可以细分成 4 组来完成。最终，一次操作会完成：4 组 读，4 次写。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/986c910b79d01b16243733aa509d0da1.png\" alt=\"\"></p>\n<p>具体实践起来，kernel 代码如下：（这里是 r 通道的处理）</p>\n<p>先把 float 换成 half，这是之前提到的一个优化点，如下是常规的读 9 次，写 1次。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/35de101cc86080eeb705fe86dffba2fb.png\" alt=\"\"></p>\n<p>按组读写优化后，代码如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/9cdc0d32222f99e64e8f4dc5e9483a78.png\" alt=\"\"></p>\n<p>这里说明下。</p>\n<p>如果需要按照写，那么需要对 dest 添加 group 修饰符。<strong>group::destination_h dest</strong></p>\n<p>蓝色区域，是当前处理的位置，即 dest.coord()。每个格子代表一个像素点。</p>\n<p>dc + float2(-0.5, -0.5) 即 g1 的中心。同理可得 g1，g2，g3，g4。这里通过 <code>s.gatherX</code>  来实现分组。</p>\n<p>然后 r1，即蓝色区域 r 通道值，则是通过周围 9 个像素点计算出来的，即</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">half r1 = (g1.x + g1.y + g1.z + g1.w + g2.x + g2.w + g3.x + g3.y + g4.x) / <span class=\"number\">9.0</span>h;</span><br></pre></td></tr></table></figure>\n<p>同理可得，r1，r2，r3，r4。<br>最后，按照写入即可。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest.write(half4(r1, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>), half4(r2, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>), half4(r3, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>), half4(r4, <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure></p>\n<p>在这个简单的例子里，可以得到 2倍的性能提升。</p>\n<p>所以其他类似的操作，尤其是卷积运算上，按组读写是一个提高性能的好办法。</p>\n<h2 id=\"Prototyping\">Prototyping</h2><p>回顾我们平时实现自研效果的流程：</p>\n<p>特效同学，在电脑上模拟出最终的效果，然后我们（客户端开发）依照算法规则，在 iOS 平台上实现。</p>\n<p>在这个过程中，经常会因为平台差异，或者工具差异，导致最终的效果不一致。比如颜色空间，技术可行性等等。</p>\n<p>比如，我们想得到一个 人形区域 mask，可以通过 NumPy，OpenCV，TensorFlow，Python 等进行原型开发。但是在 iOS 平台上具体实现的时候，可以使用的只有 Core Image，Metal，MPS 等完全不同的东西。</p>\n<p>这就可能出现因为工具的不完全一致，导致效果错误。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/6f75ea97bce31c1f3583f53236a0edba.png\" alt=\"\"></p>\n<p>还有一个问题，就是性能。</p>\n<p>在进行原型开发的时候，平台和工具不同，对内存和CPU／GPU 占用等，都没有具体的参考价值，这导致很多性能问题，会在最终实际开发过程中，才暴露出来。</p>\n<p>为了解决上述提到的问题，Apple 引入了 <strong>PyCoreImage</strong>。</p>\n<blockquote>\n<p><strong>Python bindings for Core Image.</strong></p>\n<p>把 Core Image 强大的图像处理能力，和 Python 语言的灵活结合起来。</p>\n</blockquote>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/6d31d0cde0cc10f6ae6904c8cf808374.png\" alt=\"\"></p>\n<p>使用 PyCoreImage，可以最大程度的模拟真实环境，并且无需额外的学习成本。如果习惯用 Swift 的话，可以直接在 Playground 中模拟效果。</p>\n<p>要使用 PyCoreImage，需要借助 Mac OS X 10.5 就引入的 PyObjC，它实现了在 Python 中调用 Objective-C 代码。</p>\n<p>下面是一个简单的转换示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Objc</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CoreImage/CoreImage.h&gt;</span></span></span><br><span class=\"line\"><span class=\"built_in\">CIVector</span> *v = [<span class=\"built_in\">CIVector</span> vectorWithX:<span class=\"number\">0</span> Y:<span class=\"number\">1</span> Z:<span class=\"number\">2</span> W:<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// Python</span></span><br><span class=\"line\">from Quartz import <span class=\"built_in\">CIVector</span></span><br><span class=\"line\">v = <span class=\"built_in\">CIVector</span>.vectorWithX_Y_Z_W_(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/1f60d7db46d202a75a7c565de98b3a91.png\" alt=\"\"></p>\n<p>至于 PyCoreImage 的整体架构，如下：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/a6c5ee7aca6b0128da518cf2273a4e2e.png\" alt=\"\"></p>\n<p><strong>可以通过 NumPy 加载图片，获取二维图像数据数组，转为 CIImage 传入 PyCoreImage 中使用，PyCoreImage 通过 PyObjC，与 Core Image 进行交互，下发指令进行处理。</strong></p>\n<blockquote>\n<p>PS：</p>\n<p>NumPy 是一个为 Python 提供高性能向量、矩阵和高维数据结构的科学计算库。它通过 C 和 Fortran 实现，因此用向量和矩阵建立方程并实现数值计算有非常好的性能。NumPy 基本上是所有使用 Python 进行数值计算的框架和包的基础，例如 TensorFlow 和 PyTorch，构建机器学习模型最基础的内容就是学会使用 NumPy 搭建计算过程。</p>\n<p>NumPy 主要的运算对象为同质的多维数组，即由同一类型元素（一般是数字）组成的表格，且所有元素通过正整数元组进行索引。</p>\n</blockquote>\n<p>下面是一个高斯模糊的具体例子：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/520e9259123a89b57904efa8225be7a0.png\" alt=\"\"></p>\n<p>代码很简单，这里不具体说明。</p>\n<p>另外，为了降低学习成本，PyCoreImage 对比 Core Image 做了一些简化，比如颜色空间统一为 sRGB 等。绿色标注即差异项：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/c0b518b8dc68e00b780994c71262c308.png\" alt=\"\"></p>\n<p>下面是一个备忘录，列举了常用的一些操作：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/bb6efbe96c4b43c89ff4201d85f2ccc8.png\" alt=\"\"></p>\n<p>这里额外提一个，Kernel 的加载方式。</p>\n<p>自定义 Filter，可以通过如下方式加载并应用效果。这里可以留意到，kernel 和我们在 iOS 上用的完全一致，真正的减少了移植的成本。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4bb2a0a17af53277611da8ada541dc05.png\" alt=\"\"></p>\n<p>如果想了解这部分的更多知识，包括安装方式，其他 API 等，可以查阅官方文档：</p>\n<p><a href=\"https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python\">Prototyping Your App’s Core Image Pipeline with Python</a></p>\n<h2 id=\"Machine_Learning\">Machine Learning</h2><p>新加入了一个内置 Filter，CICoreMLModelFilter，可以和方便的与 CoreML 结合起来，实现效果。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/9aa47e880bd8c47618449e1d00d28de2.png\" alt=\"\"></p>\n<p>参数十分简洁，就两个，inputImage 和 inputModel。如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = image.applyingFilter(<span class=\"string\">\"CICoreMLModelFilter\"</span>, parameters: [<span class=\"string\">\"inputModel\"</span>: model])!</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：</p>\n<p>不过目前在官方文档上，还搜不到 CICoreMLModelFilter 的任何内容，内置的 CIFilter 也找不到，估计还没开放。</p>\n</blockquote>\n<p>关于与 CoreML 的配合，这里还提了一点。</p>\n<p>当我们在训练模型的时候，其实就是我们调参的过程，这样模型能将具体的输入（比如说图像）映射为输出（标签）。我们的优化目标就是尽力让模型的损失调低，当然需要往正确的方向调整模型参数才行。成功的神经网络拥有数以百万计的参数！自然而然，如果你有很多参数，就需要为模型展示大量的样本，才能让模型获得良好的性能。</p>\n<p>所以说，训练集和模型的准确性成正比。不同类型的大量数据，对神经网络的鲁棒性起着至关重要的作用。</p>\n<p>但不得不提到，真实数据的采集是十分困难的。这种情况下，我们一般会借助  <strong>Data Augmentation</strong> 来模拟，填充数据。</p>\n<blockquote>\n<p>PS：</p>\n<p>在深度学习中，有的时候训练集不够多，或者某一类数据较少，或者为了防止过拟合，让模型更加鲁棒性， Data Augmentation 是一个不错的选择。</p>\n<p>普通的图像增强方法包括：<strong>翻转、旋转、平移、裁剪、缩放和高斯噪声</strong>；高级版图像增强方法还有<strong>常数填充、反射、边缘延伸、对称和包裹模式</strong>等。</p>\n<p>更多的，可以查阅：<a href=\"https://www.zhihu.com/question/35339639\">使用深度学习(CNN)算法进行图像识别工作时，有哪些data augmentation 的奇技淫巧？</a></p>\n</blockquote>\n<p>借助 Core Image 内置滤镜，可以十分方便实现图像增强。</p>\n<p>如下是几个具体例子：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/41b67e67f039708afa127dffb5fee528.png\" alt=\"\"></p>\n<p>另外，结合 PyCoreImage，在电脑上可以快速生成样本数据。如下是具体的实践代码：</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/45d9cb192ff6c84f40ae25c1d2bacaed.png\" alt=\"\"></p>\n<p>运行后，就可以得到大量样本啦～</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5444a7aa0d60df9eabe6a3135943fb44.png\" alt=\"\"></p>\n<h2 id=\"延伸阅读\">延伸阅读</h2><p><a href=\"https://developer.apple.com/videos/play/wwdc2018/719/\">Core Image: Performance, Prototyping, and Python</a></p>\n<p><a href=\"https://developer.apple.com/documentation/coreimage/prototyping_your_app_s_core_image_pipeline_with_python\">Prototyping Your App’s Core Image Pipeline with Python</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck4hqo1lr0000zwlnijf5roqj","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1m5000dzwlnufjo4oq5"},{"post_id":"ck4hqo1lr0000zwlnijf5roqj","tag_id":"ck4hqo1m10007zwlnep178kbj","_id":"ck4hqo1m5000ezwln2vh431rh"},{"post_id":"ck4hqo1lr0000zwlnijf5roqj","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1m6000gzwlnlrsydiar"},{"post_id":"ck4hqo1lx0002zwlnzl7kai3a","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1m8000jzwln15e13caa"},{"post_id":"ck4hqo1lx0002zwlnzl7kai3a","tag_id":"ck4hqo1m10007zwlnep178kbj","_id":"ck4hqo1m8000kzwln603t4bum"},{"post_id":"ck4hqo1lx0002zwlnzl7kai3a","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1m8000mzwln2zkq3cjs"},{"post_id":"ck4hqo1m00005zwlnae5uoyxr","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1m9000ozwlnb8ckskne"},{"post_id":"ck4hqo1m00005zwlnae5uoyxr","tag_id":"ck4hqo1m8000lzwln4vugob95","_id":"ck4hqo1m9000pzwln19lpg2zr"},{"post_id":"ck4hqo1m00006zwln569cdgll","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1m9000rzwlnm77tryy1"},{"post_id":"ck4hqo1m00006zwln569cdgll","tag_id":"ck4hqo1m8000nzwlnr0ewv6km","_id":"ck4hqo1ma000szwlnyso2ftqd"},{"post_id":"ck4hqo1m10008zwlnfbgbj6qh","tag_id":"ck4hqo1m9000qzwlnlvjo4ung","_id":"ck4hqo1ma000vzwlnlwo06m16"},{"post_id":"ck4hqo1m10008zwlnfbgbj6qh","tag_id":"ck4hqo1ma000tzwlnwms39rqy","_id":"ck4hqo1mb000wzwln3iimlps5"},{"post_id":"ck4hqo1m20009zwlnhx70fn2e","tag_id":"ck4hqo1ma000uzwln5y0mrhox","_id":"ck4hqo1md0011zwlndrc0nlnd"},{"post_id":"ck4hqo1m20009zwlnhx70fn2e","tag_id":"ck4hqo1mb000xzwlng15yl33y","_id":"ck4hqo1me0012zwlnl5fqz6qm"},{"post_id":"ck4hqo1m20009zwlnhx70fn2e","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1me0013zwlnfwv11eze"},{"post_id":"ck4hqo1m20009zwlnhx70fn2e","tag_id":"ck4hqo1ma000tzwlnwms39rqy","_id":"ck4hqo1me0014zwln4bqiw4du"},{"post_id":"ck4hqo1m3000azwlnd4hb9n5h","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1me0015zwlnrfwfp0fb"},{"post_id":"ck4hqo1m3000azwlnd4hb9n5h","tag_id":"ck4hqo1ma000tzwlnwms39rqy","_id":"ck4hqo1me0016zwlno8igvwry"},{"post_id":"ck4hqo1mr0018zwlnj2xm7pgn","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1mt001bzwlnuhx71t4m"},{"post_id":"ck4hqo1mr0018zwlnj2xm7pgn","tag_id":"ck4hqo1ma000tzwlnwms39rqy","_id":"ck4hqo1mu001dzwlnnvbkplpa"},{"post_id":"ck4hqo1ms001azwlnf3g1tl6r","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1mv001gzwlnsuxqmeq2"},{"post_id":"ck4hqo1ms001azwlnf3g1tl6r","tag_id":"ck4hqo1ma000tzwlnwms39rqy","_id":"ck4hqo1mw001izwln8biebi14"},{"post_id":"ck4hqo1mt001czwlnw646c7ks","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1mx001kzwlnrfncxy6s"},{"post_id":"ck4hqo1mt001czwlnw646c7ks","tag_id":"ck4hqo1m10007zwlnep178kbj","_id":"ck4hqo1mx001lzwlnan7x6xzq"},{"post_id":"ck4hqo1mt001czwlnw646c7ks","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1my001nzwlnu4u1vlia"},{"post_id":"ck4hqo1mr0017zwln2hvadra6","tag_id":"ck4hqo1ms0019zwlnnlsmisy8","_id":"ck4hqo1my001ozwln0m5g6ivw"},{"post_id":"ck4hqo1mr0017zwln2hvadra6","tag_id":"ck4hqo1mu001ezwln9v9q7s0g","_id":"ck4hqo1my001pzwlnqjx9dfbm"},{"post_id":"ck4hqo1mu001fzwlnrstml56r","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1my001rzwlndz571xvr"},{"post_id":"ck4hqo1mu001fzwlnrstml56r","tag_id":"ck4hqo1mw001jzwlnk5k5c3lm","_id":"ck4hqo1my001szwlnu3wykcrd"},{"post_id":"ck4hqo1mu001fzwlnrstml56r","tag_id":"ck4hqo1mx001mzwlnrqsjvh7w","_id":"ck4hqo1mz001uzwlnc5xy7vpm"},{"post_id":"ck4hqo1mv001hzwlnhk9z21g6","tag_id":"ck4hqo1my001qzwlnp99wwtlo","_id":"ck4hqo1mz001vzwlnxsnuahpg"},{"post_id":"ck4hqo1mv001hzwlnhk9z21g6","tag_id":"ck4hqo1mz001tzwlnoaavd5u7","_id":"ck4hqo1mz001wzwlnnq2tb3yl"},{"post_id":"ck4hqo1n3001xzwln8inne0e7","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1n40020zwlnadzl5nj4"},{"post_id":"ck4hqo1n3001xzwln8inne0e7","tag_id":"ck4hqo1m10007zwlnep178kbj","_id":"ck4hqo1n50022zwlne19xv53i"},{"post_id":"ck4hqo1n3001xzwln8inne0e7","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1n60024zwlnx9gvlriy"},{"post_id":"ck4hqo1n4001zzwlnwmrtz0ri","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1n60026zwlnm3vsfsu4"},{"post_id":"ck4hqo1n4001zzwlnwmrtz0ri","tag_id":"ck4hqo1m10007zwlnep178kbj","_id":"ck4hqo1n70028zwlntwxg884n"},{"post_id":"ck4hqo1n4001zzwlnwmrtz0ri","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1n70029zwlnofflald3"},{"post_id":"ck4hqo1n40021zwln5cawuhwv","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1n7002azwln5xabk9vg"},{"post_id":"ck4hqo1n40021zwln5cawuhwv","tag_id":"ck4hqo1m10007zwlnep178kbj","_id":"ck4hqo1n8002czwlnactbm23j"},{"post_id":"ck4hqo1n40021zwln5cawuhwv","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1n8002dzwlnahbo0yez"},{"post_id":"ck4hqo1n50023zwlnspfekhdo","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1n8002ezwln1nvklqrv"},{"post_id":"ck4hqo1n50023zwlnspfekhdo","tag_id":"ck4hqo1ma000tzwlnwms39rqy","_id":"ck4hqo1n8002fzwlnilu5j64d"},{"post_id":"ck4hqo1n60025zwlnh2yf11cl","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1n8002gzwlnf65v5fhp"},{"post_id":"ck4hqo1n60025zwlnh2yf11cl","tag_id":"ck4hqo1n70027zwlnmenp6svr","_id":"ck4hqo1n8002hzwlnu70t0h6s"},{"post_id":"ck4hqo1n60025zwlnh2yf11cl","tag_id":"ck4hqo1n7002bzwlngs6ygjks","_id":"ck4hqo1n8002izwlntdqda1ri"},{"post_id":"ck4hqo1nh002kzwln7j4xf33q","tag_id":"ck4hqo1lz0004zwlnqybag7he","_id":"ck4hqo1nj002nzwlnjmsa44dd"},{"post_id":"ck4hqo1nh002kzwln7j4xf33q","tag_id":"ck4hqo1m10007zwlnep178kbj","_id":"ck4hqo1nj002ozwlnmrkm00sc"},{"post_id":"ck4hqo1nh002kzwln7j4xf33q","tag_id":"ck4hqo1m3000bzwlnjqqixuy5","_id":"ck4hqo1nk002qzwln5s2yd58d"},{"post_id":"ck4hqo1nh002jzwlnejrzb6fc","tag_id":"ck4hqo1ni002lzwlnlamgjmpc","_id":"ck4hqo1nk002rzwln477nkriy"},{"post_id":"ck4hqo1nj002mzwlnzzugh9rl","tag_id":"ck4hqo1ms0019zwlnnlsmisy8","_id":"ck4hqo1nl002szwlnoliegj7l"},{"post_id":"ck4hqo1nj002mzwlnzzugh9rl","tag_id":"ck4hqo1nk002pzwlnk0mcgdzg","_id":"ck4hqo1nl002tzwlnmb3xmsot"},{"post_id":"ck4hqo1nm002uzwln0ek9vfog","tag_id":"ck4hqo1ni002lzwlnlamgjmpc","_id":"ck4hqo1nm002vzwlnmosur2db"},{"post_id":"ck4hqrjok000200ln3u7pj5eu","tag_id":"ck4hqo1ni002lzwlnlamgjmpc","_id":"ck4hr1uft000400lnjbp7oqcd"}],"Tag":[{"name":"iOS开发","_id":"ck4hqo1lz0004zwlnqybag7he"},{"name":"OpenGLES","_id":"ck4hqo1m10007zwlnep178kbj"},{"name":"图像处理","_id":"ck4hqo1m3000bzwlnjqqixuy5"},{"name":"正则","_id":"ck4hqo1m8000lzwln4vugob95"},{"name":"宏","_id":"ck4hqo1m8000nzwlnr0ewv6km"},{"name":"Hexo","_id":"ck4hqo1m9000qzwlnlvjo4ung"},{"name":"教程","_id":"ck4hqo1ma000tzwlnwms39rqy"},{"name":"iOS 开发","_id":"ck4hqo1ma000uzwln5y0mrhox"},{"name":"Metal","_id":"ck4hqo1mb000xzwlng15yl33y"},{"name":"iOS 10","_id":"ck4hqo1ms0019zwlnnlsmisy8"},{"name":"CallKit","_id":"ck4hqo1mu001ezwln9v9q7s0g"},{"name":"设计思想","_id":"ck4hqo1mw001jzwlnk5k5c3lm"},{"name":"测试","_id":"ck4hqo1mx001mzwlnrqsjvh7w"},{"name":"面试","_id":"ck4hqo1my001qzwlnp99wwtlo"},{"name":"随笔","_id":"ck4hqo1mz001tzwlnoaavd5u7"},{"name":"TDD","_id":"ck4hqo1n70027zwlnmenp6svr"},{"name":"Swift","_id":"ck4hqo1n7002bzwlngs6ygjks"},{"name":"Core Image","_id":"ck4hqo1ni002lzwlnlamgjmpc"},{"name":"翻译","_id":"ck4hqo1nk002pzwlnk0mcgdzg"}]}}