<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[渲染基本图元]]></title>
      <url>/2017/04/18/OpenGLES-Lesson03/</url>
      <content type="html"><![CDATA[<p>在<a href="http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/" target="_blank" rel="external">上篇文章</a>中，已经介绍了 OpenGL ES 的基础环境搭建，并且实现了设置背景色功能。</p>
<p>在本文中，我们将会在上文的基础上，渲染基本图元，三角形。在这个过程中，将会详细介绍可编程图形渲染管线是如何工作的。</p>
<p>最终的效果如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017013028167QQ20170130-174258@2x.png" alt="2017013028167QQ20170130-174258@2x.png"></p>
<a id="more"></a>
<h2 id="0-_初始工程">0. 初始工程</h2><p>你可以从<a href="https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip" target="_blank" rel="external">这里</a>下载到初始工程，避免重复实现一些和本节内容不相干的事情。</p>
<p>这是上一节的最终工程，包含了 OpenGL ES 的基础环境搭建。</p>
<blockquote>
<p>PS：</p>
<p>在之后的步骤里，如果你细心观察对比，你会发现其实它就是围绕图形渲染管线展开的，把之前介绍的内容，用代码的方式实现出来，具体流程可以参照下图回顾：<img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112148420103614414.jpg?imageView2/0/format/jpg" alt="20170112148420103614414.jpg"></p>
</blockquote>
<h2 id="1-_顶点数据">1. 顶点数据</h2><p>开始渲染图形之前，我们必须先给 OpenGL ES 输入一些顶点数据。</p>
<p>为了渲染一个如图所示的三角形，我们需要以数组的形式传递3个 3D 坐标（之前提到过，在 OpenGL 中，任何事物都在 <strong>3D</strong> 空间中）作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data），<strong>顶点数据是一系列顶点的集合</strong>。</p>
<p>在这个简单的例子里，我们一共要指定三个顶点，每个顶点只由一个 3D 位置和一个颜色值组成。</p>
<p>自定义顶点结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> position[<span class="number">4</span>]; <span class="comment">// 3D 位置</span></span><br><span class="line">    <span class="keyword">float</span> color[<span class="number">4</span>];    <span class="comment">// 颜色值</span></span><br><span class="line">&#125; CustomVertex;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：</p>
<p><strong>Q：</strong>这里的颜色值，用四维向量表示可以理解（RGBA），那么 3D 位置为什么也是四维向量（XYZW）呢（包含4个元素的数组表示的向量）？</p>
<p><strong>A：</strong> 3D 图形渲染过程中用到了 4x4 的矩阵（4行4列），矩阵乘法要求 nxm <em> mxp（n行m列 乘 m行p列）才能相乘，注意 m 是相同的，所以 1x4 </em> 4x4 才能相乘。</p>
<p>The w in vec4(x, y, z, w) is used for clipping, and plays its part while linear algebra transformations are applied to the position.</p>
<p>By default, this should be set to 1.0.</p>
<p><strong>See here for some more info：</strong></p>
<p><a href="http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html" target="_blank" rel="external">http://web.archive.org/web/20160408103910/http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-iOS-chapter-4.html</a></p>
</blockquote>
<p>针对此三角形，我们可以填充对应的数据如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> CustomVertex vertices[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; .position = &#123; <span class="number">-1.0</span>,  <span class="number">1.0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, .color = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    &#123; .position = &#123; <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, .color = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    &#123; .position = &#123;  <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, .color = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然 OpenGL 是在 3D 空间中工作的，但是我们渲染的是一个 2D 三角形，所以我们可以将它顶点的 z 坐标设置为 0.0。这样子的话三角形每一点的<strong>深度</strong>都是一样的，从而使它看上去像是 2D 的。</p>
<blockquote>
<p>PS：</p>
<p>深度通常可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</p>
</blockquote>
<p>另外，没有特殊操作的情况下，W 轴默认都设置为 1.0。</p>
<h2 id="2-_顶点缓存对象（VBO）">2. 顶点缓存对象（VBO）</h2><p>定义了上述顶点数据后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：<strong>顶点着色器</strong>。它会在 GPU 上创建内存用于储存我们的顶点数据。</p>
<p>我们通过顶点缓存对象（Vertex Buffer Objects，<strong>VBO</strong>）管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓存对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>
<p>创建 VBO 的过程如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLuint vertexBuffer;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;vertexBuffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>和之前的其它对象一样，OpenGL ES 对象的创建离不开 Gen，Bin 操作。这里记住 VBO 的缓存类型是 <strong>GL_ARRAY_BUFFER</strong> 即可。</p>
<p>这里着重介绍下 <code>glBufferData</code> 函数，它会把之前定义的顶点数据复制到缓存的内存中：</p>
<p>它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> GL_APIENTRY <span class="title">glBufferData</span> <span class="params">(GLenum target, GLsizeiptr size, <span class="keyword">const</span> GLvoid* data, GLenum usage)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>target：缓存类型，这里指定 GL_ARRAY_BUFFER。</p>
</li>
<li><p>size：传输数据的大小（以字节为单位）。直接通过 <code>sizeof(vertices)</code> 计算出顶点数据大小即可。</p>
</li>
<li><p>data：指向实际传输数据。</p>
</li>
<li><p>usage：指定我们希望显卡如何管理给定的数据。它有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
<p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓存中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW 或 GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>
</li>
</ul>
<h2 id="3-_着色器编写">3. 着色器编写</h2><p>准备好顶点数据后，接下去需要做的就是着色器的编写。关于着色器相关的内容，这节不做过多的解释，下节会针对着色器做详细的介绍。</p>
<p>顶点着色器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 position;</span><br><span class="line">attribute vec4 color;</span><br><span class="line"></span><br><span class="line">varying vec4 colorVarying;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    colorVarying = color;</span><br><span class="line">    gl_Position = position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段着色器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">varying lowp vec4 colorVarying;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    gl_FragColor = colorVarying;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>着色器是用着色器语言 GLSL（OpenGL Shading Language）编写的，它看起来很像C语言。</p>
<p>在本节中，我们需要简单的知道这几个概念就好了：</p>
<ul>
<li>顶点着色器每个顶点执行一次，片段着色器每个片段执行一次。</li>
<li>color，position 是变量，和我们自定义的顶点数据对应。</li>
<li>colorVarying，顶点着色器和片段着色器中相同的变量，它们是相对应的。</li>
<li>vec4 是参数类型，GLSL 内置的向量数据类型，这里我们用到的都是四元向量。</li>
<li>attribute，存储类型限定符，表示链接，链接 OpenGL ES 的每一个顶点数据到顶点着色器（一个一个地）。可以简单理解成输入顶点属性。这里我们将 color，position 传入顶点着色器。</li>
<li>varying，存储类型限定符，表示链接顶点着色器和片元着色器的内部数据。</li>
<li>着色器由 main 函数开始执行，也可以自定义函数，和 C 都是一样的。</li>
<li>lowp，精度限定符。</li>
<li>gl_Position，内建变量，顶点着色器的输出值，而且是<strong>必须要赋值</strong>的变量。对 gl_Position 设置的值会成为该顶点着色器的输出。</li>
<li>gl_FragColor，和 gl_Position 一样，也是内建变量，对应片段的色值。</li>
</ul>
<p>理解完这几个概念，再看这两个着色器，就是设置对应顶点的位置和色值，再简单不过了。</p>
<p>至此，你可能会有一些疑惑：</p>
<p><strong>Q：着色器代码以什么形式存在？</strong></p>
<p><strong>A：</strong>创建的时候，是通过传入字符串来实现的。所以着色器代码可以通过任何形式存在，最后加载成 NSString 来使用。这里我们在 Xcode 里头，一般是 <strong>New File —&gt; Empty —&gt; xx.vsh / xx.fsh</strong>。然后在对应的文件里面添加代码。这样有个好处就是编辑起来有高亮，更直观。</p>
<p><strong>Q：为什么传入的三个顶点色值是固定的，但是最终的效果却是渐变色？</strong></p>
<p><strong>A：</strong>这是因为 <strong>varying</strong> 变量存在<strong>内插（interpolate）</strong>的过程。</p>
<p>之前提到过，varying 变量的作用是从顶点着色器向片段着色器传值，<strong>但是值不是直接传递，会先进行内插</strong>。</p>
<p>所谓内插，就像补间动画一样。比如想要把一系列散点连成平滑曲线，相邻已知点之间缺少很多点，此时就需要通过内插填补缺少的数据，最终平滑曲线上除已知点之外的所有点都是插值得到的。</p>
<p>同样的，三角形的三个角色值给定后，其它的片段则根据插值计算出来，也就呈现来渐变的效果。</p>
<h2 id="4-_编译着色器">4. 编译着色器</h2><p>我们已经有了着色器源码，但是为了能够让 OpenGL ES 使用它，我们必须在运行时动态编译它的源码。具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (GLuint)compileShader:(<span class="built_in">NSString</span> *)shaderName withType:(GLenum)shaderType &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *shaderPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:shaderName ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSString</span> *shaderString = [<span class="built_in">NSString</span> stringWithContentsOfFile:shaderPath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!shaderString) &#123;</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* shaderStringUFT8 = [shaderString UTF8String];</span><br><span class="line">    <span class="keyword">int</span> shaderStringLength = (<span class="keyword">int</span>)[shaderString length];</span><br><span class="line">  </span><br><span class="line">    GLuint shaderHandle = glCreateShader(shaderType);</span><br><span class="line">    </span><br><span class="line">    glShaderSource(shaderHandle, <span class="number">1</span>, &amp;shaderStringUFT8, &amp;shaderStringLength);</span><br><span class="line">    glCompileShader(shaderHandle);</span><br><span class="line">    </span><br><span class="line">    GLint compileSuccess;</span><br><span class="line">    glGetShaderiv(shaderHandle, GL_CO<span class="built_in">MPILE_STATUS</span>, &amp;compileSuccess);</span><br><span class="line">    <span class="keyword">if</span> (compileSuccess == GL_FALSE) &#123;</span><br><span class="line">        GLchar messages[<span class="number">256</span>];</span><br><span class="line">        glGetShaderInfoLog(shaderHandle, <span class="keyword">sizeof</span>(messages), <span class="number">0</span>, &amp;messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">NSString</span> *messageString = [<span class="built_in">NSString</span> stringWithUTF8String:messages];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"glGetShaderiv ShaderIngoLog: %@"</span>, messageString);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shaderHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 <strong>shaderStringUFT8</strong> 的方式就不说明了，下面主要分析 OpenGL ES 相关 API 的调用情况：</p>
<p>我们首先要做的是创建一个着色器对象，还是用 ID 来引用。所以我们储存这个顶点着色器为 <code>GLuint</code>，然后用 <code>glCreateShader</code> 创建这个着色器，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLuint GL_APIENTRY <span class="title">glCreateShader</span> <span class="params">(GLenum type)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>type：着色器类型，可选值有 <strong>GL_VERTEX_SHADER</strong> 和 <strong>GL_FRAGMENT_SHADER</strong>。</li>
</ul>
<p>下一步我们需要通过 <code>glShaderSource</code> 把着色器源码附加到着色器对象上，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> GL_APIENTRY <span class="title">glShaderSource</span> <span class="params">(GLuint shader, GLsizei count, <span class="keyword">const</span> GLchar* <span class="keyword">const</span> *<span class="built_in">string</span>, <span class="keyword">const</span> GLint* length)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>shader：要编译的着色器对象。</li>
<li>count：传递的源码字符串数量，这里只有一个。</li>
<li>string：着色器真正的源码。</li>
<li>length：着色器源码的长度。</li>
</ul>
<p>最后，通过 <code>glCompileShader</code> 来编译着色器，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> GL_APIENTRY <span class="title">glCompileShader</span> <span class="params">(GLuint shader)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>shader：待编译的着色器对象。</li>
</ul>
<p>至此，着色器的编译就完成了。</p>
<p>但是，你可能希望知道在调用 <code>glCompileShader</code> 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修正它们。剩余的一部分代码，则是检测编译时是否发生了错误。</p>
<p>首先定义一个变量 <strong>compileSuccess</strong> 来表示是否成功编译。然后用 <code>glGetShaderiv</code> 检查是否编译成功。如果编译失败，会用 <code>glGetShaderInfoLog</code> 获取错误消息，然后打印它。</p>
<p>最后，在使用上，我们只需调用 <code>compileShader</code>，即可获得对应的着色器对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint vertexShader = [<span class="keyword">self</span> compileShader:<span class="string">@"OpenGLESDemo.vsh"</span> withType:GL_VERTEX_SHADER];</span><br><span class="line">GLuint fragmentShader = [<span class="keyword">self</span> compileShader:<span class="string">@"OpenGLESDemo.fsh"</span> withType:GL_FRAGMENT_SHADER];</span><br></pre></td></tr></table></figure>
<h2 id="5-_着色器程序">5. 着色器程序</h2><p>着色器程序对象（Shader Program Object）是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器，我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序（已激活着色器程序的着色器将在我们发送渲染调用的时候被使用）。</p>
<blockquote>
<p>PS：</p>
<p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会得到一个链接错误。</p>
</blockquote>
<p>对应的具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GLuint programHandle = glCreateProgram();</span><br><span class="line">glAttachShader(programHandle, vertexShader);</span><br><span class="line">glAttachShader(programHandle, fragmentShader);</span><br><span class="line">glLinkProgram(programHandle);</span><br><span class="line"></span><br><span class="line">GLint linkSuccess;</span><br><span class="line">glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkSuccess);</span><br><span class="line"><span class="keyword">if</span> (linkSuccess == GL_FALSE) &#123;</span><br><span class="line">    GLchar messages[<span class="number">256</span>];</span><br><span class="line">    glGetShaderInfoLog(programHandle, <span class="keyword">sizeof</span>(messages), <span class="number">0</span>, &amp;messages[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">NSString</span> *messageString = [<span class="built_in">NSString</span> stringWithUTF8String:messages];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"glGetProgramiv ShaderIngoLog: %@"</span>, messageString);</span><br><span class="line">    exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glUseProgram(programHandle);</span><br></pre></td></tr></table></figure>
<p>创建一个着色器程序对象很简单，直接通过调用 <code>glCreateProgram</code> 函数即可，它会返回新创建着色器程序对象的 ID 引用。然后需要通过 <code>glAttachShader</code>，把之前编译好的着色器附加到着色器程序对象上。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glAttachShader</span> <span class="params">(GLuint program, GLuint shader)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>program：着色器程序对象。</li>
<li>shader：需要附加的着色器。</li>
</ul>
<p>然后用 <code>glLinkProgram</code> 链接它们，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glLinkProgram</span> <span class="params">(GLuint program)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>program：着色器程序对象。</li>
</ul>
<p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与之前不同，我们不会调用 <code>glGetShaderiv</code> 和 <code>glGetShaderInfoLog</code>，现在使用 <code>glGetProgramiv</code> 和 <code>glGetProgramInfoLog</code>，不再赘述。</p>
<p>得到着色器程序对象后，我们可以调用 <code>glUseProgram</code> 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象。</p>
<p>另外，在把着色器对象链接到着色器程序对象以后，不再需要它们，记得删除着色器对象，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：</p>
<p>glDeleteShader 删除不再使用的着色器。如果当前着色器链接到一个程序对象上，那么这个着色器将不会被真正的删除，直到此着色器不再链接到任何程序对象。</p>
</blockquote>
<h2 id="6-_链接顶点属性">6. 链接顶点属性</h2><p>现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。但是，OpenGL ES 还不知道它该如何解析内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL ES 怎么做。</p>
<p>我们传入的顶点数据 <strong>vertices</strong>，是这样排布的：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017020171966DA004F9B-C0A7-44FE-B747-AA5BEC0ABCF5.png" alt="2017020171966DA004F9B-C0A7-44FE-B747-AA5BEC0ABCF5.png"></p>
<p>从这个图上，我们可以很清晰知道我们的顶点数据是如何排布，每个字节对应哪些内容，但是 OpenGL ES 本身并不知道，我们应该告诉它如何解析这些顶点数据。</p>
<p>首先，我们需要定义与着色器脚本相对应的变量，为了方便，可以直接使用枚举。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    ATTRIBUTE_POSITION = <span class="number">0</span>,</span><br><span class="line">    ATTRIBUTE_COLOR,</span><br><span class="line">    NUM_ATTRIBUTES</span><br><span class="line">&#125;;</span><br><span class="line">GLint glViewAttributes[NUM_ATTRIBUTES];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">glViewAttributes[ATTRIBUTE_POSITION] = glGetAttribLocation(programHandle, <span class="string">"position"</span>);</span><br><span class="line">glViewAttributes[ATTRIBUTE_COLOR]  = glGetAttribLocation(programHandle, <span class="string">"color"</span>);</span><br><span class="line"></span><br><span class="line">glEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_POSITION]);</span><br><span class="line">glEnableVertexAttribArray(glViewAttributes[ATTRIBUTE_COLOR]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：</p>
<p>通过 NUM_ATTRIBUTES，可以很方便拿到变量的个数。</p>
</blockquote>
<p>然后使用 <code>glGetAttribLocation</code>，来获得着色器变量的入口，使之绑定起来。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> GL_APIENTRY <span class="title">glGetAttribLocation</span> <span class="params">(GLuint program, <span class="keyword">const</span> GLchar* name)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>program：着色器程序对象</li>
<li>name：着色器中对应的变量名</li>
</ul>
<p>然后，使用 <code>glEnableVertexAttribArray</code> ，以顶点属性值作为参数，启用顶点属性（顶点属性默认是禁用的）。</p>
<p>至此，顶点属性的绑定已经完成了，之后只需要在渲染的时候，为对应的顶点属性赋值即可。</p>
<p>下面是对应的渲染代码，其中 <strong>/////////</strong> 包围的是本节新增的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)render &#123;</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);</span><br><span class="line">    glClearColor(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//////////////////</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.height);</span><br><span class="line">    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_POSITION], <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(CustomVertex), <span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(glViewAttributes[ATTRIBUTE_COLOR], <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(CustomVertex), (GLvoid *)(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>));</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//////////////////</span></span><br><span class="line">  </span><br><span class="line">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了渲染图形，我们需要给定渲染区域（视见区域），即告诉 OpenGL ES 应把渲染之后的图形绘制在窗体的哪个部位。当视见区域是整个窗体时，OpenGL ES 将把渲染结果绘制到整个窗口。</p>
<p>调用 <code>glViewPort</code> 函数来决定视见区域，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glViewport</span> <span class="params">(GLint x, GLint y, GLsizei width, GLsizei height)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>x，y：指定了视见区域的左下角在窗口中的位置。</li>
<li>width，height：指定了视见区域的宽度和高度。</li>
</ul>
<p>这里我们直接设置成窗口的大小即可。</p>
<p>准备工作都完成后，有了这些信息我们就可以使用 glVertexAttribPointer 函数告诉 OpenGL ES 该如何解析顶点数据（应用到逐个顶点属性上）了，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> GL_APIENTRY <span class="title">glVertexAttribPointer</span> <span class="params">(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, <span class="keyword">const</span> GLvoid* ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>indx：指定要配置的顶点属性。</li>
<li>size：指定顶点属性的大小（这里不管是位置还是色值，都是四元向量，所以是4）。</li>
<li>type：指定属性的类型，这里是 <strong>GL_FLOAT</strong> （GLSL中 <code>vec*</code> 都是由浮点数值组成的）。</li>
<li>normalized：指定是否希望数据被标准化（Normalize）。如果设置为 GL_TRUE，所有数据都会被映射到0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为GL_FALSE。</li>
<li>stride：步长（Stride），它告诉 OpenGL ES 连续的顶点数据组之间的间隔。如上图所示，每个顶点数据大小都是 32 字节（<code>sizeof(CustomVertex)</code>），即下组顶点数据数据在一个 <code>CustomVertex</code> 之后，所以我们把步长设置为 <code>sizeof(CustomVertex)</code>。</li>
<li>ptr：表示该属性在缓存中起始位置的偏移量（Offset）。如图，位置属性的偏移量是 0，而对于色值属性，它是紧挨着位置属性之后，所以它相对起始位置的偏移量，应该是一个位置属性的大小，即 16（sizeof(float) <em> 4）。另外，参数类型是 `GLvoid</em>`，所以需要进行这个奇怪的强制类型转换。</li>
</ul>
<p>至此，所有东西都已经设置好了：我们使用一个顶点缓存对象将顶点数据初始化至缓存中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL ES 如何把顶点数据链接到顶点着色器的顶点属性上。</p>
<p>最后，要想渲染我们想要的图形，OpenGL ES 提供了 <code>glDrawArrays</code> 函数，它使用当前激活的着色器，之前定义的顶点属性配置，以及VBO的顶点数据来渲染图元。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> GL_APIENTRY <span class="title">glDrawArrays</span> <span class="params">(GLenum mode, GLint first, GLsizei count)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>mode：指定渲染的 OpenGL ES 图元的类型。这里渲染的是一个三角形，所以传递 GL_TRIANGLES 给它。</li>
<li>first：指定了顶点数据的起始索引，这里为 0。</li>
<li>count：指定顶点个数，这里为 3。</li>
</ul>
<blockquote>
<p>PS：</p>
<p>mode 的类型还有其他几种，应用于不同的场景，感兴趣的可以了解下～</p>
</blockquote>
<h2 id="7-_测试，运行">7. 测试，运行</h2><p>最后，在 setup 中添加如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> compileShaders];</span><br><span class="line">[<span class="keyword">self</span> setupVBOs];</span><br></pre></td></tr></table></figure>
<p>运行，不出意外的话，你将会看到之前的三角形。</p>
<p>最终的工程可以从<a href="https://github.com/colin1994/OpenGLES/blob/master/Lesson03/OpenGLESDemo.zip" target="_blank" rel="external">这里</a>下载。下一节，将详细介绍 GLSL，一起期待吧～</p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> OpenGLES </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL ES 环境搭建]]></title>
      <url>/2017/04/09/OpenGLES-Lesson02/</url>
      <content type="html"><![CDATA[<p>在<a href="http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/" target="_blank" rel="external">上篇文章</a>中，已经介绍了 OpenGL ES 的一些基础概念以及大致工作流程。</p>
<p>在本文中，我们将会介绍在 iOS 平台上如何接入 OpenGL ES，并搭建好基础环境，实现设置背景色功能。它是之后任何实战的基础模版。在搭建过程中，会针对之前介绍的一些概念，再结合代码讲解。</p>
<blockquote>
<p>PS：这一节是 OpenGL ES 的入门，也是最重要的一部分。再绚丽的特性，都是在此基础上完成的。所以理解它是很有必要的～</p>
</blockquote>
<p>设置蓝色背景后，效果如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017012639178QQ20170126-231448@2x.png" alt="2017012639178QQ20170126-231448@2x.png"></p>
<a id="more"></a>
<h2 id="0-_初始工程">0. 初始工程</h2><p>你可以从<a href="https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip" target="_blank" rel="external">这里</a>下载到初始工程，避免重复实现一些和本节内容不相干的事情。</p>
<p>在这个初始工程里面，已经实现了新建一个继承自 <strong>UIView</strong> 的 <strong>GLView</strong>，这个自定义的视图将用来显示 OpenGL ES 的渲染内容。然后在 Main.storyboard 中，将 ViewController 的 view 改成 <strong>GLView</strong> 类型，即可。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017012663829D0A3C5CE-818A-4C93-8D3E-1C302E29220F.png" alt="2017012663829D0A3C5CE-818A-4C93-8D3E-1C302E29220F.png"></p>
<p>至此，我们的工作都将在 <strong>GLView</strong> 中展开。</p>
<p>在 <strong>GLView.h</strong> 中，先声明一些将要用到的成员变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLView</span> : <span class="title">UIView</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CAEAGLLayer</span> *_eaglLayer;</span><br><span class="line">    EAGLContext *_context;</span><br><span class="line">    GLuint       _framebuffer;</span><br><span class="line">    GLuint       _renderbuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在 <strong>GLView.m</strong> 中，需要导入对应的 OpenGLES 框架（framework），如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import OpenGLES;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：</p>
<p><code>@import</code>是 iOS 7 之后的新特性语法，这种方式叫 Modules（模块导入） 或者 Semantic import（语义导入）。用这种方式，不用手动添加 framework，系统会自动帮我们 link，是一种更好的头部预处理的执行方式（相比之前的 #import）。</p>
<ul>
<li>Imports complete semantic description of a framework</li>
<li>Doesn’t need to parse the headers</li>
<li>Better way to import a framework’s interface</li>
<li>Loads binary representation</li>
<li>More flexible than precompiled headers</li>
<li>Immune to effects of local macro definitions (e.g. <code>#define readonly 0x01</code>)</li>
<li>Enabled for new projects by default</li>
</ul>
</blockquote>
<h2 id="1-_CAEAGLLayer">1. CAEAGLLayer</h2><p>CAEAGLLayer 实现了 <strong>EAGLDrawable</strong> 协议，它是 Apple 专门为 OpenGL ES 准备的一个图层类。</p>
<p>所以想要显示 OpenGL ES 的内容，需要把它默认的 layer 设置为一个特殊的 layer（<strong>CAEAGLLayer</strong>），我们简单的重写 <code>layerClass</code> 即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">CAEAGLLayer</span> class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，为了方便起见，我们使 <strong>_eaglLayer</strong> 这个成员变量指代 <strong>self.layer</strong>，这样除了调用上方便外，可读性也更好。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupLayer &#123;</span><br><span class="line">    <span class="comment">// 用于显示的layer</span></span><br><span class="line">    _eaglLayer = (<span class="built_in">CAEAGLLayer</span> *)<span class="keyword">self</span>.layer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CALayer 默认是透明的（opaque = NO），而透明的层对性能负荷很大。所以将其关闭。</span></span><br><span class="line">    _eaglLayer.opaque = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：</p>
<p>By default, CALayers are set to non-opaque (i.e. transparent). However, this is bad for performance reasons (especially with OpenGL), so it’s best to set this as opaque when possible.</p>
<p>CAEAGLLayer: the default value of the `opaque’ property in this class is true, not false as in CALayer.</p>
<p>透明对性能影响较大，CAEAGLLayer 中的 <strong>opaque</strong> 默认值已经是 YES 了。</p>
</blockquote>
<p>至此 layer 的配置已经就绪，下面创建并设置与 OpenGL ES 相关的东西。</p>
<h2 id="2-_EAGLContext">2. EAGLContext</h2><p>上篇已经提到了<strong>上下文</strong>概念，即 <strong>EAGLContext</strong> 对象，这个 context 管理所有使用 OpenGL ES 进行渲染的状态，命令以及资源信息。</p>
<p>通过 <code>initWithAPI</code> 创建完 context，然后需要使用 <code>setCurrentContext</code> 将它设置为当前 context，因为我们之前提过，context 可以同时存在多个，需要指定当前环境对应的 context。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupContext &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_context) &#123;</span><br><span class="line">        <span class="comment">// 创建GL环境上下文</span></span><br><span class="line">        <span class="comment">// EAGLContext 管理所有通过 OpenGL ES 进行渲染的信息.</span></span><br><span class="line">        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSAssert</span>(_context &amp;&amp; [EAGLContext setCurrentContext:_context], <span class="string">@"初始化GL环境失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <strong>kEAGLRenderingAPIOpenGLES2</strong> 即对应的 OpenGL ES 版本，它的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* EAGL rendering API */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, EAGLRenderingAPI)</span><br><span class="line">&#123;</span><br><span class="line">	kEAGLRenderingAPIOpenGLES1 = <span class="number">1</span>,</span><br><span class="line">	kEAGLRenderingAPIOpenGLES2 = <span class="number">2</span>,</span><br><span class="line">	kEAGLRenderingAPIOpenGLES3 = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-_Renderbuffer">3. Renderbuffer</h2><p>有了上下文，OpenGL ES 还需要在一块 buffer 上进行渲染，这块 buffer 就是 <strong>Renderbuffer</strong>（OpenGL ES 总共有三大不同用途的 buffer，分别是 <strong>color buffer，depth buffer 和 stencil buffer</strong>，这里是最基本的 color buffer）。可以简单的把 renderbuffer 理解成用于展示的窗口。</p>
<p>它的创建过程如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupRenderBuffer &#123;</span><br><span class="line">    <span class="comment">// 生成 renderbuffer ( renderbuffer = 用于展示的窗口 )</span></span><br><span class="line">    glGenRenderbuffers(<span class="number">1</span>, &amp;_renderbuffer);</span><br><span class="line">    <span class="comment">// 绑定 renderbuffer</span></span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _renderbuffer);</span><br><span class="line">    <span class="comment">// GL_RENDERBUFFER 的内容存储到实现 EAGLDrawable 协议的 CAEAGLLayer</span></span><br><span class="line">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glGenRenderbuffers</code> 用于生成 renderbuffer，并分配 id。它的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glGenRenderbuffers</span> <span class="params">(GLsizei n, GLuint* renderbuffers)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>n：表示申请生成 renderbuffer 的个数。</li>
<li>renderbuffers：返回分配给 renderbuffer 的 id。</li>
</ul>
<blockquote>
<p>PS：返回的 id 不会为 0，0 是OpenGL ES 保留的，0 则表示这个 buffer 这个不存在或者创建失败。</p>
</blockquote>
<p>所以，一般会通过 id 来判断某个 buffer 是否存在，执行对应的操作。比如在 gen 之前，释放旧的 renderbuffer，确保之后的操作无误。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放旧的 renderbuffer</span></span><br><span class="line"><span class="keyword">if</span> (_renderbuffer) &#123;</span><br><span class="line">    glDeleteRenderbuffers(<span class="number">1</span>, &amp;_renderbuffer);</span><br><span class="line">    _renderbuffer = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glBindRenderbuffer</code> 用于绑定 renderbuffer，将指定 id 的 renderbuffer 设置为当前 renderbuffer。它的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBindRenderbuffer</span> <span class="params">(GLenum target, GLuint renderbuffer)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>target：表示当前 renderbuffer，必须是 <strong>GL_RENDERBUFFER</strong>。</li>
<li>renderbuffer：某个 renderbuffer 对应的 id（比如使用 glGenRenderbuffers 生成的 id）。</li>
</ul>
<p><code>renderbufferStorage</code> 用于将 GL_RENDERBUFFER 的内容存储到实现 <strong>EAGLDrawable</strong> 协议的 CAEAGLLayer。它的原型为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Attaches an EAGLDrawable as storage for the OpenGL ES renderbuffer object bound to &lt;target&gt; */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)renderbufferStorage:(<span class="built_in">NSUInteger</span>)target fromDrawable:(<span class="keyword">id</span>&lt;EAGLDrawable&gt;)drawable;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：</p>
<p>这个函数内部，会使用 drawable（_eaglLayer）的相关信息（设置存储在 drawableProperties 属性中）作为参数，调用 glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</p>
<p> <code>glRenderbufferStorage</code> 指定存储在 renderbuffer 中图像的宽高以及颜色格式，并按照此规格为之分配存储空间。</p>
</blockquote>
<p>至此，我们的第一个 buffer 创建完毕了。注意理解 <strong>gen</strong> 和 <strong>bind</strong> 这两个概念，它将会贯穿我们 OpenGL ES 的整个学习过程。</p>
<h2 id="4-_Framebuffer">4. Framebuffer</h2><p>接下去我们将会创建 framebuffer object，它通常也被称之为 <strong>FBO</strong>。</p>
<p>我们之前提到过了，它相当于 buffer（color, depth, stencil）的管理者，三大 buffer 可以附加到一个  FBO 上。</p>
<p>它的创建过程如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupFrameBuffer &#123;</span><br><span class="line">    <span class="comment">// 释放旧的 framebuffer</span></span><br><span class="line">    <span class="keyword">if</span> (_framebuffer) &#123;</span><br><span class="line">        glDeleteFramebuffers(<span class="number">1</span>, &amp;_framebuffer);</span><br><span class="line">        _framebuffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 framebuffer ( framebuffer = 画布 )</span></span><br><span class="line">    glGenFramebuffers(<span class="number">1</span>, &amp;_framebuffer);</span><br><span class="line">    <span class="comment">// 绑定 fraembuffer</span></span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// framebuffer 不对渲染的内容做存储, 所以这一步是将 framebuffer 绑定到 renderbuffer ( 渲染的结果就存在 renderbuffer )</span></span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">                              GL_RENDERBUFFER, _renderbuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的 gen，bin 操作和 renderbuffer 中对应的都是一致的，只是做相应的替换，比如 renderbuffer 改成 framebuffer 即可，这里就不细说，重点看一下 <code>glFramebufferRenderbuffer</code>。</p>
<p>之前说过，framebuffer 不对渲染的内容做存储，而 <code>glFramebufferRenderbuffer</code> 的作用正是将相关的 buffer（三大 buffer 之一）装配到 framebuffer 上，使得 framebuffer 能索引到对应的渲染内容。它的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glFramebufferRenderbuffer</span> <span class="params">(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>target：表示当前 framebuffer，必须是 GL_FRAMEBUFFER。</li>
<li>attachment：指定 renderbuffer 被装配到那个装配点上，其值是 GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT，GL_STENCIL_ATTACHMENT 中的一个，分别对应 color，depth 和  stencil 三大 buffer。</li>
<li>renderbuffertarget：表示当前 renderbuffer，必须是 <strong>GL_RENDERBUFFER</strong>。</li>
<li>renderbuffer：某个 renderbuffer 对应的 id，表示需要装配的 renderbuffer。</li>
</ul>
<blockquote>
<p>PS：</p>
<p>为了安全起见，可以通过 <code>glCheckFramebufferStatus</code> 来检查 framebuffer 的创建情况，并根据对应的 log，来排查错误。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)checkFramebuffer:(<span class="built_in">NSError</span> *__autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// 检查 framebuffer 是否创建成功</span></span><br><span class="line">    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line">    <span class="built_in">NSString</span> *errorMessage = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> result = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> GL_FRAMEBUFFER_U<span class="built_in">NSUPPORTED</span>:</span><br><span class="line">            errorMessage = <span class="string">@"framebuffer不支持该格式"</span>;</span><br><span class="line">            result = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GL_FRAMEBUFFER_CO<span class="built_in">MPLETE</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"framebuffer 创建成功"</span>);</span><br><span class="line">            result = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GL_FRAMEBUFFER_INCO<span class="built_in">MPLETE_MISSING_ATTACHMENT</span>:</span><br><span class="line">            errorMessage = <span class="string">@"Framebuffer不完整 缺失组件"</span>;</span><br><span class="line">            result = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GL_FRAMEBUFFER_INCO<span class="built_in">MPLETE_DIMENSIONS</span>:</span><br><span class="line">            errorMessage = <span class="string">@"Framebuffer 不完整, 附加图片必须要指定大小"</span>;</span><br><span class="line">            result = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 一般是超出GL纹理的最大限制</span></span><br><span class="line">            errorMessage = <span class="string">@"未知错误 error !!!!"</span>;</span><br><span class="line">            result = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,errorMessage ? errorMessage : <span class="string">@""</span>);</span><br><span class="line">    *error = errorMessage ? [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"com.colin.error"</span></span><br><span class="line">                                                code:status</span><br><span class="line">                                            userInfo:@&#123;<span class="string">@"ErrorMessage"</span> : errorMessage&#125;] : <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们需要的环境配置以及相关 buffer 资源都已经准备好了，接下去就是渲染部分了。</p>
<h2 id="5-_最简单的渲染，设置背景色">5. 最简单的渲染，设置背景色</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)render &#123;</span><br><span class="line">    glClearColor(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 做完所有绘制操作后，最终呈现到屏幕上</span></span><br><span class="line">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glClearColor</code> 用来设置清屏颜色，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glClearColor</span> <span class="params">(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>glClear (GLbitfield mask)</code> 用来指定要用清屏颜色来清除由 mask 指定的 buffer，mask 可以是 GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT 和 GL_STENCIL_BUFFER_BIT 的自由组合。</p>
<p>在这里我们只使用到 color buffer，所以清除的就是 clolor buffer。</p>
<p><code>presentRenderbuffer</code> 是将指定 renderbuffer 呈现在屏幕上。</p>
<blockquote>
<p>PS：</p>
<p>在此之前，建议使用 <code>glBindFramebuffer</code>，<code>glBindRenderbuffer</code> 来重新绑定当前 buffer 对象。因为 GL 的所有 API 都是基于最后一次绑定的对象作为作用对象。所以每次在修改 GL 对象时，先绑定一次要修改的对象。有很多错误是因为没有绑定或者绑定了错误的对象导致得到了错误的结果。</p>
</blockquote>
<h2 id="6-_收工，检验">6. 收工，检验</h2><p>至此，关于 OpenGL ES 环境搭建的相关准备东西都已就绪，接下去只要按需调用相关方法，即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder])) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setup];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didMoveToWindow &#123;</span><br><span class="line">    [<span class="keyword">super</span> didMoveToWindow];</span><br><span class="line">    [<span class="keyword">self</span> render];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Setup</span></span><br><span class="line">- (<span class="keyword">void</span>)setup &#123;</span><br><span class="line">    [<span class="keyword">self</span> setupLayer];</span><br><span class="line">    [<span class="keyword">self</span> setupContext];</span><br><span class="line">    [<span class="keyword">self</span> setupRenderBuffer];</span><br><span class="line">    [<span class="keyword">self</span> setupFrameBuffer];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSAssert1</span>([<span class="keyword">self</span> checkFramebuffer:&amp;error], <span class="string">@"%@"</span>,error.userInfo[<span class="string">@"ErrorMessage"</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不出意外的话，你将会看到开头的那个纯色背景。</p>
<p>你可能注意到了，这个过程我们并没有涉及到所谓的图形渲染管线，如果你试着使用 kEAGLRenderingAPIOpenGLES1 来创建 context，会发现这是完成可以的。</p>
<p>最终的工程可以从<a href="https://github.com/colin1994/OpenGLES/blob/master/Lesson02/OpenGLESDemo_1.zip" target="_blank" rel="external">这里</a>下载。有了这个基础，模版，接下去，我们将会围绕渲染管线，实现一系列的炫酷效果，一起期待吧～</p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> OpenGLES </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL ES 基础概念]]></title>
      <url>/2017/04/01/OpenGLES-Lesson01/</url>
      <content type="html"><![CDATA[<p>这里主要描述一些 OpenGL ES 必须先了解的一些概念，为之后的实战铺路。</p>
<h2 id="状态机">状态机</h2><blockquote>
<p>OpenGL 是一个状态机，它维持自己的状态，并根据用户调用的函数来改变自己的状态。</p>
<p>根据状态的不同，调用同样的函数也可能产生不同的效果。</p>
</blockquote>
<p>在 OpenGL 的世界里，<strong>大多数元素都可以用状态来描述</strong>，比如：</p>
<a id="more"></a>
<ul>
<li>颜色、纹理坐标、光源的各种参数…</li>
<li>是否启用了光照、是否启用了纹理、是否启用了混合、是否启用了深度测试…</li>
<li>…</li>
</ul>
<p><strong>OpenGL 会保持状态，除非我们调用 OpenGL 函数来改变它。</strong></p>
<ul>
<li>比如你用 <code>glEnablexxx</code> 开启了一个状态，在以后的渲染中将一直保留并应用这个状态，除非你调用 <code>glDisablexxx</code> 及同类函数来改变该状态或程序退出。</li>
</ul>
<ul>
<li>又或者当前颜色是一个状态变量，可以把当前颜色设置为白色、红色或其他任何颜色，在此之后绘制的所有物体都将使用这种颜色，直到把当前颜色设置为其他颜色。</li>
</ul>
<p>理解了状态机这个概念，我们再来看 OpenGL ES 提供的 API，就会非常明了，因为OpenGL 当中很多 API，其实仅仅是向 OpenGL 这个状态机传数据或者读数据。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/201701114141530D41464-66AF-4A71-80E5-9BF8AABC016F.png" alt="201701114141530D41464-66AF-4A71-80E5-9BF8AABC016F.png"></p>
<p>100 来个接口，如果按照不同的数据类型（GLfloat，GLint，GLsize …），不同的元素（Uniform，Color，Texture…）划分开来，再看各个分类的接口，（<del>无法</del>）无非就是围绕状态展开的。</p>
<p>比如：<code>glClearColor</code> 函数是一个状态设置函数，而 <code>glClear</code> 函数则是一个状态应用的函数。</p>
<h2 id="上下文">上下文</h2><p>上面提到的各种状态值，将保存在对应的上下文（<strong>Context</strong>）中。</p>
<blockquote>
<p>OpenGL ES 上下文（EAGLContext） : 管理所有 iOS 要绘制的 OpenGL ES 信息。</p>
<p>类似在 Core Graphics 中做任何事情都需要一个 Core Graphics 上下文。</p>
</blockquote>
<p>通过放置这些状态到上下文中，上下文可以跟踪用于渲染的帧缓存、用于几何数据、颜色等的缓存。还会决定是否使用如纹理、灯光等功能以及会为渲染定义当前的坐标系统等。并且在多任务的情况下，就能很容易的共享硬件设备，而互不影响各自的状态。</p>
<p>因此渲染的时候，要<strong>指定对应的当前上下文</strong>。</p>
<h2 id="渲染管线">渲染管线</h2><p>在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：<strong>第一部分把你的3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素。</strong></p>
<blockquote>
<p>2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。</p>
</blockquote>
<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。<strong>它的工作过程和车间流水线一致，各个模块各司其职但是又相互依赖。</strong></p>
<p>下图就是渲染管线：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112148420103614414.jpg?imageView2/0/format/jpg" alt="20170112148420103614414.jpg"></p>
<blockquote>
<p>PS：OpenGL ES 采用<strong>服务器/客户端编程模型</strong>，客户端运行在 CPU 上，服务端运行在 GPU 上，调用 OpenGL ES 函数的时，由客户端发送至服务器端，并被服务端转换成底层图形硬件支持的绘制命令。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170111148411873373682.jpg?imageView2/0/format/jpg" alt="20170111148411873373682.jpg"></p>
</blockquote>
<p>左边的客户端程序通过调用 OpenGL ES 接口，将顶点，着色器程序，纹理，以及其他一些 GL 状态参数传入右边的 GL 服务端， 然后在客户端调用绘制命令的时候， GL 便会将输入的图元，逐一执行渲染管线的每个阶段，然后将每个像素的颜色值写入到帧缓存中， 最后视窗系统就可以将帧缓存中的颜色值显示在屏幕上。 此外，应用程序也可以从帧缓存中读取数据到客户端。</p>
<p>在整个管线中，<strong>顶点着色器和片段着色器是可编程的部分</strong>，应用程序可以通过提供着色器程序在 GPU 中被作用于渲染管线，可编程就是说这个操作可以动态编程实现而不必固定写死在代码中。可动态编程实现这一功能一般都是脚本提供的，在 OpenGL ES 中也一样，编写这样脚本的能力是由 OpenGL 着色语言（OpenGL Shading Language, GLSL）提供的。</p>
<p>那可编程管线有什么好处呢？<strong>方便我们动态修改渲染过程，而无需重写编译代码</strong>。当然也和很多脚本语言一样，调试起来不太方便。其他阶段则只能使用一些固定的 GL 命令来影响该阶段的执行。</p>
<p>下面以<strong>绘制一个三角形为例</strong>，针对渲染管线的各个阶段，详细分析。</p>
<h3 id="1-_顶点数组">1. 顶点数组</h3><p>为了渲染一个三角形，我们以数组的形式传递3个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data）；<strong>顶点数据是一系列顶点的集合。</strong>一个顶点（Vertex）是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性（Vertex Attribute）表示的，它可以包含任何我们想用的数据，但是简单起见，我们假定每个顶点只由一个 3D 位置和一些颜色值组成。</p>
<p>至此，你可能会疑惑，</p>
<ul>
<li>我们仅仅是传递了三个点，但是 OpenGL ES 是怎么知道它们用来组成三角形呢？</li>
<li>加入我要绘制一个 3D 模型，那么要怎么传入顶点数据？</li>
</ul>
<p>为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元（Primitive），任何一个绘制指令的调用都将把图元传递给 OpenGL 。OpenGL 支持三种基本图元：点，线和三角形。</p>
<p>当然，OpenGL ES 并不提供对 3D 模型的定义，在传入 OpenGL ES 之前应用程序应该首先将 3D 模型转换为一组图元的集合。每个模型是独立绘制的，修改其中一个模型的一些设置并不会影响其他模型。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112148420555397978.jpg?imageView2/0/format/jpg" alt="20170112148420555397978.jpg"></p>
<p>每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据，这些数据首先被上传到 GL 服务端，然后就可以进行绘制。</p>
<blockquote>
<p>PS：OpenGL 中的命令总是按照它被接收到的顺序执行，这意味着一组图元必须被全部绘制完毕才会开始绘制下一组图元。同时也意味着程序对帧缓冲的像素读取的结果一定是该命令之前所有 OpenGL 命令执行的结果。</p>
</blockquote>
<h3 id="2-_顶点着色器">2. 顶点着色器</h3><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017011229641BBC4CB30-3B94-4F28-8FAB-AF502E37E641.png" alt="2017011229641BBC4CB30-3B94-4F28-8FAB-AF502E37E641.png"></p>
<p><strong>顶点着色器对每个顶点执行一次运算</strong>，它可以使用顶点数据来计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。</p>
<p>在顶点着色器中最重要的任务是执行顶点坐标变换，应用程序中设置的图元顶点坐标通常是针对本地坐标系的。本地坐标系简化了程序中的坐标计算，但是 GL 并不识别本地坐标系，所以在顶点着色器中要对本地坐标执行模型视图变换，将本地坐标转化为裁剪坐标系的坐标值。</p>
<p>顶点着色器的另一个功能是向后面的片段着色器提供一组易变变量（varying）。易变变量会在图元装配阶段之后被执行插值计算，如果是单重采样，其插值点为片段的中心，如果多重采样，其插值点可能为多个采样片段中的任意一个位置。易变变量可以用来保存插值计算片段的颜色，纹理坐标等信息。</p>
<h3 id="3-_图元装配">3. 图元装配</h3><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017011250662FC720569-D123-4FC5-9F0D-C99287364AC7.png" alt="2017011250662FC720569-D123-4FC5-9F0D-C99287364AC7.png"></p>
<p>在顶点着色器程序输出顶点坐标之后，各个顶点被按照绘制命令中的图元类型参数，以及顶点索引数组被组装成一个个图元。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112148421538042641.jpg?imageView2/0/format/jpg" alt="20170112148421538042641.jpg"></p>
<p>顶点数组首先通过 GL 命令输入到 GL 渲染管线中，此时顶点坐标位于应用程序的本地坐标系；在经过顶点着色器的计算之后，顶点坐标被转化到裁剪坐标系中，这通常通过向顶点着色器传入一个模型视图变换矩阵，然后在顶点着色器中执行坐标变换。</p>
<p>裁剪坐标系被定义在一个视锥体裁剪的空间里，视锥体是游戏场景的一个可视空间，它由6个裁剪平面构成，分别是：近平面，远平面，左平面，右平面，上平面和下平面。</p>
<p>视锥体在 3D 应用程序中通常表现为一个摄像机，其观察点为裁剪坐标系的原点，方向为穿过远近平面的中点。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112148421539517039.jpg?imageView2/0/format/jpg" alt="20170112148421539517039.jpg"></p>
<p>处于视锥体以外的图元将被丢弃，如果该图元与视锥体相交则会发生裁剪产生新的图元。值得注意的是透视裁剪是一个比较影响性能的过程，因为每个图元都需要和 6 个面进行相交计算，并产生新的图元。但是一般在x，y方向超出屏幕之外的，则无需产生新的图元，这些顶点能在视口变换的时候被更高效的丢弃。</p>
<p><strong>通过图元装配，所有 3D 的图元已经被转化为屏幕上 2D 的图元。</strong></p>
<h3 id="4-_光栅化">4. 光栅化</h3><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112706113F85123B-6006-4633-9D8C-C4C4DB4BA3AC.png" alt="20170112706113F85123B-6006-4633-9D8C-C4C4DB4BA3AC.png"></p>
<p><strong>在光栅化阶段，基本图元被转换为供片段着色器使用的片段</strong>（Fragment），Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。<strong>这是从顶点数据到可渲染在显示设备上的像素的质变过程。</strong></p>
<p>在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<h3 id="5-_片段着色器">5. 片段着色器</h3><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112997054573CDB0-956C-4A00-837F-6BDA9BA4F550.png" alt="20170112997054573CDB0-956C-4A00-837F-6BDA9BA4F550.png"></p>
<p>可编程的片段着色器是实现一些高级特效如纹理贴图，光照，环境光，阴影等功能的基础。<strong>片段着色器的主要作用是计算每一个片段最终的颜色值（或者丢弃该片段）。</strong></p>
<p>在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。在 3D 图形程序开发中，贴图是最重要的部分，程序可以通过 GL 命令上传纹理数据至 GL 内存中，这些纹理可以被片段着色器使用。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值。</p>
<p>另外，片段着色器也是执行光照等高级特效的地方，比如可以传给片段着色器一个光源位置和光源颜色，可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。</p>
<h3 id="6-_片段测试">6. 片段测试</h3><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017011371566F6C27776-D170-48EF-8877-E0E541F6F193.png" alt="2017011371566F6C27776-D170-48EF-8877-E0E541F6F193.png"></p>
<p>片段着色器输出的颜色值，还要经过几个阶段的片段操作，这些操作可能会修改片段的颜色值，或者丢弃该片段，<strong>最终的片段颜色值才会被写入到帧缓冲中。</strong></p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2017011214842168484373.jpg?imageView2/0/format/jpg" alt="2017011214842168484373.jpg"></p>
<p>像素所有权测试用来判断帧缓冲区中该位置的像素是否属于当前 OpenGL ES，例如在窗口系统中该位置可能会被其他应用程序窗口遮挡，此时该像素则不会被显示。</p>
<p>在片段测试之后，片段要么被丢弃，要么每个片段对应的颜色，深度，模板值会被写入帧缓冲区，最终呈现在设备屏幕上。帧缓冲区中的颜色值也可以被读回到客户端应用程序中，这样可以实现绘制到纹理的效果。</p>
<p>至此，OpenGL ES 渲染管道最终将每个像素点的颜色，深度，模板等数据输送到帧缓存中（Framebuffer）。</p>
<h2 id="帧缓存_/_渲染缓存">帧缓存 / 渲染缓存</h2><p>那么，帧缓存和渲染缓存到底代表什么，又用来做什么呢？</p>
<p>总的来说，<strong>帧缓存是接收渲染结果的缓冲区，为GPU指定存储渲染结果的区域</strong>。它存储着 OpenGL ES 绘制每个像素点最终的所有信息：颜色，深度和模板值。更通俗点，可以理解成存储屏幕上最终显示的一帧画面的区域。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112148423006492580.jpg?imageView2/0/format/jpg" alt="20170112148423006492580.jpg"></p>
<p>而<strong>渲染缓存则存储呈现在屏幕上的渲染图像，它也被称作颜色缓冲区</strong>，因为它本质上是存储要显示的颜色。多个纹理对象或多个渲染缓存对象，可通过连接点（attachment points）连接到帧缓存对象上。</p>
<p>可以同时存在很多帧缓存，并且可以通过 OpenGL ES 让 GPU 把渲染结果存储到任意数量的帧缓存中。但是，只有将内容绘制到视窗体提供的帧缓存中，才能将内容输出到显示设备。视图系统提供的帧缓存通常由两个缓存对象组成，一个前端缓存，一个后端缓存。</p>
<p>前帧缓存决定了屏幕上显示的像素颜色。程序的渲染结果通常保存在后帧缓存在内的其他帧缓存，当渲染后的后帧缓存包含一个完成的图像时，前后帧缓存会立即互换，前帧缓存变成新的后帧缓存，后帧缓存变成新的前帧缓存。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170113188548B1802A3-32BF-465F-A4E0-DDC1A4D6CFF2.png" alt="20170113188548B1802A3-32BF-465F-A4E0-DDC1A4D6CFF2.png"></p>
<p>但是前后帧我们无法去操纵，它是由系统控制的。我们只能显式的告诉系统，要展示哪个帧缓存了，然后由系统去完成前后帧的切换。</p>
<h2 id="纹理">纹理</h2><p><strong>纹理是一个用来保存图像的色值的 OpenGL ES 缓存。</strong></p>
<p>现实生活中，纹理最通常的作用是装饰我们的物体模型，它就像是贴纸一样贴在物体表面，使得物体表面拥有图案。</p>
<p>但实际上在 OpenGL 中，纹理的作用不仅限于此，它可以用来存储大量的数据。一个典型的例子就是利用纹理存储画笔笔刷的 mask 信息。</p>
<h2 id="坐标系">坐标系</h2><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170116148453735421681.jpg?imageView2/0/format/jpg" alt="20170116148453735421681.jpg"></p>
<p>OpenGL 渲染管线整个流程中，涉及了多个坐标系变化，看起来非常繁琐。但是针对 2D 图像处理，我们其实不需要关心这些变化，我们只需要了解<strong>标准化设备坐标</strong>即可。</p>
<p>标准化设备坐标是一个 x、y 和 z 值在 -1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃／裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形（忽略 z 轴，仅处理 2D 图像，z 轴设置为 0.0）：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170116148453238386304.jpg?imageView2/0/format/jpg" alt="20170116148453238386304.jpg"></p>
<p>与通常的屏幕（UIKit）坐标不同，y 轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。</p>
<p>为了方便记忆，可以借助右手左边系。</p>
<p>按照惯例，OpenGL 是一个右手坐标系。简单来说，就是正 x 轴在你的右手边，正 y 轴朝上，而正 z 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 z 轴穿过你的屏幕朝向你。坐标系画起来如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170116148453800669809.jpg?imageView2/0/format/jpg" alt="20170116148453800669809.jpg"></p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170116148453810158450.jpg?imageView2/0/format/jpg" alt="20170116148453810158450.jpg"></p>
<p>另外，为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值。</p>
<p>纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样。纹理坐标起始于（0, 0），也就是纹理图片的左下角，终始于（1, 1），即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170116148453793035367.jpg?imageView2/0/format/jpg" alt="20170116148453793035367.jpg"></p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> OpenGLES </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL ES 开篇]]></title>
      <url>/2017/04/01/OpenGLES-Lesson00/</url>
      <content type="html"><![CDATA[<p>在学习 OpenGL ES 之前，总结下我自己接触 OpenGL ES 时的一些疑惑，我相信这也是初学者都会遇到的一些困惑。</p>
<h2 id="Q_&amp;_A">Q &amp; A</h2><p><strong>Q：OpenGL 是什么 ?</strong></p>
<blockquote>
<p>A：<strong>OpenGL</strong>（Open Graphics Library）是 Khronos Group （一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准）开发维护的一个规范，它是硬件无关的。它主要为我们定义了用来操作图形和图片的一系列函数的 API，需要注意的是 <strong>OpenGL 本身并非 API</strong>。</p>
<p>而 GPU 的硬件开发商则需要提供满足 OpenGL 规范的实现，这些实现通常被称为”驱动“，它们负责将 OpenGL 定义的 API 命令翻译为 GPU 指令。<strong>所以你可以用同样的 OpenGL 代码在不同的显卡上跑</strong>，因为它们实现了同一套规范，尽管内部实现可能存在差异。</p>
</blockquote>
<a id="more"></a>
<p><strong>Q：OpenGL ES 和 OpenGL 有什么关系 ?</strong></p>
<blockquote>
<p>A：OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该规范也是由 Khronos Group 开发维护。</p>
<p>OpenGL ES 是从 OpenGL 裁剪定制而来的，去除了 glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性，剩下最核心有用的部分。</p>
<p>可以理解成是一个<strong>在移动平台上能够支持 OpenGL 最基本功能的精简规范</strong>。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170111148411873373682.jpg?imageView2/0/format/jpg" alt="20170111148411873373682.jpg"></p>
<p>OpenGL ES 横跨在两个处理器之间，<strong>协调两个内存区域之间的数据交换</strong>。</p>
</blockquote>
<p><strong>Q：为什么要使用 OpenGL ES ?</strong></p>
<blockquote>
<p>A：通常来说，计算机系统中 CPU、GPU 是协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。所以，尽可能让 CPU 和 GPU 各司其职发挥作用是提高渲染效率的关键。</p>
<p>正如我们之前提到过，OpenGL 正是给我们提供了访问 GPU 的能力，不仅如此，它还引入了<strong>缓存</strong>（Buffer）这个概念，大大提高了处理效率。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170111148411700373589.jpg?imageView2/0/format/jpg" alt="20170111148411700373589.jpg"></p>
<p>图中的剪头，代表着数据交换，也是主要的性能瓶颈。</p>
<p><strong>从一个内存区域复制到另一个内存区域的速度是相对较慢的</strong>，并且在内存复制的过程中，CPU 和 GPU 都不能处理这区域内存，避免引起错误。此外，CPU / GPU 执行计算的速度是很快的，而内存的访问是相对较慢的，这也导致<strong>处理器的性能处于次优状态</strong>，这种状态叫做“<strong>数据饥饿</strong>”，简单来说就是<strong>空有一身本事却无用武之地</strong>。</p>
<p>针对此，OpenGL 为了提升渲染的性能，为两个内存区域间的数据交换定义了<strong>缓存</strong>。缓存是指 <strong>GPU 能够控制和管理的连续 RAM</strong>。程序从 CPU 的内存复制数据到 OpenGL ES 的缓存。通过独占缓存，GPU 能够尽可能以有效的方式读写内存。 GPU 把它处理数据的能力异步地应用在缓存上，意味着 GPU 使用缓存中的数据工作的同时，运行在 CPU 中的程序可以继续执行。</p>
<p>另外，在 iOS 平台上，<a href="https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043" target="_blank" rel="external">SpriteKit</a>，<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185" target="_blank" rel="external">Core Image</a>，<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="external">Core Animation</a> 也都是基于 OpenGL ES 实现的，所以在它们各自的领域，也都有不错的表现。</p>
<p>在图像处理方面，Core Image 提供了便捷的使用以及高效的性能，但是使用原生的 OpenGL ES 会更灵活，可定制性更高，同时支持跨平台。</p>
</blockquote>
<p><strong>Q：学习 OpenGL ES 需要关注哪些内容，本系列会如何介绍 OpenGL ES ?</strong></p>
<blockquote>
<p>A：当然，如果你想全面系统的了解 OpenGL ES，那么每个接口，每种数据类型，OpenGL 工作原理，图形渲染管线每个阶段做了什么，如何编写着色器脚本等等都是需要了解的。这样的话，对着红蓝宝书学习是没有错的。</p>
<p>毋庸置疑，这样的学习必定是漫长枯燥的。</p>
<ul>
<li>你可能看了半天，学会渲染一个旋转的立方体，然后被一堆矩阵变换公式折腾的死去活来…</li>
<li>又或者看了半天，了解了一大堆概念，混合，深度测试，模版测试，面剔除等等，但是却不知道什么时候该用…</li>
</ul>
<p>无可厚非，OpenGL 需要学习的东西太多太多（至少我个人还只是学了点皮毛），但是它们也有轻重之分，也有更好的学习方式。</p>
<p>本系列要做的，就是先详述必备的概念，便于之后的学习。然后用最直接的方式，<strong>针对图像处理，逐步实现各种效果</strong>，来慢慢深入学习 OpenGL。毕竟真正做出了东西，才会有学习的动力。</p>
</blockquote>
<p><strong>Q：该系列会使用哪个版本的 OpenGL ES ?</strong></p>
<blockquote>
<p>A：OpenGL ES 2.0</p>
<p>目前 iOS 平台支持的有 OpenGL ES 1.0，2.0，3.0。</p>
<p>OpenGL ES 1.0 是<strong>固定管线</strong>，就是只可配置的管线，实现不同效果就好像在电路中打开不同的开关一样，可定制程度低，当然不选择它。</p>
<p>OpenGL ES 2.0，3.0 都是<strong>可编程管线</strong>，各种效果及他们的组合可以通过一般编程的方式实现，自由度高得多。虽然 OpenGL ES 3.0 加入了一些新的特性，但是它除了需要 <strong>iOS 7.0</strong> 以上之外，还对硬件有要求。<strong>需要 iPhone 5S 之后的设备才支持</strong>，这意味着包括 iPhone 5C 上使用的 PowerVR Series6 的 GPU 也是不支持。</p>
<p>出于现有主流设备的考虑，选择了 OpenGL ES 2.0。</p>
</blockquote>
<p>至此，如果觉得本系列文章还值得期待，那么，让我们一起努力吧～</p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> OpenGLES </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL ES， 初学者的自我总结]]></title>
      <url>/2017/04/01/OpenGLES-Menu/</url>
      <content type="html"><![CDATA[<h2 id="前言：">前言：</h2><blockquote>
<p>学习 OpenGL ES 一段时间了，<strong>深知这个过程的不容易</strong>。</p>
<p>尤其是入门，OpenGL 到底好在哪里？什么是渲染管线？什么是状态机？纹理是不是就是图片？深度测试，模版测试又是什么鬼？…</p>
<p>OpenGL <strong>有太多太多的东西需要学习</strong>。我最初接触 OpenGL，就是想借助它，实现美图秀秀里的一些功能。然而，不知道看了多少教程，实现了多少个旋转立方体，困惑了多少次，放弃了多少回…</p>
<p>慢慢地，似乎找到了一些门路…</p>
<ul>
<li>可以导入照片处理并保存了</li>
<li>可以实现简单的滤镜了</li>
<li>可以实现画笔功能了</li>
<li>可以实现马赛克功能了</li>
<li>…</li>
</ul>
<p>于是，这系列的文章应运而生。</p>
</blockquote>
<a id="more"></a>
<h2 id="目标">目标</h2><p>这系列文章主要是个人学习过程中的一些总结，因为本人也是初学者，所以会从初学者角度，介绍 OpenGL ES 图像处理最直接的一些知识。</p>
<p><strong>利用 OpenGL ES，学习如何在 iOS 平台上进行图像处理，实现各种效果。</strong></p>
<p>这，就是我想学到的，也是想分享给大家的。</p>
<blockquote>
<p>PS：时间允许的话，希望能保证一个星期输出一篇文章，鞭策自己～</p>
</blockquote>
<h2 id="目录">目录</h2><h3 id="基础扫盲：">基础扫盲：</h3><ol>
<li><a href="http://colin1994.github.io/2017/04/01/OpenGLES-Lesson00/" target="_blank" rel="external">OpenGL ES 开篇</a> : 以 Q&amp;A 的形式，列举出在学习 OpenGL ES 之前会存在的一些疑惑。权衡是否该继续学习 OpenGL ES。</li>
<li><a href="http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/" target="_blank" rel="external">OpenGL ES 基础概念</a>：扫盲篇，先介绍一些必须了解的知识，便于之后能直接进入实战阶段。</li>
<li><a href="http://colin1994.github.io/2017/04/09/OpenGLES-Lesson02/" target="_blank" rel="external">OpenGL ES 环境搭建</a>：详解 OpenGL ES 接入方式，以最基础效果（设置背景色）来阐述。</li>
<li><a href="http://colin1994.github.io/2017/04/18/OpenGLES-Lesson03/" target="_blank" rel="external">渲染基本图元，三角形</a>：详细介绍可编程图形渲染管线是如何工作的。</li>
<li>GLSL 详解（基础篇）：详细介绍 OpenGL ES 2.0 着色器语言 GLSL 基础语法。</li>
<li>GLSL 详解（高级篇）：详细介绍 OpenGL ES 2.0 着色器语言高级特性。</li>
</ol>
<h3 id="Demo_讲解：">Demo 讲解：</h3><ol>
<li>显示图片</li>
<li>视图封装</li>
<li>滤镜：色温（简单全局应用）</li>
<li>滤镜：Vignette，晕映（根据距离，区分处理）</li>
<li>形变：马赛克（简单形变，几点汇聚成一点）</li>
<li>形变：素描效果（根据边缘点，动态计算取样点色值）</li>
<li>基于 Lookup Table（Lut）的滤镜实现（用查找表替代浮点计算，提高效率）</li>
<li>多重滤镜叠加（实现及优化）</li>
</ol>
<h3 id="实战训练：">实战训练：</h3><blockquote>
<p>敬请期待</p>
</blockquote>
<h2 id="学习资料">学习资料</h2><blockquote>
<p>PS：这里将罗列个人学习过程中，认为好的一些书籍，教程，Demo等。</p>
<p>该系列的文章中，一些阐述，配图，可能是从其它文章或者书籍中摘录整理的。为保证阅读以及书写方便，这部分出处说明统一放到学习资料里。</p>
<p>本人也处于学习阶段，精力有限，难免引用前人优秀教程。如果对您造成不必要的麻烦，请及时告知。</p>
</blockquote>
<h3 id="书籍">书籍</h3><p><a href="https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf" target="_blank" rel="external">OpenGL ES 2.0 API 快速参考卡片</a></p>
<p><a href="https://www.amazon.com/OpenGL-Programming-Guide-Official-Learning/dp/0134495497" target="_blank" rel="external">红宝书：OpenGL Programming Guide</a></p>
<p><a href="https://www.amazon.com/OpenGL-Superbible-Comprehensive-Tutorial-Reference/dp/0672337479" target="_blank" rel="external">蓝宝书：OpenGL Superbible</a></p>
<h3 id="教程">教程</h3><p><a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1" target="_blank" rel="external">OpenGL ES Programming Guide for iOS</a></p>
<p><a href="http://learnopengl.com/" target="_blank" rel="external">Learn OpenGL</a></p>
<p><a href="http://www.edwinho.org/lessons/2015-08/opengl-es.html" target="_blank" rel="external">OpenGL ES_Max</a></p>
<p><a href="http://blog.csdn.net/kesalin/article/details/8221393" target="_blank" rel="external">OpenGL ES 01 OpenGL ES之初体验</a></p>
<h3 id="Demo">Demo</h3><p><a href="https://github.com/twenty3/GLImageProcessing" target="_blank" rel="external">GLImageProcessing</a></p>
<p><a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a></p>
<p><a href="https://github.com/Ciechan/BCMeshTransformView" target="_blank" rel="external">BCMeshTransformView</a></p>
<h3 id="Idea">Idea</h3><p><a href="https://www.shadertoy.com/" target="_blank" rel="external">Shadertoy</a></p>
<p><a href="https://photofunia.com/" target="_blank" rel="external">PhotoFunia</a></p>
<blockquote>
<p>PS：本人也处于 OpenGL ES 学习阶段，所以文章中<strong>难免存在问题</strong>，或者待优化地方。如果有任何不对，<strong>欢迎指出交流</strong>～</p>
</blockquote>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> OpenGLES </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Core Image 之自定义 Filter~]]></title>
      <url>/2016/10/21/Core-Image-Custom-Filter/</url>
      <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~</p>
<p>本文主要讲解 Core Image 自定义滤镜部分的内容，包括如何使用自定义 Filter，如何编写 kernel，QC 工具介绍，注意点以及一些开发技巧。</p>
<p>在这之前，我默认你了解 Core Image 的基本原理以及使用方式。如果没有，我建议你花点时间看看我的上一篇文章：<a href="http://colin1994.github.io/2016/10/21/Core-Image-OverView/" target="_blank" rel="external">Core Image 你需要了解的那些事~</a>，它介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比，想必会有所收获。</p>
<p>现在，开始吧～<img src="http://wanzao2.b0.upaiyun.com/system/pictures/1/original/27.png" alt=""></p>
<a id="more"></a>
<h2 id="自定义_Filter_流程">自定义 Filter 流程</h2><p>自定义的 Filter 和系统内置的各种 CIFilter，使用起来方式是一样的。我们唯一要做的，就是实现一个符合规范的 CIFilter 的子类，然后该怎么用怎么用。</p>
<p>这里总结起来就3步：</p>
<ul>
<li>编写 CIKernel：使用 CIKL，自定义滤镜效果。</li>
<li>加载 CIKernel：CIFilter 读取编写好的 CIKernel。</li>
<li>设置参数：设置 CIKernel 需要的输入参数以及 DOD 和 ROI。</li>
</ul>
<p>不难看出，这些操作都是围绕 <strong>CIKernel</strong> 展开的，那么，它是什么？ CIKL，DOD，ROI 又是什么鬼？<img src="http://wanzao2.b0.upaiyun.com/system/pictures/14/original/5.png" alt=""></p>
<p>先撇开这些麻烦的东西，我们先这样简单的认为：</p>
<ul>
<li>CIKernel 是我们 Filter 对应的脚本，它描述 Filter 的具体工作原理。</li>
<li>CIKL （Core Image Kernel Language）是编写 CIKernel 的语言。</li>
<li>DOD，ROI 当做普通的参数处理。</li>
</ul>
<p>弄清了这些，我们再来看具体操作过程。</p>
<p>拿一个图片翻转效果举例，效果如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101449356mirrorX.png" alt="2016101449356mirrorX.png"></p>
<h3 id="1-_编写_CIKernel">1. 编写 CIKernel</h3><p><strong>File —&gt; New —&gt; File —&gt; Empty</strong>， 创建一个名为 <strong>MirrorX.cikernel</strong> 的文件。</p>
<p>编辑 .cikernel 文件，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel vec2 mirrorX ( <span class="keyword">float</span> imageWidth ) </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 获取待处理点的位置</span></span><br><span class="line">  	vec2 currentVec = destCoord();</span><br><span class="line">    <span class="comment">// 返回最终显示位置</span></span><br><span class="line">  	<span class="keyword">return</span> vec2 ( imageWidth - currentVec.x , currentVec.y ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：这个 kernel 如果有不懂的，可以先跳过。下文会重点说明。</p>
</blockquote>
<h3 id="2-_加载_CIKernel">2. 加载 CIKernel</h3><p><strong>File —&gt; New —&gt; File —&gt; Cocoa Touch Clas</strong>，新建一个继承自 CIFilter 的类，比如 <strong>MirrorXFilter</strong>。</p>
<p>在 <strong>MirrorXFilter.m</strong> 中，添加如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CIKernel</span> *customKernel = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (customKernel == <span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleForClass: [<span class="keyword">self</span> class]];</span><br><span class="line">            <span class="built_in">NSURL</span> *kernelURL = [bundle URLForResource:<span class="string">@"MirrorX"</span> withExtension:<span class="string">@"cikernel"</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSError</span> *error;</span><br><span class="line">            <span class="built_in">NSString</span> *kernelCode = [<span class="built_in">NSString</span> stringWithContentsOfURL:kernelURL</span><br><span class="line">                                                            encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">            <span class="keyword">if</span> (kernelCode == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Error loading kernel code string in %@\n%@"</span>,</span><br><span class="line">                      <span class="built_in">NSStringFromSelector</span>(_cmd),</span><br><span class="line">                      [error localizedDescription]);</span><br><span class="line">                abort();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSArray</span> *kernels = [<span class="built_in">CIKernel</span> kernelsWithString:kernelCode];</span><br><span class="line">            customKernel = [kernels objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，重写 <strong>init</strong> 方法，主要就是读取 .cikernel 文件中代表 CIKernel 的字符串（当然， CIKernel 也可以直接写在 NSString 里头，免去文件读取这步），然后使用 <strong>kernelsWithString</strong></p>
<p>方法获取到真正的 CIKernel 对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable <span class="built_in">NSArray</span>&lt;<span class="built_in">CIKernel</span> *&gt; *)kernelsWithString:(<span class="built_in">NSString</span> *)string  <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_4, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>至此，CIKernel 加载完毕。</p>
<h3 id="3-_设置参数">3. 设置参数</h3><p>在 <strong>MirrorXFilter.m</strong> 中，添加需要的成员变量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MirrorXFilter</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">CIImage</span>  *inputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只需要一个成员变量，<strong>inputImage</strong> 表示我们的输入图片。</p>
<p>之后，就是设置参数，传入 kernel 中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">- (<span class="built_in">CIImage</span> *)outputImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> inputWidth = inputImage.extent.size.width;</span><br><span class="line">    <span class="built_in">CIImage</span> *result = [customKernel applyWithExtent: inputImage.extent roiCallback: ^( <span class="keyword">int</span> index, <span class="built_in">CGRect</span> rect ) &#123;</span><br><span class="line">        <span class="keyword">return</span> rect;</span><br><span class="line">    &#125; inputImage: inputImage arguments: @[@(inputWidth)]];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只需要重写 outputImage 方法即可。</p>
<p><strong>extent</strong> 用于返回 CIImage 对象对应的 bounds，通过它可以拿到图片的宽度。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return a rect the defines the bounds of non-(0,0,0,0) pixels */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="built_in">NS_NONATOMIC_IOSONLY</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> extent;</span><br></pre></td></tr></table></figure>
<p>然后通过  applyWithExtent 来设置对应的参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="built_in">CIImage</span> *)applyWithExtent:(<span class="built_in">CGRect</span>)extent</span><br><span class="line">                          roiCallback:(<span class="built_in">CIKernelROICallback</span>)callback</span><br><span class="line">                           inputImage:(<span class="built_in">CIImage</span>*)image</span><br><span class="line">                            arguments:(nullable <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&gt; *)args;</span><br></pre></td></tr></table></figure>
<p>这里有4个参数。</p>
<ul>
<li>extent，也就是之前提到的 DOD，暂且略过。</li>
<li>callback，也就是之前提到的 ROI，暂且略过。</li>
<li>image，缺省的 inputImage，传入我们的成员变量 inputImage 即可。</li>
<li>args，输入参数数组，与 CIKernel 中定义的一一对应。这里只有一个 inputWidth。</li>
</ul>
<blockquote>
<p>PS：这里可能有同学会有疑惑，为什么 inputImage 可以缺省，inputWidth 就需要传入呢。这里暂且不纠结，下面会详细说明~</p>
</blockquote>
<p>如此，一个自定义 Filter 就完成了。简单吧~</p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png" alt=""></p>
<h3 id="4-_使用">4. 使用</h3><p>至于使用上，则和普通的 CIFilter 基本一致。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MirrorXFilter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 将UIImage转换成CIImage</span></span><br><span class="line"><span class="built_in">CIImage</span> *ciImage = [[<span class="built_in">CIImage</span> alloc] initWithImage:<span class="keyword">self</span>.imageView.image];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建滤镜</span></span><br><span class="line"><span class="keyword">self</span>.filter = [[MirrorXFilter alloc] init];</span><br><span class="line"><span class="comment">// 设置相关参数</span></span><br><span class="line">[<span class="keyword">self</span>.filter setValue:ciImage forKey:<span class="string">@"inputImage"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 渲染并输出CIImage</span></span><br><span class="line"><span class="built_in">CIImage</span> *outputImage = [<span class="keyword">self</span>.filter outputImage];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取绘制上下文</span></span><br><span class="line"><span class="keyword">self</span>.context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建输出CGImage</span></span><br><span class="line"><span class="built_in">CGImageRef</span> cgImage = [<span class="keyword">self</span>.context create<span class="built_in">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:cgImage];</span><br><span class="line"><span class="comment">// 6. 释放CGImage</span></span><br><span class="line"><span class="built_in">CGImageRelease</span>(cgImage);</span><br></pre></td></tr></table></figure>
<p>如此，我们便可得到翻转后的图片。</p>
<h3 id="5-_更多">5. 更多</h3><p>当然，如果你是一个完美主义者，我觉得你还还可以做更多~</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> *)customAttributes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">        <span class="string">@"inputDistance"</span> :  @&#123;</span><br><span class="line">            k<span class="built_in">CIAttributeMin</span>       : @<span class="number">0.0</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeMax</span>       : @<span class="number">1.0</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeSliderMin</span> : @<span class="number">0.0</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeSliderMax</span> : @<span class="number">0.7</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeDefault</span>   : @<span class="number">0.2</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeIdentity</span>  : @<span class="number">0.0</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeType</span>      : k<span class="built_in">CIAttributeTypeScalar</span></span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">@"inputSlope"</span> : @&#123;</span><br><span class="line">            k<span class="built_in">CIAttributeSliderMin</span> : @<span class="number">-0.01</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeSliderMax</span> : @<span class="number">0.01</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeDefault</span>   : @<span class="number">0.00</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeIdentity</span>  : @<span class="number">0.00</span>,</span><br><span class="line">            k<span class="built_in">CIAttributeType</span>      : k<span class="built_in">CIAttributeTypeScalar</span></span><br><span class="line">            &#125;,</span><br><span class="line">         k<span class="built_in">CIInputColorKey</span> : @&#123;</span><br><span class="line">         k<span class="built_in">CIAttributeDefault</span> : [<span class="built_in">CIColor</span> colorWithRed:<span class="number">1.0</span></span><br><span class="line">                                               green:<span class="number">1.0</span></span><br><span class="line">                                                blue:<span class="number">1.0</span></span><br><span class="line">                                               alpha:<span class="number">1.0</span>]</span><br><span class="line">           &#125;,</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以为自定义的 Filter 添加对应的参数描述，以及默认值，范围限制等。</p>
<p>这不是必须的，但却是可取的。至于如何设置，可以参考 CIFilter 对应的 <strong>attributes</strong> 属性，或者参照上面这个例子。</p>
<p>另外，iOS 9之后，引入了 <strong>registerFilterName</strong> , 你可以通过重写 <code>+ (CIFilter *)filterWithName: (NSString *)name;</code> ，然后外部使用的时候，跟 CIFilter 一模一样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Publishes a new filter called 'name'.</span><br><span class="line"></span><br><span class="line"> The constructor object 'anObject' should implement the filterWithName: method.</span><br><span class="line"> That method will be invoked with the name of the filter to create.</span><br><span class="line"> The class attributes must have a kCIAttributeFilterCategories key associated with a set of categories.</span><br><span class="line"> @param   attributes    Dictionary of the registration attributes of the filter. See below for attribute keys.</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">void</span>)registerFilterName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">               constructor:(<span class="keyword">id</span>&lt;<span class="built_in">CIFilterConstructor</span>&gt;)anObject</span><br><span class="line">           classAttributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)attributes <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_4, <span class="number">9</span>_0);</span><br></pre></td></tr></table></figure>
<p>不过需要 iOS 9以上才支持，另外一般用于打包成 Image Units 给他人使用。</p>
<p>正常情况下应该是用不到。如果真有这个需求，可以参考这篇文章： <a href="https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_image_units/ci_image_units.html#//apple_ref/doc/uid/TP30001185-CH7-SW12" target="_blank" rel="external">Packaging and Loading Image Units</a>。</p>
<p>至此，自定义 Filter 的流程就算走完了，我们很容易就可以配置好需要的环境。</p>
<p>然而，真正的自定义部分，才刚刚开始！</p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/183/original/%E5%BC%80%E5%BF%8336.png" alt=""></p>
<h2 id="DOD_&amp;_ROI">DOD &amp; ROI</h2><h3 id="1-_DOD">1. DOD</h3><p>DOD ( domain of definition ) ，简单来说就是 Filter 处理后，输入的图片区域。</p>
<p>一般来说，Filter 操作都是基于原图，添加上效果，但是并不会改变图片的大小，显示区域。所以一般与原图的一致即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> dod = inputImage.extent;</span><br></pre></td></tr></table></figure>
<p>但是针对形变类的 Filter，则需要根据输出图片大小，设置正确的 DOD。</p>
<h3 id="2-_ROI">2. ROI</h3><p>ROI ( region of interest )，在一定的时间内特别感兴趣的区域，即当前处理区域。</p>
<p>可以简单的理解为：当前处理区域对应于原图中的哪个区域。</p>
<p>ROI 的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Block callback used by Core Image to ask what rectangles of a kernel's input images</span><br><span class="line"> * are needed to produce a desired rectangle of the kernel's output image.</span><br><span class="line"> *</span><br><span class="line"> * 'index' is the 0-based index specifying which of the kernel's input images is being queried.</span><br><span class="line"> * 'destRect' is the extent rectangle of kernel's output image being queried.</span><br><span class="line"> *</span><br><span class="line"> * Returns the rectangle of the index'th input image that is needed to produce destRect.</span><br><span class="line"> * Returning CGRectNull indicates that the index'th input image is not needed to produce destRect.</span><br><span class="line"> * The returned rectangle need not be contained by the extent of the index'th input image.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CGRect</span> (^<span class="built_in">CIKernelROICallback</span>)(<span class="keyword">int</span> index, <span class="built_in">CGRect</span> destRect);</span><br></pre></td></tr></table></figure>
<p>CIKernelROICallback 在 Core Image 内部进行处理的时候，会多次调用。</p>
<p><strong>index</strong> 表示输入图片的下标，顺序和 kernel 中的入参顺序一致，从0开始。</p>
<p><strong>destRect</strong> 表示输出图片的区域。 也就是我们先前设置的 DOD。</p>
<p>那，我们为什么要显示设置 ROI 呢 ？</p>
<p>因为输入图片中，参与处理的实际区域，Core Image 是无法知道的，我们需要显式的告诉 CI 这个区域。</p>
<p>这么讲可能有点难以理解，下面我们看两个具体的例子。</p>
<p>先看一个旋转的例子。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101449433roi_1.png" alt="2016101449433roi_1.png"></p>
<p>这里就是进行了 x，y 互换操作。很容易得到我们的 DOD：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> dod = <span class="built_in">CGRectMake</span>(inputImage.extent.origin.y, inputImage.extent.origin.x, inputImage.extent.size.height, inputImage.extent.size.width);</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="comment">// 原图片extent (0, 0, 200, 300)</span></span><br><span class="line"><span class="comment">// 旋转后的输出图片 (0, 0, 300, 200)，也就是 DOD</span></span><br></pre></td></tr></table></figure>
<p>那 ROI 应该怎么设置呢 ？我们之前说过，ROI 计算就是计算当前处理区域对应于原图中的哪个区域。</p>
<p>也就是一个逆向过程。</p>
<p>假如，A：输入图片中的某点   B：输出图片中的某点。那么 ROI 计算可以理解成  ROI（B）= A。</p>
<p>理解好这点，我们不难写出这个操作对应的 ROI：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIKernelROICallback</span> callback = ^(<span class="keyword">int</span> index, <span class="built_in">CGRect</span> rect) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(rect.origin.y, rect.origin.x, rect.size.height, rect.size.width);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，当输入图片不止一个的时候，则需要根据 <strong>index</strong> 来做区别。因为这里的 <strong>rect</strong> 每次都是返回 <strong>DOD</strong>，而不是当前图片的 extent。</p>
<h2 id="CIKernel_介绍">CIKernel 介绍</h2><p>终于到了本文最重要的部分了，CIKernel 介绍！</p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/187/original/%E5%BC%80%E5%BF%83ForeverAloneExcited.png" alt=""></p>
<p>在此之前，我们先了解下它的一些背景知识。</p>
<p>CIKernel 需要使用 Core Image Kernel Language (CIKL) 来编写，CIKL 是 OpenGL Shading Language (GLSL) 的子集，如果你之前有过 OpenGL 着色器编写的经验，这部分你会感觉格外亲切。CIKL 集成了 GLSL 绝大部分的参数类型和内置函数，另外它还添加了一些适应 Core Image 的参数类似和函数。</p>
<p>一个 kernel 的处理过程，可以用下面伪代码表示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ... image.width</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span> ... image.height</span><br><span class="line">        New_Image[i][j] = CustomKernel(Current_Image[i][j])</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>也就是说，每个需要处理的 fragment 都会调用一次 kernel 相关操作，每次操作的目的就是返回当前 fragment 对应的结果 fragment，这里 fragment 可以理解为像素点。</p>
<p>所以我们的 kernel，应该是针对一个点，而不是一张图片。</p>
<p>Core Image 内置了3种适用于不同场景的 Kernel，可以根据实际需求来选择。</p>
<ul>
<li>CIColorKernel：用于处理色值变化的 Filter。</li>
<li>CIWarpKernel：用于处理形变的 Filter。</li>
<li>CIKernel：通用。</li>
</ul>
<p>CIColorKernel，CIWarpKernel 是官方推荐使用的。某个 Filter，在使用它们能实现的情况下，应该使用它们，即使是一个 CIKernel 拆分成多个 CIColorKernel 以及 CIWarpKernel，也应该用这种方式。因为 Core Image 内部对这两张 Kernel 做了优化。</p>
<p>当然，它们的使用时有限制的。目的一定要很纯粹，比如 CIColorKernel 只能处理色值上的变化。否则就算定义为 CIColorKernel，如果实现上涉及了其他 CIColorKernel 不允许的操作，Core Image 也会当做普通的 CIFilter 处理。</p>
<p>另外，kernel 的入参只支持下面这么几种：</p>
<table>
<thead>
<tr>
<th>Kernel routine input parameter</th>
<th>Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>sampler</td>
<td>CISampler</td>
</tr>
<tr>
<td>__table sampler</td>
<td>CISampler</td>
</tr>
<tr>
<td>__color</td>
<td><code>CIColor</code></td>
</tr>
<tr>
<td>float</td>
<td>NSNumber</td>
</tr>
<tr>
<td>vec2, vec3, or vec4</td>
<td>CIVector</td>
</tr>
</tbody>
</table>
<p>简单说明一下：</p>
<ul>
<li>sampler：可以理解成纹理，或者图片。外部以 CIImage 形式传入。</li>
<li>__table sampler：表示颜色查找表（lookup table），虽然它也是图片，但是添加该声明可以避免被修改。外部以 CIImage 形式传入。</li>
<li>__color：表示颜色。外部以 CIColor 形式传入。</li>
<li>float：kernel 内部处理都是 float 类型。外部以 NSNumber 形式传入。</li>
<li>vecN：表示一个多元向量。比如 vec2 可以表示一个点，vec4 可以表示一个色值。外部以 CIVector 形式传入。</li>
</ul>
<p>至于 kernel 中可以使用的函数，那就太多了。这里不一一枚举，在下面的具体讲解中，会说明几个常用的。如果想了解更多，可以参考  <a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397" target="_blank" rel="external">Core Image Kernel Language Reference</a>，以及 <a href="http://www.shaderific.com/glsl/" target="_blank" rel="external">OpenGL ES Shading Language Reference</a>。</p>
<p>下面我会通过一个 Demo，讲解这三种 Kernel 的具体用法。</p>
<blockquote>
<p>PS：建议阅读之前，下载 <a href="https://github.com/colin1994/CoreImageDemo" target="_blank" rel="external">源码</a> 配合着看。</p>
</blockquote>
<h3 id="1-_CIColorKernel">1. CIColorKernel</h3><p>首先看下官方的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * CIColorKernel is an object that encapsulates a Core Image Kernel Language</span><br><span class="line"> * routine that processes only the color information in images.</span><br><span class="line"> *</span><br><span class="line"> * Color kernels functions are declared akin to this example:</span><br><span class="line"> *   kernel vec4 myColorKernel (__sample fore, __sample back, vec4 params)</span><br><span class="line"> *</span><br><span class="line"> * The function must take a __sample argument for each input image.</span><br><span class="line"> * Additional arguments can be of type float, vec2, vec3, vec4, or __color.</span><br><span class="line"> * The destination pixel location is obtained by calling destCoord().</span><br><span class="line"> * The kernel should not call sample(), sampleCoord(), or samplerTransform().</span><br><span class="line"> * The function must return a vec4 pixel color.</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NS_CLASS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">8</span>_0)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CIColorKernel</span> : <span class="title">CIKernel</span></span></span><br></pre></td></tr></table></figure>
<p>很重要的一点：<strong>processes only the color information in images</strong>，它只处理图片的颜色信息。</p>
<p>所以在使用它之前，一定要确保该 Filter 只涉及颜色处理。</p>
<p>CIKL 的语法和大多数 C 阵营一样，变量，运算符，控制结构，函数等都大同小异，所以它的学习成本是很低的。</p>
<p>真正的核心应该是：<strong>如果用这样的语言来实现这个滤镜，也就是我们经常说的算法。</strong></p>
<p>下面我们以一个 <strong>Vignette</strong> 来实际讲解一下。</p>
<p>它的效果如下所示：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101796011vignette_demo.gif" alt="2016101796011vignette_demo.gif"></p>
<p>不难看出，Vignette 滤镜，它实际上就是一个FOV（Field of View） 的效果，即视野中央看的最清楚，清晰程度与到中心距离呈反比，与人类的视觉是类似的。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101524815vignette.png" alt="2016101524815vignette.png"></p>
<p>所以针对图片上的每个像素点 A，经过 Vignette 滤镜处理后得到的 B，应该满足：</p>
<p>Vignette（A）＝ A * Darken ＝ B； 而 Darken 的计算依赖 A 与中心点的距离。</p>
<p>如此，我们可以很容易的写出对应的 kernel：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kernel vec4 vignetteKernel(__sample image, vec2 center, <span class="keyword">float</span> radius, <span class="keyword">float</span> alpha)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算出当前点与中心的距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = distance(destCoord(), center) ;</span><br><span class="line">    <span class="comment">// 根据距离计算出暗淡程度</span></span><br><span class="line">    <span class="keyword">float</span> darken = <span class="number">1.0</span> - (distance / radius * alpha);</span><br><span class="line">    <span class="comment">// 返回该像素点最终的色值</span></span><br><span class="line">    image.rgb *= darken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image.rgba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 C 语言的一样，函数需要具备：</p>
<ul>
<li>返回类型：vec4</li>
<li>函数名：vignetteKernel</li>
<li>参数列表：__sample image, vec2 center, float radius, float alpha）</li>
<li>函数体：｛｝中的具体实现</li>
</ul>
<p>有所不同的，kernel 函数需要带上 kernel 关键字，与其它普通函数做区分。一个 .cikernel 文件中，允许包括多个函数，甚至是多个 kernel 函数，不过<strong>函数调用要出现在函数定义之后</strong>！</p>
<p>另外，这里有个特别的参数类型，<strong>__sample</strong> ，和之前讲的 <strong>sampler</strong> 有所不同。因为这里我们使用的是 <strong>CIColorKernel</strong>，在得到高效性能的同时，也有一定的局限性。因为只是处理图片当前位置的颜色信息，所以 <strong>__sample</strong> 提供的 <strong>rgba</strong> 变量足够了，无法获取一些其它的信息。</p>
<blockquote>
<p>比如在 CIKernel 中，可以通过 sample() 等函数获取其它位置的色值，而在 CIColorKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。</p>
</blockquote>
<p>下面逐行解释这个 kernel。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算出当前点与中心的距离</span></span><br><span class="line"><span class="keyword">float</span> distance = distance(destCoord(), center) ;</span><br></pre></td></tr></table></figure>
<p><strong>destCoord</strong></p>
<ul>
<li><p><code>varying vec2 destCoord ()</code></p>
<p>返回当前正在处理的像素点所处坐标。(working space coordinates)</p>
</li>
</ul>
<p>这里使用的 CIKL 内置的函数 destCoord，它返回的坐标是基于 <strong>working space</strong> 的。所谓 working space，即工作空间，它的取值范围对应图片实际大小。比如 inputImage 的大小为 300 * 200，那么 destCoord() 返回坐标的取值范围在 (0, 0) - (300, 200)。</p>
<p><strong>distance</strong></p>
<ul>
<li><p><code>float distance (vec2 p0, vec2 p1)</code></p>
<p>计算向量p0，p1之间的距离</p>
</li>
</ul>
<p>如此便能很容易得到当前点与中心的距离。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据距离计算出暗淡程度</span></span><br><span class="line"><span class="keyword">float</span> darken = <span class="number">1.0</span> - (distance / radius * alpha);</span><br></pre></td></tr></table></figure>
<p>之后根据清晰程度与到中心距离呈反比这一原理，结合外部控制的 <strong>alpha</strong> 变量，计算出暗淡程度。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回该像素点最终的色值</span></span><br><span class="line">image.rgb *= darken;</span><br><span class="line"><span class="keyword">return</span> image.rgba;</span><br></pre></td></tr></table></figure>
<p>这里之前提到，<strong>__sample</strong> 有个 rgba 变量，通过它可以获取到当前处理点的色值。</p>
<p>在 CIKL 中，vec4 的任何一个分量都可以单独获取，也可以组合获取，例如 <strong>image.a</strong>，<strong>image.rrgg</strong> 等，都是可行的。</p>
<p>CIColorKernel 是针对色值的处理，所以它的返回值必须是一个代表色值的 vec4 类型变量。</p>
<p>至此，这个 vignetteKernel 就分析完毕了。很简单吧～</p>
<h3 id="2-_CIWarpKernel">2. CIWarpKernel</h3><p>同样，先看下文档定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * CIWarpKernel is an object that encapsulates a Core Image Kernel Language</span><br><span class="line"> * function that processes only the geometry of an image.</span><br><span class="line"> *</span><br><span class="line"> * Warp kernels functions are declared akin to this example:</span><br><span class="line"> *   kernel vec2 myWarpKernel (vec4 params)</span><br><span class="line"> *</span><br><span class="line"> * Additional arguments can be of type float, vec2, vec3, vec4.</span><br><span class="line"> * The destination pixel location is obtained by calling destCoord().</span><br><span class="line"> * The kernel should not call sample(), sampleCoord(), or samplerTransform().</span><br><span class="line"> * The function must return a vec2 source location.</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NS_CLASS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">8</span>_0)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CIWarpKernel</span> : <span class="title">CIKernel</span></span></span><br></pre></td></tr></table></figure>
<p>同样，它也有很重要一点：<strong>processes only the geometry of an image</strong>。它只处理图片的几何形状。</p>
<p>所谓的改变几何形状，也就是形变，把原本放置在 A 处的点，用 B 处的点去填充，或者反过来，把原本 B 处的点，挪到 A 处去，也是一样的。</p>
<p>它可以用这个表达式表示：<strong>Warp（A）＝ B；</strong></p>
<p>所以它和之前的 CIColorKernel 不同，它的返回值是 vec2，代表点的坐标。另外它只允许传入一张图片，所以这里的 inputImage 缺省了。</p>
<blockquote>
<p>同样的，在 CIWarpKernel 中，无法使用 sample()， sampleCoord() 以及 samplerTransform() 。</p>
</blockquote>
<p>下面以一个马赛克，像素化（Pixellate）的例子来讲解。它的效果如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101762677pixellate_demo.gif" alt="2016101762677pixellate_demo.gif"></p>
<p>马赛克，比较简单的一种算法是按照固定的间隔取像素点，将图片分割成一些小块，然后每个小块内选择一个像素点，然后把这个区域全部用这个像素点填充即可。这里的每个小块，称作晶格，晶格越大，马赛克效果越好。</p>
<p>依照这个简单算法，我们可以很容易的写出对应的 kernel：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kernel vec2 pixellateKernel(<span class="keyword">float</span> radius)</span><br><span class="line">&#123;</span><br><span class="line">    vec2 positionOfDestPixel, centerPoint;</span><br><span class="line">    <span class="comment">// 获取当前点坐标</span></span><br><span class="line">    positionOfDestPixel = destCoord();</span><br><span class="line">    <span class="comment">// 获取对应晶格内的中心像素点</span></span><br><span class="line">    centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * <span class="number">2.0</span>) + radius;</span><br><span class="line">    centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * <span class="number">2.0</span>) + radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> centerPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，先是获取到当前处理点的坐标，positionOfDestPixel。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对应晶格内的中心像素点</span></span><br><span class="line">centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * <span class="number">2.0</span>) + radius;</span><br><span class="line">centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * <span class="number">2.0</span>) + radius;</span><br></pre></td></tr></table></figure>
<p>然后这里的 <strong>mod (x, y)</strong> 和平时使用的一样，计算 <strong>x / y 的余数</strong>。</p>
<p>至于为什么这个式子能获得<strong>中心像素点坐标</strong>，想必一看就懂了吧～（不懂的可以拿张纸画画）</p>
<p>最后返回中心点坐标，替换当前点。</p>
<p>如此，一个简单的马赛克就完成了～</p>
<h3 id="3-_CIKernel">3. CIKernel</h3><p>我们之前说过，CIColorKernel 和 CIWarpKernel 内部做了优化，要尽可能的使用它们。除非真的有特殊需求，是它们无法实现的。下面罗列了 CIColorKernel 和 CIWarpKernel 的一些局限：</p>
<p><strong>CIColorKernel ：</strong></p>
<ul>
<li>只处理当前处理点色值，无法获取到其它点的状态。</li>
</ul>
<p><strong>CIWarpKernel：</strong></p>
<ul>
<li>只处理当前处理点位置，无法获取到其它点的状态。</li>
<li>只能传入一张图片。</li>
</ul>
<p>比如说，美图秀秀里面的一些简单马赛克，效果如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101864134mosaic_demo.gif" alt="2016101864134mosaic_demo.gif"></p>
<p>它的实现方式，我们可以简单的这么理解：</p>
<ol>
<li>判断当前点是否在传入点的处理范围内。</li>
<li>如果在，返回马赛克贴图中对应的像素点色值。</li>
<li>如果不在，返回当前点色值。</li>
</ol>
<p>很明显，它需要两张图片，一张我们的待处理图片，一张马赛克贴图。所以 CIWarpKernel 不适用。</p>
<p>另外，待处理图片与马赛克贴图之前不是一一对应关系，在第二步，返回马赛克贴图中对应的像素点色值中，需要一个映射计算，即当前点对应马赛克贴图中的某点。所以 CIColorKernel 也不适用。</p>
<p>这种情况下，就要使用通用的 CIKernel 了。</p>
<p>下面是对应的 kernel：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel vec4 mosaicKernel(sampler image, sampler maskImage, <span class="keyword">float</span> radius, vec2 point, <span class="keyword">float</span> maskWidth, <span class="keyword">float</span> maskHeight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前点坐标</span></span><br><span class="line">    vec2 textureCoordinate = destCoord();</span><br><span class="line">    <span class="comment">// 计算当前点与传入点的距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = distance(textureCoordinate, point);</span><br><span class="line">    <span class="keyword">if</span> (distance &lt; radius) &#123;</span><br><span class="line">        <span class="comment">// 在处理范围内, 计算对应马赛克贴图中的位置</span></span><br><span class="line">        <span class="keyword">float</span> resultX = mod(textureCoordinate.x, maskWidth);</span><br><span class="line">        <span class="keyword">float</span> resultY = mod(textureCoordinate.y, maskHeight);</span><br><span class="line">        <span class="keyword">return</span> sample(maskImage, samplerTransform(maskImage, vec2(resultX, resultY)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回原图对应像素点色值</span></span><br><span class="line">        <span class="keyword">return</span> sample(image, samplerTransform(image, textureCoordinate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里参数比较多，分别对应：</p>
<ul>
<li>image：待处理图片</li>
<li>maskImage：马赛克贴图</li>
<li>radius：处理范围，半径</li>
<li>point：传入点，即当前触摸的点</li>
<li>maskWidth：马赛克贴图宽度</li>
<li>maskHeight：马赛克贴图高度</li>
</ul>
<p>上面的 kernel，使用了两个新的函数，sample 和 samplerTransform。</p>
<blockquote>
<p><code>vec4 sample (uniform sampler src, vec2 point)</code><br>Returns the pixel value produced from sampler src at the position point, where point is specified in sampler space.</p>
<p>返回图片 src 指定点 point 处的色值。point 是基于 sampler space。</p>
<p><code>vec2 samplerTransform (uniform sampler src, vec2 point)</code><br>Returns the position in the coordinate space of the source (the first argument) that is associated with the position defined in working-space coordinates (the second argument). (Keep in mind that the working space coordinates reflect any transformations that you applied to the working space.) For example, if you are modifying a pixel in the working space, and you need to retrieve the pixels that surround this pixel in the original image, you would make calls similar to the following, where d is the location of the pixel you are modifying in the working space, and image is the image source for the pixels.</p>
<p>返回图片 src 指定点 point 处坐标对应的基于 sampler space 的坐标。point 是基于working space。</p>
<p>sampler space 的取值是 0.0 - 1.0，左下角为原点，向右，向上递增。</p>
</blockquote>
<p>了解了这两个函数的用法，想必这段代码就没什么需要特别说明的地方了，注释已经很清楚，不再累述。</p>
<h2 id="注意点">注意点</h2><h3 id="1-_premultiply">1. premultiply</h3><blockquote>
<p><code>vec4 premultiply (vec4 color)</code><br>Multiplies the red, green, and blue components of the color parameter by its alpha component.</p>
</blockquote>
<p>将颜色变量的r、g、b元素值分别于 alpha 相乘，返回一个新的四维颜色向量。</p>
<blockquote>
<p><code>vec4 unpremultiply (vec4 color)</code><br>If the alpha component of the color parameter is greater than 0, divides the red, green and blue components by alpha. If alpha is 0, this function returns color.</p>
</blockquote>
<p>将颜色变量的r、g、b元素值分别除以 alpha ，返回一个新的四维颜色向量。</p>
<p>pixel（R, G, B, A） —— (premultiply) ——&gt; (R＊A, G＊A, B＊A, A)</p>
<p>—— (unpremultiply) ——&gt; （R, G, B, A）。</p>
<p>在 Core Image 中，默认颜色空间是 sRGB，在 kernel 中得到的色值，都经过了 Premultiplied Alpha 处理。</p>
<p>至于为什么要执行 Premultiplied Alpha 操作，具体的可以参考这篇文章：<a href="https://boundary.cc/2015/07/why-premultiplied-alpha/" target="_blank" rel="external">为什么要PREMULTIPLIED ALPHA呢？</a></p>
<p>所以如果 kernel 涉及 alpha 相关操作，则需要先执行 unpremultiply，返回正确的 rgba。处理完之后，再执行 premultiply 操作。</p>
<p>比如一个反相滤镜，</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101643860rever_1.gif" alt="2016101643860rever_1.gif"><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20161016903rever_2.gif" alt="20161016903rever_2.gif"></p>
<p>它对应的 kernel 应该是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kernel vec4 _invertColor(sampler source_image)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 pixValue;</span><br><span class="line">    <span class="comment">// samplerCoord 返回当前像素点在 sampler space 中的位置</span></span><br><span class="line">    <span class="comment">// kernel 无法知道该图片是否进行了某些变换操作，所以确保转换为 sampler space 中的位置 是有必要的</span></span><br><span class="line">    pixValue = sample(source_image, samplerCoord(source_image));</span><br><span class="line">    <span class="comment">// 执行 unpremultiply 操作, 得到真正的 RGB 值</span></span><br><span class="line">    <span class="comment">// (R＊A, G＊A, B＊A, A) ——(unpremultiply)——&gt; (R, G, B, A)</span></span><br><span class="line">    <span class="comment">// Core Image is always RGB based.</span></span><br><span class="line">    unpremultiply(pixValue); </span><br><span class="line">    <span class="comment">// invertColor</span></span><br><span class="line">    pixValue.r = <span class="number">1.0</span> - pixValue.r; </span><br><span class="line">    pixValue.g = <span class="number">1.0</span> - pixValue.g;</span><br><span class="line">    pixValue.b = <span class="number">1.0</span> - pixValue.b;</span><br><span class="line">    <span class="comment">// premultiply. (R, G, B, A) —&gt; (R＊A, G＊A, B＊A, A)</span></span><br><span class="line">    <span class="keyword">return</span> premultiply(pixValue); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化：</span></span><br><span class="line"><span class="comment">// 避免了 unpremultiply 和 premultiply 操作，能更高效执行。</span></span><br><span class="line"><span class="comment">// pixValue 是 (R＊A, G＊A, B＊A, A)， pixValue.a - pixValue.r = (1-r)*a. 和最终 premultiply 得到的结果一样.</span></span><br><span class="line">kernel vec4 _invertColor(sampler source_image)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 pixValue;</span><br><span class="line">    pixValue = sample(source_image, samplerCoord(source_image));</span><br><span class="line">    pixValue.rgb = pixValue.aaa - pixValue.rgb;</span><br><span class="line">    <span class="keyword">return</span> pixValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-_关键字">2. 关键字</h3><p>和 C 语言等一样，CIKL 中变量的命名不能和关键字相同。</p>
<p>下面是官方 Session 中翻转对应的 kernel 脚本，这里用到了 input 关键字，导致整个 kernel 错误。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101638470session_error.png" alt="2016101638470session_error.png"></p>
<p>所以这点一定要牢记。</p>
<p>下面是在 Github 上引起的灾难..</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101685335error_1.png" alt="2016101685335error_1.png"></p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101697866error_2.png" alt="2016101697866error_2.png"></p>
<h3 id="3-_GLSL">3. GLSL</h3><p>CIKL 是 GLSL 的子集，所以<strong>不是 GLSL 中定义的任何东西在 CIKL 中都适用</strong>。但是 glsl 中大多数关键字都是可以用的。另外，CIKL 还提供了 glsl 不支持的，额外的数据类型，关键字，方法，来完善 CIKernel。</p>
<h3 id="4-_Array,_Mat">4. Array, Mat</h3><p> In addition, the following are not implemented:</p>
<ul>
<li>Data types: <code>mat2</code>, <code>mat3</code>, <code>mat4</code>, <code>struct</code>, <code>arrays</code></li>
</ul>
<p>这些数据类型 Core Image 不支持。但是在 kernel 内部却可以使用 … </p>
<p>如果当做参数传入，则会报错：</p>
<p><strong>invalid kernel parameter type; valid types are:  ‘float’, ‘vec2’, ‘vec3’, ‘vec4’, ‘sampler’, ‘sample’, ‘color’</strong></p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/229/original/%E6%82%B2%E4%BC%A41.png" alt=""></p>
<p>这也导致了一些依赖关键点的算法无法实现。</p>
<h3 id="5-_坐标系">5. 坐标系</h3><p>UIKit 坐标系，原点在屏幕左上，x轴向右，y轴向下。</p>
<p>Core Image 和 OpenGL 坐标系原点在屏幕的左下，x轴向右，y轴向上。</p>
<p>所以位置的处理上要注意。</p>
<h3 id="6-_局限">6. 局限</h3><p>kernel 的输入和输出像素可以相互映射。大多数像素处理都可以用这种方式表达，但是有的图像处理操作很困难，甚至不可能。</p>
<p>kernel 的使用上还是有一定的局限性。比如说通过输入图像映射计算直方图是很困难的。也不可以执行种子填充算法或者其他需要复杂条件语句的图像分析操作。</p>
<h3 id="7-_性能优化">7. 性能优化</h3><p>kernel 中的内容要尽可能简单，高效。</p>
<ul>
<li>展开循环操作会更快。</li>
<li>外部能传入的变量，尽量不要在 kernel 中计算获取。</li>
</ul>
<h2 id="开发技巧">开发技巧</h2><h3 id="1-_Log">1. Log</h3><p><strong>+(id)kernelsWithString:(id)arg1 messageLog:(id)arg2 ;</strong></p>
<p>这是  <a href="https://github.com/CPDigitalDarkroom/iOS9-SpringBoard-Headers/blob/a11be523d5644a178614585ff57f9638300c2cc0/System/Library/Frameworks/CoreImage.framework/CIKernel.h" target="_blank" rel="external">CIKernel.h</a> 里面的私有方法，在调试阶段可以利用它来打印 kernel 中的错误。</p>
<p>比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *messageLog = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">NSArray</span> *kernels = [[<span class="built_in">CIKernel</span> class] 		 performSelector:<span class="keyword">@selector</span>(kernelsWithString:messageLog:) withObject:kernelCode withObject:messageLog];</span><br><span class="line"><span class="keyword">if</span> ( messageLog.count &gt; <span class="number">0</span>) </span><br><span class="line">  	<span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, messageLog.description);</span><br><span class="line">customKernel = [kernels objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误 log</span></span><br><span class="line">Error: (</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">CIKernelMessageLineNumber</span> = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">CIKernelMessageType</span> = <span class="built_in">CIKernelMessageTypeError</span>;</span><br><span class="line">        k<span class="built_in">CIKernelMessageDescription</span> = <span class="string">"unkown type or function name 'destCoordE'; did you mean 'destCoord'?"</span>;</span><br><span class="line">        k<span class="built_in">CIKernelMessageOffset</span> = <span class="number">142</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">CIKernelMessageLineNumber</span> = <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">CIKernelMessageType</span> = <span class="built_in">CIKernelMessageTypeError</span>;</span><br><span class="line">        k<span class="built_in">CIKernelMessageDescription</span> = <span class="string">"invalid operands to binary expression ('float' and 'int')"</span>;</span><br><span class="line">        k<span class="built_in">CIKernelMessageOffset</span> = <span class="number">281</span>;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="2-_CI_PRINT_TREE">2. CI_PRINT_TREE</h3><p>这里 Core Image 中非常实用的一个环境变量，通过设置它，可以很方便的查看 Core Image 工作过程中到底做了什么。比如：</p>
<ul>
<li>工作在 GPU 还是 CPU 上？</li>
<li>各个 kernel 的参数值？</li>
<li>Core Image 是如何链接 kernel？</li>
<li>DOD，ROI 如何设置的？</li>
<li>对于大图如何拆分处理？</li>
<li>…</li>
</ul>
<blockquote>
<p>PS ： 至于 CI_PRINT_TREE 具体应该如何使用，没有找到相关资料，只是在 Session 中提到过。</p>
<p>包括 ObjC 中国 上的翻译：你可以通过在 Xcode 中设置计划配置（scheme configuration）里的 CI_PRINT_TREE 环境变量为 1 来决定用 CPU 还是 GPU 来渲染，也是很不准确的。</p>
<p>这里的结论都是自己摸索后的总结，所以可能存在错误或者遗漏，欢迎补充交流～</p>
</blockquote>
<p>CI_PRINT_TREE 的设置大致是这样的：分成 A B 两部分，它们可以结合使用。</p>
<p>其中 A 是主要分类，B 是辅助功能。</p>
<p>A 包括：</p>
<ul>
<li>1  initial graph </li>
<li>2  optimized graph </li>
<li>4  tile graph </li>
<li>8  programs graph </li>
<li>16  timing graph </li>
</ul>
<p>B 包括：</p>
<ul>
<li>graphviz </li>
<li>dump-inputs </li>
<li>dump-intermediates </li>
<li>skip-cpu </li>
<li>skip-gpu  </li>
<li>skip-small </li>
<li>frame-<number> </number></li>
</ul>
<p>使用上，比如简单的查看 initial graph 做了什么，即我们添加这个 Filter 的时候，初始化过程执行了什么，传入了哪些参数。当然，这个过程它并没有真正得到渲染，只是一个操作流程列表。设置 CI_PRINT_TREE ＝ 1，如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101786999ci_print_tree.png" alt="2016101786999ci_print_tree.png"></p>
<p>它的结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">initial graph render_to_display (opengles2 context <span class="number">1</span> frame <span class="number">1</span>) format=RGBA8 roi=[<span class="number">0</span> <span class="number">156</span> <span class="number">750</span> <span class="number">748</span>] = </span><br><span class="line">  clamptoalpha roi=[<span class="number">0</span> <span class="number">156</span> <span class="number">750</span> <span class="number">748</span>] extent=[<span class="number">0</span> <span class="number">156</span> <span class="number">750</span> <span class="number">748</span>] opaque</span><br><span class="line">    colormatch workingspace-to-devicergb roi=[<span class="number">0</span> <span class="number">156</span> <span class="number">750</span> <span class="number">748</span>] extent=[<span class="number">0</span> <span class="number">156</span> <span class="number">750</span> <span class="number">748</span>] opaque</span><br><span class="line">      affine [<span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">156</span>] roi=[<span class="number">0</span> <span class="number">156</span> <span class="number">750</span> <span class="number">748</span>] extent=[<span class="number">0</span> <span class="number">156</span> <span class="number">750</span> <span class="number">748</span>] opaque</span><br><span class="line">        colorkernel </span><br><span class="line">  roi=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] opaque</span><br><span class="line">          affine [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">374</span>] roi=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] opaque</span><br><span class="line">            colormatch <span class="string">"sRGB IEC61966-2.1"</span>-to-workingspace roi=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] opaque</span><br><span class="line">              <span class="built_in">CGImageRef</span> <span class="number">0x1701c4380</span> RGBX8 <span class="number">375</span>x374  alpha_one roi=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] opaque</span><br></pre></td></tr></table></figure>
<p>这里有很多关键信息，十分详细。它的阅读顺序是从下往上，我们简单分析下：</p>
<ul>
<li><strong>CGImageRef</strong>： 指代我们传入的图片。</li>
<li>每个阶段的 <strong>ROI，DOD</strong>。</li>
<li><strong>colormatch “sRGB IEC61966-2.1”-to-workingspace</strong> ：传入的颜色空间</li>
<li><strong>vignetteKernel(image,center=[187.5 187],radius=187.5,alpha=0.0537634)</strong> ：kernel 的每个参数</li>
<li><strong>colormatch workingspace-to-devicergb</strong>：  输出的颜色空间</li>
<li><strong>opengles2</strong> ：工作在 GPU 上</li>
<li><strong>context 1 frame 1</strong> ：分别指代当前 context 以及第几帧。每次渲染 frame + 1</li>
</ul>
<p>当然，这只是 CI_PRINT_TREE 的一部分功能，如果你设置 CI_PRINT_TREE = 8 (programs graph )，你又会得到这样的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">programs graph render_to_display (opengles2 context <span class="number">1</span> frame <span class="number">4</span> tile <span class="number">1</span>) format=RGBA8 roi=[<span class="number">0</span> <span class="number">111</span> <span class="number">640</span> <span class="number">640</span>] = </span><br><span class="line">  program affine(clamp_to_alpha(linear_to_srgb(vignetteKernel(affine(srgb_to_linear(swizzle_bgr1())))))) rois=[<span class="number">0</span> <span class="number">111</span> <span class="number">640</span> <span class="number">640</span>] extent=[<span class="number">0</span> <span class="number">111</span> <span class="number">640</span> <span class="number">640</span>]</span><br><span class="line">    IOSurface <span class="number">0x60000019ddc0</span> RGBA8 <span class="number">375</span>x374 alpha_one edge_clamp rois=[<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] extent=[infinite][<span class="number">0</span> <span class="number">0</span> <span class="number">375</span> <span class="number">374</span>] opaque</span><br></pre></td></tr></table></figure>
<p>这里描述了程序图表，即真正涉及到的操作。</p>
<p>如果觉得这样看比较杂乱，可以试试添加 B 类辅助功能。 比如：<strong>CI_PRINT_TREE = 8 graphviz</strong> ，这样就可以导出 DOT 语言脚本。然后使用 <a href="http://www.graphviz.org/" target="_blank" rel="external">Graphviz</a> 工具，即可绘制这个 DOT 语言脚本描述的图形。</p>
<p>比如上面 Log 对应绘制得到的图形如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/201610186930programs_graph.png" alt="201610186930programs_graph.png"></p>
<p>同样是从下往上看，各个操作的层级关系就很明显了。除了我们提供的 vignetteKernel，Core Image 内部还做了其他的操作，比如 <strong>linear_to_srgb，clamp_to_alpha</strong> 等。它们的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Filter DAG:</span><br><span class="line">Node: <span class="number">0</span></span><br><span class="line">  original source: vec4 _ci_clamp_to_alpha(vec4 s) &#123; <span class="keyword">return</span> clamp(s, <span class="number">0.0</span>, s.a); &#125;</span><br><span class="line">  printed AST: vec4 _ci_clamp_to_alpha(vec4 s) &#123;</span><br><span class="line">  <span class="keyword">return</span> clamp(s, <span class="number">0.000000e+00</span>, s.a);</span><br><span class="line">&#125;</span><br><span class="line">  children: <span class="number">1</span></span><br><span class="line">End Filter Node</span><br><span class="line"></span><br><span class="line">Node: <span class="number">1</span></span><br><span class="line">  original source: vec4 _ci_premultiply(vec4 s) &#123; <span class="keyword">return</span> vec4(s.rgb*s.a, s.a); &#125;</span><br><span class="line">  printed AST: vec4 _ci_premultiply(vec4 s) &#123;</span><br><span class="line">  <span class="keyword">return</span> vec4(s.rgb * s.a, s.a);</span><br><span class="line">&#125;</span><br><span class="line">  children: <span class="number">2</span></span><br><span class="line">End Filter Node</span><br><span class="line"></span><br><span class="line">Node: <span class="number">2</span></span><br><span class="line">  original source: vec4 _ci_linear_to_srgb(vec4 s)</span><br><span class="line">&#123;</span><br><span class="line">  s.rgb = sign(s.rgb)*mix(s.rgb*<span class="number">12.92</span>, pow(abs(s.rgb), vec3(<span class="number">0.4166667</span>)) * <span class="number">1.055</span> - <span class="number">0.055</span>, step(<span class="number">0.0031308</span>, abs(s.rgb)));</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">  printed AST: vec4 _ci_linear_to_srgb(vec4 s) &#123;</span><br><span class="line">  s.rgb = sign(s.rgb) * mix(s.rgb * <span class="number">1.292000e+01</span>, (pow(abs(s.rgb), vec3(<span class="number">4.166667e-01</span>)) * <span class="number">1.055000e+00</span>) - <span class="number">5.500000e-02</span>, step(<span class="number">3.130800e-03</span>, abs(s.rgb)));</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">  children: <span class="number">3</span></span><br><span class="line">End Filter Node</span><br><span class="line"></span><br><span class="line">Node: <span class="number">3</span></span><br><span class="line">  original source: vec4 _ci_unpremultiply(vec4 s) &#123; <span class="keyword">return</span> vec4(s.rgb/max(s.a,<span class="number">0.00001</span>), s.a); &#125;</span><br><span class="line">  printed AST: vec4 _ci_unpremultiply(vec4 s) &#123;</span><br><span class="line">  <span class="keyword">return</span> vec4(s.rgb / max(s.a, <span class="number">1.000000e-05</span>), s.a);</span><br><span class="line">&#125;</span><br><span class="line">  children: <span class="number">6</span></span><br><span class="line">End Filter Node</span><br><span class="line"></span><br><span class="line">Node: <span class="number">6</span></span><br><span class="line">  &lt;sample with transform&gt;</span><br><span class="line">  original source: vec4 read_pixel(sampler2D image, vec2 c, mat3 m)&#123; <span class="keyword">return</span> texture2D(image, (vec3(c, <span class="number">1.0</span>) * m).xy);&#125;</span><br><span class="line">  printed AST: vec4 read_pixel_6(sampler2D image, vec2 c, mat3 m) &#123;</span><br><span class="line">  <span class="keyword">return</span> texture2D(image, (vec3(c, <span class="number">1.000000e+00</span>) * m).xy);</span><br><span class="line">&#125;</span><br><span class="line">  children: <span class="number">4</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line">End Filter Node</span><br><span class="line"></span><br><span class="line">Node: <span class="number">4</span></span><br><span class="line">  image: <span class="number">6</span></span><br><span class="line">  printed: uniform lowp sampler2D image6_0</span><br><span class="line">End Filter Node</span><br><span class="line"></span><br><span class="line">Node: <span class="number">7</span></span><br><span class="line">  position use &lt;_dc&gt;</span><br><span class="line">End Filter Node</span><br><span class="line"></span><br><span class="line">Node: <span class="number">5</span></span><br><span class="line">  &lt;transform&gt;</span><br><span class="line">  uniform: <span class="number">6</span></span><br><span class="line">End Filter Node</span><br></pre></td></tr></table></figure>
<p>这个 DAG（有向无环图），具体描述了相关操作的实现过程，比较简单，可以自己看看，这里不累述。</p>
<h2 id="工具介绍">工具介绍</h2><p>Quartz Composer 是一款图形化的编程工具，专门用来生成各种动态视觉效果，包括可交互的界面原型。当然，它也支持 Core Image 滤镜图表的原型。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016092073920quartz_1.png" alt="2016092073920quartz_1.png"></p>
<p>另外，在 QC 上编写 Kernel，除了代码高亮，实时调整效果也很棒。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101158579quartz_2.png" alt="2016101158579quartz_2.png"></p>
<blockquote>
<p>PS ：<a href="https://developer.apple.com/downloads/" target="_blank" rel="external">Quartz Composer 下载地址</a> </p>
<p>有精力的话建议把 QC 内自带的所有 example 找出来仔细研究，苹果自己的例子是最好的。它们藏在 /Applications/Quartz Composer.app/Contents/Resources/Examples/Patches（找到 Quartz Composer.app 点右键，选择「Show Package Content」）</p>
<p> 简单了解 Quartz Composer。QCDesigners 上有比较简要的介绍：<a href="https://link.zhihu.com/?target=http%3A//qcdesigners.com/index.php/forums/topic/2/new-to-quartz-composer-start-he" target="_blank" rel="external">QC Designers</a></p>
</blockquote>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016092059430download_Graphic_Tools_for_XCode.png" alt="2016092059430download_Graphic_Tools_for_XCode.png"></p>
<p>QC 已经内置了适合 Core Image 的模板，并且实现了动态模糊滤镜效果。不过这里为了了解 QC 的使用方式，不使用内置的模板，从头开始。<strong>File —&gt; New Blank</strong>，创建一个空白的 QC 工程。</p>
<blockquote>
<p>PS： QC 的功能很强大，这里只介绍 Core Image Filter 编辑过程中会用到的，以及我所掌握的…</p>
</blockquote>
<h3 id="0-_概念介绍">0. 概念介绍</h3><p>在讲解使用方式之前，介绍几个基本概念。</p>
<p>一次滤镜操作，可以简单理解成： <strong>输入—&gt;(Patch)—&gt;输出</strong>。</p>
<p>Patch 可以理解成 Kernel。</p>
<p>输入则与 Kernel 的参数相对应，可以是 image，color，float…</p>
<p>输入这里一般就是处理后的图像。</p>
<p>还有一个比较特殊的 Patch，Layer。相当于画布，可以把结果图显示在上面，它也有层的概念。</p>
<h3 id="1-_工作区介绍">1.  工作区介绍</h3><p><strong>编辑区：</strong> 这是主面板，主要衔接各个 Patch，以及它们的输入，输出。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101175676panel_1.png" alt="2016101175676panel_1.png"></p>
<p><strong>Library：</strong> 这里陈列了 QC 内置的所有 Patch（也可以添加自定义的 Patch 进来），以及它们的详细使用介绍。(通过点击主面板左上角的 Patch Library 打开)</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101159731panel_2.png" alt="2016101159731panel_2.png"></p>
<p><strong>参数区：</strong> 这里设置各个 Patch 需要的输入参数。(通过点击主面板工具栏上的 Parameters 打开)</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101163517panel_3.png" alt="2016101163517panel_3.png"></p>
<p><strong>Viewer：</strong> 显示窗口，这里可以对 Layer 做处理，也可以响应用户操作。比如鼠标点击，移动，滑动等。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101121147panel_4.png" alt="2016101121147panel_4.png"></p>
<h3 id="2-_Filter_编辑_&amp;_放大眼睛实战">2. Filter 编辑 &amp; 放大眼睛实战</h3><p>首先，点击 Patch Library，添加一个 Core Image Filter。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101898471qc_demo_1.png" alt="2016101898471qc_demo_1.png"></p>
<p>选中这个 Filter，点击 Patch Inspector，选择 Settings，进入编辑页面。</p>
<p>改成如下放大眼睛核心代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kernel vec4 coreImageKernel(sampler image, vec2 centerPostion, <span class="keyword">float</span> radius, <span class="keyword">float</span> scaleRatio, <span class="keyword">float</span> aspectRatio)</span><br><span class="line">&#123;</span><br><span class="line">	vec2 currentPosition = destCoord();</span><br><span class="line">	vec2 positionToUse = currentPosition;</span><br><span class="line"></span><br><span class="line">     vec2 currentPositionToUse = vec2(currentPosition.x, currentPosition.y * aspectRatio + <span class="number">0.5</span> - <span class="number">0.5</span> * aspectRatio);</span><br><span class="line">     vec2 centerPostionToUse = vec2(centerPostion.x, centerPostion.y * aspectRatio + <span class="number">0.5</span> - <span class="number">0.5</span> * aspectRatio);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">float</span> r = distance(currentPositionToUse, centerPostionToUse);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(r &lt; radius)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">float</span> alpha = <span class="number">1.0</span> - scaleRatio * (r / radius - <span class="number">1.0</span>)*( r / radius - <span class="number">1.0</span>);</span><br><span class="line">         positionToUse = centerPostion + alpha * (currentPosition - centerPostion);</span><br><span class="line">         <span class="keyword">return</span> sample(image, samplerTransform(image, positionToUse));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">     	<span class="keyword">return</span> sample(image, samplerTransform(image, positionToUse));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/201610185070qc_demo_2.png" alt="201610185070qc_demo_2.png"></p>
<blockquote>
<p>PS：这里不再讲解这个眼睛放大 kernel 的实现原理。</p>
<p>我强烈建议你在了解了前面的内容后，自己试着解读这个 kernel。</p>
</blockquote>
<p>另外，这里还有几个需要说明的地方。</p>
<ul>
<li>Define Outp Image Domain of Definition as Union of Input Sampler DODs：输入输出图片的 DOD 一致。</li>
<li>Show Advanced Input Sampler Options：显示更多选项。</li>
<li>Edit Filter Function：编辑 Filter 函数。</li>
</ul>
<p>一般选中第一项就好。 如果有特殊需求，需要自定义 DOD，ROI，则选择 <strong>Edit Filter Function</strong>，进入编辑模式。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function __image main(__image image, __vec2 centerPostion, __number radius, __number scaleRatio, __number aspectRatio) &#123;</span><br><span class="line">      <span class="keyword">return</span> coreImageKernel.apply(image.definition, null, image, centerPostion, radius, scaleRatio, aspectRatio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以对默认的 function 进行编辑。在这个 Demo 里面我们不需要，感兴趣可以自己实践下，很简单。</p>
<p>这个时候，主面板应该长这样：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/201610184625qc_demo_3.png" alt="201610184625qc_demo_3.png"></p>
<p>然后拖拽一张图片到主面板中，把图片的 Output Image 与 Filter 的 Input Image 想连接。</p>
<p>再从 Patch Library 中选择 Billboard。把 Filter 的 Output Image 与 Billboard 的 Input Image 相连接。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101846779qc_demo_4.png" alt="2016101846779qc_demo_4.png"></p>
<p>然后选中 Filter，打开 Parameters 面板，输入参数值，即可。</p>
<p>当然，放大眼睛这里需要定位到眼睛的位置，是否可以通过鼠标操作来获取点呢？再或者，眼睛放大效果不够直观，有没有办法鼠标按下显示效果图，松开显示原图呢？在 QC 里头，这些都不是问题~不过工具类的使用，更多的还是得靠自己去摸索，这里不再累述。可以参考 EnlargeEyes.qtz 文件，了解更多的操作。</p>
<p>最终的效果应该是这样的：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/201610184575enlargeEyes_demo.gif" alt="201610184575enlargeEyes_demo.gif"></p>
<h2 id="总结">总结</h2><p>至此，关于 Core Image 自定义 Filter 相关的内容，就已经都讲完了。这篇近万字的文章，花了很多功夫总结出来，希望，对你有所帮助！</p>
<p>那么，打开脑洞，创造更有趣的 Filter 吧~</p>
<p>Have fun~   </p>
<p><strong>PS：源码下载地址：</strong> <a href="https://github.com/colin1994/CoreImageDemo" target="_blank" rel="external">CoreImageDemo</a></p>
<h2 id="延伸阅读">延伸阅读</h2><p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397-CH1-SW1" target="_blank" rel="external">Core Image Kernel Language Reference</a></p>
<p>Core Image Kernel Language 官方概述。</p>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingKernels/WritingKernels.html" target="_blank" rel="external">Writing Kernels</a></p>
<p>官方教程。</p>
<p><a href="http://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW4" target="_blank" rel="external">Kernel Routine Rules</a></p>
<p>官方准则。</p>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW2" target="_blank" rel="external">Region-of-Interest Methods</a> </p>
<p>ROI 教程。</p>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/QuartzComposerUserGuide/qc_intro/qc_intro.html#//apple_ref/doc/uid/TP40005381-CH201-TPXREF101" target="_blank" rel="external">Quartz Composer User Guide</a></p>
<p>QC 官方指南。</p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> Core Image </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Core Image 你需要了解的那些事~]]></title>
      <url>/2016/10/21/Core-Image-OverView/</url>
      <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近在研究 Core Image 自定义 Filter 相关内容，重新学习了 Core Image，对 Core Image 的一些优化点也有了一定的了解。故此记录，与君交流~</p>
<p>本文将会介绍逐一介绍 Core Image 相关基础概念、使用方式、注意点以及和其他图像处理方案的对比。也算是下一篇文章： <a href="http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/" target="_blank" rel="external">Core Image 自定义 Filter~</a> 的预备知识，毕竟只有了解了 Core Image 的作用以及它的优势，才有学习自定义 Filter 的动力。</p>
<p>现在，开始吧～<img src="http://wanzao2.b0.upaiyun.com/system/pictures/24/original/6.png" alt=""></p>
<a id="more"></a>
<h2 id="Core_Image_概述">Core Image 概述</h2><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016100195437core_image.png" alt="2016100195437core_image.png"></p>
<p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 <code>滤镜链</code> 将各种效果的 <code>Filter叠加</code> 起来形成强大的自定义效果。</p>
<p>一个 <strong>滤镜</strong> 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。</p>
<p>一个 <strong>滤镜链</strong> 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。</p>
<p> iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。</p>
<blockquote>
<p>Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.</p>
</blockquote>
<p>这是苹果官方文档对于 Core Image 的介绍，大致意思是：Core Image 是一种为静态图像和 Video 提供处理和分析的技术，它可以使用 GPU/CPU 的方式对图像进行处理。Core Image 提供了简洁的 API 给用户，隐藏了图像处理中复杂的底层内容。你可以在不了解 OpenGL、OpenGL ES 甚至是 GCD 的基础上对其进行使用，他已经帮你对这些复杂的内容进行处理了。</p>
<p>废话这么多，苹果就想告诉我们一件事：<strong>所有的底层细节他都帮你做好了，你只需要放心调用API就行了。</strong></p>
<p>这就是 Core Image 的基础概念，比较简短，正如它的使用方式一样简洁。</p>
<p>然而在我个人学习过程中，我有一种强烈的感觉：<strong>Apple 很重视 Core Image，Core Image 一定会越来越棒。</strong></p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/149/original/%E5%91%86%E8%90%8C_%E5%89%AF%E6%9C%AC.png" alt=""></p>
<ul>
<li>每年的 WWDC Session 中，都有提及 Core Image 的相关优化。</li>
<li>从最初的几十种内置滤镜到如今的180多种。</li>
<li>从最初只支持 macOS，到如今也支持 iOS。</li>
<li>iOS8 之后支持自定义 Filter。</li>
<li>iOS8 增强 GPU 渲染，在后台也能继续使用 GPU 进行处理。</li>
<li>引入 CIDetector，提供一些常用的图片识别功能。包括人脸识别、条形码识别、文本识别等。</li>
<li>与越来越多的框架相结合：OpenGLES，PhotoExtension，SceneKit，SpriteKit，Metal。</li>
<li>iOS 10之后，支持对原生 RAW 格式图片的处理。</li>
<li>…</li>
</ul>
<p>So，它真的值得学习！</p>
<h2 id="使用方式">使用方式</h2><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016100259378process.png" alt="2016100259378process.png"></p>
<p>这里我们从它的基础 API 介绍起。</p>
<p>Core Image 的 API 主要就是三类：</p>
<ul>
<li>CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。</li>
<li>CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</li>
<li>CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。</li>
</ul>
<p>至于使用，相当的方便。</p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/22/original/16.png" alt=""></p>
<p>下面以 “动态模糊” 举例，我们使用系统提供的 <strong>CIMotionBlur</strong> 来实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入滤镜名称(e.g. @"CIMotionBlur"), 输出处理后的图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)outputImageWithFilterName:(<span class="built_in">NSString</span> *)filterName &#123;</span><br><span class="line">    <span class="comment">// 1. 将UIImage转换成CIImage</span></span><br><span class="line">    <span class="built_in">CIImage</span> *ciImage = [[<span class="built_in">CIImage</span> alloc] initWithImage:<span class="keyword">self</span>.imageView.image];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 创建滤镜</span></span><br><span class="line">    <span class="keyword">self</span>.filter = [<span class="built_in">CIFilter</span> filterWithName:filterName keysAndValues:k<span class="built_in">CIInputImageKey</span>, ciImage, <span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 设置相关参数</span></span><br><span class="line">    [<span class="keyword">self</span>.filter setValue:@(<span class="number">10.</span>f) forKey:<span class="string">@"inputRadius"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 渲染并输出CIImage</span></span><br><span class="line">    <span class="built_in">CIImage</span> *outputImage = [<span class="keyword">self</span>.filter outputImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 获取绘制上下文</span></span><br><span class="line">    <span class="keyword">self</span>.context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 创建输出CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgImage = [<span class="keyword">self</span>.context create<span class="built_in">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:cgImage];</span><br><span class="line">    <span class="comment">// 6. 释放CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgImage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016100243119blurCompre.png" alt="2016100243119blurCompre.png"></p>
<p>至于滤镜链，则是和普通滤镜的使用没什么差别。只要把前一个滤镜的输出，当作后一个滤镜的输入，即可实现，就不累述了。</p>
<p>另外，如果想查阅 Filter 的属性，可以通过 <strong>attributes</strong> 属性来获取。比如这个例子中的 <strong>CIMotionBlur</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"CIAttributeFilterAvailable_Mac"</span> = <span class="string">"10.4"</span>;</span><br><span class="line">    <span class="string">"CIAttributeFilterAvailable_iOS"</span> = <span class="string">"8.3"</span>;</span><br><span class="line">    <span class="built_in">CIAttributeFilterCategories</span> =     (</span><br><span class="line">        <span class="built_in">CICategoryBlur</span>,</span><br><span class="line">        <span class="built_in">CICategoryStillImage</span>,</span><br><span class="line">        <span class="built_in">CICategoryVideo</span>,</span><br><span class="line">        <span class="built_in">CICategoryBuiltIn</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">CIAttributeFilterDisplayName</span> = <span class="string">"Motion Blur"</span>;</span><br><span class="line">    <span class="built_in">CIAttributeFilterName</span> = <span class="built_in">CIMotionBlur</span>;</span><br><span class="line">    <span class="built_in">CIAttributeReferenceDocumentation</span> = <span class="string">"http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIMotionBlur"</span>;</span><br><span class="line">    inputAngle =     &#123;</span><br><span class="line">        <span class="built_in">CIAttributeClass</span> = <span class="built_in">NSNumber</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDefault</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDescription</span> = <span class="string">"The angle of the motion determines which direction the blur smears."</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDisplayName</span> = Angle;</span><br><span class="line">        <span class="built_in">CIAttributeIdentity</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">CIAttributeSliderMax</span> = <span class="string">"3.141592653589793"</span>;</span><br><span class="line">        <span class="built_in">CIAttributeSliderMin</span> = <span class="string">"-3.141592653589793"</span>;</span><br><span class="line">        <span class="built_in">CIAttributeType</span> = <span class="built_in">CIAttributeTypeAngle</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    inputImage =     &#123;</span><br><span class="line">        <span class="built_in">CIAttributeClass</span> = <span class="built_in">CIImage</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDescription</span> = <span class="string">"The image to use as an input image. For filters that also use a background image, this is the foreground image."</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDisplayName</span> = Image;</span><br><span class="line">        <span class="built_in">CIAttributeType</span> = <span class="built_in">CIAttributeTypeImage</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    inputRadius =     &#123;</span><br><span class="line">        <span class="built_in">CIAttributeClass</span> = <span class="built_in">NSNumber</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDefault</span> = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDescription</span> = <span class="string">"The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result."</span>;</span><br><span class="line">        <span class="built_in">CIAttributeDisplayName</span> = Radius;</span><br><span class="line">        <span class="built_in">CIAttributeIdentity</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">CIAttributeMin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">CIAttributeSliderMax</span> = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">CIAttributeSliderMin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">CIAttributeType</span> = <span class="built_in">CIAttributeTypeDistance</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的介绍，可能偏显苍白，但是我想说的是，使用内置的滤镜，就是这么简单。如果你还想了解更多，可以继续阅读以下这几篇文章，它们对 Core Image 的基础概念介绍的更加详细。</p>
<ul>
<li><a href="https://objccn.io/issue-21-6/" target="_blank" rel="external">Core Image 介绍</a> ： ObjC 的文章，值得看看。</li>
<li><a href="http://blog.csdn.net/zhangao0086/article/details/39012231" target="_blank" rel="external">iOS8 Core Image In Swift</a> ：这个系列是对官方文档的一个完整实战，讲的比较全面。</li>
<li><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html" target="_blank" rel="external">Core Image Filter Reference</a>：内置的所有滤镜及其用法示例。</li>
<li><a href="https://github.com/FlexMonkey/Filterpedia" target="_blank" rel="external">Filterpedia</a> ：演示了内置滤镜及一些自定义滤镜的效果，基于 Swift 实现的。</li>
</ul>
<p>下面，才是本文着重想要介绍的，算是 Core Image 的一些高级应用。让我们继续往下看～</p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png" alt="goon"></p>
<h2 id="注意点">注意点</h2><h3 id="1-_image-CIImage_==_nil">1. image.CIImage == nil</h3><p>为了获取 CIImage，可能有的同学会直接通 UIImage.CIImage 的方式去获取，但是这样的方式是无法保证获取到 CIImage 对象的。定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(nullable,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CIImage</span> *<span class="built_in">CIImage</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0); </span><br><span class="line"><span class="comment">// returns underlying CIImage or nil if CGImageRef based</span></span><br></pre></td></tr></table></figure>
<p>这里已经很明确说明了，UIImage 对象可能不是基于 CIImage 创建的（比如它是由 <code>imageWithCIImage:</code> 生成的），这样就无法获取到 CIImage 对象。</p>
<p>正确的姿势应该是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIImage</span> *ciImage = [[<span class="built_in">CIImage</span> alloc] initWithImage:<span class="keyword">self</span>.originalImage];</span><br></pre></td></tr></table></figure>
<h3 id="2-_CIContext">2. CIContext</h3><p>在创建结果 UIImage 的时候，最简单的方式就是通过 <strong>imageWithCIImage</strong> 来实现。这种情况下，不需要显示的声明 <strong>CIContext</strong>，因为 <strong>imageWithCIImage</strong> 内部自动完成了这个步骤。这使得使用 Core Image 更加的方便。当然，它也引起了另外一个问题，每次都会重新创建一个 <strong>CIContext</strong>，然而 <strong>CIContext</strong> 的代价是非常高的。</p>
<p>并且，CIContext 和 CIImage 对象是不可变的，在线程之间共享这些对象是安全的。所以多个线程可以使用同一个 GPU 或者 CPU CIContext 对象来渲染 CIImage 对象。</p>
<p>所以重用 CIContext 是很有必要的。这意味着，我们不应该使用 <strong>imageWithCIImage</strong> 来生成 UIImage，而应该自己创建维护 CIContext。</p>
<p>比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CGImageRef</span> cgImage = [<span class="keyword">self</span>.context create<span class="built_in">CGImage</span>:outputImage fromRect:[outputImage extent]];</span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:cgImage];</span><br></pre></td></tr></table></figure>
<h3 id="3-_CPU_/_GPU">3. CPU / GPU</h3><p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p>
<p>Context 创建的时候，我们可以给它设置为是基于 GPU 还是 CPU。</p>
<p>基于 GPU 的话，处理速度更快，因为利用了 GPU 硬件的并行优势。可以使用 OpenGLES 或者 Metal 来渲染图像，这种方式CPU完全没有负担，应用程序的运行循环不会受到图像渲染的影响。</p>
<p>但是 GPU 受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用 CPU，因为当 App 切换到后台状态时 GPU 处理会被打断。使用 CPU 渲染的 iOS 会采用 GCD 来对图像进行渲染，这保证了 CPU 渲染在大部分情况下更可靠，比 GPU 渲染更容易使用，可以在后台实现渲染过程。</p>
<p>综上，对于复杂的图像滤镜使用 GPU 更好，但是如果在处理视频并保存文件，或保存照片到照片库中时，为避免程序进入后台对图片保存造成影响，这时应该使用 CPU 进行渲染。</p>
<p>用 Apple 官方的一句话来描述再合适不过了：</p>
<blockquote>
<p>CPU is still what will give you the best fidelity where as the GPU will give you the best performance.</p>
</blockquote>
<p>具体的设置方式，可以参考下面的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:k<span class="built_in">CIContextUseSoftwareRenderer</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithEAGLContext:eaglctx];</span><br></pre></td></tr></table></figure>
<p>同样是基于  GPU 的，它们之间也是有区别的。</p>
<p><strong>contextWithOptions</strong> 创建的 context 并没有实时性能， 虽然渲染是在 GPU 上执行，但是其输出的 image 是不能显示的，只有当其被复制回 CPU 存储器上时，才会被转成一个可被显示的 image 类型，比如 UIImage。</p>
<p>它的渲染过程大致如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016100325659cpu.png" alt="2016100325659cpu.png"></p>
<p>当使用 Core Image 在 GPU 上渲染图片的时候，先是把图像传递到 GPU 上，然后执行滤镜相关操作。但是当需要生成  CGImage 对象的时候，图像又被复制回 CPU 上。最后要在视图上显示的时候，又返回 GPU 进行渲染。这样在 GPU 和 CPU 之前来回切换，会造成很严重的性能损耗。</p>
<p><strong>contextWithEAGLContext</strong> 创建的 context 支持实时渲染，渲染图像的过程始终在 GPU 上进行，并且永远不会复制回 CPU 存储器上，这就保证了更快的渲染速度和更好的性能。</p>
<p>当然，这个前提是利用实时渲染的特效，而不是每次操作都产生一个 UIImage，然后再设置到视图上。</p>
<p>比如 OpenGLES：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 OpenGLES 渲染环境</span></span><br><span class="line">EAGLContext *eaglContext = [[EAGLContext alloc] 	  initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line"><span class="keyword">self</span>.glkView.context = eaglContext;</span><br><span class="line"><span class="keyword">self</span>.context = [<span class="built_in">CIContext</span> contextWithEAGLContext:eaglContext];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 实时渲染</span></span><br><span class="line">[<span class="keyword">self</span>.pixellateFilter setValue:@(sender.value) forKey:<span class="string">@"inputRadius"</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.context drawImage:_pixellateFilter.outputImage inRect:_targetBounds  fromRect:_inputImage.extent];</span><br><span class="line">[<span class="keyword">self</span>.glkView.context presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>
<p>它的渲染过程大致如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016100328506gpu.png" alt="2016100328506gpu.png"></p>
<p>并且，iOS8 后增强了 GPU 渲染，在后台也能继续使用 GPU 进行处理。这点会在下文详细说明。</p>
<p><strong>所以应该尽可能的使用 GPU 去做图像处理。</strong></p>
<p>另外，Apple 对 Core Image 内部进行了优化，如果通过</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>创建 <strong>context</strong>，那么它内部的渲染器会根据设备最优选择。依次为 <strong>Metal，OpenGLES，CoreGraphics。</strong></p>
<blockquote>
<p>PS：Metal 需要 iOS8 + A7，且模拟器不支持 Metal。OpenGLES3 需要 iOS7 + A7</p>
<p>测试结果：</p>
<p>iPhone 6s， iOS 10， 模拟器：OpenGLES3</p>
<p>iPhone 6s，iOS 10，真机：Metal</p>
<p>iPhone 5，iOS 8， 模拟器：OpenGLES</p>
</blockquote>
<h3 id="4-_CIFilter">4. CIFilter</h3><p>之前提到 CIContext 是线程安全的，然而 CIFilter 并不是线程安全的，这意味着 一个 CIFilter 对象不能在多个线程间共享。如果你的操作是多线程的，每个线程都必须创建自己的 CIFilter 对象。否则，你的 App 将产生不可预期的结果。</p>
<h2 id="Core_Image_vs_GPUImage">Core Image vs GPUImage</h2><p>其他图像处理方案的对比，这里比较有争议的就是 OpenGLES 和 Core Image 了。</p>
<p>在 OpenGLES 部分，拿主流的 <a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a> 来做对比，分析一下它们各自的优缺点。只有对比了才知道，Core Image 好在哪里，是否值得使用。</p>
<blockquote>
<p>PS：以下的优势阐述，撇去了两个框架都具备的，仅保留对比后各自的优势。</p>
<p>另外，GPUImage 我没有深入学习过，对于它的一些优势，主要是总结它的开发者 Brad 描述的，以及简单的 Demo 进行对比。</p>
</blockquote>
<p><strong>GPUImage 优势：</strong></p>
<ul>
<li>最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。</li>
<li>在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的）</li>
<li>GPUImage 在视频处理上有更好的表现。</li>
<li>GPUImage 的代码完成公开，实现透明。</li>
<li>可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</li>
</ul>
<p><strong>Core Image 优势：</strong></p>
<ul>
<li>官方框架，使用放心，维护方便。</li>
<li>支持 CPU 渲染，可以在后台继续处理和保存图片。</li>
<li>一些滤镜的性能更强劲。例如由 Metal Performance Shaders 支持的模糊滤镜等。</li>
<li>支持使用 Metal 渲染图像。而 Metal 在 iOS 平台上有更好的表现。</li>
<li>与 Metal，SpriteKit，SceneKit，Core Animation 等更完美的配合。</li>
<li>支持图像识别功能。包括人脸识别、条形码识别、文本识别等。</li>
<li>支持自动增强图像效果，会分析图像的直方图，图像属性，脸部区域，然后通过一组滤镜来改善图像效果。</li>
<li>支持对原生 RAW 格式图片的处理。</li>
<li>滤镜链的性能比 GPUImage 高。(没有验证过，GPUImage 的主页上是这么说的)。</li>
<li>支持对大图进行处理，超过 GPU 纹理限制 (4096 * 4096)的时候，会自动拆分成几个小块处理(Automatic tiling)。GPUImage 当处理超过纹理限制的图像时候，会先做判断，压缩成最大纹理限制的图像，导致图像质量损失。</li>
</ul>
<p>至此，我觉得 Core Image 的优势很明显了，尤其是与 Metal 的配合，自动增强图像效果，支持处理大图以及滤镜链的优化。</p>
<p>下面关于这几点优化，做个简单的描述。</p>
<h3 id="1-_滤镜链">1. 滤镜链</h3><blockquote>
<p>if you chain together a sequence of filters, Core Image will automatically concatenate these subroutines into a single program.The idea behind this is to improve performance and quality, by reducing the number of intermediate buffers.</p>
</blockquote>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016100749763filters.png" alt="2016100749763filters.png"></p>
<p>Core Image 会自动把多个滤镜组合成一个新的程序（program），通过减少中间缓冲区的数量，来提高性能和质量。</p>
<h3 id="2-_支持大图">2. 支持大图</h3><p>超过 GPU 纹理限制 （4096 * 4096）的时候，会自动拆分成几个小块处理 （Automatic tiling）。</p>
<p>图片大小：（8374，7780），验证结果：</p>
<blockquote>
<p>PS： rois 表示当前处理区域。 extent 表示图像实际大小。</p>
<p>这个输出是 Core Image 在处理过程中打印的。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) rois=[<span class="number">0</span> <span class="number">0</span> <span class="number">2092</span> <span class="number">3888</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]  </span><br><span class="line">(<span class="number">2</span>) rois=[<span class="number">2092</span> <span class="number">0</span> <span class="number">2092</span> <span class="number">3888</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]</span><br><span class="line">(<span class="number">3</span>) rois=[<span class="number">0</span> <span class="number">3888</span> <span class="number">2092</span> <span class="number">3892</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]</span><br><span class="line">(<span class="number">4</span>) rois=[<span class="number">2092</span> <span class="number">3888</span> <span class="number">2092</span> <span class="number">3892</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]</span><br><span class="line">(<span class="number">5</span>) rois=[<span class="number">4184</span> <span class="number">0</span> <span class="number">2092</span> <span class="number">3888</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]</span><br><span class="line">(<span class="number">6</span>) rois=[<span class="number">6276</span> <span class="number">0</span> <span class="number">2098</span> <span class="number">3888</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]</span><br><span class="line">(<span class="number">7</span>) rois=[<span class="number">4184</span> <span class="number">3888</span> <span class="number">2092</span> <span class="number">3892</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]</span><br><span class="line">(<span class="number">8</span>) rois=[<span class="number">6276</span> <span class="number">3888</span> <span class="number">2098</span> <span class="number">3892</span>] extent=[<span class="number">0</span> <span class="number">0</span> <span class="number">8374</span> <span class="number">7780</span>]</span><br></pre></td></tr></table></figure>
<p>如果按序讲每个区域进行拼凑，就是原图的实际区域了。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016101313942automatic_tiling.png" alt="2016101313942automatic_tiling.png"></p>
<p>另外，Core Image 对大图和小图的处理上，也有所不同。<strong>小图提前解码，大图延迟解码 !</strong></p>
<p>当传入的 image 是小图 (size &lt; inputImageMaximumSize)时，在调用 <strong>initWithCGImage</strong> 获取输入图像 <strong>CIImage</strong> 的时候，这个 image 就被完全解码了。这是很有必要的。因为小图可能多次被用到，把编码的工作提前并且只做一次，一定程度上优化性能。</p>
<p>而对于大图来说，它的解码操作是尽可能延后的（<strong>being lazy</strong>），直到真正需要显示， CIContext 执行 render 相关操作。因为大图的解码代价较大，并且不常用，无脑提前解码，放到内存中是没有必要的。</p>
<p>下面是验证结果，选了两个相差不大的图片，但是介于 4096 左右。</p>
<p><strong>4000 * 4000，小图：</strong></p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20161005272964000_memory.png" alt="20161005272964000_memory.png"></p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20161005205644000_decode.png" alt="20161005205644000_decode.png"></p>
<p>很明显的，<strong>Memory 占有率高</strong>，并且调用了 <strong>decode</strong> 相关操作。</p>
<p><strong>4100 * 4100，大图：</strong></p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20161005838734100_memory.png" alt="20161005838734100_memory.png"></p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20161005840444100.png" alt="20161005840444100.png"></p>
<p>这里的 <strong>Memory 占用较低</strong>，并且没有看到 <strong>decode</strong> 相关操作。</p>
<p>同样的，当通过 CIImage 获取输出 CGImage 的时候，如果输出 CGImage 是小图的话，那么当 <strong>[CIContext createCGImage]</strong> 调用的时候，image 就被完全渲染了。而对于大图，要等到 CGImage 真正需要渲染显示的时候，这个 image 才会被渲染。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Render the region 'fromRect' of image 'image' into a temporary buffer using</span><br><span class="line"> * the context, then create and return a new CoreGraphics image with</span><br><span class="line"> * the results. The caller is responsible for releasing the returned image.</span><br><span class="line"> * The return value will be null if size is empty or too big. */</span></span><br><span class="line"><span class="meta">#if !defined(SWIFT_CLASS_EXTRA) || (defined(SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH) &amp;&amp; SWIFT_SDK_OVERLAY_COREIMAGE_EPOCH &gt;= 2)</span></span><br><span class="line">- (nullable <span class="built_in">CGImageRef</span>)create<span class="built_in">CGImage</span>:(<span class="built_in">CIImage</span> *)image</span><br><span class="line">                            fromRect:(<span class="built_in">CGRect</span>)fromRect;</span><br></pre></td></tr></table></figure>
<p>经过这样的优化处理后，对于大图，<a href="https://developer.apple.com/videos/play/wwdc2014/514/" target="_blank" rel="external">Session 514</a> 给出了直观的数据对比：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/2016100518100largeCompare.png" alt="2016100518100largeCompare.png"></p>
<h3 id="3-_GPU_优化">3. GPU 优化</h3><p>另外一个很重要的优化就是：<strong>提高了 iOS 上 Core Image 使用 GPU 进行渲染的性能</strong></p>
<p>具体体现在：</p>
<p><strong>1.后台操作</strong></p>
<ul>
<li>短时间内，进入后台后会依旧使用高效的 GPU 进行渲染。</li>
<li>后台操作的 GPU 优先级低，不会对前台的渲染造成性能影响。</li>
</ul>
<p><strong>2.多线程</strong></p>
<p>iOS 8之前，如果主线程使用 GPU 做相关操作，次要线程想使用 Core Image 的时候，通常要使用安全的 CPU 来实现，避免引起意想不到的问题。</p>
<p>在 iOS 8之后，可以在次要线程设置 Context 的 <strong>kCIContextPriorityRequestLow</strong> 值为 YES，这样就标记为当前 Context 在 GPU 上渲染的时候优先级低，从而不会影响到 GPU 上高优先级的渲染。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions: [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:k<span class="built_in">CIContextPriorityRequestLow</span>]];</span><br></pre></td></tr></table></figure>
<p>所以，应该尽可能的使用 GPU 进行渲染，来提高性能。</p>
<p><strong>综上，我认为在某需求 Core Image 能实现的时候，使用 Core Image 应该是 iOS 平台上最好的选择。</strong></p>
<p>至此，我所了解的 Core Image 使用上的注意点已经总结完了，希望你能有所获~</p>
<p>当然，如果你还想了解更多，那么我的下一篇文章： <a href="http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/" target="_blank" rel="external">Core Image 自定义 Filter~</a>  值得你期待。</p>
<p>Have fun~</p>
<h2 id="延伸阅读">延伸阅读</h2><p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html" target="_blank" rel="external">Core Image Filter Reference</a></p>
<p>包含了 Core Image 所提供图像滤镜的完整列表以及用法示例。</p>
<p><a href="https://objccn.io/issue-21-6/" target="_blank" rel="external">Core Image 介绍</a> </p>
<p> ObjC 的文章，详细介绍了 Core Image，值得看看。</p>
<p><a href="https://developer.apple.com/search/?q=Core%20Image&amp;type=Videos" target="_blank" rel="external">Core Image Sessions</a></p>
<p>关于 Core Image 的 Session，内容很全。</p>
<p><a href="https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html" target="_blank" rel="external">Core Image Programming Guide</a></p>
<p>官方 Core Image 编程指南。</p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> Core Image </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Call Directory Extension 初探]]></title>
      <url>/2016/06/17/Call-Directory-Extension-Study/</url>
      <content type="html"><![CDATA[<blockquote>
<p>iOS 10中引入了许多令人振奋的新特性，其中 CallKit让我特别感兴趣。这是一个非常重要的 API，继2014年苹果推出 VoIP证书后，这次 VoIP 接口的开放，以及一个全新的 App Extension，简直是VOIP的福音，可见苹果对VOIP的重视。并且，<strong>”that enable call blocking and caller identification. You can create an app extension that can associate a phone number with a name or tell the system when a number should be blocked.”</strong> 这意味着现在可以通过 Call Directory Extension 来实现电话黑名单功能了。Cool~ 本文简单阐述了如果实现简单的来电黑名单功能。</p>
</blockquote>
<p><strong>阅读须知：目前学习的资料也仅限相关 API，另外 API也没有详细的注释，所以本文主要是个人探索所得，如果有什么错误，还望见谅并予以指正。现在，让我们开始吧~</strong></p>
<a id="more"></a>
<h2 id="API介绍">API介绍</h2><p><strong>Extension</strong> 一直给我的印象就是很轻量，单一的，就如之前接触的  <a href="http://colin1994.github.io/2016/03/12/Photo-Editing-Extension/" target="_blank" rel="external">Photo Editing Extension</a> 一样，使用起来十分简单。这次的 <strong>Call Directory Extension</strong> 也不出例外，出奇的简单。只涉及了两个类，四个方法。下面我们逐一介绍：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CXCallDirectoryProvider.h</span></span><br><span class="line"><span class="comment">//  CallKit</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Copyright © 2016 Apple. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CXCallDirectoryProvider</span> : <span class="title">NSObject</span>, <span class="title">NSExtensionRequestHandling</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">beginRequest</span><span class="params">(with context: CXCallDirectoryExtensionContext)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是第一个类 <strong>CXCallDirectoryProvider</strong>，它是来电的响应者，为我们提供了 <strong>beginRequest</strong> 方法，该方法在 Containing App 调用 reload 或者在 设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification里开启权限的时候，会自动被调用。所以我们之后将要重写它，来实现黑名单相关逻辑。怎么样，简单吧~ <img src="http://wanzao2.b0.upaiyun.com/system/pictures/2/original/21.png" alt="emoji_1"></p>
<p>Now, Go on~</p>
<p>接下来是另外一个类 <strong>CXCallDirectoryExtensionContext</strong>，它提供了另外三个方法，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CXCallDirectoryExtensionContext.h</span></span><br><span class="line"><span class="comment">//  CallKit</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Copyright © 2016 Apple. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CXCallDirectoryExtensionContext</span> : <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addBlockingEntry</span><span class="params">(withNextSequentialPhoneNumber phoneNumber: String)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addIdentificationEntry</span><span class="params">(withNextSequentialPhoneNumber phoneNumber: String, label: String)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">completeRequest</span><span class="params">(completionHandler completion: <span class="params">(<span class="params">(Bool)</span></span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，<strong>CXCallDirectoryExtensionContext</strong> 主要负责提交我们处理好的请求。说白点，我们利用它来让系统知道，我们对某个来电所做出的判断。 <strong>addBlockingEntry</strong> 方法，接受一个电话号码字符串，形如 <strong>“+8618…69”</strong> (PS：不要问我为什么要加区号.. 这都是血与泪的经验)，来直接加入黑名单，也就是不接听该来电。<strong>addIdentificationEntry</strong> 方法，接受一个电话号码字符串以及对该号码的描述，也就是来电的时候需要显示的内容。 <strong>completeRequest</strong> 也就是提交之前的处理结果。至此，我们所要做的工作就完成了。<img src="http://wanzao2.b0.upaiyun.com/system/pictures/16/original/15.png" alt="emoji_2"></p>
<h2 id="实战演示">实战演示</h2><p>虽然自认为上面的描述已经够详细了，不过这里还是有必要详细走一遍流程，以免遗漏。</p>
<p>开发环境：Xcode8.0 Beta + 64位 iOS10设备（至于为什么64位，之后再解释，说多了都是泪..）</p>
<h3 id="1-_创建工程">1. 创建工程</h3><p>没什么特别。 <strong>Xcode —&gt; File —&gt; New —&gt; Project</strong>。随便选个 iOS Application，创建即可。这里我选择开发语言为 Swift，你随意~。</p>
<p>这里我们的目标是来电黑名单，也就是 Extension部分，所以创建好的 Containing App，不用做什么改动。</p>
<h3 id="2-添加_Extension">2.添加 Extension</h3><p><strong>Xcode —&gt; File —&gt; New —&gt; Target</strong>。创建一个 <strong>Call Directory Extension</strong>，如下图所示：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/callExtension_1.jpeg?imageView2/2/w/600" alt="Extension_1"></p>
<p>这里注意下底部的说明， （This extension and the app it is bundled with must be <strong>64-bit only</strong>）也就是，这个 extension只支持 64位的设备，坑爹有没有！！之前创建太急，没认真看，用那台 5C倒腾了半天，就是出问题。只好狠心把主力机也升级了。</p>
<p>创建好 Extension，会弹出这样的提示框：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/callExtension_2.jpeg?imageView2/2/w/500" alt="Extension_2"></p>
<p>询问我们是否激活这个 scheme，当然选择激活咯，继续~</p>
<p>之后只要关注 <strong>xxxHandler.swift</strong> 即可，xxx是你之前创建的 extension命名。</p>
<p>这里的相关代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CallKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallDirectoryHandler</span>: <span class="title">CXCallDirectoryProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">beginRequest</span><span class="params">(with context: CXCallDirectoryExtensionContext)</span></span> &#123;</span><br><span class="line">    	<span class="comment">// --- 1</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> phoneNumbersToBlock = retrievePhoneNumbersToBlock() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"Unable to retrieve phone numbers to block"</span>)</span><br><span class="line">            <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"CallDirectoryHandler"</span>, code: <span class="number">1</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">            context.cancelRequest(withError: error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 2</span></span><br><span class="line">        <span class="keyword">for</span> phoneNumber <span class="keyword">in</span> phoneNumbersToBlock &#123;</span><br><span class="line">            context.addBlockingEntry(withNextSequentialPhoneNumber: phoneNumber)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 3</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (phoneNumbersToIdentify, phoneNumberIdentificationLabels) = retrievePhoneNumbersToIdentifyAndLabels() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"Unable to retrieve phone numbers to identify and their labels"</span>)</span><br><span class="line">            <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"CallDirectoryHandler"</span>, code: <span class="number">2</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">            context.cancelRequest(withError: error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 4</span></span><br><span class="line">        <span class="keyword">for</span> (phoneNumber, label) <span class="keyword">in</span> <span class="built_in">zip</span>(phoneNumbersToIdentify, phoneNumberIdentificationLabels) &#123;</span><br><span class="line">            context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 5</span></span><br><span class="line">        context.completeRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">retrievePhoneNumbersToBlock</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>]? &#123;</span><br><span class="line">        <span class="comment">// retrieve list of phone numbers to block</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"+8618xxxx157"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">retrievePhoneNumbersToIdentifyAndLabels</span><span class="params">()</span></span> -&gt; (phoneNumbers: [<span class="type">String</span>], labels: [<span class="type">String</span>])? &#123;</span><br><span class="line">        <span class="comment">// retrieve list of phone numbers to identify, and their labels</span></span><br><span class="line">        <span class="keyword">return</span> ([<span class="string">"+8618xxxx569"</span>], [<span class="string">"测试"</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的来电黑名单，我们只要补全 <code>retrievePhoneNumbersToBlock</code> 和 <code>retrievePhoneNumbersToIdentifyAndLabels</code> 中的相关数据即可，它们分别表示直接加入黑名单的号码以及识别出来，需要判断的号码。</p>
<p>现在我们具体看一下这个类到底做了什么。</p>
<p><code>beginRequest</code> ，该方法在 Containing App 调用 reload 或者在 设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification里开启权限的时候，会自动被调用。每次调用，都会提交当前的黑名单列表，具体操作如下：</p>
<p>在 <strong>// —- 1</strong> 中，先判断是否成功调用了 <code>retrievePhoneNumbersToBlock</code> 方法，如果没有，则打印 Log： <strong>Unable to retrieve phone numbers to block</strong>，然后直接终止这次请求并返回。</p>
<p>在 <strong>// —- 2</strong> 中，遍历添加黑名单中的号码，这里的号码将直接拦截。</p>
<p>在 <strong>// —- 3</strong> 中，先判断是否成功调用了 <code>retrievePhoneNumbersToIdentifyAndLabels</code> 方法，如果没有，则打印 Log： <strong>Unable to retrieve phone numbers to identify and their labels</strong>，然后直接终止这次请求并返回。</p>
<p>在 <strong>// —- 4</strong> 中，遍历添加识别后的号码及其描述，这里的号码将连带描述一起显示。</p>
<p>在 <strong>// —- 5</strong> 中，完成提交请求。 </p>
<p>到这里，代码已经全部完成了。</p>
<h3 id="3-_开启权限">3. 开启权限</h3><p>之后我们运行该 App到设备中，然后进入设备的设置 —&gt; 电话 —&gt; Call Blocking &amp; Identification，开启我们的 App即可。如下图所示：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/callExtension_3.png?imageView2/2/h/500" alt="Extension_3"></p>
<p>至此，相关的工作就都完成了，我们的来电黑名单也已经实现了，可以用添加到列表中的号码来测试啦，如下所示：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/callExtension_4.png?imageView2/2/h/500" alt="Extension_4"></p>
<h2 id="相关思考及后续">相关思考及后续</h2><p>虽然实现黑名单功能很简单，但是这里我认为主要的问题应该是集中在，如何编辑这个黑名单列表。列表数据项可能很多，并且数据可能是实时更新添加的，那应该怎么做才更好呢？这里我的第一反应就是利用 App Group实现数据共享，在 Containing App完成相关的数据操作，在 Extension App中去获取即可。至于可行性，倒是没有验证过，如果不行，就当我瞎比比咯~。 当然，可能还有其他的办法，以及可能还会遇到其他的问题，这里在之后的学习过程中，我会逐步完善。</p>
<p>当然，对于 CallKit的学习，我也仅限于这一两天，还是没有资料的情况下。所以文中难免存在各种错误以及遗漏，欢迎指正。</p>
<p>这之后，继续 CallKit的学习，实现它的另外一个功能：VoIP App。 wait…</p>
<p>Enjoy it~</p>
<h2 id="参考链接">参考链接</h2><p><a href="https://developer.apple.com/videos/play/wwdc2016/230/" target="_blank" rel="external">Enhancing VoIP Apps with CallKit</a></p>
<p><a href="https://developer.apple.com/reference/callkit" target="_blank" rel="external">CallKit</a></p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS 10 </tag>
            
            <tag> CallKit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[What's New in iOS 10.0 中文版(上)]]></title>
      <url>/2016/06/14/What's_New_in_iOS_10.0_zh_0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>由于原文篇幅较长，为了方便阅读，分为上下篇。</p>
<p>本文是 What’s New in iOS 10.0 中文版的上篇，主要描述了iOS 10新引入的一些新特效，概括了重要的变化。</p>
<p>在What’s New in iOS 10.0 中文版(下)中，将介绍一些已存在框架的改进以及一些弃用的 API。</p>
<p>原文链接：<a href="https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW1" target="_blank" rel="external">What’s New in iOS 10.0</a></p>
</blockquote>
<p>这篇文章总结了运行在目前 iOS设备上的 iOS 10中与开发者有关的功能，这篇文章还列出了与这些功能相关的详细文档。</p>
<a id="more"></a>
<p>关于目前已知问题的最新新闻和信息，可以查阅 <a href="https://developer.apple.com/ios/download/" target="_blank" rel="external">https://developer.apple.com/ios/download/</a> 。添加到 iOS 10中的 API 的完整列表，详见 <em><a href="https://developer.apple.com/library/prerelease/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="external">iOS 10.0 API Diffs</a></em>。有关新设备的更多信息，详见 <em><a href="https://developer.apple.com/library/prerelease/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a></em>.</p>
<p>更多关于 Swift,详见 <a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3" target="_blank" rel="external">Swift Language</a> and <em><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language (Swift 3)</a></em>.</p>
<h2 id="SiriKit">SiriKit</h2><p>Apps 在特定的领域提供服务，可以使用 SiriKit来在 iOS中通过 Siri使用这些服务。 想要提供这些服务，需要创建一个或多个使用这些意图和意图 UI frameworks的   App extensions(app extensions using the Intents and Intents UI frameworks)。SiriKit提供如下领域的服务：</p>
<ul>
<li>音频或视频通话</li>
<li>消息传递</li>
<li>发送或接收付款</li>
<li>搜索照片</li>
<li>乘坐预定</li>
<li>管理训练</li>
</ul>
<p>当用户发起一个包含了你所提供服务的请求时， SiriKit会向你的 extension发送一个意图对象( intent object )，它描述了用户了请求并且提供了与这个请求相关的所有数据。你使用这个意图对象来提供一个相关的响应对象(response object)，它包含了如何处理用户请求的详情。Siri通常处理所有的用户交互，但是你也可以使用一个 extension来提供自定义 UI，它包含来自你的 App中的品牌或者其他额外信息。</p>
<p>SiriKit还提供了一个机制，你可以使用它来告诉系统发生在你的 App中的交互和活动。 当你告诉系统这些交互，系统会判断你的 App是否可以处理用户当前的请求，如果可以，就把这个请求传递给你的 App。 除了意图，SiriKit还定义了一个交互对象(interaction object)，它把意图(intent)和意图处理过程(intent-handling process)的信息相结合，包含开始时间和特定事件发生的持续时间等细节。如果你的 App注册为可以处理一个活动，这个活动具有一个相同的名称并且作为一个意图，系统可以启动你的 App，并且携带一个包含了意图的交互对象，即使你没有提供一个意图 App extension。</p>
<p>Maps和 Siri 都提供乘坐预定，用户也可以使用 Maps来订餐。你的意图 extension处理源于 Maps的交互，同样地它处理来自 Siri的请求。如果你自定义用户界面，你的意图 UI extension还可以自行配置，取决于你的请求是来自 Siri 还是 Maps。</p>
<p>为了学习如何支持 SiriKit来给用户提供使用服务的新途径，阅读 <em><a href="https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875" target="_blank" rel="external">SiriKit Programming Guide</a></em>. 当你准备实现处理各种意图的 App extensions，参考 <em><a href="https://developer.apple.com/reference/intents" target="_blank" rel="external">Intents Framework Reference</a></em> 和 <em><a href="https://developer.apple.com/reference/intentsui" target="_blank" rel="external">Intents UI Framework Reference</a></em>.</p>
<h2 id="积极的建议">积极的建议</h2><p>iOS 10引入了新的方式来来增强与你的 App的交互度(engagement)，通过帮助系统在适当的时机把你的 App推荐给用户。 如果你通过 App搜索你的 iOS 9 App，通过 Spotlight，Safari搜索结果，Handoff以及 Siri建议，允许用户访问你的 App深处的活动(activities)以及内容。 在 iOS 10之后，你可以提供用户在你的 App中做什么的信息，这有助于系统在额外的地方推广你的 App，比如键盘和 QuickType，Maps和 CarPlay，应用切换器(app switcher)，Siri交互和(媒体播放 Apps) 的锁屏界面。这些机会提高与系统的整合，它由一系列的技术支持，比如  <code>NSUserActivity</code>，由 <a href="http://schema.org/" target="_blank" rel="external">Schema.org</a>定义的 Web标记(web markup)，以及定义在 Core Spotlight，MapKit，UIKit，以及 Media Player框架中的 API。.</p>
<p>在 iOS 10中，<code>NSUserActivity</code> 对象包含  <code>mapItem</code> 属性，该属性允许你提供可以在上下文(other contexts)使用的位置信息。比如，你的 App展示酒店信息，你可以使用 <code>mapItem</code> 属性来保存用户正在浏览的酒店的位置信息，当用户切换到另外一个旅行规划 App，酒店的位置是自动可用的。如果你支持 App搜索，你可以使用 <code>CSSearchableItemAttributeSet</code> 中新的基于文本的地址(text-based address)的属性，比如 <code>thoroughfare</code> 和 <code>postalCode</code>，来指定用户可能想要去的具体位置。注意，当你使用  <code>mapItem</code> 属性，系统自动填充  <code>contentAttributeSet</code>  属性。</p>
<p>为了与系统共享一个位置，一定要指定 <code>latitude</code> 和 <code>longitude</code> 值，除了 <code>CSSearchableItemAttributeSet</code> 中的地址属性。也建议你提供值给 <code>namedLocation</code>，这样用户可以查看位置的名称，以及  <code>phoneNumbers</code> 属性，以便用户可以使用 Siri来发起呼叫给指定位置。</p>
<p>在 iOS 9中，将标记添加到你的网站上的结构数据来丰富内容，用户可以在 Spotlight和 Safari搜索结果中看到。在 iOS 10中，你可以使用  <a href="http://schema.org/" target="_blank" rel="external">Schema.org</a> 定义的位置相关词汇，比如 <a href="http://schema.org/PostalAddress" target="_blank" rel="external">PostalAddress</a>，进一步提高用户体验。例如，如果用户查看你网站上描述的一个位置，系统可以在用户切换到 Maps中的时候建议相同的位置。注意 Safari 同时支持 JSON-LD 和 Microdata 编码的 <a href="http://schema.org/" target="_blank" rel="external">Schema.org</a> 词汇。</p>
<p>UIKit介绍了 <code>UITextInputTraits</code> 协议中的  <code>textContentType</code> 属性，它可以让你指定你希望用户输入文本区域的内容的语义。当你提供这些信息时，系统可以在某些情况下自动选择一个合适的键盘并且提高键盘修正和主动集成来自其他 App或者网站的信息。比如，如果你使用 <code>UITextContentTypeFullStreetAddress</code> 来告诉系统你希望用户在文本区域中输入一个完整的地址，系统可以显示用户最近查看的位置地址。</p>
<p>如果你的 App播放多媒体并且使用  <code>MPPlayableContentManager</code> APIs， iOS 10 帮你在锁屏界面通过你的 App，使得用户可以查看专辑封面和播放多媒体。</p>
<p>如果你的骑乘共享(ride-sharing) App使用  <code>MKDirectionsRequest</code> API，iOS 10 可以在用户想要骑行的时候，在应用程序切换器(app switcher)中展示它。想要注册成一个骑行共享提供者，在 <code>Info.plist</code> 文件中设置 <a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW33" target="_blank" rel="external">MKDirectionsApplicationSupportedModes</a> 的值为 <code>MKDirectionsModeRideShare</code> 。如果你的 App 只提供骑行共享，系统建议你的 App使用这样开头的文本  “Get a ride to…”；如果你的 App支持骑行共享和其他路由类型（如汽车或摩托车），系统建议你使用这样开头的文本  “Get directions to…”。注意 你收到的 <code>MKMapItem</code> 对象可能不包含经度和纬度信息，需要地理编码。</p>
<h2 id="与_Messages_App_交互">与 Messages App 交互</h2><p>在 iOS 10中，你可以创建 App extensions 来与 Messages App交互，使得用户可以发送文本，贴纸，媒体文件以及交互式消息。你也可以支持更新为每个收件人响应消息的交互式消息。你还可以创建两种类型的 App extensions:</p>
<ul>
<li><p>贴纸包提供一系列的贴纸，用户可以添加到他们的信息内容中。</p>
</li>
<li><p><em>iMessage app</em> 让你在 Messages App 中展示一个自定义用户界面，创建一个标签的浏览器，包括一次对话中的文本，贴纸和媒体文件，并且创建，发送和更新消息交互。</p>
<p> iMessage App也可以帮助用户搜索保存在你的 App中相关网站的图片，当它们处在  Messages App 中的时候。</p>
</li>
</ul>
<p>你可以创建一个贴纸包而无需编写任何代码：简单地拖拽图片到 Xcode中贴纸包文件夹内贴纸 asset 目录。</p>
<p>为了开发一个  iMessage App，你可以使用 Messages 框架中的 API (<code>Messages.framework</code>)。更多关于 Messages 框架，详见 <em><a href="https://developer.apple.com/reference/messages" target="_blank" rel="external">Messages Framework Reference</a></em>. 对于创建 App Extensions的普遍信息，详见 <em><a href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension Programming Guide</a></em>.</p>
<p>如果你的 App提供图片在 Messages中分享，你想要用户可以使用 Spotlight 的流行图片搜索  (即, “#images”) 来搜索图片，而不用离开 Messages App，首先创建一个 iMessage app。然后遵循下面步骤： </p>
<ul>
<li>给你 App 的 entitlements 添加  <code>com.apple.developer.associated-domains</code> 键。包括保存你想要搜索的图片的网站域名的一个列表。对于每个域，指定 <code>spotlight-image-search</code> 服务。</li>
<li>添加一个 <code>apple-app-site-association</code> 文件到你的网站。为 <code>spotlight-image-search</code> 服务添加一个字典，包含你的 app ID, 它是 team ID 或者 app ID 前缀，后跟  bundle ID。你可以指定多打500个路径和模式，应该包含 Spotlight 流行图片搜索索引。 (关于网站路径的一些实例，详见 <a href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4" target="_blank" rel="external">Creating and Uploading the Association File</a>).</li>
<li>允许 Applebot 爬虫 (详见 <a href="https://support.apple.com/en-us/HT204683" target="_blank" rel="external">About Applebot</a>).</li>
</ul>
<h2 id="用户通知">用户通知</h2><p>iOS 10 引入了用户通知框架(<code>UserNotifications.framework</code>)，它支持本地和远程通知的发送和处理。你可以使用这个框架的类来安排基于特定条件的本地通知。比如时间或者位置。当它们被发送到用户设备的时候，App 和App extensions 可以使用这个框架来接收和修改本地和远程的通知。</p>
<p>还介绍了在 iOS 10 中，用户通知 UI框架 (<code>UserNotificationsUI.framework</code>) 允许你自定义显示在用户设备上的本地和远程推送通知。你使用这个框架来定义一个接收通知数据并且提供相应可视化表示的 App extension 。这个 extension也可以响应相关的自定义动作和通知。 </p>
<h2 id="语音识别">语音识别</h2><p>iOS 10 引入了一个新的 API，支持连续语音识别和帮助你构建支持语音识别并且转换成文本的 App。使用  Speech 框架 (<code>Speech.framework</code>) 中的 API，你可以执行实时语音转录和记录音频。例如，你可以得到一个语音识别器，开始简单的语音识别，代码如下所示： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> recognizer = <span class="type">SFSpeechRecognizer</span>()</span><br><span class="line"><span class="keyword">let</span> request = <span class="type">SFSpeechURLRecognitionRequest</span>(url: audioFileURL)</span><br><span class="line">recognizer?.recognitionTask(with: request, resultHandler: &#123; (result, error) <span class="keyword">in</span></span><br><span class="line">     <span class="built_in">print</span> (result?.bestTranscription.formattedString)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>与访问其他类型的受保护数据一样，如日历，照片资料，进行语音识别需要用户的授权 (更多关于访问受保护的数据类，详见<a href="https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3" target="_blank" rel="external">Security and Privacy Enhancements</a>)。在语音识别的情况下，许可是必需的，因为数据被传递，并且暂时存储在苹果的服务器上，以提高语音识别的准确性。请求用户的权限，必须在 <code>Info.plist</code> 文件中添加<code>NSSpeechRecognitionUsageDescription</code>  键。</p>
<p>当你在你的 App中采用语音识别，一定要向用户表明他们的语音将被识别，并且他们不应该使用敏感话语。</p>
<h2 id="广泛的颜色">广泛的颜色</h2><p>贯穿系统的大多数图形框架，包括 Core Graphics, Core Image, Metal, 和 AVFoundation, 有大幅的改进来支持 extended-range 像素格式和 wide-gamut 颜色空间。通过将此行为扩展到整个图形栈中，它比以往任何时间更容易支持具有宽颜色显示的设备。此外，UIKit 使在新扩展的 sRGB颜色空间上工作标准化，因此很容易混合 sRGB和其他颜色，更广泛的色域没有明显的性能损失。</p>
<p>这里有一些你开始使用广泛颜色的最佳实践。</p>
<ul>
<li>在 iOS 10 中，<a href="https://developer.apple.com/reference/uikit/uicolor" target="_blank" rel="external">UIColor</a> 类使用扩展的 sRGB 颜色空间，并且它的构造器(initializers)不再限制初始值在  <code>0.0</code> 和 <code>1.0</code> 之间。如果你的应用程序依赖于 UIKit来限制组件(component)值 (无论你是创建一个颜色或者一个颜色的组件值)，当你链接到 iOS 10的时候，你需要改变这些行为。 </li>
<li>当在 iPad Pro (9.7 inch) 的  <a href="https://developer.apple.com/reference/uikit/uiview" target="_blank" rel="external">UIView</a> 上执行自定义的绘制时，底层的绘图环境配置了一个扩展的 sRGB颜色空间。</li>
<li>如果你的 App 渲染自定义的图像对象，使用新的  <a href="https://developer.apple.com/reference/uikit/uigraphicsimagerenderer" target="_blank" rel="external">UIGraphicsImageRenderer</a> 类来控制目标位图是使用扩展范围(extended-range)还是标准范围 (standard-range) 格式。</li>
<li>如果你使用较低级别的 API，比如 Core Graphics 和 Metal来执行你自己的图像处理，你需要使用一个扩展的颜色空间和一个支持16位浮点值的像素格式的组件值。当限制颜色值是必要的时候，你应该明确这样做。</li>
<li>Core Graphics, Core Image,以及 Metal 性能着色器提供了新的选择，可以在颜色空间之间轻松转换颜色和图像。</li>
</ul>
<h2 id="适应真实的色调显示">适应真实的色调显示</h2><p>真实的色调显示使用环境光传感器自动调整显示器的颜色和强度，以配合当前环境的照明条件。为了确保你的 App可以与真实的色调提供的标准颜色变化很好的工作，在 <code>Info.plist</code> 中添加新的 <a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31" target="_blank" rel="external">UIWhitePointAdaptivityStyle</a> 键来描述你的 App的主要视觉内容。比如： </p>
<ul>
<li>如果你的 App是一个照片编辑应用，颜色的准确性(fidelity)比自动调整环境白点(white point)更重要。在这种情况下，你可以使用 <code>UIWhitePointAdaptivityStylePhoto</code> 方式来降低系统提供的真实色调变化的强度。</li>
<li>如果你的 App是一个阅读应用，符合环境白点将为用户提供帮助。在这种情况下，你可以使用 <code>UIWhitePointAdaptivityStyleReading</code> 方式来加强系统提供的真实色调变化的强度。</li>
</ul>
<h2 id="App搜索_的改进">App搜索 的改进</h2><p>iOS 10 和 Core Spotlight框架介绍了几个 App搜索的改进点： </p>
<ul>
<li>应用内(In-app)搜索</li>
<li>继续搜索(Search continuation)</li>
<li>众包(crowdsourcing:是互联网带来的新的生产组织形式)与差分隐私(differential privacy)的深度链接</li>
<li>可视化的验证结果</li>
</ul>
<p>新的 <code>CSSearchQuery</code> 类支持应用内内容搜索，使用现有的 Core Spotlight APIs。使用这个 API可以消除需要保持你自己单独的搜索索引，让你发挥 Spotlight的强大搜索技术和匹配规则，允许用户搜索内容不离开你的 App，就像他们在 Mail, Messages,和 Notes.</p>
<p>在 iOS 9中，使用搜索 API(比如 Core Spotlight, <a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a> 和 web标记) 在你的 App中，让用户使用Spotlight 和 Safari搜索界面来搜索索引的内容。在 iOS 10中，你可以使用新的 Core Spotlight 符号，当用户打开你的 App时候，用户可以继续使用 Spotlight进行搜索。要启用这个功能，在 <code>Info.plist</code> 文件中添加 <code>CoreSpotlightContinuation</code> 键，并且设置它的值为  <code>YES</code>，然后更新你的代码来处理一个  <a href="https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype" target="_blank" rel="external">CSQueryContinuationActionType</a> 类型的活动延续。在  <a href="https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application" target="_blank" rel="external">application:continueUserActivity:restorationHandler:</a> 方法中收到的 <a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a> 对象中的用户信息字典包含了 <a href="https://developer.apple.com/reference/corespotlight/cssearchquerystring" target="_blank" rel="external">CSSearchQueryString</a> 键，它的值是一个字符串，表示用户的查询。</p>
<p>iOS 10 引入了一个不同的私人方式来帮助提高你的 App的内容在搜索结果中的排名。 iOS 提交一部分差分隐私到 Apple的服务器随着用户使用你的 App 以及  <a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a> 对象包含深度链接地址并且它们的 <a href="https://developer.apple.com/reference/foundation/nsuseractivity/1414701-eligibleforpublicindexing" target="_blank" rel="external">eligibleForPublicIndexing</a> 属性设置为  <code>YES</code> 被提交到 iOS中。差分隐形散列允许 Apple统计流行的深度链接的频率，而不曾与用户关联的链接进行访问。</p>
<p>当你使用 App 搜索 API 验证工具来测试你的网站标记和深度链接，现在展示你的结果的可视化表示，包括支持的标记，比如  <a href="http://schema.org/" target="_blank" rel="external">Schema.org</a> 中定义的。验证工具可以帮你看到 Applebot web爬虫索引信息，比如标题，描述，URL和其他支持的元素。你可以在这里获取这个验证工具： <a href="https://search.developer.apple.com/appsearch-validation-tool" target="_blank" rel="external">https://search.developer.apple.com/appsearch-validation-tool</a>. 更多关于支持深度链接和添加标记，详见： <a href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8" target="_blank" rel="external">Mark Up Web Content</a>.</p>
<p>学习如何让你的网站中的图片在 Messages App内可搜索，详见 <a href="https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4" target="_blank" rel="external">Integrating with the Messages App</a>.</p>
<h2 id="Widget_的改进">Widget 的改进</h2><p>iOS 10 为锁屏界面引入了一个新的设计，现在可以显示 widgets。为了保证你的 widget 在任何背景下看起来都不错，你可以适当地设置 <a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect" target="_blank" rel="external">widgetPrimaryVibrancyEffect</a> 或者 <a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect" target="_blank" rel="external">widgetSecondaryVibrancyEffect</a>(使用这些属性取代已废弃的 <a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect" target="_blank" rel="external">notificationCenterVibrancyEffect</a> 属性)。此外， widgets现在包括显示模式(由 <a href="https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode" target="_blank" rel="external">NCWidgetDisplayMode</a> 表示)的概念，它可以让你描述有多少内容是可用的，并允许用户选择一个紧凑或者扩展型的视图。 </p>
<h2 id="Apple_Pay_的改进">Apple Pay 的改进</h2><p>在 iOS 10中，用户可以通过 Siri和 Maps使用网页版的 Apple Pay 来便捷安全的完成支付。对于开发者来说， iOS 10 引入了新的 API，你可以在代码中使用运行在 iOS和  watchOS上，支持动态支付网络的能力和一个新的沙盒测试环境。</p>
<p>iOS 10 引入了新的 API，帮助你将 Apple Pay 直接引入你的网站。当你在你的网站支持 Apple Pay，用户在 iOS或者 OS X上通过 Safari浏览的时候，可以通过它们的 iPhone或 Apple Watch来使用 Apple Pay上的信用卡进行支付。 详见 <a href="https://developer.apple.com/reference/applepayjs" target="_blank" rel="external"><em>ApplePay JS Framework Reference</em></a>.</p>
<p> PassKit框架 (<code>PassKit.framework</code>) 介绍了让你在 UIKit不可用的地方支持 Apple Pay的 API。具体来说， <a href="https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontroller" target="_blank" rel="external">PKPaymentAuthorizationController</a> 和 <a href="https://developer.apple.com/reference/passkit/pkpaymentauthorizationcontrollerdelegate" target="_blank" rel="external">PKPaymentAuthorizationControllerDelegate</a> 使得  <a href="https://developer.apple.com/reference/passkit/pkpaymentauthorizationviewcontroller" target="_blank" rel="external">PKPaymentAuthorizationViewController</a> 提供的功能以及它的 delegate 可用，而不需要 UIKit。尽管新的 API 需要在特定的意图下在 watchOS上提供 Apple Pay，还是建议你在代码的任何地方采用它。这样你就可以用一套基础代码来广泛提供 Apple Pay支持。(更多关于意图和 Siri集成，详见 <a href="https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5" target="_blank" rel="external">SiriKit</a>.)</p>
<p> PassKit 框架还增加了新的功能，让信用卡发行机构在它们的 App中展示他们的信用卡。具体来说， <code>PKPaymentButtonTypeInStore</code> 按钮类型允许你为信用卡展示一个 Apple Pay 按钮，  <code>presentPaymentPass:</code> 方法允许你以编程方式展示信用卡。 ( <code>presentPaymentPass:</code> 方法定义在  <a href="https://developer.apple.com/reference/passkit/pkpasslibrary" target="_blank" rel="external">PKPassLibrary</a>中)。</p>
<p>当一个新的支付网络可用时，你的 App可用自动支持新的网络，而不需要修改和重新编译你的 App。<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks" target="_blank" rel="external">availableNetworks</a> 方法允许你在运行时发现用户设备可用的网络。此外， <a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks" target="_blank" rel="external">supportedNetworks</a> 属性被扩展了，以便可以携带一些支付服务提供商的名字作为参数。然后你的 App自动支持任何支付提供商支持的网络。详见<a href="https://developer.apple.com/apple-pay/" target="_blank" rel="external">https://developer.apple.com/apple-pay/</a>.</p>
<p>iOS 10 引入了一个新的测试环境，它允许你直接在设备上提供测试信用卡。测试环境返回加密后的测试支付数据。要使用这种环境，遵循以下步骤：</p>
<ol>
<li>在 iTunes Connect上创建一个测试 iCloud账号</li>
<li>在你的设备上登录该账号</li>
<li>设置测试所需的区域</li>
<li>使用 <a href="https://developer.apple.com/apple-pay/" target="_blank" rel="external">https://developer.apple.com/apple-pay/</a> 上列举的测试信用卡</li>
</ol>
<p><strong>注意:</strong> 当你切换 iCloud账号，环境自动切换。你还必须在实际生产环境中测试支付。</p>
<h2 id="安全和隐私的改进">安全和隐私的改进</h2><p>iOS 10 引入了一些修改和补充，帮助你提高你的代码的安全和维护用户数据的隐私。更多关于这方面的内容，详见 <a href="https://developer.apple.com/security/" target="_blank" rel="external">Security</a> .</p>
<ul>
<li><code>Info.plist</code> 文件中新的 <code>NSAllowsArbitraryLoadsInWebContent</code> 键，提供了一个便捷的方式来允许任意的 web页面加载任务，同时保留 ATS保护你的 App的其余部分。</li>
<li>SecKey API包括不对称密钥生成的改进。使用 SecKey API 替代已经弃用的 CDSA(Common Data Security Architecture: 通用数据安全架构) API。</li>
<li>RC4 对称加密套件现在默认禁用所有的 SSL/TLS 连接，以及 SSLv3 不再支持安全传输 API。建议你尽快停止使用  SHA-1和 3DES 加密算法。</li>
<li><a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a> 类支持剪贴板功能，该功能允许用户设置之间复制和粘贴，包括 API可以用来限制一个纸板到特定设备和设置到达过期时间戳后，纸板被清除。此外，命名过的纸板不再重复出现，取而代之的是，你应该使用共享的容器，以及“发现”纸板（也就是说，纸板被  <a href="https://developer.apple.com/reference/uikit/uipasteboardnamefind" target="_blank" rel="external">UIPasteboardNameFind</a>  常数定义）是无效的。</li>
<li>你必须静态声明你的应用程序使用受保护的数据类，通过在 <code>Info.plist</code> 文件中包含相关的目的字符串键。例如，你必须包含 <a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15" target="_blank" rel="external">NSCalendarsUsageDescription</a> 键来访问用户日历的数据。如果你不包含相关的目的字符串键，当你试图访问相关数据的时候，你的 App会退出。</li>
</ul>
<h2 id="CallKit">CallKit</h2><p> CallKit 框架 (<code>CallKit.framework</code>) 让  VoIP App与 iPhone UI相结合，给用户一个很棒的体验。使用这个框架来让用户在锁屏界面查看和接听到来的 VoIP电话，以及管理手机上 Favorites和 Recents视图上的联系人。</p>
<p>CallKit 还介绍了 App extensions，允许来电拦截并且来电识别。你可以创建一个 App extension，将一个电话号码和一个名称联系起来，或者告诉系统某个号码需要被拦截。</p>
<h2 id="News_Publisher_的改进">News Publisher 的改进</h2><p>News Publisher 可以使用 Apple News格式，很容易地提供设计精美的新闻，杂志和网络内容给 Apple News。任何人都可以注册，从主要的杂志或者新闻机构，到独立的出版商和博客。开始或学习更多关于最近的更新，访问  <a href="https://newsresources.apple.com/" target="_blank" rel="external">https://newsresources.apple.com</a>.</p>
<h2 id="Video_Subscriber_Account">Video Subscriber Account</h2><p>iOS 10 引入  Video Subscriber Account 框架 (<code>VideoSubscriberAccount.framework</code>) 来帮助 App支持支持身份验证流或验证视频点播(也称为 TV)与他们的有线或卫星 TV提供商进行身份验证。使用这个框架的 API可以帮助你支持一个单一的登录体验，用户登录一次解锁访问所有的视频应用程序订阅支持。</p>
<h2 id="App_Extensions">App Extensions</h2><p>iOS 10 引入了几个可以创建 App extension的新的 extension points，比如：</p>
<ul>
<li>Call Directory</li>
<li>Intents</li>
<li>Intents UI</li>
<li>Messages</li>
<li>Notification Content</li>
<li>Notification Service</li>
<li>Sticker Pack</li>
</ul>
<p>此外，iOS 10包含了如下的第三方键盘 app extensions的改进：</p>
<ul>
<li>你可以使用 <code>UITextDocumentProxy</code>  类中的  <code>documentInputMode</code> 属性，来自动检测文档的输入语言，并且改变你的键盘 extension来符合这个语言(如果支持的话)。当你用这种方式决定输入的语言时， 你可以做每一种语言的键盘切换，比如为 Messages内建的。</li>
<li>新的 <code>handleInputModeListFromView:withEvent:</code> 方法让键盘 extension 显示系统的键盘选择菜单(即地球标志的菜单).</li>
</ul>
<p>键盘 extension 必须放置地球标志和系统标志相同的位置。此外，如果你需要提供一个自定义的按键来启动键盘设置，例如，你应该把这个按键放在系统键盘听写键的相同位置。</p>
<p>更多关于 App extensions，详见 <a href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external"><em>App Extension Programming Guide</em></a>.</p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS 10 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TDD 学习总结（Swift 实践）]]></title>
      <url>/2016/06/03/TDD-With-Swift/</url>
      <content type="html"><![CDATA[<blockquote>
<p>花了几天时间，看完了 <a href="https://www.packtpub.com/application-development/test-driven-ios-development-swift" target="_blank" rel="external">《Test-Driven iOS Development with Swift》</a> 这本书，虽然只有短短 500页的 epub，但是讲解的很生动透彻，全书围绕一个 <code>ToDo</code> 应用展开，讲解了 <code>Test-Driven Development （TDD，即测试驱动开发）</code> 的实际应用，让我对 TDD 有了更全面的认识。故此，开坑记录之~</p>
</blockquote>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/TDDTDDFigure.png" alt="TDD"></p>
<a id="more"></a>
<h2 id="什么是_TDD">什么是 TDD</h2><p>测试驱动开发(TDD)是极限编程的重要特点，它以不断的测试推动代码的开发，既简化了代码，又保证了软件质量。</p>
<p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。</p>
<p>OK，概括来说，TDD 的开发过程可以用上图来描述：Red，Green，Refactor。</p>
<p>翻译过来就是：</p>
<ol>
<li>编写测试用例，测试不通过。（红色 Error）</li>
<li>编写代码实现功能，测试通过。（绿色 Success）</li>
<li>重构优化代码。（Refactor）</li>
</ol>
<p>再详细点，测试驱动开发的基本过程如下：</p>
<ol>
<li>明确当前要完成的功能。记录成一个 TODO 列表。</li>
<li>快速完成针对此功能的测试用例编写。</li>
<li>测试代码编译不通过。</li>
<li>编写对应的功能代码。</li>
<li>测试通过。</li>
<li>对代码进行重构，并保证测试通过。</li>
<li>循环完成所有功能的开发。</li>
</ol>
<p>怎么样，简单吧~</p>
<h2 id="是否该用_TDD">是否该用 TDD</h2><p>简单是简单，但是很明显的，开发前期，工作量绝对不是 1+1 那么简单，那么是否该用 TDD 呢？对此，我不做过多的阐述。世上并没有放之四海皆准的法则，TDD 好坏在于你的判断，方法论的主体在于使用的人，本文并不会给你一个完美的答案，这需要你自己在实践中取舍。接下去，我将列举 TDD 目前公认的一些优缺点，以及使用原则，加深大家对 TDD 的理解。</p>
<p><strong>TDD 开发的优点：</strong></p>
<ul>
<li>可以保证代码的质量。可以对自己的所需要的业务功能的每一步设计进行验证，并得到正确的结果，减少bug的出现的，特别对于复杂业务逻辑的项目，以小步慢走的方式，避免后期繁重的测试和维护工作。</li>
<li>找到了重构的信心，必要时候你还可以痛痛快快的并且满怀信心的对代码做一场大的变革。这样我们的代码变得干净了，扩展性、可以维护性以及易理解性纷至沓来。</li>
<li>在团队建设中能够进行分工，以可执行的形式文档化你的需求，迫使你分清职责隔离依赖以驱动你的设计，编织安全网以便将Bug扼杀在在摇篮状态，防止其逃逸。不同于传统开发（传统的开发人员开发的软件的测试是为了找出已经逃逸得bug，可能这个bug已经长成了毒瘤）。注：这两种活动都是必要的，而且毫不冲突，互为补充。</li>
<li>帮助你养成一个新的思维习惯，不光在你编程的道路上，在你的工作和生活中，你慢慢的会把自己的需求进行分析设计并不断地验证，最终更好去实现自己的人生目标。</li>
</ul>
<p><strong>TDD 开发的缺点：</strong></p>
<ul>
<li>对于测试驱动不熟练或者喜欢偷懒的的人员，加大了代码的编写量，测试代码是系统代码的两倍或更多。</li>
<li>可能不适合时间很紧的软件开发，更适合于产品和平台的开发。</li>
</ul>
<p><strong>TDD 原则：</strong></p>
<ul>
<li><p><strong>独立测试：</strong>不同代码的测试应该相互独立，一个类对应一个测试类，一个函数对应一个测试函数。用例也应各自独立，每个用例不能使用其他用例的结果数据，结果也不能依赖于用例执行顺序。 一个角色：开发过程包含多种工作，如：编写测试代码、编写产品代码、代码重构等。做不同的工作时，应专注于当前的角色，不要过多考虑其他方面的细节。</p>
</li>
<li><p><strong>测试列表：</strong>代码的功能点可能很多，并且需求可能是陆续出现的，任何阶段想添加功能时，应把相关功能点加到测试列表中，然后才能继续手头工作，避免疏漏。</p>
</li>
<li><p><strong>测试驱动：</strong>即利用测试来驱动开发，是TDD的核心。要实现某个功能，要编写某个类或某个函数，应首先编写测试代码，明确这个类、这个函数如何使用，如何测试，然后在对其进行设计、编码。</p>
</li>
<li><p><strong>先写断言：</strong>编写测试代码时，应该首先编写判断代码功能的断言语句，然后编写必要的辅助语句。</p>
</li>
<li><p><strong>可测试性：</strong>产品代码设计、开发时的应尽可能提高可测试性。每个代码单元的功能应该比较单纯，“各家自扫门前雪”，每个类、每个函数应该只做它该做的事，不要弄成大杂烩。尤其是增加新功能时，不要为了图一时之便，随便在原有代码中添加功能。</p>
</li>
<li><p><strong>及时重构：</strong>对结构不合理，重复等“味道”不好的代码，在测试通过后，应及时进行重构。</p>
</li>
<li><p><strong>小步前进：</strong>软件开发是复杂性非常高的工作，小步前进是降低复杂性的好办法。</p>
<p>​</p>
</li>
</ul>
<p>看到这里，如果你还觉得，有必要体验一把 TDD，那么接着往下看，我将通过一个简单的例子，走一遍 TDD 开发的流程，加深大家对 TDD 的了解，也为 iOS 中应用 TDD 做个入门介绍。</p>
<h2 id="iOS_中如何使用_TDD">iOS 中如何使用 TDD</h2><blockquote>
<p>Apple一直致力于在iOS开发中集成更加方便和可用的测试，在Xcode 5中，新的IDE和SDK引入了XCTest来替代原来的SenTestingKit，并且取消了新建工程时的“包括单元测试”的可选项（同样待遇的还有使用ARC的可选项）。新工程将自动包含测试的target，并且相关框架也搭建完毕，可以说测试终于摆脱了iOS开发中“二等公民”的地位，现在已经变得和产品代码一样重要了。  —————— 喵神</p>
</blockquote>
<p>简单 Mark 下 TDD 在 Xcode 中的历程：</p>
<ul>
<li>In 1998, the Swiss company Sen:te developed OCUnit, a testing framework for Objective-C (hence, the OC prefix). OCUnit was a port of SUnit, a testing framework that Kent Beck had written for Smalltalk in 1994.</li>
<li>With Xcode 2.1, Apple added OCUnit to Xcode.</li>
<li>In 2008, OCUnit was integrated into the iPhone SDK 2.2 to allow unit testing of iPhone apps.</li>
<li>Four years later, OCUnit was renamed XCUnit (XC stands for Xcode).</li>
</ul>
<p>既然 Xcode 为我们内置了这么方便的 XCTest，我们没理由不好好使用阿~</p>
<p>接下去通过实现一个简单的功能：把句子中每个单词的首字母转成大写字母，来走一遍 TDD 的流程。话不多说，开车了~</p>
<h3 id="1-_创建工程">1. 创建工程</h3><p>这里创建一个常规的 iOS 工程，记得 <code>“ Include Unit Tests”</code> 即可，语言我们选择 <code>Swift</code>。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/TDDdemo_0.jpeg" alt="demo_0"></p>
<p>创建完毕后的工程目录如下：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/TDDdemo_3.jpeg" alt="demo_1"></p>
<p>默认为我们创建了 <code>TDDDemoTests.swift</code> 文件，这里就是我们编写测试用例的地方。打开该文件，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  TDDDemoTests.swift</span></span><br><span class="line"><span class="comment">//  TDDDemoTests</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Colin on 16/6/3.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016年 Colin. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> TDDDemo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TDDDemoTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp()</span><br><span class="line">        <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tearDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">        <span class="keyword">super</span>.tearDown()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">        <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testPerformanceExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">        <span class="keyword">self</span>.measureBlock &#123;</span><br><span class="line">            <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，有几个地方需要说明一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> TDDDemo</span><br></pre></td></tr></table></figure>
<p>每一个测试用例都需要引入 <code>XCTest</code> 框架，它定义了我们需要的 <code>XCTestCase</code> 类，以及之后会用到的一些断言，比如 <code>XCTAssertEqual</code> 等。另外，还需要手动导入 <code>TDDDemo</code> 模块，我们之后的相关代码都会在 <code>TDDDemo</code> 中编写，但是默认情况下，类，结构体，枚举以及它们的方法，都是内联的（<code>internal</code>），这意味着它们所处模块外无法直接访问到它们。所以在此之外的测试代码无法访问到它们，故而需要使用 <code>@testable</code> 关键字来让测试代码能访问它们。</p>
<p>再看 <code>setUp</code> 方法和 <code>tearDown</code> 。在每个测试用例调用前，都会先调用 <code>setUp</code> 方法，在每个测试用例执行结束后，都会调用 <code>tearDown</code> 方法，大体流程就是：setUp — test case — tearDown — setUp — test case — tearDown …. 所以我们一般在 <code>setUp</code> 中做一些初始化操作，在 <code>tearDown</code>  做一些清除释放操作。</p>
<p>另外，每一个测试方法都需要以 <code>test</code> 开头，这样 Xcode 才能自动识别出它。比如默认提供的 <code>testExample</code> 和 <code>testPerformanceExample</code> 。</p>
<p>再有，这里建议在 Bulid 开始的时候，新建一个导航栏，并且打印 Build Log，这样我们能更直观知道发生了什么，哪里出错了。具体设置如下： <strong>Xcode | Preference | Behaviors</strong> </p>
<p>如图所示：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/TDDdemo_1.jpeg" alt="demo_2"></p>
<p>现在 <strong>Command + U</strong>，执行测试。毋庸置疑，测试通过（毕竟啥都还没开始写…）。你会看到如下界面：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/TDDdemo_4.jpeg" alt="demo_3"></p>
<p>左边的  <strong>Test Navigation</strong> 列举了所有的测试用例以及对应的测试结果。中间的编辑区展示了 <strong>Bulid</strong> 过程中具体做了什么，以及 <strong>Build</strong> 结果。</p>
<p>哦，对了。还有一处设置也很有用。</p>
<p><strong>Edit Scheme | Test</strong> ，可以看到右边列举了所有参与测试的用例。当然我们知道，每个用例的测试都是需要时间的，如果想对某个用例单独测试，或者不想测试某个用例，相应的勾选和去选就可以了。</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/TDDdemo_5.jpeg" alt="demo_4"></p>
<h3 id="2-_编写测试用例">2. 编写测试用例</h3><p>好了，万事俱备，是时候展示真正的技术了！</p>
<p>删除默认的 <code>TDDDemoTests.swift</code> 文件，重新创建一个 <code>CapitalTest.swift</code> 文件。在 <code>TDDDemoTests</code> 分组中，<strong>File | New | File | iOS | Source | Unit Test Case Class</strong> ，创建一个名为 <strong>CapitalTest</strong> 并 继承自 <strong>XCTestCase</strong> 的类。如图所示：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/TDDdemo_6.jpeg" alt="demo_5"></p>
<p>删掉无用的 <strong>testExample，testPerformanceExample</strong> 方法。</p>
<p>引用 <strong>TDDDemo</strong> 类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> TDDDemo</span><br></pre></td></tr></table></figure>
<p>编写测试用例：</p>
<p>这里我们要做的是实现句子中单词首字母的大写转换，所以只要写个测试用例验证首字母是否都是大写即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMakeHeadline_ReturnsStringWithEachWordStartCapital</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> viewController = <span class="type">ViewController</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">"this is A test headline"</span></span><br><span class="line">    <span class="keyword">let</span> headline = viewController.makeHeadline(string)</span><br><span class="line">    </span><br><span class="line">    <span class="type">XCTAssertEqual</span>(headline, <span class="string">"This Is A Test Headline"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，我们希望有这样一个函数 <code>makeHeadline</code>，它接受一个 <strong>String</strong> 类型的参数，并返回转换成功的  <strong>String</strong> 类型的结果。然后利用 <code>XCTAssertEqual</code> 判断一下，当左右值相同时，它才会通过。</p>
<p>很显然，这个时候会保持，且测试不通过，因为我们的 <code>makeHeadline</code> 函数根本就不存在，现在就去实现它。</p>
<p>回到 <strong>ViewController.swift</strong> 中，添加如下方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeHeadline</span><span class="params">(string: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This Is A Test Headline"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Command + U</strong> 走一遍，恭喜你，测试走通了。全部显示绿色的 Build succeeded。（眼尖的朋友可能发现问题了，不过不急，至少目前为止，我们的测试用例已经通过了~）</p>
<p>然后接下去，做的就是重构了。虽然只写了几行代码，但是还是有优化空间的。</p>
<p>我们之前提到过，<strong>setUp</strong> 方法将在每个 <strong>test case</strong> 调用前都自动被调用，所以这里可以放一些初始化相关操作。我们这里初始化了一个 <strong>ViewController</strong> 类型的对象，不出意外的话，在每个测试用例中中需要初始化一个，这无疑是很麻烦的。所以我们可以把 <strong>viewController</strong> 提出来，当做 <strong>CapitalTest</strong> 类的一个属性，然后在 <strong>setUp</strong> 方法中去初始化它。具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CapitalTest</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> viewController: <span class="type">ViewController</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp()</span><br><span class="line">        </span><br><span class="line">        viewController = <span class="type">ViewController</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/////////</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下去，我们需要在编写另外一个测试用例，以保证第一个测试用例并不是偶然的。这也是我们在实际开发中需要做的，列举多个测试用例，来保证某个功能确实通过了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMakeHeadline_ReturnsStringWithEachWordStartCapital2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">"Here is another Example"</span></span><br><span class="line">    <span class="keyword">let</span> headline = viewController.makeHeadline(string)</span><br><span class="line">    </span><br><span class="line">    <span class="type">XCTAssertEqual</span>(headline, <span class="string">"Here Is Another Example"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次 <strong>Command + U</strong>，不出意外，第一个还是通过，第二个则显示失败。原因大家都懂~</p>
<p>接下去修改 <code>makeHeadline</code> 的具体实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeHeadline</span><span class="params">(string: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 通过“ ”分割字符串, 存入数组</span></span><br><span class="line">    <span class="keyword">let</span> words = string.componentsSeparatedByString(<span class="string">" "</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 遍历数组, 移除首字母, 并插入对应的大写字母</span></span><br><span class="line">    <span class="keyword">var</span> headline = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">var</span> word <span class="keyword">in</span> words &#123;</span><br><span class="line">        <span class="keyword">let</span> firstCharacter = word.removeAtIndex(word.startIndex)</span><br><span class="line">        headline += <span class="string">"<span class="subst">\(String(firstCharacter)</span>.uppercaseString)<span class="subst">\(word)</span> "</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 移除最后的“ ”</span></span><br><span class="line">    headline.removeAtIndex(headline.endIndex.predecessor())</span><br><span class="line">    <span class="keyword">return</span> headline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，注释也写的很清楚，这里就不累述了。再次 <strong>Command + U</strong>，bingo~ 通过了。</p>
<p>接下去再看看，是否有优化的空间。</p>
<ol>
<li>我们的测试用例描述的其实不太清楚，几个变量之间的关系比较凌乱。</li>
<li><strong>makeHeadline</strong> 函数的实现太 Objc 化了，没有用上 Swift 里的高级功能。</li>
</ol>
<p>OK，既然不好，那就优化一下呗~</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMakeHeadline_ReturnsStringWithEachWordStartCapital</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> inputString =       <span class="string">"this is A test headline"</span></span><br><span class="line">        <span class="keyword">let</span> expectedHeadline =  <span class="string">"This Is A Test Headline"</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> result = viewController.makeHeadline(inputString)</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(result, expectedHeadline)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeHeadline</span><span class="params">(string: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> words = string.componentsSeparatedByString(<span class="string">" "</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> headline = words.<span class="built_in">map</span> &#123; (<span class="keyword">var</span> word) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">let</span> firstCharacter = word.removeAtIndex(word.startIndex)</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"<span class="subst">\(String(firstCharacter)</span>.uppercaseString)<span class="subst">\(word)</span>"</span></span><br><span class="line">          &#125;.joinWithSeparator(<span class="string">" "</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> headline</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再次  <strong>Command + U</strong>，确保测试通过。至此，这个简单的例子算是介绍完了。</p>
<p>虽然例子简单，只实现了一个功能，但是 TDD 相关的东西，具体流程也都涉及了，剩下的，只是重复这些操作直至完成所有需求。</p>
<p>如果觉得这个例子太简单了，没学够，建议看下 <a href="https://www.packtpub.com/application-development/test-driven-ios-development-swift" target="_blank" rel="external">《Test-Driven iOS Development with Swift》</a>  一书中的 <a href="http://www.packtpub.com/code_download/23832" target="_blank" rel="external">ToDo 源码</a>，大篇幅介绍 TDD 的实际应用。</p>
<p>Have Fun~</p>
<h2 id="参考链接">参考链接</h2><p>由衷感谢以下作者的贡献，文中出现的一些理论阐述，有从相关文章中摘取。</p>
<p><a href="https://onevcat.com/2014/02/ios-test-with-kiwi/" target="_blank" rel="external">TDD的iOS开发初步以及Kiwi使用入门</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-tdd/index.html" target="_blank" rel="external">浅谈测试驱动开发（TDD）</a></p>
<p><a href="http://www.cnblogs.com/whitewolf/p/4205761.html" target="_blank" rel="external">TDD(测试驱动开发)培训录</a></p>
<p><a href="https://www.packtpub.com/application-development/test-driven-ios-development-swift" target="_blank" rel="external">《Test-Driven iOS Development with Swift》</a> </p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> TDD </tag>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为Hexo博客添加版权说明和打赏功能]]></title>
      <url>/2016/06/02/hexo-copyright-and-donate/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天为博客配置了自动添加版权说明和打赏功能，加深了对Hexo框架的理解，做个小小的总结。当然，如果喜欢也可以试试为自己的博客添加上。</p>
</blockquote>
<p>效果图：</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/tailResult.png" alt="tailResult"></p>
<a id="more"></a>
<h2 id="版权说明">版权说明</h2><p>具体实现步骤如下：</p>
<ol>
<li>在博客根目录下（和 source 同级），新建一个名为 <code>scripts</code> 的文件夹。</li>
<li>在 <code>scripts</code> 文件夹内, 新建一个 <code>AddTail.js</code> 脚本文件，脚本具体内容详见下文。</li>
<li><p>在博客根目录下，新建一个 <code>tail.md</code> 文件，里面写想要展示的版本说明内容。示例如下文所示。</p>
<p><code>AddTail.js</code> 脚本文件：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filename: AddTail.js</span></span><br><span class="line"><span class="comment">// Author: Colin</span></span><br><span class="line"><span class="comment">// Date: 2016/06/02</span></span><br><span class="line"><span class="comment">// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a tail to every post from tail.md</span></span><br><span class="line"><span class="comment">// Great for adding copyright info</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(<span class="string">'before_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(data.copyright == <span class="literal">false</span>) <span class="keyword">return</span> data;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Add seperate line</span></span><br><span class="line">	data.content += <span class="string">'\n___\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Try to read tail.md</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> file_content = fs.readFileSync(<span class="string">'tail.md'</span>);</span><br><span class="line">		<span class="keyword">if</span>(file_content &amp;&amp; data.content.length &gt; <span class="number">50</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			data.content += file_content;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) <span class="keyword">throw</span> err;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// No process for ENOENT error</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 添加具体文章链接, 不需要去掉即可</span></span><br><span class="line">	<span class="keyword">var</span> permalink = <span class="string">'\n本文链接：'</span> + data.permalink;</span><br><span class="line">	data.content += permalink;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>tail.md</code> 文件示例：</p>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
<p>如此，<code>hero clean</code> 后重新 <code>hexo generate</code> 即可。</p>
<h2 id="打赏功能">打赏功能</h2><p>打赏功能的实现其实是直接嵌入到博客主题中的，所以修改了原先 <code>clone</code> 下来的源码。当然，你可以发个 <code>PR</code> ，或者直接选择支持打赏功能的主题。我这里选择的 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a> 主题并不支持这个功能，所以只好自己实现一下。（虽然知道大概并没有什么用…）</p>
<h3 id="目标">目标</h3><p>既然是嵌入到博客主题中，那么当然希望是可定制的。例如主题本身给我们提供的配置一样。大致目标如下：</p>
<p>我们只需要在 <code>_config.yml</code> 中加入如下语句, 即可完成打赏的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#打赏</span><br><span class="line">donate:</span><br><span class="line">  enable: true</span><br><span class="line">  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</span><br><span class="line">  wechat: http://7xkc7a.com1.z0.glb.clouddn.com/wechatImage.png</span><br><span class="line">  alipay: http://7xkc7a.com1.z0.glb.clouddn.com/alipayImage.png</span><br></pre></td></tr></table></figure>
<ul>
<li><code>enable</code> 参数设置是否开启打赏功能。( <code>true</code> or <code>false</code> )</li>
<li><code>text</code> 参数配置需要显示的内容</li>
<li><code>wechat</code> 参数设置微信支付二维码 URL</li>
<li><code>alipay</code> 参数设置支付宝支付二维码 URL</li>
</ul>
<h3 id="实现步骤">实现步骤</h3><p>编辑主题内的 <code>article.ejs</code> 文件，比如我这里位于 <code>themes/yilia/layout/_partial/article.ejs</code> 。</p>
<p>在 <code>&lt;div class=&quot;article-content&quot;&gt;...&lt;/div&gt;</code> 的下面，<code>&lt;%- partial(&#39;footer&#39;) %&gt;</code> 的上面插入如下HTML代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.donate</span>) &#123; %&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- css --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="xml"></span><br><span class="line">      .center &#123;</span><br><span class="line">          text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">      .hidden &#123;</span><br><span class="line">          display: none;</span><br><span class="line">      &#125;</span><br><span class="line">    .donate_bar a.btn_donate&#123;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      width: 82px;</span><br><span class="line">      height: 82px;</span><br><span class="line">      background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;</span><br><span class="line">      _background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;</span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif</span><br><span class="line">           因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，</span><br><span class="line">         为了在让打赏按钮显示效果正常 而 添加了以下几行 css，</span><br><span class="line">         嵌入其它博客时不一定要它们。 --&gt;</span></span><br><span class="line">      -webkit-transition: background 0s;</span><br><span class="line">      -moz-transition: background 0s;</span><br><span class="line">      -o-transition: background 0s;</span><br><span class="line">      -ms-transition: background 0s;</span><br><span class="line">      transition: background 0s;</span><br><span class="line">      <span class="comment">&lt;!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 --&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .donate_bar a.btn_donate:hover&#123; background-position: 0px -82px;&#125;</span><br><span class="line">    .donate_bar .donate_txt &#123;</span><br><span class="line">      display: block;</span><br><span class="line">      color: #9d9d9d;</span><br><span class="line">      font: 14px/2 "Microsoft Yahei";</span><br><span class="line">    &#125;</span><br><span class="line">    .bold&#123; font-weight: bold; &#125;</span><br><span class="line">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /css --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Donate Module --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"donate_module"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- btn_donate &amp; tips --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"donate_board"</span> <span class="attr">class</span>=<span class="string">"donate_bar center"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      ------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"btn_donate"</span> <span class="attr">class</span>=<span class="string">"btn_donate"</span> <span class="attr">target</span>=<span class="string">"_self"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">title</span>=<span class="string">"Donate 打赏"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"donate_txt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.donate.text</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /btn_donate &amp; tips --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- donate guide --&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"donate_guide"</span> <span class="attr">class</span>=<span class="string">"donate_bar center hidden"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      ------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= theme.donate.wechat %&gt;"</span> <span class="attr">title</span>=<span class="string">"用微信扫一扫哦~"</span> <span class="attr">class</span>=<span class="string">"fancybox"</span> <span class="attr">rel</span>=<span class="string">"article0"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;%= theme.donate.wechat %&gt;"</span> <span class="attr">title</span>=<span class="string">"微信打赏 Colin"</span> <span class="attr">height</span>=<span class="string">"190px"</span> <span class="attr">width</span>=<span class="string">"auto"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        &amp;nbsp;&amp;nbsp;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= theme.donate.alipay %&gt;"</span> <span class="attr">title</span>=<span class="string">"用支付宝扫一扫即可~"</span> <span class="attr">class</span>=<span class="string">"fancybox"</span> <span class="attr">rel</span>=<span class="string">"article0"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;%= theme.donate.alipay %&gt;"</span> <span class="attr">title</span>=<span class="string">"支付宝打赏 Colin"</span> <span class="attr">height</span>=<span class="string">"190px"</span> <span class="attr">width</span>=<span class="string">"auto"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"donate_txt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.donate.text</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /donate guide --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- donate script --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'btn_donate'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      $(<span class="string">'#donate_board'</span>).addClass(<span class="string">'hidden'</span>);</span><br><span class="line">      $(<span class="string">'#donate_guide'</span>).removeClass(<span class="string">'hidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">donate_on_web</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(<span class="string">'#donate'</span>).submit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> original_window_onload = <span class="built_in">window</span>.onload;</span><br><span class="line">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (original_window_onload) &#123;</span><br><span class="line">                original_window_onload();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'donate_board_wdg'</span>).className = <span class="string">'hidden'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /donate script --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /Donate Module --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里通过判断是否显示打赏模块，执行相应的操作。点击打赏按钮，显示相应的二维码。</p>
<p>这里还有个问题，在文章列表中，有时候也会显示打赏功能，这显然不是我们想要的。需要做的就是判断当前的的页面是详情页面还是介绍页面，比如我这里，把上面的代码放在如下判断语句中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">post.excerpt</span> || !<span class="attr">index</span>)&#123; %&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- /上述代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125;%&gt;</span></span><br></pre></td></tr></table></figure>
<p>如此，一个简单的打赏功能就实现了。</p>
<p>当然，你如果觉得麻烦，但是又想实现打赏功能，那么可以尝试下 <a href="http://www.dashangcloud.com" target="_blank" rel="external">云打赏</a>，据说一行代码集成打赏功能。</p>
<p>Have fun ~     ：）</p>
<h2 id="参考链接">参考链接</h2><p><a href="https://tono.tk/2016/03/26/Add_copyright_for_hexo/" target="_blank" rel="external">￼为Hexo博客文章自动添加版权信息</a></p>
<p><a href="http://icehe.me/web/donate/" target="_blank" rel="external">实现网站的支付宝打赏功能</a></p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jazzhands, 交互动画就是这么简单]]></title>
      <url>/2016/03/16/Interactive-animation-is-so-simple/</url>
      <content type="html"><![CDATA[<blockquote>
<p> <a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">Jazz Hands</a>是IFTTT发布的一个基于关键帧的动画框架, 可以用于手势，滚动视图，KVO或者ReactiveCocoa, 十分方便。</p>
</blockquote>
<p>but, 到底有多方便呢 ?</p>
<p>看看官方给出的一个demo效果:</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/Jazzhandsjazzhands-demo.gif" alt="Jazzhandsjazzhands-demo"></p>
<a id="more"></a>
<p>如果 <code>设计</code> 要你做出这样一个效果的引导页, 有没有觉得头大 ?</p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/54/original/8.png" alt="emoji"></p>
<p>然而, 在 <code>Jazzhands</code> 里, 我们需要做的, 就是规划好各个组件需要展示的时机以及对应的位置。中间的衔接动画, 完全交给 <code>Jazzhands</code> 去处理。 这样的感觉很爽有没有~ </p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/789/original/%E9%87%91%E5%A4%A7%E7%88%B79.jpg" alt=""></p>
<p>然而, <code>Jazzhands</code> 具体为我们做了什么, 它是怎么做的 ?  它适用于哪些场景 ? 下文我们一一分析~</p>
<h2 id="Jazzhands原理分析">Jazzhands原理分析</h2><p>先看一下源工程目录: </p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/Jazzhands4F254DBC-408A-4073-A73C-8CBABBC6D580.png" alt=""></p>
<p>这一大串看下来, 貌似很复杂, 实则不然。</p>
<p>我们可以简单的归为 三大类 文件来看。</p>
<ol>
<li><code>IFTTTAnimation, IFTTTAnimatable, IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …</code>  之类的动画类型。</li>
<li><code>IFTTTAnimator</code> 动画执行者</li>
<li><code>IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController</code> 封装好的控制器类型。</li>
</ol>
<h3 id="动画类型">动画类型</h3><p>动画类型, 我们拿最简单的  <code>alpha</code> 变化动画来分析。 </p>
<p><code>IFTTTAlphaAnimation.m</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  IFTTTAlphaAnimation.m</span></span><br><span class="line"><span class="comment">//  JazzHands</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Devin Foley on 9/27/13.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2013 IFTTT Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"IFTTTAlphaAnimation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IFTTTAlphaAnimation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addKeyframeForTime:(<span class="built_in">CGFloat</span>)time alpha:(<span class="built_in">CGFloat</span>)alpha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validAlpha:alpha]) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> addKeyframeForTime:time value:@(alpha)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addKeyframeForTime:(<span class="built_in">CGFloat</span>)time alpha:(<span class="built_in">CGFloat</span>)alpha withEasingFunction:(IFTTTEasingFunction)easingFunction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validAlpha:alpha]) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> addKeyframeForTime:time value:@(alpha) withEasingFunction:easingFunction];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)validAlpha:(<span class="built_in">CGFloat</span>)alpha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>((alpha &gt;= <span class="number">0.</span>f) &amp;&amp; (alpha &lt;= <span class="number">1.</span>f), <span class="string">@"Alpha values must be between zero and one."</span>);</span><br><span class="line">    <span class="keyword">if</span> ((alpha &lt; <span class="number">0.</span>f) || (alpha &gt; <span class="number">1.</span>f)) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animate:(<span class="built_in">CGFloat</span>)time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.hasKeyframes) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">self</span>.view.alpha = (<span class="built_in">CGFloat</span>)[(<span class="built_in">NSNumber</span> *)[<span class="keyword">self</span> valueAtTime:time] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>IFTTTAlphaAnimation</code> 基础自基类 <code>IFTTTAnimation</code> , 重写了对应的 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addKeyframeForTime:(<span class="built_in">CGFloat</span>)time value:(<span class="keyword">id</span>&lt;IFTTTInterpolatable&gt;)value;</span><br><span class="line">- (<span class="keyword">void</span>)addKeyframeForTime:(<span class="built_in">CGFloat</span>)time value:(<span class="keyword">id</span>&lt;IFTTTInterpolatable&gt;)value withEasingFunction:(IFTTTEasingFunction)easingFunction;</span><br><span class="line">- (<span class="keyword">id</span>&lt;IFTTTInterpolatable&gt;)valueAtTime:(<span class="built_in">CGFloat</span>)time;</span><br></pre></td></tr></table></figure>
<p>这里所有的动画, 强调一个 <code>time - value</code> 键值对。 这也是关键帧动画的重点。</p>
<p>我们需要做的, 就是维护这样一个 <code>keyframes (NSMutableArray)</code> , 里面的元素代表一个个存储了位置的时刻。</p>
<p>以 <code>alpha</code> 动画为例, 这里的 <code>time</code> 就是对应的关键帧, <code>value</code> 就是对应的alpha值。</p>
<p>比如: </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   IFTTTAlphaAnimation *alphaAnimation = [IFTTTAlphaAnimation animationWithView:aView];</span><br><span class="line">   [alphaAnimation addKeyframeForTime:<span class="number">100</span> alpha:<span class="number">0.5</span>];</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>这里表示了在 100 帧处, 他对应的 alpha 值是 0.5。</p>
<p>所以, 对于动画的设定, 我们需要做的就是:</p>
<ol>
<li>选择动画类型。 <code>IFTTTBackgroundColorAnimation, IFTTTAlphaAnimation …</code></li>
<li>添加关键帧。 <code>[alphaAnimation addKeyframeForTime:100 alpha:0.5];</code></li>
<li>把动画添加到执行者上面。 <code>[self.animator addAnimation:alphaAnimation];  (这个后面再介绍, 放心, so eazy~)</code></li>
<li>抱歉, 没有了~</li>
</ol>
<p>没错, 就是这么简单。 但是这里有个疑惑, 所谓的关键帧动画, 就是我们提供足够多的关键帧, 然后去逐帧执行。 这是否意味着, 我们需要提供足够多的帧数, 来保证动画的流畅性 ?</p>
<p>如果是这样, 那我们写出来的代码岂不是:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    [alphaAnimation addKeyframeForTime:<span class="number">1</span> alpha:<span class="number">0.1</span>];</span><br><span class="line">    [alphaAnimation addKeyframeForTime:<span class="number">2</span> alpha:<span class="number">0.15</span>];</span><br><span class="line">    [alphaAnimation addKeyframeForTime:<span class="number">3</span> alpha:<span class="number">0.2</span>];</span><br><span class="line">    [alphaAnimation addKeyframeForTime:<span class="number">4</span> alpha:<span class="number">0.25</span>];</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/599/original/%E6%82%B2%E5%82%AC8.png" alt="EMOJI"></p>
<p><strong>NO, NO, NO</strong>, 前面我们已经说过了, 这很简单~ 简单意味着, 你只需要提供几个关键点的位置 (起始点, 转折点, 终点), 再设置下它们之间的过渡类型 (Linear, EaseInQuad, EaseInOutQuad…) ，然后, 动画就做完了~ 至于中间各个关键帧的值, 是怎么确定的呢 ？ 放心, <code>Jazzhands</code> 已经帮我们做好咯~</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>&lt;IFTTTInterpolatable&gt;)valueAtTime:(<span class="built_in">CGFloat</span>)time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.isEmpty, <span class="string">@"At least one KeyFrame must be set before animation begins."</span>);</span><br><span class="line">    <span class="keyword">id</span> value;</span><br><span class="line">    <span class="built_in">NSUInteger</span> indexAfter = [<span class="keyword">self</span> indexOfKeyframeAfterTime:time];</span><br><span class="line">    <span class="keyword">if</span> (indexAfter == <span class="number">0</span>) &#123;</span><br><span class="line">        value = ((IFTTTKeyframe *)<span class="keyword">self</span>.keyframes[<span class="number">0</span>]).value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexAfter &lt; <span class="keyword">self</span>.keyframes.count) &#123;</span><br><span class="line">        IFTTTKeyframe *keyframeBefore = (IFTTTKeyframe *)<span class="keyword">self</span>.keyframes[indexAfter - <span class="number">1</span>];</span><br><span class="line">        IFTTTKeyframe *keyframeAfter = (IFTTTKeyframe *)<span class="keyword">self</span>.keyframes[indexAfter];</span><br><span class="line">        <span class="built_in">CGFloat</span> progress = [<span class="keyword">self</span> progressFromTime:keyframeBefore.time toTime:keyframeAfter.time atTime:time withEasingFunction:keyframeBefore.easingFunction];</span><br><span class="line">        value = [keyframeBefore.value interpolateTo:keyframeAfter.value withProgress:progress];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = ((IFTTTKeyframe *)<span class="keyword">self</span>.keyframes.lastObject).value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动画执行者">动画执行者</h3><p>动画执行者, 看着就很牛x, 然而它的实现实际上非常简单， 就几行代码。 它负责 <code>管理动画对象</code> 和 <code>在对应位置执行动画</code> 。</p>
<p>简单来说, 就这两个方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addAnimation:(<span class="keyword">id</span>&lt;IFTTTAnimatable&gt;)animation</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.animations addObject:animation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animate:(<span class="built_in">CGFloat</span>)time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;IFTTTAnimatable&gt; animation <span class="keyword">in</span> <span class="keyword">self</span>.animations) &#123;</span><br><span class="line">        [animation animate:time];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简洁有没有。</p>
<p>上文提到了 把动画添加到执行者上面。 <code>[self.animator addAnimation:alphaAnimation];</code></p>
<p>这也就是 <code>IFTTTAnimator</code> 的第一个作用, 管理动画对象。animations(NSMutableArray) 里面存储着所有设定的动画。</p>
<p>然后 <code>[self.animator animate:0];</code> 就是执行对应的动画了。 这个方法就是在交互的时候, 调用。比如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动视图</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> scrollViewDidScroll:scrollView];</span><br><span class="line">  [<span class="keyword">self</span>.animator animate:scrollView.contentOffset.x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手势</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)handlePan:(<span class="built_in">UIPanGestureRecognizer</span> *)recognizer</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.animator animate:[recognizer locationOfTouch:<span class="number">0</span> inView:<span class="keyword">self</span>.view].x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制器类型">控制器类型</h3><p><code>Jazzhands</code> 帮我们封装好了两种控制器类型 (IFTTTAnimatedPagingScrollViewController, IFTTTAnimatedScrollViewController)。 我们可以直接基于此, 做相应的动画。 这是十分方便的。比如官方的demo就是基于 <code>IFTTTAnimatedPagingScrollViewController</code> 来实现的。</p>
<p>它实现了 <code>scrollViewDidScroll</code> 等方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> updatePageOffset];</span><br><span class="line">    [<span class="keyword">self</span> animateCurrentFrame];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 并且把 <code>time</code> 关键帧的概念, 进一步转化为 <code>page</code> 的概念。 也就是说, 你只要指定某个动画, 它在第几个page, 第几个page存在, 各自存在什么位置即可。十分方便~</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)keepView:(<span class="built_in">UIView</span> *)view onPage:(<span class="built_in">CGFloat</span>)page withAttribute:(IFTTTHorizontalPositionAttribute)attribute</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> keepView:view onPage:page withAttribute:attribute offset:<span class="number">0.</span>f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用场景_(Demo)">使用场景 (Demo)</h2><p>说了这么多, 想必大家对 <code>Jazzhands</code> 的实现原理都有一定了解。 那什么时候该用到它呢 ?</p>
<p>我觉得 <code>引导页</code> 是不二选择 ~ 毕竟类似的视差动画, 在引导页的应用是最广的。</p>
<p>至于是否需要基于封装好的控制器来实现, 这就要根据具体的需求来定了。</p>
<p>比如官方Demo这样, 所有动画, 在相同的关键帧位置, 有重叠部分。(两个page 可以同时存在), 那基于 <code>IFTTTAnimatedPagingScrollViewController</code> 再合适不过了。</p>
<p>不过如果动画有阻尼效果, 也就是当前界面只能存在一个page, 那就建议直接用 <code>UIViewController</code> 撸, 然后借助 <code>手势</code> , 来实现对应的效果。</p>
<p>比如可以仿照下美图秀秀的引导页, 写个简单demo, 效果如下:</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/JazzhandsunityResult2.gif" alt="MTXX_DEMO"></p>
<p>具体 源码 就不上传了。 相信大家利用 Jazzhands 不难做出类似的效果。(有需要的可以私下交流~)</p>
<h2 id="总结">总结</h2><p>总体来说, 这个开源库还是非常精简，而且思路非常清晰，依然基于Core Animation之上，因为它只是针对于UIKit上去做帧的配置，对帧的封装上更加灵活，但是缺点是实现复杂的动画时，代码量比较大。另外布局约束呢, 都得手撸,,</p>
<p>还是很赞的~ </p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/801/original/%E9%87%91%E5%A4%A7%E7%88%B721.jpg" alt=""></p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Photo Editing Extension 详解 (附带应用滤镜Demo)]]></title>
      <url>/2016/03/12/Photo-Editing-Extension/</url>
      <content type="html"><![CDATA[<blockquote>
<p>extension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。允许应用帮助系统扩展自定义功能，去实现一个特定作用域的任务，如照片编辑、自定义键盘、通知中心、Action动作、Share分享等。 这对于一向封闭的iOS来说, 无疑是一大福音。</p>
</blockquote>
<a id="more"></a>
<p>虽然iOS8离现在比较远了, 分享 <strong>“Extension “</strong> 相关的文章也很多了, 不过对于<strong>“Photo Editing”</strong>, 我觉得还是有必要来讲一讲的, 一来多数教程介绍Extension 的时候都是拿<strong>Widgets</strong>举例, 再有<strong>Photo Editing</strong>是可自定义内容最丰富的一个, 你完全可以把它当作App里额外的一个界面来完成。</p>
<p>正好前一阵在实习的时候, 实现过相关功能, 总结一番也是极好。</p>
<h1 id="1-_相关概念">1. 相关概念</h1><h2 id="1-1_Extension_Point">1.1 Extension Point</h2><p>系统中支持Extension 的区域，Extension 的类别也是据此区分的，iOS上共有Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard几种，其中Today中的extension又被称为Widget。</p>
<ul>
<li><strong>今日(Today，又称为Widget)</strong>：可以快速获取更新或者在通知中心的今日视图中执行一项快速任务。</li>
<li><strong>共享(Share)</strong>：发布到一个共享网站或者与其它应用程序共享内容。</li>
<li><strong>动作(Action)</strong>：在另一个应用程序的上下文中操作或查看内容。</li>
<li><strong>照片编辑(Photo Editing)</strong>（仅限于iOS）：在照片应用程序中编辑照片或视频。</li>
<li><strong>查找器</strong>（仅限于iOS）：在查找器中直接显示文件同步的状态信息。</li>
<li><strong>文档提供程序(Storage Provider)</strong>（仅限于iOS）：提供对文件库的访问和管理。</li>
<li><strong>自定义键盘(Custom keyboard)</strong>（仅限于iOS）：用自定义键盘替代iOS系统键盘，并用于所有的应用程序中。</li>
</ul>
<p>由于每个扩展点都有与之相关的使用策略和专门的API，开发人员必须为他们想要提供的那种功能选择恰当的扩展点, 每种Extension Point的使用方式和适合干的活都不一样，因此不存在通用的Extension 。</p>
<p>例如，在默认情况下，键盘Extension“<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/Keyboard.html" target="_blank" rel="external">不能访问网络，而且不能与其包含应用程序共享同一容器</a>”。通过对Extension进行恰当的配置，这样的限制可以移除，但开发人员仍然需要遵守苹果应用商店审查指南和iOS开发者计划许可协议中的具体的网络键盘指南。</p>
<p><img src="http://img.my.csdn.net/uploads/201512/13/1449993990_7598.png" alt="Extension Point"></p>
<h2 id="1-2_App_Extension">1.2 App Extension</h2><p>即为本文所说的Extension。Extension并不是一个独立的app，它有一个包含在App Bundle中的独立Bundle，Extension的Bundle后缀名是.appex。其生命周期也和普通App不同，这些后文将会详述。</p>
<p>Extension不能单独存在，必须有一个包含它的Containing App。</p>
<p>另外，Extension需要用户手动激活，不同的Extension激活方式也不同。</p>
<p>比如：</p>
<ul>
<li>Today中的widget需要在Today中激活和关闭；</li>
<li>Custom keyboard需要在设置中进行相关设置；</li>
<li>Photo Editing需要在使用照片时在照片管理器中激活或关闭；</li>
<li>Storage Provider可以在选择文件时出现；</li>
<li>Share和Action可以在任何应用里被激活，但前提是开发者需要设置Activation Rules，以确定extension需要在合适出现。</li>
</ul>
<h2 id="1-3_Containing_App">1.3 Containing App</h2><p>尽管苹果开放了Extension，但是在iOS中Extension并不能单独存在，要想提交到AppStore，必须将Extension包含在一个app中提交，并且App的实现部分不能为空, 这个包含Extension的App就叫Containing App。</p>
<p>Extension会随着Containing App的安装而安装，同时随着Containing App的卸载而卸载。</p>
<h2 id="1-4_Host_App">1.4 Host App</h2><p>能够调起Extension的App被称为Host App。</p>
<p>比如:</p>
<ul>
<li>widget的Host App就是Today。</li>
<li>Photo Editing 的 Host App 就是 Photos</li>
</ul>
<h1 id="2-_Extension和Containing_App、Host_App通信">2. Extension和Containing App、Host App通信</h1><h2 id="2-1_Extension和Host_App">2.1 Extension和Host App</h2><p>Extension和Host App之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span>(<span class="title">NSExtensionAdditions</span>) &lt;<span class="title">NSExtensionRequestHandling</span>&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request. </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,retain) <span class="built_in">NSExtensionContext</span> *extensionContext <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0); </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实际上extension和Host App之间是通过IPC（interprocess communication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。</p>
<h2 id="2-2_Containing_App和Host_App">2.2 Containing App和Host App</h2><p>他们之间没有任何直接关系，也从来不需要通信。</p>
<h2 id="2-3_Extension和Containing_App">2.3 Extension和Containing App</h2><p>这二者之间的关系最复杂，纠纠缠缠扯不清关系。</p>
<p>众所周知，<a href="https://developer.apple.com/library/ios/documentation/iphone/conceptual/iphoneosprogrammingguide/TheiOSEnvironment/TheiOSEnvironment.html" target="_blank" rel="external">每个iOS应用程序都有自己的沙箱</a>。<a href="https://developer.apple.com/library/mac/documentation/security/conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html" target="_blank" rel="external">通过Mac苹果应用商店分发的OS X应用程序</a>也有类似的要求，不过许多OS X应用程序是在Mac苹果应用商店之外分发的，并不需要遵守这一沙箱要求。</p>
<p>沙箱是苹果iOS安全策略的基石之一。沙箱是为了限制应用程序对文件、首选项、网络资源、硬件等的访问，具体来讲，其目的是为了限制受损的应用程序可能对系统造成的损害。</p>
<p>考虑到并不是所有可以用在应用程序中的API都可以用在Extension中，所以与通常的应用程序相比，App Extension运行在有更多限制的沙箱中。不能在Extension中使用的API标记为不可用宏，如NS_EXTENSIONS_UNAVAILABLE，它会在链接时导致失败。</p>
<p>此外，对于Extension与其它应用程序之间的通信，苹果有几项强制规定：</p>
<ol>
<li>调用Extension的应用程序即主应用程序不能启动Extension；只有系统可以启动Extension。</li>
<li>当Extension启动后，主应用程序就和它直接通信。</li>
<li>主应用程序永远不和包含应用程序直接通信。</li>
<li>Extension不是一个应用程序，但它由系统生成，并有它自己单独的进程。</li>
<li>为了在包含应用程序和它的Extension之间共享数据，包含应用程序及其Extension都必须是应用程序组的一部分。对于应用程序组的其中两个成员，部分数据可以在两者沙箱之外的第三个容器中共享。</li>
</ol>
<p>正如Ars Technica的Andrew Cunningham总结的那样，这些规则的最终结果主要是一个应用程序不能进入另一个应用程序的沙箱。这与Android相反，在Android上，<a href="http://developer.android.com/guide/topics/providers/content-providers.html" target="_blank" rel="external">内容提供程序</a>和<a href="http://developer.android.com/reference/android/content/ContentResolver.html" target="_blank" rel="external">解析程序</a>仍然可以一起工作来为应用程序提供对其它应用程序中数据的访问。</p>
<p><strong>不能直接通信:</strong></p>
<p>首先，尽管Extension的bundle是放在Containing App的bundle中，但是他们是两个完全独立的进程，之间不能直接通信。不过Extension可以通过openURL的方式启动Containing App（当然也能启动其它App），不过必须通过extensionContext借助host app来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过openURL的方式启动Containing APP </span></span><br><span class="line">- (<span class="keyword">void</span>)openURLContainingAPP </span><br><span class="line">&#123; </span><br><span class="line">    [<span class="keyword">self</span>.extensionContext openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"appextension://123"</span>] </span><br><span class="line">                 completionHandler:^(<span class="built_in">BOOL</span> success) &#123; </span><br><span class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"open url result:%d"</span>,success); </span><br><span class="line">                 &#125;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Extension中是无法直接使用openURL的。</strong></p>
<p><strong>可以共享Shared Resources:</strong></p>
<p>Extension和Containing App可以共同读写一个被称为Shared Resources的存储区域，这是通过App Groups实现的，后文将会详述。</p>
<p>三者间的关系可以通过官网给的两张图片形象地说明：</p>
<p> <img src="http://img.my.csdn.net/uploads/201512/13/1449995608_4851.png" alt="Extension_Containing_App_1"></p>
<p><img src="http://img.my.csdn.net/uploads/201512/13/1449995608_8648.png" alt="Extension_Containing_App_2"></p>
<h1 id="3-_数据共享">3. 数据共享</h1><p><strong>App Groups</strong>这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一Group下的App共享同一份读写空间，以实现数据共享。</p>
<h2 id="3-1_功能开启">3.1 功能开启</h2><p>为了便于后续操作，请先确保你的开发者账号在Xcode上处于登录状态。</p>
<h3 id="3-1-1_在App中开启">3.1.1 在App中开启</h3><p>App Groups位于：</p>
<p>TARGETS—&gt;AppExtensionDemo—&gt;Capabilities—&gt;App Groups`</p>
<p>找到以后，将App Groups右上角的开关打开，然后选择添加Groups，正规的命名规则应该是：group.com.company.app。</p>
<p>添加成功以后如下图所示：</p>
<p><img src="http://img.my.csdn.net/uploads/201512/13/1449996631_7873.jpeg" alt="App_Groups"></p>
<h3 id="3-1-2_在Extension中开启">3.1.2 在Extension中开启</h3><p>开启方式和App中一样，需要注意的是必须保证这里地App Groups名称和App中的相同。</p>
<h2 id="3-2_extension和containing_app数据共享">3.2 extension和containing app数据共享</h2><p>App Groups给我们提供了同一Group内App可以共同读写的区域，可以通过以下方式实现数据共享：</p>
<h3 id="3-2-1_通过NSUserDefaults共享数据">3.2.1 通过NSUserDefaults共享数据</h3><p><strong>存数据</strong></p>
<p>通过以下方式向NSUserDefaults中保存数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saveTextBy<span class="built_in">NSUserDefaults</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUserDefaults</span> *shared = [[<span class="built_in">NSUserDefaults</span> alloc] initWithSuiteName:<span class="string">@"group.com.xx.test"</span>];</span><br><span class="line">    [shared setObject:_textField.text forKey:<span class="string">@"test"</span>];</span><br><span class="line">    [shared synchronize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ol>
<li>保存数据的时候必须指明group id；</li>
<li>而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PropertyLists/AboutPropertyLists/AboutPropertyLists.html" target="_blank" rel="external">Property List Programming Guide</a>。</li>
<li>为了防止出现数据同步问题，不要忘记调用<code>[shared synchronize];</code></li>
</ol>
<p><strong>读数据</strong></p>
<p>对应的读取数据方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)readDataFrom<span class="built_in">NSUserDefaults</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUserDefaults</span> *shared = [[<span class="built_in">NSUserDefaults</span> alloc] initWithSuiteName:<span class="string">@"group.com.xx.test"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *value = [shared valueForKey:<span class="string">@"test"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1_通过NSFileManager共享数据">3.2.1 通过NSFileManager共享数据</h3><p>NSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。</p>
<p><strong>存数据</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)saveTextBy<span class="built_in">NSFileManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="string">@"group.com.xx.test"</span>];</span><br><span class="line">    containerURL = [containerURL URLByAppendingPathComponent:<span class="string">@"Library/Caches/good"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *value = _textField.text;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [value writeToURL:containerURL atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;err];</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"save value:%@ success."</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读数据</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)readTextBy<span class="built_in">NSFileManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="string">@"group.com.xx.test"</span>];</span><br><span class="line">    containerURL = [containerURL URLByAppendingPathComponent:<span class="string">@"Library/Caches/good"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *value = [<span class="built_in">NSString</span> stringWithContentsOfURL:containerURL encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;err];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:</p>
<p>两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步。</p>
<h2 id="3-3_动态加载,_资源共享">3.3 动态加载, 资源共享</h2><p>这个感兴趣的可以看下, 无关紧要~</p>
<p>和数据共享类似，Extension和Containing App很自然地会有一些业务逻辑上可以共用的代码，这时可以通过iOS8中刚开放使用的framework实现。苹果在<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1" target="_blank" rel="external">App Extension Programming Guide</a>中是这样描述的：</p>
<blockquote>
<p>In iOS 8.0 and later, you can use an embedded framework to share code between your extension and its containing app. For example, if you develop image-processing code that you want both your Photo Editing extension and its containing app to share, you can put the code into a framework and embed it in both targets.</p>
</blockquote>
<p>即将framework分别嵌入到extension和containing app的target中实现代码共享。但这样岂不是需要分别要将framework分别copy到extension和containing app的main bundle中？</p>
<p>参考extension和containing app数据共享，我试想能不能将framework只保存一份放在App Groups区域？</p>
<h3 id="3-3-1_copy_framework到App_Groups">3.3.1 copy framework到App Groups</h3><p>在app首次启动的时候将framework放到App Groups区域：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)copyFrameworkFromMainBundleToAppGroup</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *manager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="string">@"group.com.xx.test"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *sorPath = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/Dylib.framework"</span>,[[<span class="built_in">NSBundle</span> mainBundle] bundlePath]];</span><br><span class="line">    <span class="built_in">NSString</span> *desPath = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/Library/Caches/Dylib.framework"</span>,containerURL.path];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> removeResult = [manager removeItemAtPath:desPath error:&amp;err];</span><br><span class="line">    <span class="keyword">if</span> (!removeResult) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"remove success."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> copyResult = [[<span class="built_in">NSFileManager</span> defaultManager] copyItemAtPath:sorPath toPath:desPath error:&amp;err];</span><br><span class="line">    <span class="keyword">if</span> (!copyResult) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"copy success."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copyResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2_使用framework">3.3.2 使用framework</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)loadFrameworkInAppGroup</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="string">@"group.com.xx.test"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *desPath = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/Library/Caches/Dylib.framework"</span>,containerURL.path];</span><br><span class="line">    <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:desPath];</span><br><span class="line">    <span class="built_in">BOOL</span> result = [bundle loadAndReturnError:&amp;err];</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        Class root = <span class="built_in">NSClassFromString</span>(<span class="string">@"Person"</span>);</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            Person *person = [[root alloc] init];</span><br><span class="line">            <span class="keyword">if</span> (person) &#123;</span><br><span class="line">                [person run];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试，竟然能够加载成功。</p>
<p>对比一下, 有如下总结: </p>
<p>主要验证了两种方式:</p>
<ol>
<li>导入公用framework到项目中, 只有<strong>containing app</strong> 的 <strong>Link Binary With Libraries</strong>添加对应framework, extension运行时动态加载framework。</li>
<li><strong>containing app</strong> 和 <strong>extension</strong>的<strong>Link Binary With Libraries</strong>分别链接公用framework, (Compile Sources 只包含在framework这个target中)</li>
</ol>
<p>以上两种方式都可以做到公用资源。 区别如下:</p>
<ol>
<li><p>方式一需要App Groups, 共享资源。 方式二不需要。</p>
</li>
<li><p>方式一需要<strong>containing app</strong>先启动把, 把数据copy到App Groups中, <strong>entension</strong>才能加载到。 方式二不需要。</p>
</li>
<li><p>方式一不能直接初始化类, 比如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;TestFrameWork/FilterImage.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FilterImage *filter = [[FilterImage alloc] init];</span><br><span class="line"></span><br><span class="line">将会报错:</span><br><span class="line"></span><br><span class="line">Undefined symbols <span class="keyword">for</span> architecture x86_64:</span><br><span class="line">  <span class="string">"_OBJC_CLASS_$_FilterImage"</span>, referenced from:</span><br><span class="line">      objc-class-ref <span class="keyword">in</span> PhotoEditingViewController.o</span><br><span class="line">ld: symbol(s) not found <span class="keyword">for</span> architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code <span class="number">1</span> (use -v to see invocation)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   需要用这样的方式:</p>
   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class root = <span class="built_in">NSClassFromString</span>(<span class="string">@"FilterImage"</span>);</span><br><span class="line"><span class="keyword">if</span> (root) &#123;</span><br><span class="line">    FilterImage *filter = [[root alloc] init];</span><br><span class="line">    <span class="built_in">NSString</span> *nameLUT = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/TestFrameWork.bundle/images/filter_lut_%d"</span>, desPath, <span class="number">2</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">self</span>.imageView.image = [filter filterImage:<span class="keyword">self</span>.input.displaySizeImage imageName:nameLUT];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   方式二可以直接使用。 (#import “FilterImage.h”)</p>
<p>   ​</p>
<p>   对比了一下导出包的大小。</p>
<p>   写了3个Demo, </p>
<ol>
<li>方式一, 动态加载          12.1M</li>
<li>方式二，静态链接         23.7M</li>
<li>方式三，只包含framework，没有extension   11.2M</li>
</ol>
<h1 id="4-_生命周期">4. 生命周期</h1><p>下图来自官方文档，它详细描述了Extension App的生命周期 <img src="http://img.my.csdn.net/uploads/201512/13/1449996016_4664.png" alt="Life_Cycle"></p>
<p><strong>开始</strong></p>
<p>在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。</p>
<p><strong>执行任务</strong></p>
<p>在extension启动以后，开始执行它的使命。</p>
<p><strong>终止</strong></p>
<p>在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。</p>
<p>由此可见，extension就是为了任务而生！</p>
<h1 id="5-_Photo_Editing使用滤镜实战">5. Photo Editing使用滤镜实战</h1><p>这里因为时间关系, 就直接采用 <strong>Apple</strong> 官方例子, 不再重新写了。如果实践过程中, 有遇到任何问题, 欢迎留言或者其他方式与我交流~</p>
<p>Demo下载地址: <img src="http://download.csdn.net/images/minetype/zip.gif" alt="">Photo Editing Extension Demo  </p>
<p>这里有几点需要注意的。</p>
<ol>
<li><p>因为Host App是Photos, 所以我们的Extension必须适配横竖屏, 因为它的状态是跟着Host App变的, 而不是Containing App。 至于横竖屏的适配, 建议采用Size Class, 然后监听缩放模式, 来适配屏幕</p>
<p>​</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UIContentContainer</span></span><br><span class="line">- (<span class="keyword">void</span>)willTransitionToTraitCollection:(<span class="built_in">UITraitCollection</span> *)newCollection</span><br><span class="line">              withTransitionCoordinator:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> willTransitionToTraitCollection:newCollection</span><br><span class="line">                 withTransitionCoordinator:coordinator];</span><br><span class="line">    [coordinator animateAlongsideTransition:^(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context) &#123;</span><br><span class="line">       <span class="comment">// 横屏处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 竖屏处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span>.view setNeedsLayout];</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   同样, 需要获取初始状态来处理。</p>
<p>   ​</p>
   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.traitCollection.verticalSizeClass == <span class="built_in">UIUserInterfaceSizeClassCompact</span>) &#123;</span><br><span class="line">    <span class="comment">//To Do: modify something for compact vertical size</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//To Do: modify something for other vertical size</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果第三方库用Pod来管理的话, 需要修改pod的target, 以及添加链接。</p>
<p><code>Build Settings — &gt; Other Linker Flags    **-l&quot;Pods-MBProgressHUD&quot;**</code></p>
</li>
</ol>
<h1 id="6-_相关资料">6. 相关资料</h1><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1" target="_blank" rel="external">App Extension Programming Guide</a></p>
<p><a href="http://www.infoq.com/news/2014/07/apple-ios8-app-extensions" target="_blank" rel="external">App Extensions for iOS 8 in Depth</a></p>
<p><a href="http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/" target="_blank" rel="external">WWDC2014之App Extensions学习笔记</a></p>
<p><a href="https://developer.apple.com/library/ios/samplecode/SamplePhotoEditingExtension/Introduction/Intro.html#//apple_ref/doc/uid/TP40014576" target="_blank" rel="external">Sample Photo Editing Extension</a></p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS启动页多语言]]></title>
      <url>/2016/03/12/iOS-welcome-page-multilingual/</url>
      <content type="html"><![CDATA[<blockquote>
<p> 启动页适配多语言, 想必很多 App 都有类似的需求。但是之前尝试过程中, 发现  “多语言” 的那几种实现方式, 在欢迎页上都不适应, 直到遇到了 <code>UILaunchImages</code> ~ 下文将详细描述如何实现启动页多语言。</p>
</blockquote>
<a id="more"></a>
<h2 id="传统多语言设置">传统多语言设置</h2><p>说起多语言, 我们无非这样实现:</p>
<ol>
<li><p>为 App 添加多语言支持。<img src="http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImagesLaunchImages_0.png" alt="LaunchImages_0"></p>
</li>
<li><p>添加对应的配置, 资源。 比如：</p>
<p>文本: <img src="http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImagesLaunchImages_1.png" alt="LaunchImages_1"></p>
<p>图片:<img src="http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImagesLaunchImages_2.png" alt="LaunchImages_2"></p>
</li>
<li><p>使用对应资源, 比如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.text = <span class="built_in">NSLocalizedString</span>(<span class="string">@"多语言"</span>, <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>再麻烦一点, 就是xib, storyboard的多语言的。 但是原理一样, 这样的方式都能实现多语言支持。So, 就是这么简单~</p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/181/original/%E5%BC%80%E5%BF%8309.png" alt="emoji"></p>
<p> 然而, 启动页貌似不吃这套 ,,,</p>
<h2 id="启动页设置">启动页设置</h2><p>先说说我们如何设置启动页吧。</p>
<p><code>Assets.xcassets</code> 这玩意引入之前, 我们是对启动页图片按规范命名, 比如 Default, -568h, @2x, @3x 之类的, 让系统帮助我们自动判断对应的启动页图片。</p>
<p><code>Assets.xcassets</code> 之后, 我们都了一种选择, 可以直接拖拽图片到 <code>LaunchImage</code> 中, 并且图片命名也没那么多要求。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/262538-a84f9bece1aa8b37.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg" alt="LaunchImage_3"></p>
<p>再之后, 多了 <code>LaunchScreen.storyboard</code> , 意味着我们有了更多的选择, 可以做更多的事情, 把它当做一个xib, 拖拽相关控件上去就好~</p>
<p>方式很多, 是否意味着实现多语言的办法也很多 ?</p>
<p>然而并不是,, <img src="http://wanzao2.b0.upaiyun.com/system/pictures/283/original/%E7%94%9F%E6%B0%9411.png" alt="emoji"></p>
<p>不论是对<code>图片</code> 进行多语言, 还是 <code>LaunchScreen.storyboard</code> 多语言, 发现启动页始终没有跟着系统语言变, 血崩..</p>
<p>当然, 办法并不是没有, 只是没找到对的而已~ 下面介绍如何通过<code>UILaunchImages</code> 实现启动页多语言。</p>
<blockquote>
<p>PS: 感觉 LaunchScreen.storyboard 是能做到多语言支持的, 难道是我实现过程中有问题 ? </p>
</blockquote>
<h2 id="UILaunchImages">UILaunchImages</h2><p>先看一下官方文档:</p>
<blockquote>
<p>UILaunchImages (Array - iOS) Explicitly specifies the launch images to use for the app. This key contains an array of dictionaries. Each dictionary contains detailed information about a single launch image and how it is used. Xcode fills in the value of each dictionary based on information you provide in your project settings.</p>
</blockquote>
<p>显然, 我们可以通过设置 <code>UILaunchImages</code> 来配置启动图片。</p>
<p>至于 <code>UILaunchImages</code> 的几个 Key , 简单描述如下: </p>
<ul>
<li><p><code>UILaunchImageName</code> (required) 启动页资源名称</p>
</li>
<li><p><code>UILaunchImageMinimumOSVersion</code>(required) 启动页支持的最低版本</p>
</li>
<li><p><code>UILaunchImageSize</code> 启动页尺寸</p>
</li>
<li><p><code>UILaunchImageOrientation</code> 启动页方向</p>
<p>​</p>
</li>
</ul>
<p>代表什么, 都比较简单, 具体可以参考官方文档~ [  <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW28" target="_blank" rel="external">UILaunchImages</a> ]</p>
<p>用这种方式配置启动页也十分简单, 具体步骤:</p>
<ol>
<li><p>取消启动页使用的 Asset Catalog</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImages%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-12%20%E4%B8%8B%E5%8D%884.44.06.png" alt=""></p>
</li>
<li><p>在Info.plist 中添加UILaunchImages项</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImages<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>LaunchImage<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>7.0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageSize<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>&#123;320, 480&#125;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageOrientation<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>Portrait<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>LaunchImage-568h<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>7.0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageSize<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>&#123;320, 568&#125;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageOrientation<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>Portrait<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>LaunchImage-667h<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>8.0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageSize<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>&#123;375, 667&#125;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageOrientation<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>Portrait<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>LaunchImage-736h<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageMinimumOSVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>8.0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageSize<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>&#123;414, 736&#125;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchImageOrientation<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>Portrait<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <img src="http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImagesF9E4E70D-B3D3-46E6-ADCE-E789F50491B3.png" alt=""></p>
<ol>
<li><p>添加对应的启动页资源</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/LaunchImages863C1341-C42D-47C3-9FC7-B0F85EE78DA7.png" alt=""></p>
<p>​</p>
</li>
</ol>
<p>如此, 即可完成 启动页 多语言的适配, 不信你就试试呗~ </p>
<p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/270/original/%E5%BE%97%E7%91%9F10.png" alt=""></p>
<blockquote>
<p>PS: 这里, 说明一点。 启动页只会保留一份, 也就是说, 你第一次加载完以后, 切换了语言, 再重新打开App, 它的启动页不会跟着更新的。 这也符合苹果的用户交互指引。</p>
<p>如果你想要动态修改启动页面图LaunchImage, 抱歉！<strong>根据苹果的用户交互指引,该页面是在程序加载时显示的,不建议动态修改.</strong></p>
<p>正确的做法一般都是用固定的图片做启动页面图,在启动页面结束之后做任何你想做的事.</p>
<p>如果真想动态修改启动页面,启动页面是固定的名字,可以在程序执行之后强制把页面替换掉,不过这样APP可能会被拒.</p>
<p>该怎么设置一个动态的启动图呢？在启动图结束的时候，用一个View来展示你的动图，记得placeHolder设置为和你的LaunchImage的图片一样就行，这样就可以做出类似的效果了</p>
<hr>
</blockquote>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[仿猎豹垃圾清理]]></title>
      <url>/2015/07/13/Imitation-Clean-Master/</url>
      <content type="html"><![CDATA[<blockquote>
<p>前几天无意打开猎豹内存大师, 发现它的垃圾清理很强大, 效果也不错, 闲着就研究了下。 不过.. 结果貌似和我想象的不太一样。怎么说呢, 听我下文一一分析。</p>
</blockquote>
<p>效果图:</p>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/imageliebao_0.PNG"></p>
<a id="more"></a>
<p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/imageliebao_1.PNG"></p>
<p>从效果图, 我们可以看出它有以下几个功能:</p>
<ol>
<li>获取设备上已安装的所有App</li>
<li>获取App的信息, 包括图标和名称</li>
<li>获取当前已用存储和可用存储</li>
<li>扫描App动画效果</li>
<li>清除所有App垃圾文件</li>
</ol>
<p>看到这里, 你是不是也觉得很强大?</p>
<p>然后然后, 感叹的同时, 我有几点疑惑。</p>
<ol>
<li>获取到所有已安装的App, 这个功能能通过审核?(我是去年在App Store上下载的这个App)</li>
<li>App的图标如何获取到的? (因为扫描到的App包括我自己没上架的demo, icon只能是本地获取, 从其他App沙盒拿？)</li>
<li>垃圾清理过程, 为什么会出现“存储容量已满”这个提示？ 明明是清理垃圾, 中途还会出现存储满的情况?</li>
</ol>
<p>困惑, 不解..~ 于是乎, 折腾呗。 花了两天时间。写了个小demo。</p>
<p>效果如下:</p>
<p><img src="http://img.my.csdn.net/uploads/201505/28/1432801698_3530.gif" width="400"></p>
<p>接下去, 我会介绍以下各个功能的实现过程, 包括:</p>
<ol>
<li>获取设备已安装App列表已经App信息</li>
<li>扫描动画的实现</li>
<li>获取已用存储和可用存储</li>
<li>垃圾清理</li>
</ol>
<p>不过, 分析之前, 说明以下, 该功能不能够上传到App Store上! 也就是说, 它通不过审核的。原因有二:</p>
<ol>
<li>使用了私有API</li>
<li>苹果不允许App有处理内存相关功能</li>
</ol>
<p>至于猎豹内存大师这个App、它也早已经被下架了。我怀疑它利用混淆代码通过的审核。至于功能的实现, 我觉得和猎豹的实现思路应该是一样的。</p>
<p>至此, 如果你还对这篇文章感兴趣, 欢迎继续往下阅读。</p>
<p>本文参考源码: <a href="http://download.csdn.net/detail/hitwhylz/8748739" target="_blank" rel="external">CSDN下载_防猎豹垃圾清理</a></p>
<hr>
<h2 id="获取设备已安装App列表已经App信息">获取设备已安装App列表已经App信息</h2><h3 id="不越狱,_非私有API">不越狱, 非私有API</h3><p>没有越狱的设备，官方没有提供api，所以只能用一些技巧，但是获取内容不全。</p>
<p>这里主要有两种办法:</p>
<blockquote>
<p>方法一：利用URL scheme，看对于某一应用特有的url scheme，有没有响应。如果有响应，就说明安装了这个特定的app。</p>
</blockquote>
<p>说实在.. 这个办法比较傻。 App Store几百万的App, 如何枚举的过来? 并且, 也无法扫描到自己的demo。 不过, 还真有人这么干..</p>
<p>这是对应的demo, 感兴趣可以看看。 <a href="https://github.com/danielamitay/iHasApp" target="_blank" rel="external">iHasApp</a></p>
<p><a href="http://developer.apple.com/library/ios/#featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html" target="_blank" rel="external">官方教程: iPhoneURLScheme_Reference</a></p>
<blockquote>
<p>方法二：利用一些方法获得当前正在运行的进程信息，从进程信息中获得安装的app信息。</p>
</blockquote>
<p><a href="http://forrst.com/posts/UIDevice_Category_For_Processes-h1H" target="_blank" rel="external">参考: UIDevice_Category_For_Processes</a></p>
<p>总的来说, 不越狱, 非私有API, 想获得完整列表, 基本没什么可能。</p>
<h3 id="不越狱,_私有API。">不越狱, 私有API。</h3><p>这里就是我demo所采用的办法, 比较简单。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Class LSApplicationWorkspace_class = objc_getClass(<span class="string">"LSApplicationWorkspace"</span>);  </span><br><span class="line"><span class="built_in">NSObject</span>* workspace = [LSApplicationWorkspace_class performSelector:<span class="keyword">@selector</span>(defaultWorkspace)];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"apps: %@"</span>, [workspace performSelector:<span class="keyword">@selector</span>(allApplications)]);</span><br></pre></td></tr></table></figure>
<p><strong>返回结果</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"LSApplicationProxy: com.qunar.iphoneclient8"</span>,</span><br><span class="line">   <span class="string">"LSApplicationProxy: com.apple.mobilemail"</span>,</span><br><span class="line">   <span class="string">"LSApplicationProxy: com.apple.mobilenotes"</span>,</span><br><span class="line">   <span class="string">"LSApplicationProxy: com.apple.compass"</span>,</span><br><span class="line">   <span class="string">"LSApplicationProxy: com.tencent.happymj"</span>,</span><br><span class="line">   <span class="string">"LSApplicationProxy: com.apple.mobilesafari"</span>,</span><br><span class="line">   <span class="string">"LSApplicationProxy: com.apple.reminders"</span></span><br></pre></td></tr></table></figure>
<p>返回的是个数据, 每个元素都是<code>LSApplicationProxy</code>.它的description只返回了 它的bundle id。然而这并不是我们想要的。</p>
<p>接下去我们看</p>
<p><a href="https://searchcode.com/codesearch/view/15673930/" target="_blank" rel="external">LSApplicationProxy.h</a></p>
<p>形如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">LSApplicationProxy</span>, <span class="title">NSArray</span>, <span class="title">NSDictionary</span>, <span class="title">NSProgress</span>, <span class="title">NSString</span>, <span class="title">NSURL</span>, <span class="title">NSUUID</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LSApplicationProxy</span> : <span class="title">LSResourceProxy</span> &lt;<span class="title">NSSecureCoding</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *_<span class="built_in">UIBackgroundModes</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *_applicationType;</span><br><span class="line">    <span class="built_in">NSArray</span> *_audioComponents;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _bundleFlags;</span><br><span class="line">    <span class="built_in">NSURL</span> *_bundleURL;</span><br><span class="line">    <span class="built_in">NSString</span> *_bundleVersion;</span><br><span class="line">    <span class="built_in">NSArray</span> *_directionsModes;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *_entitlements;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *_envi</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这里列举了<code>LSApplicationProxy</code>对应的属性和方法。</p>
<p>我们可以用如下代码, 打印下每个属性的值, 找出我们想要的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、<span class="comment">/* 获取对象的所有属性 以及属性值 */</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)properties_aps</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">NSMutableDictionary</span> *props = [<span class="built_in">NSMutableDictionary</span> dictionary];   </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;   </span><br><span class="line">   objc_property_t *properties = class_copyPropertyList([<span class="keyword">self</span> class], &amp;outCount);   </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;outCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       objc_property_t property = properties[i];</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span>* char_f =property_getName(property);</span><br><span class="line">       <span class="built_in">NSString</span> *propertyName = [<span class="built_in">NSString</span> stringWithUTF8String:char_f];</span><br><span class="line">       <span class="keyword">id</span> propertyValue = [<span class="keyword">self</span> valueForKey:(<span class="built_in">NSString</span> *)propertyName];   </span><br><span class="line">       <span class="keyword">if</span> (propertyValue) [props setObject:propertyValue forKey:propertyName];   </span><br><span class="line">    &#125;   </span><br><span class="line">   free(properties);   </span><br><span class="line">   <span class="keyword">return</span> props;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考: <a href="http://blog.csdn.net/crazychickone/article/details/36413671" target="_blank" rel="external">IOS 遍历未知对象的属性和方法</a></p>
<p>然后我们提取出我们需要的, 图标和应用名。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[appsInfoArr enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *boundIconsDictionary = [obj performSelector:<span class="keyword">@selector</span>(boundIconsDictionary)];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSString</span> *iconPath = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@.png"</span>, [[obj performSelector:<span class="keyword">@selector</span>(resourcesDirectoryURL)] path], [[[boundIconsDictionary objectForKey:<span class="string">@"CFBundlePrimaryIcon"</span>] objectForKey:<span class="string">@"CFBundleIconFiles"</span>]lastObject]];</span><br><span class="line"></span><br><span class="line">             <span class="built_in">UIImage</span> *image = [[[<span class="built_in">UIImage</span> alloc]initWithContentsOfFile:iconPath] TransformtoSize:<span class="built_in">CGSizeMake</span>(<span class="number">65</span>, <span class="number">65</span>)];</span><br><span class="line">            <span class="keyword">if</span> (image)</span><br><span class="line">            &#123;</span><br><span class="line">                [<span class="keyword">self</span>.appsIconArr addObject:image];</span><br><span class="line">                [<span class="keyword">self</span>.appsNameArr addObject:[obj performSelector:<span class="keyword">@selector</span>(localizedName)]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure>
<p>如此, <code>_self.appsIconArr</code> 和 <code>_appsNameArr</code>中存储的就是我们需要的App数据了。</p>
<h3 id="越狱">越狱</h3><p>.. 这里我也不懂, 也没去研究。 感兴趣的可以看看 <code>MobileInstallation.framework</code></p>
<hr>
<h2 id="扫描动画的实现">扫描动画的实现</h2><p>这里主要有两个动画。</p>
<ol>
<li>利用UIScrollView, 实现每个App自动滚动。</li>
<li>Animation动画, 中间扫描线的往返运动。</li>
</ol>
<p>至于动画, 这里我不想介绍太多。 源码里面都写清楚了。(当然, 写的比较粗糙…)</p>
<p>简单带一下扫描线的动画实现:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向左移动 */</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *animationLeft = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.translation.x"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画选项的设定</span></span><br><span class="line">    animationLeft.duration = <span class="number">0.5</span>f; <span class="comment">// 持续时间</span></span><br><span class="line">    animationLeft.beginTime = <span class="number">0.0</span>f;</span><br><span class="line">    animationLeft.autoreverses = <span class="literal">YES</span>; <span class="comment">// 结束后执行逆动画</span></span><br><span class="line">    <span class="comment">// 动画先加速后减速</span></span><br><span class="line">    animationLeft.timingFunction =</span><br><span class="line">    [<span class="built_in">CAMediaTimingFunction</span> functionWithName: k<span class="built_in">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终了帧</span></span><br><span class="line">    animationLeft.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">-40</span>];;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向右移动 */</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *animationRight = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.translation.x"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画选项的设定</span></span><br><span class="line">    animationRight.duration = <span class="number">0.5</span>f; <span class="comment">// 持续时间</span></span><br><span class="line">    animationRight.beginTime = <span class="number">1.0</span>f;</span><br><span class="line">    animationRight.autoreverses = <span class="literal">YES</span>; <span class="comment">// 结束后执行逆动画</span></span><br><span class="line">    <span class="comment">// 动画先加速后减速</span></span><br><span class="line">    animationRight.timingFunction =</span><br><span class="line">    [<span class="built_in">CAMediaTimingFunction</span> functionWithName: k<span class="built_in">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终了帧</span></span><br><span class="line">    animationRight.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">40</span>];;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 动画组 */</span></span><br><span class="line">    <span class="built_in">CAAnimationGroup</span> *group = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">    group.delegate = <span class="keyword">self</span>;</span><br><span class="line">    group.duration = <span class="number">2.0</span>;</span><br><span class="line">    group.repeatCount = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画结束后不变回初始状态</span></span><br><span class="line">    group.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">    group.fillMode = k<span class="built_in">CAFillModeForwards</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加动画</span></span><br><span class="line">    group.animations = [<span class="built_in">NSArray</span> arrayWithObjects:animationLeft, animationRight, <span class="literal">nil</span>];</span><br><span class="line">    [mySL.layer addAnimation:group forKey:<span class="string">@"moveLeft-moveRight-layer"</span>];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="获取已用存储和可用存储">获取已用存储和可用存储</h2><p>这个没什么好说的了.. Apple提供了API, 直接用就是了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取占用内存</span></span><br><span class="line">-(<span class="keyword">void</span>)usedSpaceAndfreeSpace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span>* path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>] ;</span><br><span class="line">    <span class="built_in">NSFileManager</span>* fileManager = [[<span class="built_in">NSFileManager</span> alloc ]init];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *fileSysAttributes = [fileManager attributesOfFileSystemForPath:path error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSNumber</span> *freeSpace = [fileSysAttributes objectForKey:<span class="built_in">NSFileSystemFreeSize</span>];</span><br><span class="line">    <span class="built_in">NSNumber</span> *totalSpace = [fileSysAttributes objectForKey:<span class="built_in">NSFileSystemSize</span>];</span><br><span class="line">    <span class="built_in">NSString</span>  * str= [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"已占用%0.1f G / 剩余%0.1f MB"</span>,([totalSpace longLongValue] - [freeSpace longLongValue])/<span class="number">1024.0</span>/<span class="number">1024.0</span>/<span class="number">1024.0</span>,[freeSpace longLongValue]/<span class="number">1024.0</span>/<span class="number">1024.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------%@"</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="垃圾清理">垃圾清理</h2><p>这里我本来是不想提的，毕竟这个功能，苹果是不能接受的。</p>
<p>之前提到了, 猎豹在清理过程中, 会出现“存储已满的提示”。然后我开始考虑了。</p>
<ol>
<li>为什么要弹出提示？</li>
<li>存储真的在某一刻满了吗？</li>
<li>它清理的时候, QQ直接被杀死, 应用名变成”正在清理…”（和安装中一个状态）。 真有这么厉害? !!!!!!</li>
<li>这个好像在哪里见过…</li>
</ol>
<p>最后, 我确定了猎豹的实现方式。它只不过是触发了Apple自己的垃圾回收机制而已。</p>
<p>当存储满的时候, 系统会自动帮我们进行垃圾清理, 并弹出提示说明存储已满。</p>
<p>所以, 猎豹只不过是计算了剩余多少存储, 然后制造了一个与之差不多大小的垃圾文件。 然后触发苹果的清理机制。清理完后, 删除之前生成的垃圾文件。再次统计当前可用存储, 差值即为本次清理的垃圾大小。 </p>
<p>是吧, 其实也没那么神~</p>
<p>至于如何快速制造几百M, 甚至几G的垃圾文件? </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件的长度设定为offset </span></span><br><span class="line"> -(<span class="keyword">void</span>)truncateFileAtOffset:offset</span><br></pre></td></tr></table></figure>
<p><code>truncateFileAtOffset:offset</code>就能搞定了。 感兴趣的可以自己研究下。</p>
<hr>
<p>至此, 猎豹垃圾清理分析完毕。</p>
<p>当然, 这只是我个人的看法。如果有更好的方式, 或者文章中存在任何错误。 欢迎交流指正。</p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TODO宏实现]]></title>
      <url>/2015/07/12/TODO-Macro/</url>
      <content type="html"><![CDATA[<h1 id="代码备忘,_TODO宏实现">代码备忘, TODO宏实现</h1><blockquote>
<p>我们平时在开发过程中, 往往并不是憋足气一股脑敲完全部代码。每个模块, 每个函数的实现总有个先后顺序。又或者哪个部分需要做调整, 修改… 所以, 我们需要有一个东西, 来提醒我们, 起到代码备忘功能, 避免某个功能忘记实现, 也能让我们快速定位。 所以这篇文章, 就是要实现一个TODO宏, 来达到代码备忘功能。</p>
</blockquote>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387345_9339.jpeg" width="500"></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387346_3643.jpeg" width="500"></p>
<a id="more"></a>
<h2 id="下面来分析下如何实现这个宏"><strong>下面来分析下如何实现这个宏</strong></h2><hr>
<p>在实现TODO之前, 已经自带了几个预处理指令来实现报警/报错:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#warning Colin</span></span><br><span class="line"><span class="meta">#error Colin</span></span><br><span class="line"><span class="meta">#pragma message <span class="meta-string">"Colin"</span></span></span><br><span class="line"><span class="meta">#pragma GCC warning <span class="meta-string">"Colin"</span></span></span><br><span class="line"><span class="meta">#pragma GCC error <span class="meta-string">"Colin"</span></span></span><br></pre></td></tr></table></figure>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387346_8391.jpeg" width="500"></p>
<p>既然有了, 那为什么还需要自己实现这个TODO宏呢?</p>
<ol>
<li>error 和 warning所代表的意义已经深入猿心, 我们没有理由使用它来做备忘。</li>
<li>如果也使用warning, 在警告导航栏中, 我们很难区分哪个才是我们手动打的标记, 哪个是程序本身的warning</li>
<li>带#的预处理指令是无法被#define的, 也就是没办法直接利用这个来定义我们的TODO</li>
</ol>
<p>好在C99提供了一个 <strong>_Pragma</strong> 运算符可以把部分#pragma指令字符串化, 如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma message <span class="meta-string">"Colin"</span></span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">_Pragma(<span class="string">"message \"Colin\""</span>) <span class="comment">// 需要注意双引号的转义</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">_Pragma(<span class="string">"message(\"Colin\")"</span>) <span class="comment">// 需要注意双引号的转义</span></span><br></pre></td></tr></table></figure>
<p>利用这个特性，我们就可以将warning定义成宏:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MY_WARNING _Pragma(<span class="meta-string">"message (\"</span>警察临检, 男左女右!\<span class="meta-string">")"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line"></span><br><span class="line">    MY_WARNING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387346_6563.jpeg" width="500"></p>
<p>到这里, 大体有那么一个感觉。 不过我们提示的内容, 是define的, 也就是写死固定的, 不太合适。</p>
<p>所以我们希望这个宏能接受入参, 让它正常显示到warning中。</p>
<p>这就涉及了一些宏的基本用法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define STRINGIFY(S) #S</span></span><br><span class="line"><span class="meta">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br></pre></td></tr></table></figure>
<p>STRINGIFY(S) 将入参转化成字符串，省去了_Pragma中全串加转义字符的困扰。</p>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387347_2653.jpeg" width="500"></p>
<p>这时，一个基本功能的TODO宏就完成了，下面向其中加入额外的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个已有的宏</span></span><br><span class="line"><span class="meta">#define STRINGIFY(S) #S</span></span><br><span class="line"><span class="meta">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class="line"><span class="comment">// 延迟1次展开的宏</span></span><br><span class="line"><span class="meta">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class="line"><span class="comment">// 下面的宏在第一行用`\`折行</span></span><br><span class="line"><span class="meta">#define FORMATTED_MESSAGE(MSG) <span class="meta-string">"[TODO-"</span> DEFER_STRINGIFY(__COUNTER__) <span class="meta-string">"] "</span> MSG <span class="meta-string">" \n"</span>  \</span></span><br><span class="line">    DEFER_STRINGIFY(__FILE__) <span class="string">" line "</span> DEFER_STRINGIFY(__LINE__)</span><br></pre></td></tr></table></figure>
<p>其中涉及到的知识：</p>
<ul>
<li>两个常量字符串可以拼接成一个整串 “123””456” =&gt; “123456”</li>
<li>使用到3个预定义宏，<strong>COUNTER</strong>宏展开次数的计数器，全局唯一；<strong>FILE</strong>当前文件完整目录字符串；<strong>LINE</strong>在当前文件第几行</li>
<li>在字符串中预定义宏应延时展开，如果将上面的DEFER<em>STRINGIFY换成STRINGIFY的话，如<strong>LINE</strong>不能被正确展开成行数，而是成了一个常量字符串”<em>_LINE</em></em>“</li>
<li>为了美化，warning message中可以使用\n换行</li>
</ul>
<p>于是，使用FORMATTED_MESSAGE(MSG)宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。</p>
<hr>
<p>其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加@的形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最终版本"><strong>最终版本</strong></h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 转成字符串</span></span><br><span class="line"><span class="meta">#define STRINGIFY(S) #S</span></span><br><span class="line"><span class="comment">// 需要解两次才解开的宏</span></span><br><span class="line"><span class="meta">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为warning增加更多信息</span></span><br><span class="line"><span class="meta">#define FORMATTED_MESSAGE(MSG) <span class="meta-string">"[TODO-"</span> DEFER_STRINGIFY(__COUNTER__) <span class="meta-string">"] "</span> MSG <span class="meta-string">" \n"</span> DEFER_STRINGIFY(__FILE__) <span class="meta-string">" line "</span> DEFER_STRINGIFY(__LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使宏前面可以加@</span></span><br><span class="line"><span class="meta">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终使用的宏</span></span><br><span class="line"><span class="meta">#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span></span><br></pre></td></tr></table></figure>
<h1 id="References">References</h1><p><a href="http://blog.sunnyxx.com/2015/03/01/todo-macro/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/03/01/todo-macro/</a></p>
<p><a href="http://clang.llvm.org/docs/UsersManual.html" target="_blank" rel="external">http://clang.llvm.org/docs/UsersManual.html</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html" target="_blank" rel="external">https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html</a></p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 宏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>/2015/07/11/Regular-Expressions/</url>
      <content type="html"><![CDATA[<blockquote>
<p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>
</blockquote>
<ol>
<li>系统自带的, 如: NSPredicate, rangeOfString：option, NSRegularExpression</li>
<li><a href="http://regexkit.sourceforge.net/RegexKitLite/" target="_blank" rel="external">RegexKitLite</a> RegexKitLite 是一个轻量级的 Objective-C 的正则表达式库,支持 Mac OS X 和 iOS,使用 ICU 库开发。</li>
</ol>
<p>至于<code>RegexKitLite</code>, 这里不做介绍。着重介绍系统自带的那几个办法。</p>
<blockquote>
<p>PS: 阅读本文前提是您已经掌握了正则基本语法, 如果对正则还不太了解, 可以参考以下几个链接:</p>
</blockquote>
<p>正则表达式学习链接：</p>
<ol>
<li><a href="http://doslin.com/regular%20expressions/2014/03/11/learn-regular-expressions-in-about-55-minutes.html" target="_blank" rel="external">55分钟学会正则表达式</a></li>
<li><a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="external">揭开正则表达式的神秘面纱</a></li>
<li><a href="http://www.regexplib.com/DisplayPatterns.aspx?cattabindex=4&amp;categoryId=5" target="_blank" rel="external">RegExLib.com(正则表达式库查询)</a></li>
</ol>
<hr>
<a id="more"></a>
<h2 id="1-_NSPredicate">1. NSPredicate</h2><blockquote>
<p>简述：Cocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:(<span class="built_in">NSString</span> *), ...];</span><br></pre></td></tr></table></figure>
<p>其中, 常见的<code>Format</code>有:</p>
<p>(1) 比较运算符: &gt;, &lt;, ==, &gt;=, &lt;=, !=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：@&quot;number &gt; 100&quot;</span><br></pre></td></tr></table></figure>
<p>(2) 范围运算符: IN, BETWEEN</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：@&quot;number BETWEEN &#123;1,5&#125;&quot;</span><br><span class="line">   @&quot;address IN &#123;&apos;shanghai&apos;,&apos;beijing&apos;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>(3) 字符串本身: SELF </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：@“SELF == ‘APPLE’&quot;</span><br></pre></td></tr></table></figure>
<p>(4) 字符串相关: BEGINSWITH, ENDSWITH, CONTAINS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：@&quot;name CONTAINS[cd] &apos;ang&apos;&quot;  //包含某个字符串</span><br><span class="line">   @&quot;name BEGINSWITH[c] &apos;sh&apos;&quot;  //以某个字符串开头</span><br><span class="line">   @&quot;name ENDSWITH[d] &apos;ang&apos;&quot;   //以某个字符串结束</span><br><span class="line"></span><br><span class="line">注:[c]不区分大小写</span><br><span class="line">   [d]不区分发音符号即没有重音符号</span><br><span class="line">   [cd]既不区分大小写，也不区分发音符号。</span><br></pre></td></tr></table></figure>
<p>(5) 通配符: LIKE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：@&quot;name LIKE[cd] &apos;*er*&apos;&quot;    //*代表通配符,Like也接受[cd].</span><br><span class="line">   @&quot;name LIKE[cd] &apos;???er*&apos;&quot;</span><br></pre></td></tr></table></figure>
<p>(6) 正则表达式: MATCHES</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：NSString *regex = @&quot;^A.+e$&quot;;   //以A开头，e结尾</span><br><span class="line">  @&quot;name MATCHES %@&quot;,regex</span><br></pre></td></tr></table></figure>
<p>至于如何使用呢? 下面举几个例子:</p>
<p>(a) 对NSArray进行过滤, 帅选出包含”ang”的项</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc]initWithObjects:<span class="string">@"beijing"</span>, <span class="string">@"shanghai"</span>, <span class="string">@"guangzou"</span>, <span class="string">@"wuhan"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="string">@"ang"</span>;</span><br><span class="line">    <span class="built_in">NSPredicate</span> *pred = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF CONTAINS %@"</span>, string];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [array filteredArrayUsingPredicate:pred]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    打印结果:</span></span><br><span class="line"><span class="comment">//    (</span></span><br><span class="line"><span class="comment">//     shanghai,</span></span><br><span class="line"><span class="comment">//     guangzou</span></span><br><span class="line"><span class="comment">//    )</span></span><br></pre></td></tr></table></figure>
<p>(b) 对NSDate进行筛选</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期在十天之内:</span></span><br><span class="line"><span class="built_in">NSDate</span> *endDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSTimeInterval</span> timeInterval= [endDate timeIntervalSinceReferenceDate];</span><br><span class="line">timeInterval -=<span class="number">3600</span>*<span class="number">24</span>*<span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSDate</span> *beginDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceReferenceDate:timeInterval];</span><br><span class="line"><span class="comment">//对coredata进行筛选(假设有fetchRequest)</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate_date = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"date &gt;= %@ AND date &lt;= %@"</span>, beginDate,endDate];</span><br><span class="line">[fetchRequest setPredicate:predicate_date];</span><br></pre></td></tr></table></figure>
<p>OK, <code>NSPredicate</code>的功能很多, 也很强大。这里暂时就点到此, 感兴趣的可以自己一一试验。 下面举两个例子说明一下如何使用正则。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是有效邮箱</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isValidateEmail:(<span class="built_in">NSString</span> *)email&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *regex = <span class="string">@"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;"</span>;</span><br><span class="line">    <span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF MATCHES %@"</span>, regex];</span><br><span class="line">    <span class="keyword">return</span> [predicate evaluateWithObject:email];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串首字母是否为字母</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isStartedWithWord:(<span class="built_in">NSString</span> *)aString&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *regex = <span class="string">@"[A-Za-z]+"</span>;</span><br><span class="line">    <span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF MATCHES %@"</span>, regex];</span><br><span class="line">    <span class="keyword">return</span> [predicate evaluateWithObject:aString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-_利用rangeOfString：option：直接查找">2. 利用rangeOfString：option：直接查找</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> *searchText = <span class="string">@"// Do any additional setup after loading the view, typically from a nib."</span>;</span><br><span class="line">    <span class="built_in">NSRange</span> range = [searchText rangeOfString:<span class="string">@"(?:[^,])*\\."</span> options:<span class="built_in">NSRegularExpressionSearch</span>];</span><br><span class="line">    <span class="keyword">if</span> (range.location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [searchText substringWithRange:range]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    打印结果:</span></span><br><span class="line"><span class="comment">//      typically from a nib.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>options中设定NSRegularExpressionSearch就是表示利用正则表达式匹配，会返回第一个匹配结果的位置。</p>
</blockquote>
<hr>
<h1 id="3-_使用正则表达式类">3. 使用正则表达式类</h1><p>详细了解:  <a href="http://blog.csdn.net/crayondeng/article/details/16991579" target="_blank" rel="external">iOS 正则表达式 NSRegularExpression</a></p>
<p>上面那篇文章总结的很不错. 这里简单再举个例子:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> *searchText = <span class="string">@"// Do any additional setup after loading the view, typically from a nib."</span>;    </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:<span class="string">@"(?:[^,])*\\."</span> options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSTextCheckingResult</span> *result = [regex firstMatchInString:searchText options:<span class="number">0</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [searchText length])];</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@\n"</span>, [searchText substringWithRange:result.range]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    打印结果:</span></span><br><span class="line"><span class="comment">//      typically from a nib.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用系统的正则表达式类（NSRegularExpression）会返回匹配的多个结果。</p>
</blockquote>
<hr>
<p>针对以上3种方式, 做一个小小总结</p>
<blockquote>
<p>第一种匹配需要学习NSPredicate的写法，需要查阅苹果相关技术文档；</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>如果只关心第一个匹配的结果，第二种匹配较为简洁；</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>如果需要匹配多个结果，同时匹配多次，第三种方式效率会更高。</p>
</blockquote>
<p>&gt;</p>
<h2 id="常用正则表达式">常用正则表达式</h2><p>参考:  <a href="http://blog.csdn.net/chaoyuan899/article/details/38583759" target="_blank" rel="external">IOS常用正则表达式</a></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>[\u4e00-\u9fa5]</td>
<td>匹配中文字符</td>
</tr>
<tr>
<td>[^\x00-\xff]</td>
<td>匹配双字节字符(包括汉字在内)</td>
</tr>
<tr>
<td>\n\s*\r</td>
<td>匹配空白行</td>
</tr>
<tr>
<td>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;\</td>
<td>&lt;.*? /&gt;</td>
</tr>
<tr>
<td>^\s*\</td>
<td>\s*$</td>
</tr>
<tr>
<td>\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*</td>
<td>匹配Email地</td>
</tr>
<tr>
<td>[a-zA-z]+://[^\s]*</td>
<td>匹配网址URL</td>
</tr>
<tr>
<td>\d{3}-\d{8}\</td>
<td>\d{4}-\d{7}</td>
</tr>
<tr>
<td>[1-9]\d{5}(?!\d)</td>
<td>匹配中国邮政编码</td>
</tr>
<tr>
<td>\d+.\d+.\d+.\d+</td>
<td>匹配ip地址</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 正则 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里, 网易, 腾讯]]></title>
      <url>/2015/07/11/interview-summary/</url>
      <content type="html"><![CDATA[<h1 id="一个多月来的面试总结(阿里,_网易,_腾讯)">一个多月来的面试总结(阿里, 网易, 腾讯)</h1><blockquote>
<p>想必关注我的朋友都发现了, 最近我发表原创文章的数量和质量大大不如以前了, 也不怎么活跃了。主要原因是现在大三了, 7月份就能离校实习了, 所以前段时间也在为找实习忙碌着。接下去应该就能恢复正常, 继续为大家分享一些iOS开发上的小技巧, 毕竟, 也算拿到了心仪的offer。</p>
</blockquote>
<a id="more"></a>
<p><strong>接下去, 就围绕这一个多月来参加的几场面试, 做一个总结。 设计的公司主要包括阿里研发部分, 网易邮件, 腾讯微信。希望能给同样在为找实习努力的战友提供一些帮助。(<code>已经拿到网易和微信的offer</code>)</strong></p>
<p>PS: 总结不是空穴来风, 每次面试完, 我都会坐着认真总结之前的面试, 记录每道题, 每个答案的关键点, 再比对下自己的回答是否完整。</p>
<p><img src="http://img.my.csdn.net/uploads/201504/25/1429944250_1723.jpeg" width="900"></p>
<p><strong>另外, 博客篇幅有限, 并且题目并不是适合每一位同学(我是iOS开发相关, 题目主要都是iOS相关), 所以不适合把完整的题目都描述出来, 文章主要是一些经验交流。 <code>如果需要完整面试题目的, 麻烦留下邮箱, 我看到了会一一发送</code>。</strong></p>
<blockquote>
<p>以下按参加的时间先后来描述, 另外我的个人主页 <a href="http://colin1994.xyz" target="_blank" rel="external">Colin’s Nest</a>, 里面有我的一些介绍, 包括简历。感兴趣的可以瞅瞅。</p>
</blockquote>
<h1 id="阿里_研发部门">阿里_研发部门</h1><p>阿里是最早投的一家公司, 3月初那会, 本来还在学习科二的, 然后在阿里的学长, 催着要简历, 说内推已经开始了。于是乎, 我就借机把科二给退了(被教练骂成狗的滋味真不好受, 还好及时跑了)。学长给内推的部门是和o2o相关, iOS开发。</p>
<h2 id="阿里一面_电话">阿里一面_电话</h2><p>然后等了几天, <code>3月9号</code>, 一面开始了, 节奏很快, 总共通话时候是<code>26分钟</code>..</p>
<p>电话来的比较突然, 那会还在看文章呢。一面过了, 但是具体表现并不是很理想。</p>
<ol>
<li>先是自我介绍。</li>
<li><p>问iOS相关。 比如:</p>
<ol>
<li>Category支持添加属性与成员变量吗</li>
<li>iOS7之后, 蓝牙的围栏功能</li>
<li>说说Cell重用原理<br>…</li>
</ol>
</li>
</ol>
<ol>
<li><p>设计模式。这里主要问了iOS常用的设计模式, 以及如何应用到实际需求中去。</p>
<ol>
<li>MVC是否了解?介绍下使用情况。</li>
<li>MVC里面, View怎么通知到Model</li>
<li>了解delegate吗?并介绍</li>
<li>如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么</li>
</ol>
</li>
<li><p>然后就是再交流, 对o2o有什么看法, 有没有想问他的…</p>
</li>
</ol>
<h2 id="阿里二面_电话">阿里二面_电话</h2><p>然后又过了两天, 二面如约来了, 36分钟, 感觉比上次好, 不过结果…</p>
<p>二面和一面一样, 都围绕iOS, 问了objc相关, 内存管理, 设计模式等。</p>
<p>但是更多的, 询问了我平时的一些开发习惯, 以及一些设计题。</p>
<p>比如:</p>
<ul>
<li>如果让你设计KVO, 要怎么设计</li>
<li>现在你是如何适配的</li>
<li>比较下storyboard和全代码</li>
<li>如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动</li>
<li>平时是怎么进行测试的, 内存方面怎么测试</li>
<li>平时自己有没有封装过比较复杂的控件</li>
<li>平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析..</li>
<li>如何实现类似 “Find My iPhone” 这样功能</li>
</ul>
<p>二面相比一面来说, 准备的更充分了。回答问题上, 也比较积极, 考虑的也比较多。不过二面结束没多久, 内推状态就变成”待回绝”。 Over了…</p>
<p>学长询问了面试官, 结果是: “整体还不错, 但总感觉少了点什么..”</p>
<p>经历完阿里这一次, 总体来说, 对我打击还挺大的。毕竟, 第一次就跪了..  同时, 更多的是对自我的总结。</p>
<p>首先应该是准备不够充分, 然后就是基础不够扎实。从面试官问的问题来看, <code>大公司还是对基础要求比较高</code>。</p>
<h2 id="阿里校招_在线笔试">阿里校招_在线笔试</h2><p>之后, 又投了阿里校招, 参加了在线笔试。具体题目可以在这里看到:<a href="http://www.nowcoder.com/companyCenterTerminal_134" target="_blank" rel="external">阿里笔试题</a></p>
<p>虽然笔试通过了, 不过现场面试的时间和课程冲突了, 然后就没有跑去杭州面试。</p>
<p>于是乎, 和阿里就这样不了了之了。</p>
<h1 id="网易_邮件部门(拿到offer)">网易_邮件部门(拿到offer)</h1><p>在结束阿里内推没多久, 偶然在网上看到网易的一个招聘。 因为方式比较新颖, 就关注了下。</p>
<p><img src="http://img.my.csdn.net/uploads/201504/25/1429947172_7894.jpg" width="900"></p>
<p><strong>答案就在门的背后！(至于如何解题欢迎大家交流)</strong></p>
<p>解开这个题目后, 拿到了面试官的邮箱.. 然后抱着侥幸的心理, 就投了。</p>
<h2 id="网易一面_电话">网易一面_电话</h2><p>没想到, 第二天就来电话了。效率很高。 <code>55分钟</code>.. 感觉被虐哭了。</p>
<p>网易考核的主要是<code>objc, iOS, 设计模式, 算法</code>。 </p>
<p>主要如下:</p>
<ol>
<li>autorelease 和 @autoreleasepool区别</li>
<li>unsafe_unretained , weak, assign 区别</li>
<li>在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗</li>
<li>在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok</li>
<li>NSThread, NSOperation, GCD区别</li>
<li>runtime什么时候用</li>
<li>通知和KVO区别</li>
<li>深度遍历和广度遍历使用场景</li>
<li>常用的设计模式</li>
<li>算法题 * 2</li>
<li>自己有什么优点</li>
</ol>
<p>…</p>
<p>面完之后, 感觉整个人都不好了。<code>内存管理</code>部分, 都能说出那么一些, 但是一说多了, 就不知道怎么回答了。总体来说, 还是基础不够扎实。研究不够透彻。</p>
<p>然后面试完, 一个很大的感受就是, <code>一次面试, 学到的, 比自己闷头看书一个月, 学到的还多</code>。<code>面试很直观的反应出了自己的不足</code>。于是乎, 针对内存管理, 多线程等知识上的不足。 我重新把那本狮子头的书认真看了遍。</p>
<p>PS: 如果觉得这方面知识也有所欠缺的话, 可以到这里下载<code>Objective-C高级编程 iOS与OS X多线程和内存管理.pdf</code>这本书, 极力推荐。</p>
<p>下载链接: <a href="http://pan.baidu.com/s/1pJsno7p" target="_blank" rel="external">电子书分享</a></p>
<p>本以为, 网易也就是这么结束了。 没想到过了几天, 人力资源部的妹子打电话来, 约去杭州面试。</p>
<p>于是乎于是乎, 去杭州浪了~</p>
<h2 id="网易二面_现场">网易二面_现场</h2><p>初到杭州, 很巧的是在机场大巴上碰到了一个去H3C培训的大叔, 更巧的是, 他也住我那个酒店。 然后就跟着他, 一路聊到酒店.. 挺好。</p>
<p>第二天网易面试, 还是挺紧张的。9点多到了待客大厅, 填了表, 然后等面试官。然后网易给我的一个感觉就是, 很<code>内敛, 低调</code>, 感觉挺好。</p>
<p>之后一下来了两个面试官, 领我到单独的小隔间面试.. 一次两个, 有点虚。</p>
<p>不过没多久, 就适应了这种气氛, 然后和面试官交流也比较开心。</p>
<p>主要问题如下:</p>
<ol>
<li>我是上次和你通电话的那位, 你觉得自己上次表现怎么样</li>
<li>这段时间, 都在干嘛</li>
<li>我们认真看了你的github, 感觉还不错</li>
</ol>
<p>然后给我一张纸, 问了几个算法题:</p>
<ol>
<li>如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3]</li>
<li>实现连连看算法</li>
<li>T9算法如何实现, 全拼算法</li>
</ol>
<p>总的来说, 问的都是<code>算法</code>相关, 没有再涉及iOS部分。 然后就算法来说, 回答的还不错。虽然每道题不是一步到位, 但是在与面试官沟通过程中, 最后都逐步完善了自己的算法。</p>
<p>然后就是和面试官聊天了, 两位面试官都很平易近人, 聊得也比较开心。 然后就约了下午HR面。</p>
<p>…面试完后, 包括面试官已经人力管理的妹子都邀请我去网易食堂吃饭, 不过毕竟腼腆, 我给拒绝了。出来才发现.. 找个饭店真不容易.. 早知道就厚着脸皮试试”丁家猪”了。</p>
<h2 id="网易HR面_现场">网易HR面_现场</h2><p>下午HR面, HR是个很漂亮的妹子.. 整个过程都比较欢乐， 虽然一些问题上可能有不同看法。</p>
<p>HR问的主要是一些职业规划, 抗压能力, 学习习惯, 别人怎么看待自己等等..</p>
<p>面试完以后, HR问我接下去准备干嘛, 我说我要一路玩到萧山机场(那天酒店在萧山机场附近)。然后她打趣到:”真潇洒阿..”</p>
<p>杭州确实很美, 不够时间关系, 就在西湖附近逛了会。 附带两张图片。</p>
<p><img src="http://img.my.csdn.net/uploads/201504/25/1429949156_7015.JPG" width="900"><br><img src="http://img.my.csdn.net/uploads/201504/25/1429949125_2851.JPG" width="900"></p>
<p>3.31参加完网易杭州的现场面试. 4月23号收到网易的正式offer。 总算, 踏实了…</p>
<h1 id="腾讯_微信事业部(拿到offer)">腾讯_微信事业部(拿到offer)</h1><p>之前腾讯校招的时候, 投了简历。 不过一直到周围同学都参加了在线笔试, 我仍然没收到通知的时候, 我基本上已经放弃了。觉得自己应该在简历环节就被刷了, 比较凄凉..</p>
<h2 id="微信一面_电话">微信一面_电话</h2><p>不过4月20的时候, 突然来了个电话, 对方说是腾讯微信事业部的。 很突然, 完全没想到。 可以说， 幸福来的太突然了..</p>
<p>电话用时<code>1小时10分</code>.. 中间把院长的课给翘了.. - -!</p>
<p>主要还是围绕这几个方面: 项目, 设计模式, 算法..</p>
<p>问题包括:</p>
<ol>
<li>如何保证软件质量, 怎么分析Crash日志</li>
<li>谈谈你觉得最重要的一个项目</li>
<li>你的个人主页是怎么写的</li>
<li>假如我是一名初学者, 你会向我推荐哪些第三方库</li>
<li>使用了第三方库, 有看他们是怎么实现的吗</li>
<li>有没有看过大型项目的源码</li>
<li>强连通量算法</li>
<li>最短路径算法</li>
<li>排序算法</li>
<li>25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名</li>
</ol>
<p>腾讯给我的感觉就是, 很靠谱。 <code>这几轮面试, 就腾讯当场就给出了结果, 不管是一面, 二面, 还是HR面 而不是说让你再等通知。 给我的感觉非常好</code>。</p>
<p>一面最后, 这个面试官就说, 他这里通过了, 问我明天什么时候有时间, 给我约下另外一个面试官。</p>
<h2 id="微信二面_collabedit+电话">微信二面_collabedit+电话</h2><p>第二天微信二面如约来了, 面试官很好。提前打电话问我有没有时间, 我表示想午睡一会, 一个小时后开始。他答应了。</p>
<p>然后一个小时后, 另外一个面试官打电话来了, 要我登录 <a href="http://collabedit.com/xxxx" target="_blank" rel="external">http://collabedit.com/xxxx</a> 答题。</p>
<p>collabedit可以在线共享。 就是说, 我这里敲什么, 面试官那里就能同步显示。 主要是考核编码能力。</p>
<p>主要是两个算法题, 第一道要求写出完整代码, 第二道思路交流。</p>
<ol>
<li>求两个整数的最大公约数</li>
<li>微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分。</li>
</ol>
<p>完了之后, 面试官问了我实习时间, 然后问我对深圳和广州的看法(因为我第一志愿填的是深圳, 微信本部在广州), 问我愿意去广州吗。 之后就表示他这里也通过了。 这一两天给我约HR。</p>
<h2 id="微信HR面_电话">微信HR面_电话</h2><p>果然, 两天后, 微信HR来电话了。</p>
<p>和她聊天很轻松, 从头到尾都是喊我’龙泽 .. 龙泽’, 感觉很亲切。 主要也是围绕职业规划等展开。</p>
<p>然后最后就问我, 是否愿意来微信实习, 如果愿意, 马上就给我offer, 如果还犹豫, 考虑清楚再联系她。</p>
<p>当然, 我表示愿意。 然后hr留了微信号, 说安排同事给我发确认函。</p>
<p>当天晚上, 另外一个人力资源的妹子打电话, 和我讨论薪资等问题..</p>
<p>总的来说, 微信从一面, 到最后确定下来, 就经历了4天。 非常效率。 中间也很愉快。</p>
<p>说来也巧, 网易和微信是同时发来来的offer。网易电话刚放下没多久, 微信hr就来电话了。所以当时两边是先都允诺能去实习了，毕竟时间太紧, 还没考虑好。</p>
<p>之后还是因为个人原因, 选择了微信, 所以当天下午就打电话给网易, 告知了他们。多少也有些遗憾, 毕竟网易也是我很向往的一家公司。</p>
<p>好了。 到此, 这段时间的面试总结就写好了。下面就我个人来说, 提几点建议:</p>
<ol>
<li>基础。 不管是哪个方向, 基础很重要。就比如iOS, objc的方方面面都必须了解。</li>
<li>全面。 有些东西, 虽然不见得能答好, 但你至少应该懂。</li>
<li>设计模式。 主流的那些设计模式非常有必要了解。</li>
<li>算法。 这个不是说恶补能补好的。建议大家长期积累。 另外推荐&lt;剑指offer&gt;这本书。同时, 可以在这里线上答题: <a href="http://www.nowcoder.com/books/coding-interviews" target="_blank" rel="external">牛客网-剑指offer</a></li>
<li>简历一定要真实! 基本上面试官都是围绕简历展开交流的。 懂或不懂, 一问就知道, 没必要搬起石头砸自己的脚</li>
<li>提前准备。 比如自我介绍, 项目介绍, 职业规划等等。基本都是必问的题目，能提前准备就提前准备好。</li>
<li>开源, 分享, 积累。 我一直认为, 分享和开源是程序员进步的不二法门。 我建议每个程序员都应该有自己的Github, 有自己的博客。就这几次面试来说, 博客和Github帮了我多。 网易面试官直言, 他们认真看过我的Github, 微信HR问我要CSDN博客ID, 说她很感兴趣。帮助别人, 也是帮助自己。</li>
<li>沟通。 有时候一个问题, 可能不懂, 甚至题目都不理解。不要害怕, 主动与面试官沟通。 我在网易面试的时候, 关于全拼算法的实现, 我当时连全拼都没一个完整的概念, 它要满足哪些条件更加不清楚。我跟面试官坦诚我不懂这个概念, 与他们的一步步沟通中实现了自己的算法。 所以沟通, 远比闷头写, 到头来还可能错误来的实在。</li>
<li>自信。 能得到面试机会, 最起码证明, 你很优秀。 我觉得自信很重要。 如果一开始, 就表现的慌慌张张, 畏首畏尾, 那么不管是你自己的发挥, 还是面试官对你的看法, 我觉得都不会很好。 </li>
</ol>
<p>敲了一下午.. 真累。</p>
<p><code>希望和我一样大三找实习的朋友, 都能拿到自己心仪的offer!</code></p>
<p><strong>学习的路上, 与君共勉。</strong></p>
<hr>
<p><a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external"><img src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png" alt="知识共享许可协议"></a>本作品采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://colin1994.github.io/" target="_blank" rel="external">Colin’s Nest</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</p>
]]></content>
      
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
