<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Colin's Nest]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-07-13T06:43:30.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Colin丶]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[TODO宏实现]]></title>
    <link href="http://yoursite.com/2015/07/13/TODO%E5%AE%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2015/07/13/TODO宏实现/</id>
    <published>2015-07-13T02:14:52.000Z</published>
    <updated>2015-07-13T06:43:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="代码备忘,_TODO宏实现">代码备忘, TODO宏实现</h1><blockquote>
<p>我们平时在开发过程中, 往往并不是憋足气一股脑敲完全部代码。每个模块, 每个函数的实现总有个先后顺序。又或者哪个部分需要做调整, 修改… 所以, 我们需要有一个东西, 来提醒我们, 起到代码备忘功能, 避免某个功能忘记实现, 也能让我们快速定位。 所以这篇文章, 就是要实现一个TODO宏, 来达到代码备忘功能。</p>
</blockquote>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387345_9339.jpeg" width="500"><br><img src="http://img.my.csdn.net/uploads/201503/15/1426387346_3643.jpeg" width="500"></p>
<h2 id="下面来分析下如何实现这个宏"><strong>下面来分析下如何实现这个宏</strong></h2><hr>
<p>在实现TODO之前, 已经自带了几个预处理指令来实现报警/报错:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#warning Colin</span></span><br><span class="line"><span class="preprocessor">#error Colin</span></span><br><span class="line"><span class="preprocessor">#pragma message <span class="title">"Colin"</span></span></span><br><span class="line"><span class="preprocessor">#pragma GCC warning <span class="title">"Colin"</span></span></span><br><span class="line"><span class="preprocessor">#pragma GCC error <span class="title">"Colin"</span></span></span><br></pre></td></tr></table></figure>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387346_8391.jpeg" width="500"></p>
<p>既然有了, 那为什么还需要自己实现这个TODO宏呢?</p>
<ol>
<li>error 和 warning所代表的意义已经深入猿心, 我们没有理由使用它来做备忘。</li>
<li>如果也使用warning, 在警告导航栏中, 我们很难区分哪个才是我们手动打的标记, 哪个是程序本身的warning</li>
<li>带#的预处理指令是无法被#define的, 也就是没办法直接利用这个来定义我们的TODO</li>
</ol>
<p>好在C99提供了一个 <strong>_Pragma</strong> 运算符可以把部分#pragma指令字符串化, 如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma message <span class="title">"Colin"</span></span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">_Pragma(<span class="string">"message \"Colin\""</span>) <span class="comment">// 需要注意双引号的转义</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">_Pragma(<span class="string">"message(\"Colin\")"</span>) <span class="comment">// 需要注意双引号的转义</span></span><br></pre></td></tr></table></figure>
<p>利用这个特性，我们就可以将warning定义成宏:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MY_WARNING _Pragma(&#34;message (\&#34;&#35686;&#23519;&#20020;&#26816;, &#30007;&#24038;&#22899;&#21491;!\&#34;)&#34;)&#10;&#10;&#10;- (void)viewDidLoad &#123;&#10;    [super viewDidLoad];&#10;    // Do any additional setup after loading the view, typically from a nib.&#10;    &#10;    MY_WARNING&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387346_6563.jpeg" width="500"></p>
<p>到这里, 大体有那么一个感觉。 不过我们提示的内容, 是define的, 也就是写死固定的, 不太合适。</p>
<p>所以我们希望这个宏能接受入参, 让它正常显示到warning中。</p>
<p>这就涉及了一些宏的基本用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define STRINGIFY(S) #S&#10;#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span><br></pre></td></tr></table></figure>
<p>STRINGIFY(S) 将入参转化成字符串，省去了_Pragma中全串加转义字符的困扰。</p>
<p><strong>效果如下:</strong></p>
<p><img src="http://img.my.csdn.net/uploads/201503/15/1426387347_2653.jpeg" width="500"></p>
<p>这时，一个基本功能的TODO宏就完成了，下面向其中加入额外的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20004;&#20010;&#24050;&#26377;&#30340;&#23439;&#10;#define STRINGIFY(S) #S&#10;#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))&#10;// &#24310;&#36831;1&#27425;&#23637;&#24320;&#30340;&#23439;&#10;#define DEFER_STRINGIFY(S) STRINGIFY(S)&#10;// &#19979;&#38754;&#30340;&#23439;&#22312;&#31532;&#19968;&#34892;&#29992;`\`&#25240;&#34892;&#10;#define FORMATTED_MESSAGE(MSG) &#34;[TODO-&#34; DEFER_STRINGIFY(__COUNTER__) &#34;] &#34; MSG &#34; \n&#34;  \&#10;    DEFER_STRINGIFY(__FILE__) &#34; line &#34; DEFER_STRINGIFY(__LINE__)</span><br></pre></td></tr></table></figure>
<p>其中涉及到的知识：</p>
<ul>
<li>两个常量字符串可以拼接成一个整串 “123””456” =&gt; “123456”</li>
<li>使用到3个预定义宏，<strong>COUNTER</strong>宏展开次数的计数器，全局唯一；<strong>FILE</strong>当前文件完整目录字符串；<strong>LINE</strong>在当前文件第几行</li>
<li>在字符串中预定义宏应延时展开，如果将上面的DEFER<em>STRINGIFY换成STRINGIFY的话，如<strong>LINE</strong>不能被正确展开成行数，而是成了一个常量字符串”<em>_LINE</em></em>“</li>
<li>为了美化，warning message中可以使用\n换行</li>
</ul>
<p>于是，使用FORMATTED_MESSAGE(MSG)宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。</p>
<hr>
<p>其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加@的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最终版本"><strong>最终版本</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;// &#36716;&#25104;&#23383;&#31526;&#20018;&#10;#define STRINGIFY(S) #S&#10;// &#38656;&#35201;&#35299;&#20004;&#27425;&#25165;&#35299;&#24320;&#30340;&#23439;&#10;#define DEFER_STRINGIFY(S) STRINGIFY(S)&#10;&#10;#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))&#10;&#10;// &#20026;warning&#22686;&#21152;&#26356;&#22810;&#20449;&#24687;&#10;#define FORMATTED_MESSAGE(MSG) &#34;[TODO-&#34; DEFER_STRINGIFY(__COUNTER__) &#34;] &#34; MSG &#34; \n&#34; DEFER_STRINGIFY(__FILE__) &#34; line &#34; DEFER_STRINGIFY(__LINE__)&#10;&#10;// &#20351;&#23439;&#21069;&#38754;&#21487;&#20197;&#21152;@&#10;#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;&#10;&#10;// &#26368;&#32456;&#20351;&#29992;&#30340;&#23439;&#10;#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span><br></pre></td></tr></table></figure>
<h1 id="References">References</h1><p><a href="http://blog.sunnyxx.com/2015/03/01/todo-macro/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/03/01/todo-macro/</a></p>
<p><a href="http://clang.llvm.org/docs/UsersManual.html" target="_blank" rel="external">http://clang.llvm.org/docs/UsersManual.html</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html" target="_blank" rel="external">https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="代码备忘,_TODO宏实现">代码备忘, TODO宏实现</h1><blockquote>
<p>我们平时在开发过程中, 往往并不是憋足气一股脑敲完全部代码。每个模块, 每个函数的实现总有个先后顺序。又或者哪个部分需要做调整, 修改… 所以, 我们需要有一个东西,]]>
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="宏" scheme="http://yoursite.com/tags/%E5%AE%8F/"/>
    
  </entry>
  
</feed>